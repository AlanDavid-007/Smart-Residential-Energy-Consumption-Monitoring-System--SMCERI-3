{"ast":null,"code":"/**\n * TinyMCE version 7.5.1 (TBD)\n */\n\n(function () {\n  'use strict';\n\n  var typeOf$1 = function (x) {\n    if (x === null) {\n      return 'null';\n    }\n    if (x === undefined) {\n      return 'undefined';\n    }\n    var t = typeof x;\n    if (t === 'object' && (Array.prototype.isPrototypeOf(x) || x.constructor && x.constructor.name === 'Array')) {\n      return 'array';\n    }\n    if (t === 'object' && (String.prototype.isPrototypeOf(x) || x.constructor && x.constructor.name === 'String')) {\n      return 'string';\n    }\n    return t;\n  };\n  var isEquatableType = function (x) {\n    return ['undefined', 'boolean', 'number', 'string', 'function', 'xml', 'null'].indexOf(x) !== -1;\n  };\n  var sort$1 = function (xs, compareFn) {\n    var clone = Array.prototype.slice.call(xs);\n    return clone.sort(compareFn);\n  };\n  var contramap = function (eqa, f) {\n    return eq$2(function (x, y) {\n      return eqa.eq(f(x), f(y));\n    });\n  };\n  var eq$2 = function (f) {\n    return {\n      eq: f\n    };\n  };\n  var tripleEq = eq$2(function (x, y) {\n    return x === y;\n  });\n  var eqString = tripleEq;\n  var eqArray = function (eqa) {\n    return eq$2(function (x, y) {\n      if (x.length !== y.length) {\n        return false;\n      }\n      var len = x.length;\n      for (var i = 0; i < len; i++) {\n        if (!eqa.eq(x[i], y[i])) {\n          return false;\n        }\n      }\n      return true;\n    });\n  };\n  var eqSortedArray = function (eqa, compareFn) {\n    return contramap(eqArray(eqa), function (xs) {\n      return sort$1(xs, compareFn);\n    });\n  };\n  var eqRecord = function (eqa) {\n    return eq$2(function (x, y) {\n      var kx = Object.keys(x);\n      var ky = Object.keys(y);\n      if (!eqSortedArray(eqString).eq(kx, ky)) {\n        return false;\n      }\n      var len = kx.length;\n      for (var i = 0; i < len; i++) {\n        var q = kx[i];\n        if (!eqa.eq(x[q], y[q])) {\n          return false;\n        }\n      }\n      return true;\n    });\n  };\n  var eqAny = eq$2(function (x, y) {\n    if (x === y) {\n      return true;\n    }\n    var tx = typeOf$1(x);\n    var ty = typeOf$1(y);\n    if (tx !== ty) {\n      return false;\n    }\n    if (isEquatableType(tx)) {\n      return x === y;\n    } else if (tx === 'array') {\n      return eqArray(eqAny).eq(x, y);\n    } else if (tx === 'object') {\n      return eqRecord(eqAny).eq(x, y);\n    }\n    return false;\n  });\n  const getPrototypeOf$2 = Object.getPrototypeOf;\n  const hasProto = (v, constructor, predicate) => {\n    var _a;\n    if (predicate(v, constructor.prototype)) {\n      return true;\n    } else {\n      return ((_a = v.constructor) === null || _a === void 0 ? void 0 : _a.name) === constructor.name;\n    }\n  };\n  const typeOf = x => {\n    const t = typeof x;\n    if (x === null) {\n      return 'null';\n    } else if (t === 'object' && Array.isArray(x)) {\n      return 'array';\n    } else if (t === 'object' && hasProto(x, String, (o, proto) => proto.isPrototypeOf(o))) {\n      return 'string';\n    } else {\n      return t;\n    }\n  };\n  const isType$1 = type => value => typeOf(value) === type;\n  const isSimpleType = type => value => typeof value === type;\n  const eq$1 = t => a => t === a;\n  const is$4 = (value, constructor) => isObject(value) && hasProto(value, constructor, (o, proto) => getPrototypeOf$2(o) === proto);\n  const isString = isType$1('string');\n  const isObject = isType$1('object');\n  const isPlainObject = value => is$4(value, Object);\n  const isArray$1 = isType$1('array');\n  const isNull = eq$1(null);\n  const isBoolean = isSimpleType('boolean');\n  const isUndefined = eq$1(undefined);\n  const isNullable = a => a === null || a === undefined;\n  const isNonNullable = a => !isNullable(a);\n  const isFunction = isSimpleType('function');\n  const isNumber = isSimpleType('number');\n  const isArrayOf = (value, pred) => {\n    if (isArray$1(value)) {\n      for (let i = 0, len = value.length; i < len; ++i) {\n        if (!pred(value[i])) {\n          return false;\n        }\n      }\n      return true;\n    }\n    return false;\n  };\n  const noop = () => {};\n  const compose = (fa, fb) => {\n    return (...args) => {\n      return fa(fb.apply(null, args));\n    };\n  };\n  const compose1 = (fbc, fab) => a => fbc(fab(a));\n  const constant = value => {\n    return () => {\n      return value;\n    };\n  };\n  const identity = x => {\n    return x;\n  };\n  const tripleEquals = (a, b) => {\n    return a === b;\n  };\n  function curry(fn, ...initialArgs) {\n    return (...restArgs) => {\n      const all = initialArgs.concat(restArgs);\n      return fn.apply(null, all);\n    };\n  }\n  const not = f => t => !f(t);\n  const die = msg => {\n    return () => {\n      throw new Error(msg);\n    };\n  };\n  const apply$1 = f => {\n    return f();\n  };\n  const call = f => {\n    f();\n  };\n  const never = constant(false);\n  const always = constant(true);\n  class Optional {\n    constructor(tag, value) {\n      this.tag = tag;\n      this.value = value;\n    }\n    static some(value) {\n      return new Optional(true, value);\n    }\n    static none() {\n      return Optional.singletonNone;\n    }\n    fold(onNone, onSome) {\n      if (this.tag) {\n        return onSome(this.value);\n      } else {\n        return onNone();\n      }\n    }\n    isSome() {\n      return this.tag;\n    }\n    isNone() {\n      return !this.tag;\n    }\n    map(mapper) {\n      if (this.tag) {\n        return Optional.some(mapper(this.value));\n      } else {\n        return Optional.none();\n      }\n    }\n    bind(binder) {\n      if (this.tag) {\n        return binder(this.value);\n      } else {\n        return Optional.none();\n      }\n    }\n    exists(predicate) {\n      return this.tag && predicate(this.value);\n    }\n    forall(predicate) {\n      return !this.tag || predicate(this.value);\n    }\n    filter(predicate) {\n      if (!this.tag || predicate(this.value)) {\n        return this;\n      } else {\n        return Optional.none();\n      }\n    }\n    getOr(replacement) {\n      return this.tag ? this.value : replacement;\n    }\n    or(replacement) {\n      return this.tag ? this : replacement;\n    }\n    getOrThunk(thunk) {\n      return this.tag ? this.value : thunk();\n    }\n    orThunk(thunk) {\n      return this.tag ? this : thunk();\n    }\n    getOrDie(message) {\n      if (!this.tag) {\n        throw new Error(message !== null && message !== void 0 ? message : 'Called getOrDie on None');\n      } else {\n        return this.value;\n      }\n    }\n    static from(value) {\n      return isNonNullable(value) ? Optional.some(value) : Optional.none();\n    }\n    getOrNull() {\n      return this.tag ? this.value : null;\n    }\n    getOrUndefined() {\n      return this.value;\n    }\n    each(worker) {\n      if (this.tag) {\n        worker(this.value);\n      }\n    }\n    toArray() {\n      return this.tag ? [this.value] : [];\n    }\n    toString() {\n      return this.tag ? `some(${this.value})` : 'none()';\n    }\n  }\n  Optional.singletonNone = new Optional(false);\n  const nativeSlice = Array.prototype.slice;\n  const nativeIndexOf = Array.prototype.indexOf;\n  const nativePush = Array.prototype.push;\n  const rawIndexOf = (ts, t) => nativeIndexOf.call(ts, t);\n  const indexOf$1 = (xs, x) => {\n    const r = rawIndexOf(xs, x);\n    return r === -1 ? Optional.none() : Optional.some(r);\n  };\n  const contains$2 = (xs, x) => rawIndexOf(xs, x) > -1;\n  const exists = (xs, pred) => {\n    for (let i = 0, len = xs.length; i < len; i++) {\n      const x = xs[i];\n      if (pred(x, i)) {\n        return true;\n      }\n    }\n    return false;\n  };\n  const map$3 = (xs, f) => {\n    const len = xs.length;\n    const r = new Array(len);\n    for (let i = 0; i < len; i++) {\n      const x = xs[i];\n      r[i] = f(x, i);\n    }\n    return r;\n  };\n  const each$e = (xs, f) => {\n    for (let i = 0, len = xs.length; i < len; i++) {\n      const x = xs[i];\n      f(x, i);\n    }\n  };\n  const eachr = (xs, f) => {\n    for (let i = xs.length - 1; i >= 0; i--) {\n      const x = xs[i];\n      f(x, i);\n    }\n  };\n  const partition$2 = (xs, pred) => {\n    const pass = [];\n    const fail = [];\n    for (let i = 0, len = xs.length; i < len; i++) {\n      const x = xs[i];\n      const arr = pred(x, i) ? pass : fail;\n      arr.push(x);\n    }\n    return {\n      pass,\n      fail\n    };\n  };\n  const filter$5 = (xs, pred) => {\n    const r = [];\n    for (let i = 0, len = xs.length; i < len; i++) {\n      const x = xs[i];\n      if (pred(x, i)) {\n        r.push(x);\n      }\n    }\n    return r;\n  };\n  const foldr = (xs, f, acc) => {\n    eachr(xs, (x, i) => {\n      acc = f(acc, x, i);\n    });\n    return acc;\n  };\n  const foldl = (xs, f, acc) => {\n    each$e(xs, (x, i) => {\n      acc = f(acc, x, i);\n    });\n    return acc;\n  };\n  const findUntil$1 = (xs, pred, until) => {\n    for (let i = 0, len = xs.length; i < len; i++) {\n      const x = xs[i];\n      if (pred(x, i)) {\n        return Optional.some(x);\n      } else if (until(x, i)) {\n        break;\n      }\n    }\n    return Optional.none();\n  };\n  const find$2 = (xs, pred) => {\n    return findUntil$1(xs, pred, never);\n  };\n  const findIndex$2 = (xs, pred) => {\n    for (let i = 0, len = xs.length; i < len; i++) {\n      const x = xs[i];\n      if (pred(x, i)) {\n        return Optional.some(i);\n      }\n    }\n    return Optional.none();\n  };\n  const flatten = xs => {\n    const r = [];\n    for (let i = 0, len = xs.length; i < len; ++i) {\n      if (!isArray$1(xs[i])) {\n        throw new Error('Arr.flatten item ' + i + ' was not an array, input: ' + xs);\n      }\n      nativePush.apply(r, xs[i]);\n    }\n    return r;\n  };\n  const bind$3 = (xs, f) => flatten(map$3(xs, f));\n  const forall = (xs, pred) => {\n    for (let i = 0, len = xs.length; i < len; ++i) {\n      const x = xs[i];\n      if (pred(x, i) !== true) {\n        return false;\n      }\n    }\n    return true;\n  };\n  const reverse = xs => {\n    const r = nativeSlice.call(xs, 0);\n    r.reverse();\n    return r;\n  };\n  const difference = (a1, a2) => filter$5(a1, x => !contains$2(a2, x));\n  const mapToObject = (xs, f) => {\n    const r = {};\n    for (let i = 0, len = xs.length; i < len; i++) {\n      const x = xs[i];\n      r[String(x)] = f(x, i);\n    }\n    return r;\n  };\n  const sort = (xs, comparator) => {\n    const copy = nativeSlice.call(xs, 0);\n    copy.sort(comparator);\n    return copy;\n  };\n  const get$b = (xs, i) => i >= 0 && i < xs.length ? Optional.some(xs[i]) : Optional.none();\n  const head = xs => get$b(xs, 0);\n  const last$2 = xs => get$b(xs, xs.length - 1);\n  const from = isFunction(Array.from) ? Array.from : x => nativeSlice.call(x);\n  const findMap = (arr, f) => {\n    for (let i = 0; i < arr.length; i++) {\n      const r = f(arr[i], i);\n      if (r.isSome()) {\n        return r;\n      }\n    }\n    return Optional.none();\n  };\n  const unique$1 = (xs, comparator) => {\n    const r = [];\n    const isDuplicated = isFunction(comparator) ? x => exists(r, i => comparator(i, x)) : x => contains$2(r, x);\n    for (let i = 0, len = xs.length; i < len; i++) {\n      const x = xs[i];\n      if (!isDuplicated(x)) {\n        r.push(x);\n      }\n    }\n    return r;\n  };\n  const keys = Object.keys;\n  const hasOwnProperty$1 = Object.hasOwnProperty;\n  const each$d = (obj, f) => {\n    const props = keys(obj);\n    for (let k = 0, len = props.length; k < len; k++) {\n      const i = props[k];\n      const x = obj[i];\n      f(x, i);\n    }\n  };\n  const map$2 = (obj, f) => {\n    return tupleMap(obj, (x, i) => ({\n      k: i,\n      v: f(x, i)\n    }));\n  };\n  const tupleMap = (obj, f) => {\n    const r = {};\n    each$d(obj, (x, i) => {\n      const tuple = f(x, i);\n      r[tuple.k] = tuple.v;\n    });\n    return r;\n  };\n  const objAcc = r => (x, i) => {\n    r[i] = x;\n  };\n  const internalFilter = (obj, pred, onTrue, onFalse) => {\n    each$d(obj, (x, i) => {\n      (pred(x, i) ? onTrue : onFalse)(x, i);\n    });\n  };\n  const bifilter = (obj, pred) => {\n    const t = {};\n    const f = {};\n    internalFilter(obj, pred, objAcc(t), objAcc(f));\n    return {\n      t,\n      f\n    };\n  };\n  const filter$4 = (obj, pred) => {\n    const t = {};\n    internalFilter(obj, pred, objAcc(t), noop);\n    return t;\n  };\n  const mapToArray = (obj, f) => {\n    const r = [];\n    each$d(obj, (value, name) => {\n      r.push(f(value, name));\n    });\n    return r;\n  };\n  const values = obj => {\n    return mapToArray(obj, identity);\n  };\n  const get$a = (obj, key) => {\n    return has$2(obj, key) ? Optional.from(obj[key]) : Optional.none();\n  };\n  const has$2 = (obj, key) => hasOwnProperty$1.call(obj, key);\n  const hasNonNullableKey = (obj, key) => has$2(obj, key) && obj[key] !== undefined && obj[key] !== null;\n  const equal$1 = (a1, a2, eq = eqAny) => eqRecord(eq).eq(a1, a2);\n  const stringArray = a => {\n    const all = {};\n    each$e(a, key => {\n      all[key] = {};\n    });\n    return keys(all);\n  };\n  const isArrayLike = o => o.length !== undefined;\n  const isArray = Array.isArray;\n  const toArray$1 = obj => {\n    if (!isArray(obj)) {\n      const array = [];\n      for (let i = 0, l = obj.length; i < l; i++) {\n        array[i] = obj[i];\n      }\n      return array;\n    } else {\n      return obj;\n    }\n  };\n  const each$c = (o, cb, s) => {\n    if (!o) {\n      return false;\n    }\n    s = s || o;\n    if (isArrayLike(o)) {\n      for (let n = 0, l = o.length; n < l; n++) {\n        if (cb.call(s, o[n], n, o) === false) {\n          return false;\n        }\n      }\n    } else {\n      for (const n in o) {\n        if (has$2(o, n)) {\n          if (cb.call(s, o[n], n, o) === false) {\n            return false;\n          }\n        }\n      }\n    }\n    return true;\n  };\n  const map$1 = (array, callback) => {\n    const out = [];\n    each$c(array, (item, index) => {\n      out.push(callback(item, index, array));\n    });\n    return out;\n  };\n  const filter$3 = (a, f) => {\n    const o = [];\n    each$c(a, (v, index) => {\n      if (!f || f(v, index, a)) {\n        o.push(v);\n      }\n    });\n    return o;\n  };\n  const indexOf = (a, v) => {\n    if (a) {\n      for (let i = 0, l = a.length; i < l; i++) {\n        if (a[i] === v) {\n          return i;\n        }\n      }\n    }\n    return -1;\n  };\n  const reduce = (collection, iteratee, accumulator, thisArg) => {\n    let acc = isUndefined(accumulator) ? collection[0] : accumulator;\n    for (let i = 0; i < collection.length; i++) {\n      acc = iteratee.call(thisArg, acc, collection[i], i);\n    }\n    return acc;\n  };\n  const findIndex$1 = (array, predicate, thisArg) => {\n    for (let i = 0, l = array.length; i < l; i++) {\n      if (predicate.call(thisArg, array[i], i, array)) {\n        return i;\n      }\n    }\n    return -1;\n  };\n  const last$1 = collection => collection[collection.length - 1];\n  const cached = f => {\n    let called = false;\n    let r;\n    return (...args) => {\n      if (!called) {\n        called = true;\n        r = f.apply(null, args);\n      }\n      return r;\n    };\n  };\n  const DeviceType = (os, browser, userAgent, mediaMatch) => {\n    const isiPad = os.isiOS() && /ipad/i.test(userAgent) === true;\n    const isiPhone = os.isiOS() && !isiPad;\n    const isMobile = os.isiOS() || os.isAndroid();\n    const isTouch = isMobile || mediaMatch('(pointer:coarse)');\n    const isTablet = isiPad || !isiPhone && isMobile && mediaMatch('(min-device-width:768px)');\n    const isPhone = isiPhone || isMobile && !isTablet;\n    const iOSwebview = browser.isSafari() && os.isiOS() && /safari/i.test(userAgent) === false;\n    const isDesktop = !isPhone && !isTablet && !iOSwebview;\n    return {\n      isiPad: constant(isiPad),\n      isiPhone: constant(isiPhone),\n      isTablet: constant(isTablet),\n      isPhone: constant(isPhone),\n      isTouch: constant(isTouch),\n      isAndroid: os.isAndroid,\n      isiOS: os.isiOS,\n      isWebView: constant(iOSwebview),\n      isDesktop: constant(isDesktop)\n    };\n  };\n  const firstMatch = (regexes, s) => {\n    for (let i = 0; i < regexes.length; i++) {\n      const x = regexes[i];\n      if (x.test(s)) {\n        return x;\n      }\n    }\n    return undefined;\n  };\n  const find$1 = (regexes, agent) => {\n    const r = firstMatch(regexes, agent);\n    if (!r) {\n      return {\n        major: 0,\n        minor: 0\n      };\n    }\n    const group = i => {\n      return Number(agent.replace(r, '$' + i));\n    };\n    return nu$3(group(1), group(2));\n  };\n  const detect$4 = (versionRegexes, agent) => {\n    const cleanedAgent = String(agent).toLowerCase();\n    if (versionRegexes.length === 0) {\n      return unknown$2();\n    }\n    return find$1(versionRegexes, cleanedAgent);\n  };\n  const unknown$2 = () => {\n    return nu$3(0, 0);\n  };\n  const nu$3 = (major, minor) => {\n    return {\n      major,\n      minor\n    };\n  };\n  const Version = {\n    nu: nu$3,\n    detect: detect$4,\n    unknown: unknown$2\n  };\n  const detectBrowser$1 = (browsers, userAgentData) => {\n    return findMap(userAgentData.brands, uaBrand => {\n      const lcBrand = uaBrand.brand.toLowerCase();\n      return find$2(browsers, browser => {\n        var _a;\n        return lcBrand === ((_a = browser.brand) === null || _a === void 0 ? void 0 : _a.toLowerCase());\n      }).map(info => ({\n        current: info.name,\n        version: Version.nu(parseInt(uaBrand.version, 10), 0)\n      }));\n    });\n  };\n  const detect$3 = (candidates, userAgent) => {\n    const agent = String(userAgent).toLowerCase();\n    return find$2(candidates, candidate => {\n      return candidate.search(agent);\n    });\n  };\n  const detectBrowser = (browsers, userAgent) => {\n    return detect$3(browsers, userAgent).map(browser => {\n      const version = Version.detect(browser.versionRegexes, userAgent);\n      return {\n        current: browser.name,\n        version\n      };\n    });\n  };\n  const detectOs = (oses, userAgent) => {\n    return detect$3(oses, userAgent).map(os => {\n      const version = Version.detect(os.versionRegexes, userAgent);\n      return {\n        current: os.name,\n        version\n      };\n    });\n  };\n  const removeFromStart = (str, numChars) => {\n    return str.substring(numChars);\n  };\n  const checkRange = (str, substr, start) => substr === '' || str.length >= substr.length && str.substr(start, start + substr.length) === substr;\n  const removeLeading = (str, prefix) => {\n    return startsWith(str, prefix) ? removeFromStart(str, prefix.length) : str;\n  };\n  const contains$1 = (str, substr, start = 0, end) => {\n    const idx = str.indexOf(substr, start);\n    if (idx !== -1) {\n      return isUndefined(end) ? true : idx + substr.length <= end;\n    } else {\n      return false;\n    }\n  };\n  const startsWith = (str, prefix) => {\n    return checkRange(str, prefix, 0);\n  };\n  const endsWith = (str, suffix) => {\n    return checkRange(str, suffix, str.length - suffix.length);\n  };\n  const blank = r => s => s.replace(r, '');\n  const trim$4 = blank(/^\\s+|\\s+$/g);\n  const lTrim = blank(/^\\s+/g);\n  const rTrim = blank(/\\s+$/g);\n  const isNotEmpty = s => s.length > 0;\n  const isEmpty$3 = s => !isNotEmpty(s);\n  const repeat = (s, count) => count <= 0 ? '' : new Array(count + 1).join(s);\n  const toInt = (value, radix = 10) => {\n    const num = parseInt(value, radix);\n    return isNaN(num) ? Optional.none() : Optional.some(num);\n  };\n  const normalVersionRegex = /.*?version\\/\\ ?([0-9]+)\\.([0-9]+).*/;\n  const checkContains = target => {\n    return uastring => {\n      return contains$1(uastring, target);\n    };\n  };\n  const browsers = [{\n    name: 'Edge',\n    versionRegexes: [/.*?edge\\/ ?([0-9]+)\\.([0-9]+)$/],\n    search: uastring => {\n      return contains$1(uastring, 'edge/') && contains$1(uastring, 'chrome') && contains$1(uastring, 'safari') && contains$1(uastring, 'applewebkit');\n    }\n  }, {\n    name: 'Chromium',\n    brand: 'Chromium',\n    versionRegexes: [/.*?chrome\\/([0-9]+)\\.([0-9]+).*/, normalVersionRegex],\n    search: uastring => {\n      return contains$1(uastring, 'chrome') && !contains$1(uastring, 'chromeframe');\n    }\n  }, {\n    name: 'IE',\n    versionRegexes: [/.*?msie\\ ?([0-9]+)\\.([0-9]+).*/, /.*?rv:([0-9]+)\\.([0-9]+).*/],\n    search: uastring => {\n      return contains$1(uastring, 'msie') || contains$1(uastring, 'trident');\n    }\n  }, {\n    name: 'Opera',\n    versionRegexes: [normalVersionRegex, /.*?opera\\/([0-9]+)\\.([0-9]+).*/],\n    search: checkContains('opera')\n  }, {\n    name: 'Firefox',\n    versionRegexes: [/.*?firefox\\/\\ ?([0-9]+)\\.([0-9]+).*/],\n    search: checkContains('firefox')\n  }, {\n    name: 'Safari',\n    versionRegexes: [normalVersionRegex, /.*?cpu os ([0-9]+)_([0-9]+).*/],\n    search: uastring => {\n      return (contains$1(uastring, 'safari') || contains$1(uastring, 'mobile/')) && contains$1(uastring, 'applewebkit');\n    }\n  }];\n  const oses = [{\n    name: 'Windows',\n    search: checkContains('win'),\n    versionRegexes: [/.*?windows\\ nt\\ ?([0-9]+)\\.([0-9]+).*/]\n  }, {\n    name: 'iOS',\n    search: uastring => {\n      return contains$1(uastring, 'iphone') || contains$1(uastring, 'ipad');\n    },\n    versionRegexes: [/.*?version\\/\\ ?([0-9]+)\\.([0-9]+).*/, /.*cpu os ([0-9]+)_([0-9]+).*/, /.*cpu iphone os ([0-9]+)_([0-9]+).*/]\n  }, {\n    name: 'Android',\n    search: checkContains('android'),\n    versionRegexes: [/.*?android\\ ?([0-9]+)\\.([0-9]+).*/]\n  }, {\n    name: 'macOS',\n    search: checkContains('mac os x'),\n    versionRegexes: [/.*?mac\\ os\\ x\\ ?([0-9]+)_([0-9]+).*/]\n  }, {\n    name: 'Linux',\n    search: checkContains('linux'),\n    versionRegexes: []\n  }, {\n    name: 'Solaris',\n    search: checkContains('sunos'),\n    versionRegexes: []\n  }, {\n    name: 'FreeBSD',\n    search: checkContains('freebsd'),\n    versionRegexes: []\n  }, {\n    name: 'ChromeOS',\n    search: checkContains('cros'),\n    versionRegexes: [/.*?chrome\\/([0-9]+)\\.([0-9]+).*/]\n  }];\n  const PlatformInfo = {\n    browsers: constant(browsers),\n    oses: constant(oses)\n  };\n  const edge = 'Edge';\n  const chromium = 'Chromium';\n  const ie = 'IE';\n  const opera = 'Opera';\n  const firefox = 'Firefox';\n  const safari = 'Safari';\n  const unknown$1 = () => {\n    return nu$2({\n      current: undefined,\n      version: Version.unknown()\n    });\n  };\n  const nu$2 = info => {\n    const current = info.current;\n    const version = info.version;\n    const isBrowser = name => () => current === name;\n    return {\n      current,\n      version,\n      isEdge: isBrowser(edge),\n      isChromium: isBrowser(chromium),\n      isIE: isBrowser(ie),\n      isOpera: isBrowser(opera),\n      isFirefox: isBrowser(firefox),\n      isSafari: isBrowser(safari)\n    };\n  };\n  const Browser = {\n    unknown: unknown$1,\n    nu: nu$2,\n    edge: constant(edge),\n    chromium: constant(chromium),\n    ie: constant(ie),\n    opera: constant(opera),\n    firefox: constant(firefox),\n    safari: constant(safari)\n  };\n  const windows = 'Windows';\n  const ios = 'iOS';\n  const android = 'Android';\n  const linux = 'Linux';\n  const macos = 'macOS';\n  const solaris = 'Solaris';\n  const freebsd = 'FreeBSD';\n  const chromeos = 'ChromeOS';\n  const unknown = () => {\n    return nu$1({\n      current: undefined,\n      version: Version.unknown()\n    });\n  };\n  const nu$1 = info => {\n    const current = info.current;\n    const version = info.version;\n    const isOS = name => () => current === name;\n    return {\n      current,\n      version,\n      isWindows: isOS(windows),\n      isiOS: isOS(ios),\n      isAndroid: isOS(android),\n      isMacOS: isOS(macos),\n      isLinux: isOS(linux),\n      isSolaris: isOS(solaris),\n      isFreeBSD: isOS(freebsd),\n      isChromeOS: isOS(chromeos)\n    };\n  };\n  const OperatingSystem = {\n    unknown,\n    nu: nu$1,\n    windows: constant(windows),\n    ios: constant(ios),\n    android: constant(android),\n    linux: constant(linux),\n    macos: constant(macos),\n    solaris: constant(solaris),\n    freebsd: constant(freebsd),\n    chromeos: constant(chromeos)\n  };\n  const detect$2 = (userAgent, userAgentDataOpt, mediaMatch) => {\n    const browsers = PlatformInfo.browsers();\n    const oses = PlatformInfo.oses();\n    const browser = userAgentDataOpt.bind(userAgentData => detectBrowser$1(browsers, userAgentData)).orThunk(() => detectBrowser(browsers, userAgent)).fold(Browser.unknown, Browser.nu);\n    const os = detectOs(oses, userAgent).fold(OperatingSystem.unknown, OperatingSystem.nu);\n    const deviceType = DeviceType(os, browser, userAgent, mediaMatch);\n    return {\n      browser,\n      os,\n      deviceType\n    };\n  };\n  const PlatformDetection = {\n    detect: detect$2\n  };\n  const mediaMatch = query => window.matchMedia(query).matches;\n  let platform$4 = cached(() => PlatformDetection.detect(window.navigator.userAgent, Optional.from(window.navigator.userAgentData), mediaMatch));\n  const detect$1 = () => platform$4();\n  const userAgent = window.navigator.userAgent;\n  const platform$3 = detect$1();\n  const browser$3 = platform$3.browser;\n  const os$1 = platform$3.os;\n  const deviceType = platform$3.deviceType;\n  const windowsPhone = userAgent.indexOf('Windows Phone') !== -1;\n  const Env = {\n    transparentSrc: 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7',\n    documentMode: browser$3.isIE() ? document.documentMode || 7 : 10,\n    cacheSuffix: null,\n    container: null,\n    canHaveCSP: !browser$3.isIE(),\n    windowsPhone,\n    browser: {\n      current: browser$3.current,\n      version: browser$3.version,\n      isChromium: browser$3.isChromium,\n      isEdge: browser$3.isEdge,\n      isFirefox: browser$3.isFirefox,\n      isIE: browser$3.isIE,\n      isOpera: browser$3.isOpera,\n      isSafari: browser$3.isSafari\n    },\n    os: {\n      current: os$1.current,\n      version: os$1.version,\n      isAndroid: os$1.isAndroid,\n      isChromeOS: os$1.isChromeOS,\n      isFreeBSD: os$1.isFreeBSD,\n      isiOS: os$1.isiOS,\n      isLinux: os$1.isLinux,\n      isMacOS: os$1.isMacOS,\n      isSolaris: os$1.isSolaris,\n      isWindows: os$1.isWindows\n    },\n    deviceType: {\n      isDesktop: deviceType.isDesktop,\n      isiPad: deviceType.isiPad,\n      isiPhone: deviceType.isiPhone,\n      isPhone: deviceType.isPhone,\n      isTablet: deviceType.isTablet,\n      isTouch: deviceType.isTouch,\n      isWebView: deviceType.isWebView\n    }\n  };\n  const whiteSpaceRegExp$1 = /^\\s*|\\s*$/g;\n  const trim$3 = str => {\n    return isNullable(str) ? '' : ('' + str).replace(whiteSpaceRegExp$1, '');\n  };\n  const is$3 = (obj, type) => {\n    if (!type) {\n      return obj !== undefined;\n    }\n    if (type === 'array' && isArray(obj)) {\n      return true;\n    }\n    return typeof obj === type;\n  };\n  const makeMap$4 = (items, delim, map = {}) => {\n    const resolvedItems = isString(items) ? items.split(delim || ',') : items || [];\n    let i = resolvedItems.length;\n    while (i--) {\n      map[resolvedItems[i]] = {};\n    }\n    return map;\n  };\n  const hasOwnProperty = has$2;\n  const extend$3 = (obj, ...exts) => {\n    for (let i = 0; i < exts.length; i++) {\n      const ext = exts[i];\n      for (const name in ext) {\n        if (has$2(ext, name)) {\n          const value = ext[name];\n          if (value !== undefined) {\n            obj[name] = value;\n          }\n        }\n      }\n    }\n    return obj;\n  };\n  const walk$4 = function (o, f, n, s) {\n    s = s || this;\n    if (o) {\n      if (n) {\n        o = o[n];\n      }\n      each$c(o, (o, i) => {\n        if (f.call(s, o, i, n) === false) {\n          return false;\n        } else {\n          walk$4(o, f, n, s);\n          return true;\n        }\n      });\n    }\n  };\n  const resolve$3 = (n, o = window) => {\n    const path = n.split('.');\n    for (let i = 0, l = path.length; i < l; i++) {\n      o = o[path[i]];\n      if (!o) {\n        break;\n      }\n    }\n    return o;\n  };\n  const explode$3 = (s, d) => {\n    if (isArray$1(s)) {\n      return s;\n    } else if (s === '') {\n      return [];\n    } else {\n      return map$1(s.split(d || ','), trim$3);\n    }\n  };\n  const _addCacheSuffix = url => {\n    const cacheSuffix = Env.cacheSuffix;\n    if (cacheSuffix) {\n      url += (url.indexOf('?') === -1 ? '?' : '&') + cacheSuffix;\n    }\n    return url;\n  };\n  const Tools = {\n    trim: trim$3,\n    isArray: isArray,\n    is: is$3,\n    toArray: toArray$1,\n    makeMap: makeMap$4,\n    each: each$c,\n    map: map$1,\n    grep: filter$3,\n    inArray: indexOf,\n    hasOwn: hasOwnProperty,\n    extend: extend$3,\n    walk: walk$4,\n    resolve: resolve$3,\n    explode: explode$3,\n    _addCacheSuffix\n  };\n  const is$2 = (lhs, rhs, comparator = tripleEquals) => lhs.exists(left => comparator(left, rhs));\n  const equals = (lhs, rhs, comparator = tripleEquals) => lift2(lhs, rhs, comparator).getOr(lhs.isNone() && rhs.isNone());\n  const cat = arr => {\n    const r = [];\n    const push = x => {\n      r.push(x);\n    };\n    for (let i = 0; i < arr.length; i++) {\n      arr[i].each(push);\n    }\n    return r;\n  };\n  const lift2 = (oa, ob, f) => oa.isSome() && ob.isSome() ? Optional.some(f(oa.getOrDie(), ob.getOrDie())) : Optional.none();\n  const lift3 = (oa, ob, oc, f) => oa.isSome() && ob.isSome() && oc.isSome() ? Optional.some(f(oa.getOrDie(), ob.getOrDie(), oc.getOrDie())) : Optional.none();\n  const someIf = (b, a) => b ? Optional.some(a) : Optional.none();\n  const Global = typeof window !== 'undefined' ? window : Function('return this;')();\n  const path = (parts, scope) => {\n    let o = scope !== undefined && scope !== null ? scope : Global;\n    for (let i = 0; i < parts.length && o !== undefined && o !== null; ++i) {\n      o = o[parts[i]];\n    }\n    return o;\n  };\n  const resolve$2 = (p, scope) => {\n    const parts = p.split('.');\n    return path(parts, scope);\n  };\n  const unsafe = (name, scope) => {\n    return resolve$2(name, scope);\n  };\n  const getOrDie = (name, scope) => {\n    const actual = unsafe(name, scope);\n    if (actual === undefined || actual === null) {\n      throw new Error(name + ' not available on this browser');\n    }\n    return actual;\n  };\n  const getPrototypeOf$1 = Object.getPrototypeOf;\n  const sandHTMLElement = scope => {\n    return getOrDie('HTMLElement', scope);\n  };\n  const isPrototypeOf = x => {\n    const scope = resolve$2('ownerDocument.defaultView', x);\n    return isObject(x) && (sandHTMLElement(scope).prototype.isPrototypeOf(x) || /^HTML\\w*Element$/.test(getPrototypeOf$1(x).constructor.name));\n  };\n  const COMMENT = 8;\n  const DOCUMENT = 9;\n  const DOCUMENT_FRAGMENT = 11;\n  const ELEMENT = 1;\n  const TEXT = 3;\n  const name = element => {\n    const r = element.dom.nodeName;\n    return r.toLowerCase();\n  };\n  const type$1 = element => element.dom.nodeType;\n  const isType = t => element => type$1(element) === t;\n  const isComment$1 = element => type$1(element) === COMMENT || name(element) === '#comment';\n  const isHTMLElement$1 = element => isElement$7(element) && isPrototypeOf(element.dom);\n  const isElement$7 = isType(ELEMENT);\n  const isText$c = isType(TEXT);\n  const isDocument$2 = isType(DOCUMENT);\n  const isDocumentFragment$1 = isType(DOCUMENT_FRAGMENT);\n  const isTag = tag => e => isElement$7(e) && name(e) === tag;\n  const rawSet = (dom, key, value) => {\n    if (isString(value) || isBoolean(value) || isNumber(value)) {\n      dom.setAttribute(key, value + '');\n    } else {\n      console.error('Invalid call to Attribute.set. Key ', key, ':: Value ', value, ':: Element ', dom);\n      throw new Error('Attribute value was not simple');\n    }\n  };\n  const set$3 = (element, key, value) => {\n    rawSet(element.dom, key, value);\n  };\n  const setAll$1 = (element, attrs) => {\n    const dom = element.dom;\n    each$d(attrs, (v, k) => {\n      rawSet(dom, k, v);\n    });\n  };\n  const get$9 = (element, key) => {\n    const v = element.dom.getAttribute(key);\n    return v === null ? undefined : v;\n  };\n  const getOpt = (element, key) => Optional.from(get$9(element, key));\n  const has$1 = (element, key) => {\n    const dom = element.dom;\n    return dom && dom.hasAttribute ? dom.hasAttribute(key) : false;\n  };\n  const remove$9 = (element, key) => {\n    element.dom.removeAttribute(key);\n  };\n  const hasNone = element => {\n    const attrs = element.dom.attributes;\n    return attrs === undefined || attrs === null || attrs.length === 0;\n  };\n  const clone$4 = element => foldl(element.dom.attributes, (acc, attr) => {\n    acc[attr.name] = attr.value;\n    return acc;\n  }, {});\n  const read$4 = (element, attr) => {\n    const value = get$9(element, attr);\n    return value === undefined || value === '' ? [] : value.split(' ');\n  };\n  const add$4 = (element, attr, id) => {\n    const old = read$4(element, attr);\n    const nu = old.concat([id]);\n    set$3(element, attr, nu.join(' '));\n    return true;\n  };\n  const remove$8 = (element, attr, id) => {\n    const nu = filter$5(read$4(element, attr), v => v !== id);\n    if (nu.length > 0) {\n      set$3(element, attr, nu.join(' '));\n    } else {\n      remove$9(element, attr);\n    }\n    return false;\n  };\n  const supports = element => element.dom.classList !== undefined;\n  const get$8 = element => read$4(element, 'class');\n  const add$3 = (element, clazz) => add$4(element, 'class', clazz);\n  const remove$7 = (element, clazz) => remove$8(element, 'class', clazz);\n  const toggle$2 = (element, clazz) => {\n    if (contains$2(get$8(element), clazz)) {\n      return remove$7(element, clazz);\n    } else {\n      return add$3(element, clazz);\n    }\n  };\n  const add$2 = (element, clazz) => {\n    if (supports(element)) {\n      element.dom.classList.add(clazz);\n    } else {\n      add$3(element, clazz);\n    }\n  };\n  const cleanClass = element => {\n    const classList = supports(element) ? element.dom.classList : get$8(element);\n    if (classList.length === 0) {\n      remove$9(element, 'class');\n    }\n  };\n  const remove$6 = (element, clazz) => {\n    if (supports(element)) {\n      const classList = element.dom.classList;\n      classList.remove(clazz);\n    } else {\n      remove$7(element, clazz);\n    }\n    cleanClass(element);\n  };\n  const toggle$1 = (element, clazz) => {\n    const result = supports(element) ? element.dom.classList.toggle(clazz) : toggle$2(element, clazz);\n    cleanClass(element);\n    return result;\n  };\n  const has = (element, clazz) => supports(element) && element.dom.classList.contains(clazz);\n  const fromHtml$1 = (html, scope) => {\n    const doc = scope || document;\n    const div = doc.createElement('div');\n    div.innerHTML = html;\n    if (!div.hasChildNodes() || div.childNodes.length > 1) {\n      const message = 'HTML does not have a single root node';\n      console.error(message, html);\n      throw new Error(message);\n    }\n    return fromDom$2(div.childNodes[0]);\n  };\n  const fromTag = (tag, scope) => {\n    const doc = scope || document;\n    const node = doc.createElement(tag);\n    return fromDom$2(node);\n  };\n  const fromText = (text, scope) => {\n    const doc = scope || document;\n    const node = doc.createTextNode(text);\n    return fromDom$2(node);\n  };\n  const fromDom$2 = node => {\n    if (node === null || node === undefined) {\n      throw new Error('Node cannot be null or undefined');\n    }\n    return {\n      dom: node\n    };\n  };\n  const fromPoint$2 = (docElm, x, y) => Optional.from(docElm.dom.elementFromPoint(x, y)).map(fromDom$2);\n  const SugarElement = {\n    fromHtml: fromHtml$1,\n    fromTag,\n    fromText,\n    fromDom: fromDom$2,\n    fromPoint: fromPoint$2\n  };\n  const toArray = (target, f) => {\n    const r = [];\n    const recurse = e => {\n      r.push(e);\n      return f(e);\n    };\n    let cur = f(target);\n    do {\n      cur = cur.bind(recurse);\n    } while (cur.isSome());\n    return r;\n  };\n  const is$1 = (element, selector) => {\n    const dom = element.dom;\n    if (dom.nodeType !== ELEMENT) {\n      return false;\n    } else {\n      const elem = dom;\n      if (elem.matches !== undefined) {\n        return elem.matches(selector);\n      } else if (elem.msMatchesSelector !== undefined) {\n        return elem.msMatchesSelector(selector);\n      } else if (elem.webkitMatchesSelector !== undefined) {\n        return elem.webkitMatchesSelector(selector);\n      } else if (elem.mozMatchesSelector !== undefined) {\n        return elem.mozMatchesSelector(selector);\n      } else {\n        throw new Error('Browser lacks native selectors');\n      }\n    }\n  };\n  const bypassSelector = dom => dom.nodeType !== ELEMENT && dom.nodeType !== DOCUMENT && dom.nodeType !== DOCUMENT_FRAGMENT || dom.childElementCount === 0;\n  const all = (selector, scope) => {\n    const base = scope === undefined ? document : scope.dom;\n    return bypassSelector(base) ? [] : map$3(base.querySelectorAll(selector), SugarElement.fromDom);\n  };\n  const one = (selector, scope) => {\n    const base = scope === undefined ? document : scope.dom;\n    return bypassSelector(base) ? Optional.none() : Optional.from(base.querySelector(selector)).map(SugarElement.fromDom);\n  };\n  const eq = (e1, e2) => e1.dom === e2.dom;\n  const contains = (e1, e2) => {\n    const d1 = e1.dom;\n    const d2 = e2.dom;\n    return d1 === d2 ? false : d1.contains(d2);\n  };\n  const owner$1 = element => SugarElement.fromDom(element.dom.ownerDocument);\n  const documentOrOwner = dos => isDocument$2(dos) ? dos : owner$1(dos);\n  const documentElement = element => SugarElement.fromDom(documentOrOwner(element).dom.documentElement);\n  const defaultView = element => SugarElement.fromDom(documentOrOwner(element).dom.defaultView);\n  const parent = element => Optional.from(element.dom.parentNode).map(SugarElement.fromDom);\n  const parentElement = element => Optional.from(element.dom.parentElement).map(SugarElement.fromDom);\n  const parents$1 = (element, isRoot) => {\n    const stop = isFunction(isRoot) ? isRoot : never;\n    let dom = element.dom;\n    const ret = [];\n    while (dom.parentNode !== null && dom.parentNode !== undefined) {\n      const rawParent = dom.parentNode;\n      const p = SugarElement.fromDom(rawParent);\n      ret.push(p);\n      if (stop(p) === true) {\n        break;\n      } else {\n        dom = rawParent;\n      }\n    }\n    return ret;\n  };\n  const siblings = element => {\n    const filterSelf = elements => filter$5(elements, x => !eq(element, x));\n    return parent(element).map(children$1).map(filterSelf).getOr([]);\n  };\n  const prevSibling = element => Optional.from(element.dom.previousSibling).map(SugarElement.fromDom);\n  const nextSibling = element => Optional.from(element.dom.nextSibling).map(SugarElement.fromDom);\n  const prevSiblings = element => reverse(toArray(element, prevSibling));\n  const nextSiblings = element => toArray(element, nextSibling);\n  const children$1 = element => map$3(element.dom.childNodes, SugarElement.fromDom);\n  const child$1 = (element, index) => {\n    const cs = element.dom.childNodes;\n    return Optional.from(cs[index]).map(SugarElement.fromDom);\n  };\n  const firstChild = element => child$1(element, 0);\n  const lastChild = element => child$1(element, element.dom.childNodes.length - 1);\n  const childNodesCount = element => element.dom.childNodes.length;\n  const getHead = doc => {\n    const b = doc.dom.head;\n    if (b === null || b === undefined) {\n      throw new Error('Head is not available yet');\n    }\n    return SugarElement.fromDom(b);\n  };\n  const isShadowRoot = dos => isDocumentFragment$1(dos) && isNonNullable(dos.dom.host);\n  const getRootNode = e => SugarElement.fromDom(e.dom.getRootNode());\n  const getStyleContainer = dos => isShadowRoot(dos) ? dos : getHead(documentOrOwner(dos));\n  const getContentContainer = dos => isShadowRoot(dos) ? dos : SugarElement.fromDom(documentOrOwner(dos).dom.body);\n  const getShadowRoot = e => {\n    const r = getRootNode(e);\n    return isShadowRoot(r) ? Optional.some(r) : Optional.none();\n  };\n  const getShadowHost = e => SugarElement.fromDom(e.dom.host);\n  const getOriginalEventTarget = event => {\n    if (isNonNullable(event.target)) {\n      const el = SugarElement.fromDom(event.target);\n      if (isElement$7(el) && isOpenShadowHost(el)) {\n        if (event.composed && event.composedPath) {\n          const composedPath = event.composedPath();\n          if (composedPath) {\n            return head(composedPath);\n          }\n        }\n      }\n    }\n    return Optional.from(event.target);\n  };\n  const isOpenShadowHost = element => isNonNullable(element.dom.shadowRoot);\n  const inBody = element => {\n    const dom = isText$c(element) ? element.dom.parentNode : element.dom;\n    if (dom === undefined || dom === null || dom.ownerDocument === null) {\n      return false;\n    }\n    const doc = dom.ownerDocument;\n    return getShadowRoot(SugarElement.fromDom(dom)).fold(() => doc.body.contains(dom), compose1(inBody, getShadowHost));\n  };\n  var ClosestOrAncestor = (is, ancestor, scope, a, isRoot) => {\n    if (is(scope, a)) {\n      return Optional.some(scope);\n    } else if (isFunction(isRoot) && isRoot(scope)) {\n      return Optional.none();\n    } else {\n      return ancestor(scope, a, isRoot);\n    }\n  };\n  const ancestor$4 = (scope, predicate, isRoot) => {\n    let element = scope.dom;\n    const stop = isFunction(isRoot) ? isRoot : never;\n    while (element.parentNode) {\n      element = element.parentNode;\n      const el = SugarElement.fromDom(element);\n      if (predicate(el)) {\n        return Optional.some(el);\n      } else if (stop(el)) {\n        break;\n      }\n    }\n    return Optional.none();\n  };\n  const closest$4 = (scope, predicate, isRoot) => {\n    const is = (s, test) => test(s);\n    return ClosestOrAncestor(is, ancestor$4, scope, predicate, isRoot);\n  };\n  const sibling$1 = (scope, predicate) => {\n    const element = scope.dom;\n    if (!element.parentNode) {\n      return Optional.none();\n    }\n    return child(SugarElement.fromDom(element.parentNode), x => !eq(scope, x) && predicate(x));\n  };\n  const child = (scope, predicate) => {\n    const pred = node => predicate(SugarElement.fromDom(node));\n    const result = find$2(scope.dom.childNodes, pred);\n    return result.map(SugarElement.fromDom);\n  };\n  const descendant$2 = (scope, predicate) => {\n    const descend = node => {\n      for (let i = 0; i < node.childNodes.length; i++) {\n        const child = SugarElement.fromDom(node.childNodes[i]);\n        if (predicate(child)) {\n          return Optional.some(child);\n        }\n        const res = descend(node.childNodes[i]);\n        if (res.isSome()) {\n          return res;\n        }\n      }\n      return Optional.none();\n    };\n    return descend(scope.dom);\n  };\n  const ancestor$3 = (scope, selector, isRoot) => ancestor$4(scope, e => is$1(e, selector), isRoot);\n  const descendant$1 = (scope, selector) => one(selector, scope);\n  const closest$3 = (scope, selector, isRoot) => {\n    const is = (element, selector) => is$1(element, selector);\n    return ClosestOrAncestor(is, ancestor$3, scope, selector, isRoot);\n  };\n  const closest$2 = target => closest$3(target, '[contenteditable]');\n  const isEditable$2 = (element, assumeEditable = false) => {\n    if (inBody(element)) {\n      return element.dom.isContentEditable;\n    } else {\n      return closest$2(element).fold(constant(assumeEditable), editable => getRaw$1(editable) === 'true');\n    }\n  };\n  const getRaw$1 = element => element.dom.contentEditable;\n  const isSupported = dom => dom.style !== undefined && isFunction(dom.style.getPropertyValue);\n  const internalSet = (dom, property, value) => {\n    if (!isString(value)) {\n      console.error('Invalid call to CSS.set. Property ', property, ':: Value ', value, ':: Element ', dom);\n      throw new Error('CSS value must be a string: ' + value);\n    }\n    if (isSupported(dom)) {\n      dom.style.setProperty(property, value);\n    }\n  };\n  const internalRemove = (dom, property) => {\n    if (isSupported(dom)) {\n      dom.style.removeProperty(property);\n    }\n  };\n  const set$2 = (element, property, value) => {\n    const dom = element.dom;\n    internalSet(dom, property, value);\n  };\n  const setAll = (element, css) => {\n    const dom = element.dom;\n    each$d(css, (v, k) => {\n      internalSet(dom, k, v);\n    });\n  };\n  const get$7 = (element, property) => {\n    const dom = element.dom;\n    const styles = window.getComputedStyle(dom);\n    const r = styles.getPropertyValue(property);\n    return r === '' && !inBody(element) ? getUnsafeProperty(dom, property) : r;\n  };\n  const getUnsafeProperty = (dom, property) => isSupported(dom) ? dom.style.getPropertyValue(property) : '';\n  const getRaw = (element, property) => {\n    const dom = element.dom;\n    const raw = getUnsafeProperty(dom, property);\n    return Optional.from(raw).filter(r => r.length > 0);\n  };\n  const getAllRaw = element => {\n    const css = {};\n    const dom = element.dom;\n    if (isSupported(dom)) {\n      for (let i = 0; i < dom.style.length; i++) {\n        const ruleName = dom.style.item(i);\n        css[ruleName] = dom.style[ruleName];\n      }\n    }\n    return css;\n  };\n  const remove$5 = (element, property) => {\n    const dom = element.dom;\n    internalRemove(dom, property);\n    if (is$2(getOpt(element, 'style').map(trim$4), '')) {\n      remove$9(element, 'style');\n    }\n  };\n  const reflow = e => e.dom.offsetWidth;\n  const before$3 = (marker, element) => {\n    const parent$1 = parent(marker);\n    parent$1.each(v => {\n      v.dom.insertBefore(element.dom, marker.dom);\n    });\n  };\n  const after$4 = (marker, element) => {\n    const sibling = nextSibling(marker);\n    sibling.fold(() => {\n      const parent$1 = parent(marker);\n      parent$1.each(v => {\n        append$1(v, element);\n      });\n    }, v => {\n      before$3(v, element);\n    });\n  };\n  const prepend = (parent, element) => {\n    const firstChild$1 = firstChild(parent);\n    firstChild$1.fold(() => {\n      append$1(parent, element);\n    }, v => {\n      parent.dom.insertBefore(element.dom, v.dom);\n    });\n  };\n  const append$1 = (parent, element) => {\n    parent.dom.appendChild(element.dom);\n  };\n  const wrap$2 = (element, wrapper) => {\n    before$3(element, wrapper);\n    append$1(wrapper, element);\n  };\n  const after$3 = (marker, elements) => {\n    each$e(elements, (x, i) => {\n      const e = i === 0 ? marker : elements[i - 1];\n      after$4(e, x);\n    });\n  };\n  const append = (parent, elements) => {\n    each$e(elements, x => {\n      append$1(parent, x);\n    });\n  };\n  const empty = element => {\n    element.dom.textContent = '';\n    each$e(children$1(element), rogue => {\n      remove$4(rogue);\n    });\n  };\n  const remove$4 = element => {\n    const dom = element.dom;\n    if (dom.parentNode !== null) {\n      dom.parentNode.removeChild(dom);\n    }\n  };\n  const unwrap = wrapper => {\n    const children = children$1(wrapper);\n    if (children.length > 0) {\n      after$3(wrapper, children);\n    }\n    remove$4(wrapper);\n  };\n  const fromHtml = (html, scope) => {\n    const doc = scope || document;\n    const div = doc.createElement('div');\n    div.innerHTML = html;\n    return children$1(SugarElement.fromDom(div));\n  };\n  const fromDom$1 = nodes => map$3(nodes, SugarElement.fromDom);\n  const get$6 = element => element.dom.innerHTML;\n  const set$1 = (element, content) => {\n    const owner = owner$1(element);\n    const docDom = owner.dom;\n    const fragment = SugarElement.fromDom(docDom.createDocumentFragment());\n    const contentElements = fromHtml(content, docDom);\n    append(fragment, contentElements);\n    empty(element);\n    append$1(element, fragment);\n  };\n  const getOuter = element => {\n    const container = SugarElement.fromTag('div');\n    const clone = SugarElement.fromDom(element.dom.cloneNode(true));\n    append$1(container, clone);\n    return get$6(container);\n  };\n  const mkEvent = (target, x, y, stop, prevent, kill, raw) => ({\n    target,\n    x,\n    y,\n    stop,\n    prevent,\n    kill,\n    raw\n  });\n  const fromRawEvent = rawEvent => {\n    const target = SugarElement.fromDom(getOriginalEventTarget(rawEvent).getOr(rawEvent.target));\n    const stop = () => rawEvent.stopPropagation();\n    const prevent = () => rawEvent.preventDefault();\n    const kill = compose(prevent, stop);\n    return mkEvent(target, rawEvent.clientX, rawEvent.clientY, stop, prevent, kill, rawEvent);\n  };\n  const handle$1 = (filter, handler) => rawEvent => {\n    if (filter(rawEvent)) {\n      handler(fromRawEvent(rawEvent));\n    }\n  };\n  const binder = (element, event, filter, handler, useCapture) => {\n    const wrapped = handle$1(filter, handler);\n    element.dom.addEventListener(event, wrapped, useCapture);\n    return {\n      unbind: curry(unbind, element, event, wrapped, useCapture)\n    };\n  };\n  const bind$2 = (element, event, filter, handler) => binder(element, event, filter, handler, false);\n  const unbind = (element, event, handler, useCapture) => {\n    element.dom.removeEventListener(event, handler, useCapture);\n  };\n  const r = (left, top) => {\n    const translate = (x, y) => r(left + x, top + y);\n    return {\n      left,\n      top,\n      translate\n    };\n  };\n  const SugarPosition = r;\n  const boxPosition = dom => {\n    const box = dom.getBoundingClientRect();\n    return SugarPosition(box.left, box.top);\n  };\n  const firstDefinedOrZero = (a, b) => {\n    if (a !== undefined) {\n      return a;\n    } else {\n      return b !== undefined ? b : 0;\n    }\n  };\n  const absolute = element => {\n    const doc = element.dom.ownerDocument;\n    const body = doc.body;\n    const win = doc.defaultView;\n    const html = doc.documentElement;\n    if (body === element.dom) {\n      return SugarPosition(body.offsetLeft, body.offsetTop);\n    }\n    const scrollTop = firstDefinedOrZero(win === null || win === void 0 ? void 0 : win.pageYOffset, html.scrollTop);\n    const scrollLeft = firstDefinedOrZero(win === null || win === void 0 ? void 0 : win.pageXOffset, html.scrollLeft);\n    const clientTop = firstDefinedOrZero(html.clientTop, body.clientTop);\n    const clientLeft = firstDefinedOrZero(html.clientLeft, body.clientLeft);\n    return viewport(element).translate(scrollLeft - clientLeft, scrollTop - clientTop);\n  };\n  const viewport = element => {\n    const dom = element.dom;\n    const doc = dom.ownerDocument;\n    const body = doc.body;\n    if (body === dom) {\n      return SugarPosition(body.offsetLeft, body.offsetTop);\n    }\n    if (!inBody(element)) {\n      return SugarPosition(0, 0);\n    }\n    return boxPosition(dom);\n  };\n  const get$5 = _DOC => {\n    const doc = _DOC !== undefined ? _DOC.dom : document;\n    const x = doc.body.scrollLeft || doc.documentElement.scrollLeft;\n    const y = doc.body.scrollTop || doc.documentElement.scrollTop;\n    return SugarPosition(x, y);\n  };\n  const to = (x, y, _DOC) => {\n    const doc = _DOC !== undefined ? _DOC.dom : document;\n    const win = doc.defaultView;\n    if (win) {\n      win.scrollTo(x, y);\n    }\n  };\n  const intoView = (element, alignToTop) => {\n    const isSafari = detect$1().browser.isSafari();\n    if (isSafari && isFunction(element.dom.scrollIntoViewIfNeeded)) {\n      element.dom.scrollIntoViewIfNeeded(false);\n    } else {\n      element.dom.scrollIntoView(alignToTop);\n    }\n  };\n  const get$4 = _win => {\n    const win = _win === undefined ? window : _win;\n    if (detect$1().browser.isFirefox()) {\n      return Optional.none();\n    } else {\n      return Optional.from(win.visualViewport);\n    }\n  };\n  const bounds = (x, y, width, height) => ({\n    x,\n    y,\n    width,\n    height,\n    right: x + width,\n    bottom: y + height\n  });\n  const getBounds = _win => {\n    const win = _win === undefined ? window : _win;\n    const doc = win.document;\n    const scroll = get$5(SugarElement.fromDom(doc));\n    return get$4(win).fold(() => {\n      const html = win.document.documentElement;\n      const width = html.clientWidth;\n      const height = html.clientHeight;\n      return bounds(scroll.left, scroll.top, width, height);\n    }, visualViewport => bounds(Math.max(visualViewport.pageLeft, scroll.left), Math.max(visualViewport.pageTop, scroll.top), visualViewport.width, visualViewport.height));\n  };\n  const children = (scope, predicate) => filter$5(children$1(scope), predicate);\n  const descendants$1 = (scope, predicate) => {\n    let result = [];\n    each$e(children$1(scope), x => {\n      if (predicate(x)) {\n        result = result.concat([x]);\n      }\n      result = result.concat(descendants$1(x, predicate));\n    });\n    return result;\n  };\n  const descendants = (scope, selector) => all(selector, scope);\n  const ancestor$2 = (scope, predicate, isRoot) => ancestor$4(scope, predicate, isRoot).isSome();\n  const sibling = (scope, predicate) => sibling$1(scope, predicate).isSome();\n  const descendant = (scope, predicate) => descendant$2(scope, predicate).isSome();\n  class DomTreeWalker {\n    constructor(startNode, rootNode) {\n      this.node = startNode;\n      this.rootNode = rootNode;\n      this.current = this.current.bind(this);\n      this.next = this.next.bind(this);\n      this.prev = this.prev.bind(this);\n      this.prev2 = this.prev2.bind(this);\n    }\n    current() {\n      return this.node;\n    }\n    next(shallow) {\n      this.node = this.findSibling(this.node, 'firstChild', 'nextSibling', shallow);\n      return this.node;\n    }\n    prev(shallow) {\n      this.node = this.findSibling(this.node, 'lastChild', 'previousSibling', shallow);\n      return this.node;\n    }\n    prev2(shallow) {\n      this.node = this.findPreviousNode(this.node, shallow);\n      return this.node;\n    }\n    findSibling(node, startName, siblingName, shallow) {\n      if (node) {\n        if (!shallow && node[startName]) {\n          return node[startName];\n        }\n        if (node !== this.rootNode) {\n          let sibling = node[siblingName];\n          if (sibling) {\n            return sibling;\n          }\n          for (let parent = node.parentNode; parent && parent !== this.rootNode; parent = parent.parentNode) {\n            sibling = parent[siblingName];\n            if (sibling) {\n              return sibling;\n            }\n          }\n        }\n      }\n      return undefined;\n    }\n    findPreviousNode(node, shallow) {\n      if (node) {\n        const sibling = node.previousSibling;\n        if (this.rootNode && sibling === this.rootNode) {\n          return;\n        }\n        if (sibling) {\n          if (!shallow) {\n            for (let child = sibling.lastChild; child; child = child.lastChild) {\n              if (!child.lastChild) {\n                return child;\n              }\n            }\n          }\n          return sibling;\n        }\n        const parent = node.parentNode;\n        if (parent && parent !== this.rootNode) {\n          return parent;\n        }\n      }\n      return undefined;\n    }\n  }\n  const zeroWidth = '\\uFEFF';\n  const nbsp = '\\xA0';\n  const isZwsp$2 = char => char === zeroWidth;\n  const removeZwsp = s => s.replace(/\\uFEFF/g, '');\n  const whiteSpaceRegExp = /^[ \\t\\r\\n]*$/;\n  const isWhitespaceText = text => whiteSpaceRegExp.test(text);\n  const isZwsp$1 = text => {\n    for (const c of text) {\n      if (!isZwsp$2(c)) {\n        return false;\n      }\n    }\n    return true;\n  };\n  const isCollapsibleWhitespace$1 = c => ' \\f\\t\\x0B'.indexOf(c) !== -1;\n  const isNewLineChar = c => c === '\\n' || c === '\\r';\n  const isNewline = (text, idx) => idx < text.length && idx >= 0 ? isNewLineChar(text[idx]) : false;\n  const normalize$4 = (text, tabSpaces = 4, isStartOfContent = true, isEndOfContent = true) => {\n    const tabSpace = repeat(' ', tabSpaces);\n    const normalizedText = text.replace(/\\t/g, tabSpace);\n    const result = foldl(normalizedText, (acc, c) => {\n      if (isCollapsibleWhitespace$1(c) || c === nbsp) {\n        if (acc.pcIsSpace || acc.str === '' && isStartOfContent || acc.str.length === normalizedText.length - 1 && isEndOfContent || isNewline(normalizedText, acc.str.length + 1)) {\n          return {\n            pcIsSpace: false,\n            str: acc.str + nbsp\n          };\n        } else {\n          return {\n            pcIsSpace: true,\n            str: acc.str + ' '\n          };\n        }\n      } else {\n        return {\n          pcIsSpace: isNewLineChar(c),\n          str: acc.str + c\n        };\n      }\n    }, {\n      pcIsSpace: false,\n      str: ''\n    });\n    return result.str;\n  };\n  const isNodeType = type => {\n    return node => {\n      return !!node && node.nodeType === type;\n    };\n  };\n  const isRestrictedNode = node => !!node && !Object.getPrototypeOf(node);\n  const isElement$6 = isNodeType(1);\n  const isHTMLElement = node => isElement$6(node) && isHTMLElement$1(SugarElement.fromDom(node));\n  const isSVGElement = node => isElement$6(node) && node.namespaceURI === 'http://www.w3.org/2000/svg';\n  const matchNodeName = name => {\n    const lowerCasedName = name.toLowerCase();\n    return node => isNonNullable(node) && node.nodeName.toLowerCase() === lowerCasedName;\n  };\n  const matchNodeNames = names => {\n    const lowerCasedNames = names.map(s => s.toLowerCase());\n    return node => {\n      if (node && node.nodeName) {\n        const nodeName = node.nodeName.toLowerCase();\n        return contains$2(lowerCasedNames, nodeName);\n      }\n      return false;\n    };\n  };\n  const matchStyleValues = (name, values) => {\n    const items = values.toLowerCase().split(' ');\n    return node => {\n      if (isElement$6(node)) {\n        const win = node.ownerDocument.defaultView;\n        if (win) {\n          for (let i = 0; i < items.length; i++) {\n            const computed = win.getComputedStyle(node, null);\n            const cssValue = computed ? computed.getPropertyValue(name) : null;\n            if (cssValue === items[i]) {\n              return true;\n            }\n          }\n        }\n      }\n      return false;\n    };\n  };\n  const hasAttribute = attrName => {\n    return node => {\n      return isElement$6(node) && node.hasAttribute(attrName);\n    };\n  };\n  const isBogus$1 = node => isElement$6(node) && node.hasAttribute('data-mce-bogus');\n  const isBogusAll = node => isElement$6(node) && node.getAttribute('data-mce-bogus') === 'all';\n  const isTable$2 = node => isElement$6(node) && node.tagName === 'TABLE';\n  const hasContentEditableState = value => {\n    return node => {\n      if (isHTMLElement(node)) {\n        if (node.contentEditable === value) {\n          return true;\n        }\n        if (node.getAttribute('data-mce-contenteditable') === value) {\n          return true;\n        }\n      }\n      return false;\n    };\n  };\n  const isTextareaOrInput = matchNodeNames(['textarea', 'input']);\n  const isText$b = isNodeType(3);\n  const isCData = isNodeType(4);\n  const isPi = isNodeType(7);\n  const isComment = isNodeType(8);\n  const isDocument$1 = isNodeType(9);\n  const isDocumentFragment = isNodeType(11);\n  const isBr$6 = matchNodeName('br');\n  const isImg = matchNodeName('img');\n  const isContentEditableTrue$3 = hasContentEditableState('true');\n  const isContentEditableFalse$b = hasContentEditableState('false');\n  const isTableCell$3 = matchNodeNames(['td', 'th']);\n  const isTableCellOrCaption = matchNodeNames(['td', 'th', 'caption']);\n  const isMedia$2 = matchNodeNames(['video', 'audio', 'object', 'embed']);\n  const isListItem$2 = matchNodeName('li');\n  const isDetails = matchNodeName('details');\n  const isSummary$1 = matchNodeName('summary');\n  const defaultOptionValues = {\n    skipBogus: true,\n    includeZwsp: false,\n    checkRootAsContent: false\n  };\n  const hasWhitespacePreserveParent = (node, rootNode, schema) => {\n    const rootElement = SugarElement.fromDom(rootNode);\n    const startNode = SugarElement.fromDom(node);\n    const whitespaceElements = schema.getWhitespaceElements();\n    const predicate = node => has$2(whitespaceElements, name(node));\n    return ancestor$2(startNode, predicate, curry(eq, rootElement));\n  };\n  const isNamedAnchor = node => {\n    return isElement$6(node) && node.nodeName === 'A' && !node.hasAttribute('href') && (node.hasAttribute('name') || node.hasAttribute('id'));\n  };\n  const isNonEmptyElement$1 = (node, schema) => {\n    return isElement$6(node) && has$2(schema.getNonEmptyElements(), node.nodeName);\n  };\n  const isBookmark = hasAttribute('data-mce-bookmark');\n  const hasNonEditableParent = node => parentElement(SugarElement.fromDom(node)).exists(parent => !isEditable$2(parent));\n  const isWhitespace$1 = (node, rootNode, schema) => isWhitespaceText(node.data) && !hasWhitespacePreserveParent(node, rootNode, schema);\n  const isText$a = (node, rootNode, schema, options) => isText$b(node) && !isWhitespace$1(node, rootNode, schema) && (!options.includeZwsp || !isZwsp$1(node.data));\n  const isContentNode = (schema, node, rootNode, options) => {\n    return isFunction(options.isContent) && options.isContent(node) || isNonEmptyElement$1(node, schema) || isBookmark(node) || isNamedAnchor(node) || isText$a(node, rootNode, schema, options) || isContentEditableFalse$b(node) || isContentEditableTrue$3(node) && hasNonEditableParent(node);\n  };\n  const isEmptyNode = (schema, targetNode, opts) => {\n    const options = {\n      ...defaultOptionValues,\n      ...opts\n    };\n    if (options.checkRootAsContent) {\n      if (isContentNode(schema, targetNode, targetNode, options)) {\n        return false;\n      }\n    }\n    let node = targetNode.firstChild;\n    let brCount = 0;\n    if (!node) {\n      return true;\n    }\n    const walker = new DomTreeWalker(node, targetNode);\n    do {\n      if (options.skipBogus && isElement$6(node)) {\n        const bogusValue = node.getAttribute('data-mce-bogus');\n        if (bogusValue) {\n          node = walker.next(bogusValue === 'all');\n          continue;\n        }\n      }\n      if (isComment(node)) {\n        node = walker.next(true);\n        continue;\n      }\n      if (isBr$6(node)) {\n        brCount++;\n        node = walker.next();\n        continue;\n      }\n      if (isContentNode(schema, node, targetNode, options)) {\n        return false;\n      }\n      node = walker.next();\n    } while (node);\n    return brCount <= 1;\n  };\n  const isEmpty$2 = (schema, elm, options) => {\n    return isEmptyNode(schema, elm.dom, {\n      checkRootAsContent: true,\n      ...options\n    });\n  };\n  const isContent$1 = (schema, node, options) => {\n    return isContentNode(schema, node, node, {\n      includeZwsp: defaultOptionValues.includeZwsp,\n      ...options\n    });\n  };\n  const Cell = initial => {\n    let value = initial;\n    const get = () => {\n      return value;\n    };\n    const set = v => {\n      value = v;\n    };\n    return {\n      get,\n      set\n    };\n  };\n  const singleton = doRevoke => {\n    const subject = Cell(Optional.none());\n    const revoke = () => subject.get().each(doRevoke);\n    const clear = () => {\n      revoke();\n      subject.set(Optional.none());\n    };\n    const isSet = () => subject.get().isSome();\n    const get = () => subject.get();\n    const set = s => {\n      revoke();\n      subject.set(Optional.some(s));\n    };\n    return {\n      clear,\n      isSet,\n      get,\n      set\n    };\n  };\n  const repeatable = delay => {\n    const intervalId = Cell(Optional.none());\n    const revoke = () => intervalId.get().each(id => clearInterval(id));\n    const clear = () => {\n      revoke();\n      intervalId.set(Optional.none());\n    };\n    const isSet = () => intervalId.get().isSome();\n    const get = () => intervalId.get();\n    const set = functionToRepeat => {\n      revoke();\n      intervalId.set(Optional.some(setInterval(functionToRepeat, delay)));\n    };\n    return {\n      clear,\n      isSet,\n      get,\n      set\n    };\n  };\n  const value$2 = () => {\n    const subject = singleton(noop);\n    const on = f => subject.get().each(f);\n    return {\n      ...subject,\n      on\n    };\n  };\n  const nodeNameToNamespaceType = name => {\n    const lowerCaseName = name.toLowerCase();\n    if (lowerCaseName === 'svg') {\n      return 'svg';\n    } else if (lowerCaseName === 'math') {\n      return 'math';\n    } else {\n      return 'html';\n    }\n  };\n  const isNonHtmlElementRootName = name => nodeNameToNamespaceType(name) !== 'html';\n  const isNonHtmlElementRoot = node => isNonHtmlElementRootName(node.nodeName);\n  const toScopeType = node => nodeNameToNamespaceType(node.nodeName);\n  const namespaceElements = ['svg', 'math'];\n  const createNamespaceTracker = () => {\n    const currentScope = value$2();\n    const current = () => currentScope.get().map(toScopeType).getOr('html');\n    const track = node => {\n      if (isNonHtmlElementRoot(node)) {\n        currentScope.set(node);\n      } else if (currentScope.get().exists(scopeNode => !scopeNode.contains(node))) {\n        currentScope.clear();\n      }\n      return current();\n    };\n    const reset = () => {\n      currentScope.clear();\n    };\n    return {\n      track,\n      current,\n      reset\n    };\n  };\n  const transparentBlockAttr = 'data-mce-block';\n  const elementNames = map => filter$5(keys(map), key => !/[A-Z]/.test(key));\n  const makeSelectorFromSchemaMap = map => map$3(elementNames(map), name => {\n    const escapedName = CSS.escape(name);\n    return `${escapedName}:` + map$3(namespaceElements, ns => `not(${ns} ${escapedName})`).join(':');\n  }).join(',');\n  const updateTransparent = (blocksSelector, transparent) => {\n    if (isNonNullable(transparent.querySelector(blocksSelector))) {\n      transparent.setAttribute(transparentBlockAttr, 'true');\n      if (transparent.getAttribute('data-mce-selected') === 'inline-boundary') {\n        transparent.removeAttribute('data-mce-selected');\n      }\n      return true;\n    } else {\n      transparent.removeAttribute(transparentBlockAttr);\n      return false;\n    }\n  };\n  const updateBlockStateOnChildren = (schema, scope) => {\n    const transparentSelector = makeSelectorFromSchemaMap(schema.getTransparentElements());\n    const blocksSelector = makeSelectorFromSchemaMap(schema.getBlockElements());\n    return filter$5(scope.querySelectorAll(transparentSelector), transparent => updateTransparent(blocksSelector, transparent));\n  };\n  const trimEdge = (schema, el, leftSide) => {\n    var _a;\n    const childPropertyName = leftSide ? 'lastChild' : 'firstChild';\n    for (let child = el[childPropertyName]; child; child = child[childPropertyName]) {\n      if (isEmptyNode(schema, child, {\n        checkRootAsContent: true\n      })) {\n        (_a = child.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(child);\n        return;\n      }\n    }\n  };\n  const split$2 = (schema, parentElm, splitElm) => {\n    const range = document.createRange();\n    const parentNode = parentElm.parentNode;\n    if (parentNode) {\n      range.setStartBefore(parentElm);\n      range.setEndBefore(splitElm);\n      const beforeFragment = range.extractContents();\n      trimEdge(schema, beforeFragment, true);\n      range.setStartAfter(splitElm);\n      range.setEndAfter(parentElm);\n      const afterFragment = range.extractContents();\n      trimEdge(schema, afterFragment, false);\n      if (!isEmptyNode(schema, beforeFragment, {\n        checkRootAsContent: true\n      })) {\n        parentNode.insertBefore(beforeFragment, parentElm);\n      }\n      if (!isEmptyNode(schema, splitElm, {\n        checkRootAsContent: true\n      })) {\n        parentNode.insertBefore(splitElm, parentElm);\n      }\n      if (!isEmptyNode(schema, afterFragment, {\n        checkRootAsContent: true\n      })) {\n        parentNode.insertBefore(afterFragment, parentElm);\n      }\n      parentNode.removeChild(parentElm);\n    }\n  };\n  const splitInvalidChildren = (schema, scope, transparentBlocks) => {\n    const blocksElements = schema.getBlockElements();\n    const rootNode = SugarElement.fromDom(scope);\n    const isBlock = el => name(el) in blocksElements;\n    const isRoot = el => eq(el, rootNode);\n    each$e(fromDom$1(transparentBlocks), transparentBlock => {\n      ancestor$4(transparentBlock, isBlock, isRoot).each(parentBlock => {\n        const invalidChildren = children(transparentBlock, el => isBlock(el) && !schema.isValidChild(name(parentBlock), name(el)));\n        if (invalidChildren.length > 0) {\n          const stateScope = parentElement(parentBlock);\n          each$e(invalidChildren, child => {\n            ancestor$4(child, isBlock, isRoot).each(parentBlock => {\n              split$2(schema, parentBlock.dom, child.dom);\n            });\n          });\n          stateScope.each(scope => updateBlockStateOnChildren(schema, scope.dom));\n        }\n      });\n    });\n  };\n  const unwrapInvalidChildren = (schema, scope, transparentBlocks) => {\n    each$e([...transparentBlocks, ...(isTransparentBlock(schema, scope) ? [scope] : [])], block => each$e(descendants(SugarElement.fromDom(block), block.nodeName.toLowerCase()), elm => {\n      if (isTransparentInline(schema, elm.dom)) {\n        unwrap(elm);\n      }\n    }));\n  };\n  const updateChildren = (schema, scope) => {\n    const transparentBlocks = updateBlockStateOnChildren(schema, scope);\n    splitInvalidChildren(schema, scope, transparentBlocks);\n    unwrapInvalidChildren(schema, scope, transparentBlocks);\n  };\n  const updateElement = (schema, target) => {\n    if (isTransparentElement(schema, target)) {\n      const blocksSelector = makeSelectorFromSchemaMap(schema.getBlockElements());\n      updateTransparent(blocksSelector, target);\n    }\n  };\n  const updateCaret = (schema, root, caretParent) => {\n    const isRoot = el => eq(el, SugarElement.fromDom(root));\n    const parents = parents$1(SugarElement.fromDom(caretParent), isRoot);\n    get$b(parents, parents.length - 2).filter(isElement$7).fold(() => updateChildren(schema, root), scope => updateChildren(schema, scope.dom));\n  };\n  const hasBlockAttr = el => el.hasAttribute(transparentBlockAttr);\n  const isTransparentElementName = (schema, name) => has$2(schema.getTransparentElements(), name);\n  const isTransparentElement = (schema, node) => isElement$6(node) && isTransparentElementName(schema, node.nodeName);\n  const isTransparentBlock = (schema, node) => isTransparentElement(schema, node) && hasBlockAttr(node);\n  const isTransparentInline = (schema, node) => isTransparentElement(schema, node) && !hasBlockAttr(node);\n  const isTransparentAstBlock = (schema, node) => node.type === 1 && isTransparentElementName(schema, node.name) && isString(node.attr(transparentBlockAttr));\n  const browser$2 = detect$1().browser;\n  const firstElement = nodes => find$2(nodes, isElement$7);\n  const getTableCaptionDeltaY = elm => {\n    if (browser$2.isFirefox() && name(elm) === 'table') {\n      return firstElement(children$1(elm)).filter(elm => {\n        return name(elm) === 'caption';\n      }).bind(caption => {\n        return firstElement(nextSiblings(caption)).map(body => {\n          const bodyTop = body.dom.offsetTop;\n          const captionTop = caption.dom.offsetTop;\n          const captionHeight = caption.dom.offsetHeight;\n          return bodyTop <= captionTop ? -captionHeight : 0;\n        });\n      }).getOr(0);\n    } else {\n      return 0;\n    }\n  };\n  const hasChild = (elm, child) => elm.children && contains$2(elm.children, child);\n  const getPos = (body, elm, rootElm) => {\n    let x = 0,\n      y = 0;\n    const doc = body.ownerDocument;\n    rootElm = rootElm ? rootElm : body;\n    if (elm) {\n      if (rootElm === body && elm.getBoundingClientRect && get$7(SugarElement.fromDom(body), 'position') === 'static') {\n        const pos = elm.getBoundingClientRect();\n        x = pos.left + (doc.documentElement.scrollLeft || body.scrollLeft) - doc.documentElement.clientLeft;\n        y = pos.top + (doc.documentElement.scrollTop || body.scrollTop) - doc.documentElement.clientTop;\n        return {\n          x,\n          y\n        };\n      }\n      let offsetParent = elm;\n      while (offsetParent && offsetParent !== rootElm && offsetParent.nodeType && !hasChild(offsetParent, rootElm)) {\n        const castOffsetParent = offsetParent;\n        x += castOffsetParent.offsetLeft || 0;\n        y += castOffsetParent.offsetTop || 0;\n        offsetParent = castOffsetParent.offsetParent;\n      }\n      offsetParent = elm.parentNode;\n      while (offsetParent && offsetParent !== rootElm && offsetParent.nodeType && !hasChild(offsetParent, rootElm)) {\n        x -= offsetParent.scrollLeft || 0;\n        y -= offsetParent.scrollTop || 0;\n        offsetParent = offsetParent.parentNode;\n      }\n      y += getTableCaptionDeltaY(SugarElement.fromDom(elm));\n    }\n    return {\n      x,\n      y\n    };\n  };\n  const StyleSheetLoader = (documentOrShadowRoot, settings = {}) => {\n    let idCount = 0;\n    const loadedStates = {};\n    const edos = SugarElement.fromDom(documentOrShadowRoot);\n    const doc = documentOrOwner(edos);\n    const _setReferrerPolicy = referrerPolicy => {\n      settings.referrerPolicy = referrerPolicy;\n    };\n    const _setContentCssCors = contentCssCors => {\n      settings.contentCssCors = contentCssCors;\n    };\n    const addStyle = element => {\n      append$1(getStyleContainer(edos), element);\n    };\n    const removeStyle = id => {\n      const styleContainer = getStyleContainer(edos);\n      descendant$1(styleContainer, '#' + id).each(remove$4);\n    };\n    const getOrCreateState = url => get$a(loadedStates, url).getOrThunk(() => ({\n      id: 'mce-u' + idCount++,\n      passed: [],\n      failed: [],\n      count: 0\n    }));\n    const load = url => new Promise((success, failure) => {\n      let link;\n      const urlWithSuffix = Tools._addCacheSuffix(url);\n      const state = getOrCreateState(urlWithSuffix);\n      loadedStates[urlWithSuffix] = state;\n      state.count++;\n      const resolve = (callbacks, status) => {\n        each$e(callbacks, call);\n        state.status = status;\n        state.passed = [];\n        state.failed = [];\n        if (link) {\n          link.onload = null;\n          link.onerror = null;\n          link = null;\n        }\n      };\n      const passed = () => resolve(state.passed, 2);\n      const failed = () => resolve(state.failed, 3);\n      if (success) {\n        state.passed.push(success);\n      }\n      if (failure) {\n        state.failed.push(failure);\n      }\n      if (state.status === 1) {\n        return;\n      }\n      if (state.status === 2) {\n        passed();\n        return;\n      }\n      if (state.status === 3) {\n        failed();\n        return;\n      }\n      state.status = 1;\n      const linkElem = SugarElement.fromTag('link', doc.dom);\n      setAll$1(linkElem, {\n        rel: 'stylesheet',\n        type: 'text/css',\n        id: state.id\n      });\n      if (settings.contentCssCors) {\n        set$3(linkElem, 'crossOrigin', 'anonymous');\n      }\n      if (settings.referrerPolicy) {\n        set$3(linkElem, 'referrerpolicy', settings.referrerPolicy);\n      }\n      link = linkElem.dom;\n      link.onload = passed;\n      link.onerror = failed;\n      addStyle(linkElem);\n      set$3(linkElem, 'href', urlWithSuffix);\n    });\n    const loadRawCss = (key, css) => {\n      const state = getOrCreateState(key);\n      loadedStates[key] = state;\n      state.count++;\n      const styleElem = SugarElement.fromTag('style', doc.dom);\n      setAll$1(styleElem, {\n        rel: 'stylesheet',\n        type: 'text/css',\n        id: state.id\n      });\n      styleElem.dom.innerHTML = css;\n      addStyle(styleElem);\n    };\n    const loadAll = urls => {\n      const loadedUrls = Promise.allSettled(map$3(urls, url => load(url).then(constant(url))));\n      return loadedUrls.then(results => {\n        const parts = partition$2(results, r => r.status === 'fulfilled');\n        if (parts.fail.length > 0) {\n          return Promise.reject(map$3(parts.fail, result => result.reason));\n        } else {\n          return map$3(parts.pass, result => result.value);\n        }\n      });\n    };\n    const unload = url => {\n      const urlWithSuffix = Tools._addCacheSuffix(url);\n      get$a(loadedStates, urlWithSuffix).each(state => {\n        const count = --state.count;\n        if (count === 0) {\n          delete loadedStates[urlWithSuffix];\n          removeStyle(state.id);\n        }\n      });\n    };\n    const unloadRawCss = key => {\n      get$a(loadedStates, key).each(state => {\n        const count = --state.count;\n        if (count === 0) {\n          delete loadedStates[key];\n          removeStyle(state.id);\n        }\n      });\n    };\n    const unloadAll = urls => {\n      each$e(urls, url => {\n        unload(url);\n      });\n    };\n    return {\n      load,\n      loadRawCss,\n      loadAll,\n      unload,\n      unloadRawCss,\n      unloadAll,\n      _setReferrerPolicy,\n      _setContentCssCors\n    };\n  };\n  const create$c = () => {\n    const map = new WeakMap();\n    const forElement = (referenceElement, settings) => {\n      const root = getRootNode(referenceElement);\n      const rootDom = root.dom;\n      return Optional.from(map.get(rootDom)).getOrThunk(() => {\n        const sl = StyleSheetLoader(rootDom, settings);\n        map.set(rootDom, sl);\n        return sl;\n      });\n    };\n    return {\n      forElement\n    };\n  };\n  const instance = create$c();\n  const isSpan = node => node.nodeName.toLowerCase() === 'span';\n  const isInlineContent = (node, schema) => isNonNullable(node) && (isContent$1(schema, node) || schema.isInline(node.nodeName.toLowerCase()));\n  const surroundedByInlineContent = (node, root, schema) => {\n    const prev = new DomTreeWalker(node, root).prev(false);\n    const next = new DomTreeWalker(node, root).next(false);\n    const prevIsInline = isUndefined(prev) || isInlineContent(prev, schema);\n    const nextIsInline = isUndefined(next) || isInlineContent(next, schema);\n    return prevIsInline && nextIsInline;\n  };\n  const isBookmarkNode$2 = node => isSpan(node) && node.getAttribute('data-mce-type') === 'bookmark';\n  const isKeepTextNode = (node, root, schema) => isText$b(node) && node.data.length > 0 && surroundedByInlineContent(node, root, schema);\n  const isKeepElement = node => isElement$6(node) ? node.childNodes.length > 0 : false;\n  const isDocument = node => isDocumentFragment(node) || isDocument$1(node);\n  const trimNode = (dom, node, schema, root) => {\n    var _a;\n    const rootNode = root || node;\n    if (isElement$6(node) && isBookmarkNode$2(node)) {\n      return node;\n    }\n    const children = node.childNodes;\n    for (let i = children.length - 1; i >= 0; i--) {\n      trimNode(dom, children[i], schema, rootNode);\n    }\n    if (isElement$6(node)) {\n      const currentChildren = node.childNodes;\n      if (currentChildren.length === 1 && isBookmarkNode$2(currentChildren[0])) {\n        (_a = node.parentNode) === null || _a === void 0 ? void 0 : _a.insertBefore(currentChildren[0], node);\n      }\n    }\n    if (!isDocument(node) && !isContent$1(schema, node) && !isKeepElement(node) && !isKeepTextNode(node, rootNode, schema)) {\n      dom.remove(node);\n    }\n    return node;\n  };\n  const makeMap$3 = Tools.makeMap;\n  const attrsCharsRegExp = /[&<>\\\"\\u0060\\u007E-\\uD7FF\\uE000-\\uFFEF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g;\n  const textCharsRegExp = /[<>&\\u007E-\\uD7FF\\uE000-\\uFFEF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g;\n  const rawCharsRegExp = /[<>&\\\"\\']/g;\n  const entityRegExp = /&#([a-z0-9]+);?|&([a-z0-9]+);/gi;\n  const asciiMap = {\n    128: '\\u20AC',\n    130: '\\u201A',\n    131: '\\u0192',\n    132: '\\u201E',\n    133: '\\u2026',\n    134: '\\u2020',\n    135: '\\u2021',\n    136: '\\u02c6',\n    137: '\\u2030',\n    138: '\\u0160',\n    139: '\\u2039',\n    140: '\\u0152',\n    142: '\\u017d',\n    145: '\\u2018',\n    146: '\\u2019',\n    147: '\\u201C',\n    148: '\\u201D',\n    149: '\\u2022',\n    150: '\\u2013',\n    151: '\\u2014',\n    152: '\\u02DC',\n    153: '\\u2122',\n    154: '\\u0161',\n    155: '\\u203A',\n    156: '\\u0153',\n    158: '\\u017e',\n    159: '\\u0178'\n  };\n  const baseEntities = {\n    '\"': '&quot;',\n    '\\'': '&#39;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '&': '&amp;',\n    '`': '&#96;'\n  };\n  const reverseEntities = {\n    '&lt;': '<',\n    '&gt;': '>',\n    '&amp;': '&',\n    '&quot;': '\"',\n    '&apos;': `'`\n  };\n  const nativeDecode = text => {\n    const elm = SugarElement.fromTag('div').dom;\n    elm.innerHTML = text;\n    return elm.textContent || elm.innerText || text;\n  };\n  const buildEntitiesLookup = (items, radix) => {\n    const lookup = {};\n    if (items) {\n      const itemList = items.split(',');\n      radix = radix || 10;\n      for (let i = 0; i < itemList.length; i += 2) {\n        const chr = String.fromCharCode(parseInt(itemList[i], radix));\n        if (!baseEntities[chr]) {\n          const entity = '&' + itemList[i + 1] + ';';\n          lookup[chr] = entity;\n          lookup[entity] = chr;\n        }\n      }\n      return lookup;\n    } else {\n      return undefined;\n    }\n  };\n  const namedEntities = buildEntitiesLookup('50,nbsp,51,iexcl,52,cent,53,pound,54,curren,55,yen,56,brvbar,57,sect,58,uml,59,copy,' + '5a,ordf,5b,laquo,5c,not,5d,shy,5e,reg,5f,macr,5g,deg,5h,plusmn,5i,sup2,5j,sup3,5k,acute,' + '5l,micro,5m,para,5n,middot,5o,cedil,5p,sup1,5q,ordm,5r,raquo,5s,frac14,5t,frac12,5u,frac34,' + '5v,iquest,60,Agrave,61,Aacute,62,Acirc,63,Atilde,64,Auml,65,Aring,66,AElig,67,Ccedil,' + '68,Egrave,69,Eacute,6a,Ecirc,6b,Euml,6c,Igrave,6d,Iacute,6e,Icirc,6f,Iuml,6g,ETH,6h,Ntilde,' + '6i,Ograve,6j,Oacute,6k,Ocirc,6l,Otilde,6m,Ouml,6n,times,6o,Oslash,6p,Ugrave,6q,Uacute,' + '6r,Ucirc,6s,Uuml,6t,Yacute,6u,THORN,6v,szlig,70,agrave,71,aacute,72,acirc,73,atilde,74,auml,' + '75,aring,76,aelig,77,ccedil,78,egrave,79,eacute,7a,ecirc,7b,euml,7c,igrave,7d,iacute,7e,icirc,' + '7f,iuml,7g,eth,7h,ntilde,7i,ograve,7j,oacute,7k,ocirc,7l,otilde,7m,ouml,7n,divide,7o,oslash,' + '7p,ugrave,7q,uacute,7r,ucirc,7s,uuml,7t,yacute,7u,thorn,7v,yuml,ci,fnof,sh,Alpha,si,Beta,' + 'sj,Gamma,sk,Delta,sl,Epsilon,sm,Zeta,sn,Eta,so,Theta,sp,Iota,sq,Kappa,sr,Lambda,ss,Mu,' + 'st,Nu,su,Xi,sv,Omicron,t0,Pi,t1,Rho,t3,Sigma,t4,Tau,t5,Upsilon,t6,Phi,t7,Chi,t8,Psi,' + 't9,Omega,th,alpha,ti,beta,tj,gamma,tk,delta,tl,epsilon,tm,zeta,tn,eta,to,theta,tp,iota,' + 'tq,kappa,tr,lambda,ts,mu,tt,nu,tu,xi,tv,omicron,u0,pi,u1,rho,u2,sigmaf,u3,sigma,u4,tau,' + 'u5,upsilon,u6,phi,u7,chi,u8,psi,u9,omega,uh,thetasym,ui,upsih,um,piv,812,bull,816,hellip,' + '81i,prime,81j,Prime,81u,oline,824,frasl,88o,weierp,88h,image,88s,real,892,trade,89l,alefsym,' + '8cg,larr,8ch,uarr,8ci,rarr,8cj,darr,8ck,harr,8dl,crarr,8eg,lArr,8eh,uArr,8ei,rArr,8ej,dArr,' + '8ek,hArr,8g0,forall,8g2,part,8g3,exist,8g5,empty,8g7,nabla,8g8,isin,8g9,notin,8gb,ni,8gf,prod,' + '8gh,sum,8gi,minus,8gn,lowast,8gq,radic,8gt,prop,8gu,infin,8h0,ang,8h7,and,8h8,or,8h9,cap,8ha,cup,' + '8hb,int,8hk,there4,8hs,sim,8i5,cong,8i8,asymp,8j0,ne,8j1,equiv,8j4,le,8j5,ge,8k2,sub,8k3,sup,8k4,' + 'nsub,8k6,sube,8k7,supe,8kl,oplus,8kn,otimes,8l5,perp,8m5,sdot,8o8,lceil,8o9,rceil,8oa,lfloor,8ob,' + 'rfloor,8p9,lang,8pa,rang,9ea,loz,9j0,spades,9j3,clubs,9j5,hearts,9j6,diams,ai,OElig,aj,oelig,b0,' + 'Scaron,b1,scaron,bo,Yuml,m6,circ,ms,tilde,802,ensp,803,emsp,809,thinsp,80c,zwnj,80d,zwj,80e,lrm,' + '80f,rlm,80j,ndash,80k,mdash,80o,lsquo,80p,rsquo,80q,sbquo,80s,ldquo,80t,rdquo,80u,bdquo,810,dagger,' + '811,Dagger,81g,permil,81p,lsaquo,81q,rsaquo,85c,euro', 32);\n  const encodeRaw = (text, attr) => text.replace(attr ? attrsCharsRegExp : textCharsRegExp, chr => {\n    return baseEntities[chr] || chr;\n  });\n  const encodeAllRaw = text => ('' + text).replace(rawCharsRegExp, chr => {\n    return baseEntities[chr] || chr;\n  });\n  const encodeNumeric = (text, attr) => text.replace(attr ? attrsCharsRegExp : textCharsRegExp, chr => {\n    if (chr.length > 1) {\n      return '&#' + ((chr.charCodeAt(0) - 55296) * 1024 + (chr.charCodeAt(1) - 56320) + 65536) + ';';\n    }\n    return baseEntities[chr] || '&#' + chr.charCodeAt(0) + ';';\n  });\n  const encodeNamed = (text, attr, entities) => {\n    const resolveEntities = entities || namedEntities;\n    return text.replace(attr ? attrsCharsRegExp : textCharsRegExp, chr => {\n      return baseEntities[chr] || resolveEntities[chr] || chr;\n    });\n  };\n  const getEncodeFunc = (name, entities) => {\n    const entitiesMap = buildEntitiesLookup(entities) || namedEntities;\n    const encodeNamedAndNumeric = (text, attr) => text.replace(attr ? attrsCharsRegExp : textCharsRegExp, chr => {\n      if (baseEntities[chr] !== undefined) {\n        return baseEntities[chr];\n      }\n      if (entitiesMap[chr] !== undefined) {\n        return entitiesMap[chr];\n      }\n      if (chr.length > 1) {\n        return '&#' + ((chr.charCodeAt(0) - 55296) * 1024 + (chr.charCodeAt(1) - 56320) + 65536) + ';';\n      }\n      return '&#' + chr.charCodeAt(0) + ';';\n    });\n    const encodeCustomNamed = (text, attr) => {\n      return encodeNamed(text, attr, entitiesMap);\n    };\n    const nameMap = makeMap$3(name.replace(/\\+/g, ','));\n    if (nameMap.named && nameMap.numeric) {\n      return encodeNamedAndNumeric;\n    }\n    if (nameMap.named) {\n      if (entities) {\n        return encodeCustomNamed;\n      }\n      return encodeNamed;\n    }\n    if (nameMap.numeric) {\n      return encodeNumeric;\n    }\n    return encodeRaw;\n  };\n  const decode = text => text.replace(entityRegExp, (all, numeric) => {\n    if (numeric) {\n      if (numeric.charAt(0).toLowerCase() === 'x') {\n        numeric = parseInt(numeric.substr(1), 16);\n      } else {\n        numeric = parseInt(numeric, 10);\n      }\n      if (numeric > 65535) {\n        numeric -= 65536;\n        return String.fromCharCode(55296 + (numeric >> 10), 56320 + (numeric & 1023));\n      }\n      return asciiMap[numeric] || String.fromCharCode(numeric);\n    }\n    return reverseEntities[all] || namedEntities[all] || nativeDecode(all);\n  });\n  const Entities = {\n    encodeRaw,\n    encodeAllRaw,\n    encodeNumeric,\n    encodeNamed,\n    getEncodeFunc,\n    decode\n  };\n  const split$1 = (items, delim) => {\n    items = Tools.trim(items);\n    return items ? items.split(delim || ' ') : [];\n  };\n  const patternToRegExp = str => new RegExp('^' + str.replace(/([?+*])/g, '.$1') + '$');\n  const isRegExp$1 = obj => isObject(obj) && obj.source && Object.prototype.toString.call(obj) === '[object RegExp]';\n  const deepCloneElementRule = obj => {\n    const helper = value => {\n      if (isArray$1(value)) {\n        return map$3(value, helper);\n      } else if (isRegExp$1(value)) {\n        return new RegExp(value.source, value.flags);\n      } else if (isObject(value)) {\n        return map$2(value, helper);\n      } else {\n        return value;\n      }\n    };\n    return helper(obj);\n  };\n  const parseCustomElementsRules = value => {\n    const customElementRegExp = /^(~)?(.+)$/;\n    return bind$3(split$1(value, ','), rule => {\n      const matches = customElementRegExp.exec(rule);\n      if (matches) {\n        const inline = matches[1] === '~';\n        const cloneName = inline ? 'span' : 'div';\n        const name = matches[2];\n        return [{\n          cloneName,\n          name\n        }];\n      } else {\n        return [];\n      }\n    });\n  };\n  const getGlobalAttributeSet = type => {\n    return Object.freeze(['id', 'accesskey', 'class', 'dir', 'lang', 'style', 'tabindex', 'title', 'role', ...(type !== 'html4' ? ['contenteditable', 'contextmenu', 'draggable', 'dropzone', 'hidden', 'spellcheck', 'translate', 'itemprop', 'itemscope', 'itemtype'] : []), ...(type !== 'html5-strict' ? ['xml:lang'] : [])]);\n  };\n  const getElementSetsAsStrings = type => {\n    let blockContent;\n    let phrasingContent;\n    blockContent = 'address blockquote div dl fieldset form h1 h2 h3 h4 h5 h6 hr menu ol p pre table ul';\n    phrasingContent = 'a abbr b bdo br button cite code del dfn em embed i iframe img input ins kbd ' + 'label map noscript object q s samp script select small span strong sub sup ' + 'textarea u var #text #comment';\n    if (type !== 'html4') {\n      const transparentContent = 'a ins del canvas map';\n      blockContent += ' article aside details dialog figure main header footer hgroup section nav ' + transparentContent;\n      phrasingContent += ' audio canvas command data datalist mark meter output picture ' + 'progress time wbr video ruby bdi keygen svg';\n    }\n    if (type !== 'html5-strict') {\n      const html4PhrasingContent = 'acronym applet basefont big font strike tt';\n      phrasingContent = [phrasingContent, html4PhrasingContent].join(' ');\n      const html4BlockContent = 'center dir isindex noframes';\n      blockContent = [blockContent, html4BlockContent].join(' ');\n    }\n    const flowContent = [blockContent, phrasingContent].join(' ');\n    return {\n      blockContent,\n      phrasingContent,\n      flowContent\n    };\n  };\n  const getElementSets = type => {\n    const {\n      blockContent,\n      phrasingContent,\n      flowContent\n    } = getElementSetsAsStrings(type);\n    const toArr = value => {\n      return Object.freeze(value.split(' '));\n    };\n    return Object.freeze({\n      blockContent: toArr(blockContent),\n      phrasingContent: toArr(phrasingContent),\n      flowContent: toArr(flowContent)\n    });\n  };\n  const cachedSets = {\n    'html4': cached(() => getElementSets('html4')),\n    'html5': cached(() => getElementSets('html5')),\n    'html5-strict': cached(() => getElementSets('html5-strict'))\n  };\n  const getElementsPreset = (type, name) => {\n    const {\n      blockContent,\n      phrasingContent,\n      flowContent\n    } = cachedSets[type]();\n    if (name === 'blocks') {\n      return Optional.some(blockContent);\n    } else if (name === 'phrasing') {\n      return Optional.some(phrasingContent);\n    } else if (name === 'flow') {\n      return Optional.some(flowContent);\n    } else {\n      return Optional.none();\n    }\n  };\n  const makeSchema = type => {\n    const globalAttributes = getGlobalAttributeSet(type);\n    const {\n      phrasingContent,\n      flowContent\n    } = getElementSetsAsStrings(type);\n    const schema = {};\n    const addElement = (name, attributes, children) => {\n      schema[name] = {\n        attributes: mapToObject(attributes, constant({})),\n        attributesOrder: attributes,\n        children: mapToObject(children, constant({}))\n      };\n    };\n    const add = (name, attributes = '', children = '') => {\n      const childNames = split$1(children);\n      const names = split$1(name);\n      let ni = names.length;\n      const allAttributes = [...globalAttributes, ...split$1(attributes)];\n      while (ni--) {\n        addElement(names[ni], allAttributes.slice(), childNames);\n      }\n    };\n    const addAttrs = (name, attributes) => {\n      const names = split$1(name);\n      const attrs = split$1(attributes);\n      let ni = names.length;\n      while (ni--) {\n        const schemaItem = schema[names[ni]];\n        for (let i = 0, l = attrs.length; i < l; i++) {\n          schemaItem.attributes[attrs[i]] = {};\n          schemaItem.attributesOrder.push(attrs[i]);\n        }\n      }\n    };\n    if (type !== 'html5-strict') {\n      const html4PhrasingContent = 'acronym applet basefont big font strike tt';\n      each$e(split$1(html4PhrasingContent), name => {\n        add(name, '', phrasingContent);\n      });\n      const html4BlockContent = 'center dir isindex noframes';\n      each$e(split$1(html4BlockContent), name => {\n        add(name, '', flowContent);\n      });\n    }\n    add('html', 'manifest', 'head body');\n    add('head', '', 'base command link meta noscript script style title');\n    add('title hr noscript br');\n    add('base', 'href target');\n    add('link', 'href rel media hreflang type sizes hreflang');\n    add('meta', 'name http-equiv content charset');\n    add('style', 'media type scoped');\n    add('script', 'src async defer type charset');\n    add('body', 'onafterprint onbeforeprint onbeforeunload onblur onerror onfocus ' + 'onhashchange onload onmessage onoffline ononline onpagehide onpageshow ' + 'onpopstate onresize onscroll onstorage onunload', flowContent);\n    add('dd div', '', flowContent);\n    add('address dt caption', '', type === 'html4' ? phrasingContent : flowContent);\n    add('h1 h2 h3 h4 h5 h6 pre p abbr code var samp kbd sub sup i b u bdo span legend em strong small s cite dfn', '', phrasingContent);\n    add('blockquote', 'cite', flowContent);\n    add('ol', 'reversed start type', 'li');\n    add('ul', '', 'li');\n    add('li', 'value', flowContent);\n    add('dl', '', 'dt dd');\n    add('a', 'href target rel media hreflang type', type === 'html4' ? phrasingContent : flowContent);\n    add('q', 'cite', phrasingContent);\n    add('ins del', 'cite datetime', flowContent);\n    add('img', 'src sizes srcset alt usemap ismap width height');\n    add('iframe', 'src name width height', flowContent);\n    add('embed', 'src type width height');\n    add('object', 'data type typemustmatch name usemap form width height', [flowContent, 'param'].join(' '));\n    add('param', 'name value');\n    add('map', 'name', [flowContent, 'area'].join(' '));\n    add('area', 'alt coords shape href target rel media hreflang type');\n    add('table', 'border', 'caption colgroup thead tfoot tbody tr' + (type === 'html4' ? ' col' : ''));\n    add('colgroup', 'span', 'col');\n    add('col', 'span');\n    add('tbody thead tfoot', '', 'tr');\n    add('tr', '', 'td th');\n    add('td', 'colspan rowspan headers', flowContent);\n    add('th', 'colspan rowspan headers scope abbr', flowContent);\n    add('form', 'accept-charset action autocomplete enctype method name novalidate target', flowContent);\n    add('fieldset', 'disabled form name', [flowContent, 'legend'].join(' '));\n    add('label', 'form for', phrasingContent);\n    add('input', 'accept alt autocomplete checked dirname disabled form formaction formenctype formmethod formnovalidate ' + 'formtarget height list max maxlength min multiple name pattern readonly required size src step type value width');\n    add('button', 'disabled form formaction formenctype formmethod formnovalidate formtarget name type value', type === 'html4' ? flowContent : phrasingContent);\n    add('select', 'disabled form multiple name required size', 'option optgroup');\n    add('optgroup', 'disabled label', 'option');\n    add('option', 'disabled label selected value');\n    add('textarea', 'cols dirname disabled form maxlength name readonly required rows wrap');\n    add('menu', 'type label', [flowContent, 'li'].join(' '));\n    add('noscript', '', flowContent);\n    if (type !== 'html4') {\n      add('wbr');\n      add('ruby', '', [phrasingContent, 'rt rp'].join(' '));\n      add('figcaption', '', flowContent);\n      add('mark rt rp bdi', '', phrasingContent);\n      add('summary', '', [phrasingContent, 'h1 h2 h3 h4 h5 h6'].join(' '));\n      add('canvas', 'width height', flowContent);\n      add('data', 'value', phrasingContent);\n      add('video', 'src crossorigin poster preload autoplay mediagroup loop ' + 'muted controls width height buffered', [flowContent, 'track source'].join(' '));\n      add('audio', 'src crossorigin preload autoplay mediagroup loop muted controls ' + 'buffered volume', [flowContent, 'track source'].join(' '));\n      add('picture', '', 'img source');\n      add('source', 'src srcset type media sizes');\n      add('track', 'kind src srclang label default');\n      add('datalist', '', [phrasingContent, 'option'].join(' '));\n      add('article section nav aside main header footer', '', flowContent);\n      add('hgroup', '', 'h1 h2 h3 h4 h5 h6');\n      add('figure', '', [flowContent, 'figcaption'].join(' '));\n      add('time', 'datetime', phrasingContent);\n      add('dialog', 'open', flowContent);\n      add('command', 'type label icon disabled checked radiogroup command');\n      add('output', 'for form name', phrasingContent);\n      add('progress', 'value max', phrasingContent);\n      add('meter', 'value min max low high optimum', phrasingContent);\n      add('details', 'open', [flowContent, 'summary'].join(' '));\n      add('keygen', 'autofocus challenge disabled form keytype name');\n      addElement('svg', 'id tabindex lang xml:space class style x y width height viewBox preserveAspectRatio zoomAndPan transform'.split(' '), []);\n    }\n    if (type !== 'html5-strict') {\n      addAttrs('script', 'language xml:space');\n      addAttrs('style', 'xml:space');\n      addAttrs('object', 'declare classid code codebase codetype archive standby align border hspace vspace');\n      addAttrs('embed', 'align name hspace vspace');\n      addAttrs('param', 'valuetype type');\n      addAttrs('a', 'charset name rev shape coords');\n      addAttrs('br', 'clear');\n      addAttrs('applet', 'codebase archive code object alt name width height align hspace vspace');\n      addAttrs('img', 'name longdesc align border hspace vspace');\n      addAttrs('iframe', 'longdesc frameborder marginwidth marginheight scrolling align');\n      addAttrs('font basefont', 'size color face');\n      addAttrs('input', 'usemap align');\n      addAttrs('select');\n      addAttrs('textarea');\n      addAttrs('h1 h2 h3 h4 h5 h6 div p legend caption', 'align');\n      addAttrs('ul', 'type compact');\n      addAttrs('li', 'type');\n      addAttrs('ol dl menu dir', 'compact');\n      addAttrs('pre', 'width xml:space');\n      addAttrs('hr', 'align noshade size width');\n      addAttrs('isindex', 'prompt');\n      addAttrs('table', 'summary width frame rules cellspacing cellpadding align bgcolor');\n      addAttrs('col', 'width align char charoff valign');\n      addAttrs('colgroup', 'width align char charoff valign');\n      addAttrs('thead', 'align char charoff valign');\n      addAttrs('tr', 'align char charoff valign bgcolor');\n      addAttrs('th', 'axis align char charoff valign nowrap bgcolor width height');\n      addAttrs('form', 'accept');\n      addAttrs('td', 'abbr axis scope align char charoff valign nowrap bgcolor width height');\n      addAttrs('tfoot', 'align char charoff valign');\n      addAttrs('tbody', 'align char charoff valign');\n      addAttrs('area', 'nohref');\n      addAttrs('body', 'background bgcolor text link vlink alink');\n    }\n    if (type !== 'html4') {\n      addAttrs('input button select textarea', 'autofocus');\n      addAttrs('input textarea', 'placeholder');\n      addAttrs('a', 'download');\n      addAttrs('link script img', 'crossorigin');\n      addAttrs('img', 'loading');\n      addAttrs('iframe', 'sandbox seamless allow allowfullscreen loading referrerpolicy');\n    }\n    if (type !== 'html4') {\n      each$e([schema.video, schema.audio], item => {\n        delete item.children.audio;\n        delete item.children.video;\n      });\n    }\n    each$e(split$1('a form meter progress dfn'), name => {\n      if (schema[name]) {\n        delete schema[name].children[name];\n      }\n    });\n    delete schema.caption.children.table;\n    delete schema.script;\n    return schema;\n  };\n  const prefixToOperation = prefix => prefix === '-' ? 'remove' : 'add';\n  const parseValidChild = name => {\n    const validChildRegExp = /^(@?)([A-Za-z0-9_\\-.\\u00b7\\u00c0-\\u00d6\\u00d8-\\u00f6\\u00f8-\\u037d\\u037f-\\u1fff\\u200c-\\u200d\\u203f-\\u2040\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]+)$/;\n    return Optional.from(validChildRegExp.exec(name)).map(matches => ({\n      preset: matches[1] === '@',\n      name: matches[2]\n    }));\n  };\n  const parseValidChildrenRules = value => {\n    const childRuleRegExp = /^([+\\-]?)([A-Za-z0-9_\\-.\\u00b7\\u00c0-\\u00d6\\u00d8-\\u00f6\\u00f8-\\u037d\\u037f-\\u1fff\\u200c-\\u200d\\u203f-\\u2040\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]+)\\[([^\\]]+)]$/;\n    return bind$3(split$1(value, ','), rule => {\n      const matches = childRuleRegExp.exec(rule);\n      if (matches) {\n        const prefix = matches[1];\n        const operation = prefix ? prefixToOperation(prefix) : 'replace';\n        const name = matches[2];\n        const validChildren = bind$3(split$1(matches[3], '|'), validChild => parseValidChild(validChild).toArray());\n        return [{\n          operation,\n          name,\n          validChildren\n        }];\n      } else {\n        return [];\n      }\n    });\n  };\n  const parseValidElementsAttrDataIntoElement = (attrData, targetElement) => {\n    const attrRuleRegExp = /^([!\\-])?(\\w+[\\\\:]:\\w+|[^=~<]+)?(?:([=~<])(.*))?$/;\n    const hasPatternsRegExp = /[*?+]/;\n    const {\n      attributes,\n      attributesOrder\n    } = targetElement;\n    return each$e(split$1(attrData, '|'), rule => {\n      const matches = attrRuleRegExp.exec(rule);\n      if (matches) {\n        const attr = {};\n        const attrType = matches[1];\n        const attrName = matches[2].replace(/[\\\\:]:/g, ':');\n        const attrPrefix = matches[3];\n        const value = matches[4];\n        if (attrType === '!') {\n          targetElement.attributesRequired = targetElement.attributesRequired || [];\n          targetElement.attributesRequired.push(attrName);\n          attr.required = true;\n        }\n        if (attrType === '-') {\n          delete attributes[attrName];\n          attributesOrder.splice(Tools.inArray(attributesOrder, attrName), 1);\n          return;\n        }\n        if (attrPrefix) {\n          if (attrPrefix === '=') {\n            targetElement.attributesDefault = targetElement.attributesDefault || [];\n            targetElement.attributesDefault.push({\n              name: attrName,\n              value\n            });\n            attr.defaultValue = value;\n          } else if (attrPrefix === '~') {\n            targetElement.attributesForced = targetElement.attributesForced || [];\n            targetElement.attributesForced.push({\n              name: attrName,\n              value\n            });\n            attr.forcedValue = value;\n          } else if (attrPrefix === '<') {\n            attr.validValues = Tools.makeMap(value, '?');\n          }\n        }\n        if (hasPatternsRegExp.test(attrName)) {\n          const attrPattern = attr;\n          targetElement.attributePatterns = targetElement.attributePatterns || [];\n          attrPattern.pattern = patternToRegExp(attrName);\n          targetElement.attributePatterns.push(attrPattern);\n        } else {\n          if (!attributes[attrName]) {\n            attributesOrder.push(attrName);\n          }\n          attributes[attrName] = attr;\n        }\n      }\n    });\n  };\n  const cloneAttributesInto = (from, to) => {\n    each$d(from.attributes, (value, key) => {\n      to.attributes[key] = value;\n    });\n    to.attributesOrder.push(...from.attributesOrder);\n  };\n  const parseValidElementsRules = (globalElement, validElements) => {\n    const elementRuleRegExp = /^([#+\\-])?([^\\[!\\/]+)(?:\\/([^\\[!]+))?(?:(!?)\\[([^\\]]+)])?$/;\n    return bind$3(split$1(validElements, ','), rule => {\n      const matches = elementRuleRegExp.exec(rule);\n      if (matches) {\n        const prefix = matches[1];\n        const elementName = matches[2];\n        const outputName = matches[3];\n        const attrsPrefix = matches[4];\n        const attrData = matches[5];\n        const element = {\n          attributes: {},\n          attributesOrder: []\n        };\n        globalElement.each(el => cloneAttributesInto(el, element));\n        if (prefix === '#') {\n          element.paddEmpty = true;\n        } else if (prefix === '-') {\n          element.removeEmpty = true;\n        }\n        if (attrsPrefix === '!') {\n          element.removeEmptyAttrs = true;\n        }\n        if (attrData) {\n          parseValidElementsAttrDataIntoElement(attrData, element);\n        }\n        if (outputName) {\n          element.outputName = elementName;\n        }\n        if (elementName === '@') {\n          if (globalElement.isNone()) {\n            globalElement = Optional.some(element);\n          } else {\n            return [];\n          }\n        }\n        return [outputName ? {\n          name: elementName,\n          element,\n          aliasName: outputName\n        } : {\n          name: elementName,\n          element\n        }];\n      } else {\n        return [];\n      }\n    });\n  };\n  const mapCache = {};\n  const makeMap$2 = Tools.makeMap,\n    each$b = Tools.each,\n    extend$2 = Tools.extend,\n    explode$2 = Tools.explode;\n  const createMap = (defaultValue, extendWith = {}) => {\n    const value = makeMap$2(defaultValue, ' ', makeMap$2(defaultValue.toUpperCase(), ' '));\n    return extend$2(value, extendWith);\n  };\n  const getTextRootBlockElements = schema => createMap('td th li dt dd figcaption caption details summary', schema.getTextBlockElements());\n  const compileElementMap = (value, mode) => {\n    if (value) {\n      const styles = {};\n      if (isString(value)) {\n        value = {\n          '*': value\n        };\n      }\n      each$b(value, (value, key) => {\n        styles[key] = styles[key.toUpperCase()] = mode === 'map' ? makeMap$2(value, /[, ]/) : explode$2(value, /[, ]/);\n      });\n      return styles;\n    } else {\n      return undefined;\n    }\n  };\n  const Schema = (settings = {}) => {\n    var _a;\n    const elements = {};\n    const children = {};\n    let patternElements = [];\n    const customElementsMap = {};\n    const specialElements = {};\n    const createLookupTable = (option, defaultValue, extendWith) => {\n      const value = settings[option];\n      if (!value) {\n        let newValue = mapCache[option];\n        if (!newValue) {\n          newValue = createMap(defaultValue, extendWith);\n          mapCache[option] = newValue;\n        }\n        return newValue;\n      } else {\n        return makeMap$2(value, /[, ]/, makeMap$2(value.toUpperCase(), /[, ]/));\n      }\n    };\n    const schemaType = (_a = settings.schema) !== null && _a !== void 0 ? _a : 'html5';\n    const schemaItems = makeSchema(schemaType);\n    if (settings.verify_html === false) {\n      settings.valid_elements = '*[*]';\n    }\n    const validStyles = compileElementMap(settings.valid_styles);\n    const invalidStyles = compileElementMap(settings.invalid_styles, 'map');\n    const validClasses = compileElementMap(settings.valid_classes, 'map');\n    const whitespaceElementsMap = createLookupTable('whitespace_elements', 'pre script noscript style textarea video audio iframe object code');\n    const selfClosingElementsMap = createLookupTable('self_closing_elements', 'colgroup dd dt li option p td tfoot th thead tr');\n    const voidElementsMap = createLookupTable('void_elements', 'area base basefont br col frame hr img input isindex link ' + 'meta param embed source wbr track');\n    const boolAttrMap = createLookupTable('boolean_attributes', 'checked compact declare defer disabled ismap multiple nohref noresize ' + 'noshade nowrap readonly selected autoplay loop controls allowfullscreen');\n    const nonEmptyOrMoveCaretBeforeOnEnter = 'td th iframe video audio object script code';\n    const nonEmptyElementsMap = createLookupTable('non_empty_elements', nonEmptyOrMoveCaretBeforeOnEnter + ' pre svg textarea summary', voidElementsMap);\n    const moveCaretBeforeOnEnterElementsMap = createLookupTable('move_caret_before_on_enter_elements', nonEmptyOrMoveCaretBeforeOnEnter + ' table', voidElementsMap);\n    const headings = 'h1 h2 h3 h4 h5 h6';\n    const textBlockElementsMap = createLookupTable('text_block_elements', headings + ' p div address pre form ' + 'blockquote center dir fieldset header footer article section hgroup aside main nav figure');\n    const blockElementsMap = createLookupTable('block_elements', 'hr table tbody thead tfoot ' + 'th tr td li ol ul caption dl dt dd noscript menu isindex option ' + 'datalist select optgroup figcaption details summary html body multicol listing', textBlockElementsMap);\n    const textInlineElementsMap = createLookupTable('text_inline_elements', 'span strong b em i font s strike u var cite ' + 'dfn code mark q sup sub samp');\n    const transparentElementsMap = createLookupTable('transparent_elements', 'a ins del canvas map');\n    const wrapBlockElementsMap = createLookupTable('wrap_block_elements', 'pre ' + headings);\n    each$b('script noscript iframe noframes noembed title style textarea xmp plaintext'.split(' '), name => {\n      specialElements[name] = new RegExp('</' + name + '[^>]*>', 'gi');\n    });\n    const addValidElements = validElements => {\n      const globalElement = Optional.from(elements['@']);\n      const hasPatternsRegExp = /[*?+]/;\n      each$e(parseValidElementsRules(globalElement, validElements !== null && validElements !== void 0 ? validElements : ''), ({\n        name,\n        element,\n        aliasName\n      }) => {\n        if (aliasName) {\n          elements[aliasName] = element;\n        }\n        if (hasPatternsRegExp.test(name)) {\n          const patternElement = element;\n          patternElement.pattern = patternToRegExp(name);\n          patternElements.push(patternElement);\n        } else {\n          elements[name] = element;\n        }\n      });\n    };\n    const setValidElements = validElements => {\n      patternElements = [];\n      each$e(keys(elements), name => {\n        delete elements[name];\n      });\n      addValidElements(validElements);\n    };\n    const addCustomElement = (name, spec) => {\n      var _a, _b;\n      delete mapCache.text_block_elements;\n      delete mapCache.block_elements;\n      const inline = spec.extends ? !isBlock(spec.extends) : false;\n      const cloneName = spec.extends;\n      children[name] = cloneName ? children[cloneName] : {};\n      customElementsMap[name] = cloneName !== null && cloneName !== void 0 ? cloneName : name;\n      nonEmptyElementsMap[name.toUpperCase()] = {};\n      nonEmptyElementsMap[name] = {};\n      if (!inline) {\n        blockElementsMap[name.toUpperCase()] = {};\n        blockElementsMap[name] = {};\n      }\n      if (cloneName && !elements[name] && elements[cloneName]) {\n        const customRule = deepCloneElementRule(elements[cloneName]);\n        delete customRule.removeEmptyAttrs;\n        delete customRule.removeEmpty;\n        elements[name] = customRule;\n      } else {\n        elements[name] = {\n          attributesOrder: [],\n          attributes: {}\n        };\n      }\n      if (isArray$1(spec.attributes)) {\n        const processAttrName = name => {\n          customRule.attributesOrder.push(name);\n          customRule.attributes[name] = {};\n        };\n        const customRule = (_a = elements[name]) !== null && _a !== void 0 ? _a : {};\n        delete customRule.attributesDefault;\n        delete customRule.attributesForced;\n        delete customRule.attributePatterns;\n        delete customRule.attributesRequired;\n        customRule.attributesOrder = [];\n        customRule.attributes = {};\n        each$e(spec.attributes, attrName => {\n          const globalAttrs = getGlobalAttributeSet(schemaType);\n          parseValidChild(attrName).each(({\n            preset,\n            name\n          }) => {\n            if (preset) {\n              if (name === 'global') {\n                each$e(globalAttrs, processAttrName);\n              }\n            } else {\n              processAttrName(name);\n            }\n          });\n        });\n        elements[name] = customRule;\n      }\n      if (isBoolean(spec.padEmpty)) {\n        const customRule = (_b = elements[name]) !== null && _b !== void 0 ? _b : {};\n        customRule.paddEmpty = spec.padEmpty;\n        elements[name] = customRule;\n      }\n      if (isArray$1(spec.children)) {\n        const customElementChildren = {};\n        const processNodeName = name => {\n          customElementChildren[name] = {};\n        };\n        const processPreset = name => {\n          getElementsPreset(schemaType, name).each(names => {\n            each$e(names, processNodeName);\n          });\n        };\n        each$e(spec.children, child => {\n          parseValidChild(child).each(({\n            preset,\n            name\n          }) => {\n            if (preset) {\n              processPreset(name);\n            } else {\n              processNodeName(name);\n            }\n          });\n        });\n        children[name] = customElementChildren;\n      }\n      if (cloneName) {\n        each$d(children, (element, elmName) => {\n          if (element[cloneName]) {\n            children[elmName] = element = extend$2({}, children[elmName]);\n            element[name] = element[cloneName];\n          }\n        });\n      }\n    };\n    const addCustomElementsFromString = customElements => {\n      each$e(parseCustomElementsRules(customElements !== null && customElements !== void 0 ? customElements : ''), ({\n        name,\n        cloneName\n      }) => {\n        addCustomElement(name, {\n          extends: cloneName\n        });\n      });\n    };\n    const addCustomElements = customElements => {\n      if (isObject(customElements)) {\n        each$d(customElements, (spec, name) => addCustomElement(name, spec));\n      } else if (isString(customElements)) {\n        addCustomElementsFromString(customElements);\n      }\n    };\n    const addValidChildren = validChildren => {\n      each$e(parseValidChildrenRules(validChildren !== null && validChildren !== void 0 ? validChildren : ''), ({\n        operation,\n        name,\n        validChildren\n      }) => {\n        const parent = operation === 'replace' ? {\n          '#comment': {}\n        } : children[name];\n        const processNodeName = name => {\n          if (operation === 'remove') {\n            delete parent[name];\n          } else {\n            parent[name] = {};\n          }\n        };\n        const processPreset = name => {\n          getElementsPreset(schemaType, name).each(names => {\n            each$e(names, processNodeName);\n          });\n        };\n        each$e(validChildren, ({\n          preset,\n          name\n        }) => {\n          if (preset) {\n            processPreset(name);\n          } else {\n            processNodeName(name);\n          }\n        });\n        children[name] = parent;\n      });\n    };\n    const getElementRule = name => {\n      const element = elements[name];\n      if (element) {\n        return element;\n      }\n      let i = patternElements.length;\n      while (i--) {\n        const patternElement = patternElements[i];\n        if (patternElement.pattern.test(name)) {\n          return patternElement;\n        }\n      }\n      return undefined;\n    };\n    const setup = () => {\n      if (!settings.valid_elements) {\n        each$b(schemaItems, (element, name) => {\n          elements[name] = {\n            attributes: element.attributes,\n            attributesOrder: element.attributesOrder\n          };\n          children[name] = element.children;\n        });\n        each$b(split$1('strong/b em/i'), item => {\n          const items = split$1(item, '/');\n          elements[items[1]].outputName = items[0];\n        });\n        each$b(textInlineElementsMap, (_val, name) => {\n          if (elements[name]) {\n            if (settings.padd_empty_block_inline_children) {\n              elements[name].paddInEmptyBlock = true;\n            }\n            elements[name].removeEmpty = true;\n          }\n        });\n        each$b(split$1('ol ul blockquote a table tbody'), name => {\n          if (elements[name]) {\n            elements[name].removeEmpty = true;\n          }\n        });\n        each$b(split$1('p h1 h2 h3 h4 h5 h6 th td pre div address caption li summary'), name => {\n          if (elements[name]) {\n            elements[name].paddEmpty = true;\n          }\n        });\n        each$b(split$1('span'), name => {\n          elements[name].removeEmptyAttrs = true;\n        });\n      } else {\n        setValidElements(settings.valid_elements);\n        each$b(schemaItems, (element, name) => {\n          children[name] = element.children;\n        });\n      }\n      delete elements.svg;\n      addCustomElements(settings.custom_elements);\n      addValidChildren(settings.valid_children);\n      addValidElements(settings.extended_valid_elements);\n      addValidChildren('+ol[ul|ol],+ul[ul|ol]');\n      each$b({\n        dd: 'dl',\n        dt: 'dl',\n        li: 'ul ol',\n        td: 'tr',\n        th: 'tr',\n        tr: 'tbody thead tfoot',\n        tbody: 'table',\n        thead: 'table',\n        tfoot: 'table',\n        legend: 'fieldset',\n        area: 'map',\n        param: 'video audio object'\n      }, (parents, item) => {\n        if (elements[item]) {\n          elements[item].parentsRequired = split$1(parents);\n        }\n      });\n      if (settings.invalid_elements) {\n        each$b(explode$2(settings.invalid_elements), item => {\n          if (elements[item]) {\n            delete elements[item];\n          }\n        });\n      }\n      if (!getElementRule('span')) {\n        addValidElements('span[!data-mce-type|*]');\n      }\n    };\n    const getValidStyles = constant(validStyles);\n    const getInvalidStyles = constant(invalidStyles);\n    const getValidClasses = constant(validClasses);\n    const getBoolAttrs = constant(boolAttrMap);\n    const getBlockElements = constant(blockElementsMap);\n    const getTextBlockElements = constant(textBlockElementsMap);\n    const getTextInlineElements = constant(textInlineElementsMap);\n    const getVoidElements = constant(Object.seal(voidElementsMap));\n    const getSelfClosingElements = constant(selfClosingElementsMap);\n    const getNonEmptyElements = constant(nonEmptyElementsMap);\n    const getMoveCaretBeforeOnEnterElements = constant(moveCaretBeforeOnEnterElementsMap);\n    const getWhitespaceElements = constant(whitespaceElementsMap);\n    const getTransparentElements = constant(transparentElementsMap);\n    const getWrapBlockElements = constant(wrapBlockElementsMap);\n    const getSpecialElements = constant(Object.seal(specialElements));\n    const isValidChild = (name, child) => {\n      const parent = children[name.toLowerCase()];\n      return !!(parent && parent[child.toLowerCase()]);\n    };\n    const isValid = (name, attr) => {\n      const rule = getElementRule(name);\n      if (rule) {\n        if (attr) {\n          if (rule.attributes[attr]) {\n            return true;\n          }\n          const attrPatterns = rule.attributePatterns;\n          if (attrPatterns) {\n            let i = attrPatterns.length;\n            while (i--) {\n              if (attrPatterns[i].pattern.test(attr)) {\n                return true;\n              }\n            }\n          }\n        } else {\n          return true;\n        }\n      }\n      return false;\n    };\n    const isBlock = name => has$2(getBlockElements(), name);\n    const isInline = name => !startsWith(name, '#') && isValid(name) && !isBlock(name);\n    const isWrapper = name => has$2(getWrapBlockElements(), name) || isInline(name);\n    const getCustomElements = constant(customElementsMap);\n    setup();\n    return {\n      type: schemaType,\n      children,\n      elements,\n      getValidStyles,\n      getValidClasses,\n      getBlockElements,\n      getInvalidStyles,\n      getVoidElements,\n      getTextBlockElements,\n      getTextInlineElements,\n      getBoolAttrs,\n      getElementRule,\n      getSelfClosingElements,\n      getNonEmptyElements,\n      getMoveCaretBeforeOnEnterElements,\n      getWhitespaceElements,\n      getTransparentElements,\n      getSpecialElements,\n      isValidChild,\n      isValid,\n      isBlock,\n      isInline,\n      isWrapper,\n      getCustomElements,\n      addValidElements,\n      setValidElements,\n      addCustomElements,\n      addValidChildren\n    };\n  };\n  const hexColour = value => ({\n    value: normalizeHex(value)\n  });\n  const normalizeHex = hex => removeLeading(hex, '#').toUpperCase();\n  const toHex = component => {\n    const hex = component.toString(16);\n    return (hex.length === 1 ? '0' + hex : hex).toUpperCase();\n  };\n  const fromRgba = rgbaColour => {\n    const value = toHex(rgbaColour.red) + toHex(rgbaColour.green) + toHex(rgbaColour.blue);\n    return hexColour(value);\n  };\n  const rgbRegex = /^\\s*rgb\\s*\\(\\s*(\\d+)\\s*[,\\s]\\s*(\\d+)\\s*[,\\s]\\s*(\\d+)\\s*\\)\\s*$/i;\n  const rgbaRegex = /^\\s*rgba\\s*\\(\\s*(\\d+)\\s*[,\\s]\\s*(\\d+)\\s*[,\\s]\\s*(\\d+)\\s*[,\\s]\\s*((?:\\d?\\.\\d+|\\d+)%?)\\s*\\)\\s*$/i;\n  const rgbaColour = (red, green, blue, alpha) => ({\n    red,\n    green,\n    blue,\n    alpha\n  });\n  const fromStringValues = (red, green, blue, alpha) => {\n    const r = parseInt(red, 10);\n    const g = parseInt(green, 10);\n    const b = parseInt(blue, 10);\n    const a = parseFloat(alpha);\n    return rgbaColour(r, g, b, a);\n  };\n  const getColorFormat = colorString => {\n    if (rgbRegex.test(colorString)) {\n      return 'rgb';\n    } else if (rgbaRegex.test(colorString)) {\n      return 'rgba';\n    }\n    return 'other';\n  };\n  const fromString = rgbaString => {\n    const rgbMatch = rgbRegex.exec(rgbaString);\n    if (rgbMatch !== null) {\n      return Optional.some(fromStringValues(rgbMatch[1], rgbMatch[2], rgbMatch[3], '1'));\n    }\n    const rgbaMatch = rgbaRegex.exec(rgbaString);\n    if (rgbaMatch !== null) {\n      return Optional.some(fromStringValues(rgbaMatch[1], rgbaMatch[2], rgbaMatch[3], rgbaMatch[4]));\n    }\n    return Optional.none();\n  };\n  const toString = rgba => `rgba(${rgba.red},${rgba.green},${rgba.blue},${rgba.alpha})`;\n  const rgbaToHexString = color => fromString(color).map(fromRgba).map(h => '#' + h.value).getOr(color);\n  const Styles = (settings = {}, schema) => {\n    const urlOrStrRegExp = /(?:url(?:(?:\\(\\s*\\\"([^\\\"]+)\\\"\\s*\\))|(?:\\(\\s*\\'([^\\']+)\\'\\s*\\))|(?:\\(\\s*([^)\\s]+)\\s*\\))))|(?:\\'([^\\']+)\\')|(?:\\\"([^\\\"]+)\\\")/gi;\n    const styleRegExp = /\\s*([^:]+):\\s*([^;]+);?/g;\n    const trimRightRegExp = /\\s+$/;\n    const encodingLookup = {};\n    let validStyles;\n    let invalidStyles;\n    const invisibleChar = zeroWidth;\n    if (schema) {\n      validStyles = schema.getValidStyles();\n      invalidStyles = schema.getInvalidStyles();\n    }\n    const encodingItems = (`\\\\\" \\\\' \\\\; \\\\: ; : ` + invisibleChar).split(' ');\n    for (let i = 0; i < encodingItems.length; i++) {\n      encodingLookup[encodingItems[i]] = invisibleChar + i;\n      encodingLookup[invisibleChar + i] = encodingItems[i];\n    }\n    const self = {\n      parse: css => {\n        const styles = {};\n        let isEncoded = false;\n        const urlConverter = settings.url_converter;\n        const urlConverterScope = settings.url_converter_scope || self;\n        const compress = (prefix, suffix, noJoin) => {\n          const top = styles[prefix + '-top' + suffix];\n          if (!top) {\n            return;\n          }\n          const right = styles[prefix + '-right' + suffix];\n          if (!right) {\n            return;\n          }\n          const bottom = styles[prefix + '-bottom' + suffix];\n          if (!bottom) {\n            return;\n          }\n          const left = styles[prefix + '-left' + suffix];\n          if (!left) {\n            return;\n          }\n          const box = [top, right, bottom, left];\n          let i = box.length - 1;\n          while (i--) {\n            if (box[i] !== box[i + 1]) {\n              break;\n            }\n          }\n          if (i > -1 && noJoin) {\n            return;\n          }\n          styles[prefix + suffix] = i === -1 ? box[0] : box.join(' ');\n          delete styles[prefix + '-top' + suffix];\n          delete styles[prefix + '-right' + suffix];\n          delete styles[prefix + '-bottom' + suffix];\n          delete styles[prefix + '-left' + suffix];\n        };\n        const canCompress = key => {\n          const value = styles[key];\n          if (!value) {\n            return;\n          }\n          const values = value.indexOf(',') > -1 ? [value] : value.split(' ');\n          let i = values.length;\n          while (i--) {\n            if (values[i] !== values[0]) {\n              return false;\n            }\n          }\n          styles[key] = values[0];\n          return true;\n        };\n        const compress2 = (target, a, b, c) => {\n          if (!canCompress(a)) {\n            return;\n          }\n          if (!canCompress(b)) {\n            return;\n          }\n          if (!canCompress(c)) {\n            return;\n          }\n          styles[target] = styles[a] + ' ' + styles[b] + ' ' + styles[c];\n          delete styles[a];\n          delete styles[b];\n          delete styles[c];\n        };\n        const encode = str => {\n          isEncoded = true;\n          return encodingLookup[str];\n        };\n        const decode = (str, keepSlashes) => {\n          if (isEncoded) {\n            str = str.replace(/\\uFEFF[0-9]/g, str => {\n              return encodingLookup[str];\n            });\n          }\n          if (!keepSlashes) {\n            str = str.replace(/\\\\([\\'\\\";:])/g, '$1');\n          }\n          return str;\n        };\n        const decodeSingleHexSequence = escSeq => {\n          return String.fromCharCode(parseInt(escSeq.slice(1), 16));\n        };\n        const decodeHexSequences = value => {\n          return value.replace(/\\\\[0-9a-f]+/gi, decodeSingleHexSequence);\n        };\n        const processUrl = (match, url, url2, url3, str, str2) => {\n          str = str || str2;\n          if (str) {\n            str = decode(str);\n            return `'` + str.replace(/\\'/g, `\\\\'`) + `'`;\n          }\n          url = decode(url || url2 || url3 || '');\n          if (!settings.allow_script_urls) {\n            const scriptUrl = url.replace(/[\\s\\r\\n]+/g, '');\n            if (/(java|vb)script:/i.test(scriptUrl)) {\n              return '';\n            }\n            if (!settings.allow_svg_data_urls && /^data:image\\/svg/i.test(scriptUrl)) {\n              return '';\n            }\n          }\n          if (urlConverter) {\n            url = urlConverter.call(urlConverterScope, url, 'style');\n          }\n          return `url('` + url.replace(/\\'/g, `\\\\'`) + `')`;\n        };\n        if (css) {\n          css = css.replace(/[\\u0000-\\u001F]/g, '');\n          css = css.replace(/\\\\[\\\"\\';:\\uFEFF]/g, encode).replace(/\\\"[^\\\"]+\\\"|\\'[^\\']+\\'/g, str => {\n            return str.replace(/[;:]/g, encode);\n          });\n          let matches;\n          while (matches = styleRegExp.exec(css)) {\n            styleRegExp.lastIndex = matches.index + matches[0].length;\n            let name = matches[1].replace(trimRightRegExp, '').toLowerCase();\n            let value = matches[2].replace(trimRightRegExp, '');\n            if (name && value) {\n              name = decodeHexSequences(name);\n              value = decodeHexSequences(value);\n              if (name.indexOf(invisibleChar) !== -1 || name.indexOf('\"') !== -1) {\n                continue;\n              }\n              if (!settings.allow_script_urls && (name === 'behavior' || /expression\\s*\\(|\\/\\*|\\*\\//.test(value))) {\n                continue;\n              }\n              if (name === 'font-weight' && value === '700') {\n                value = 'bold';\n              } else if (name === 'color' || name === 'background-color') {\n                value = value.toLowerCase();\n              }\n              if (getColorFormat(value) === 'rgb') {\n                fromString(value).each(rgba => {\n                  value = rgbaToHexString(toString(rgba)).toLowerCase();\n                });\n              }\n              value = value.replace(urlOrStrRegExp, processUrl);\n              styles[name] = isEncoded ? decode(value, true) : value;\n            }\n          }\n          compress('border', '', true);\n          compress('border', '-width');\n          compress('border', '-color');\n          compress('border', '-style');\n          compress('padding', '');\n          compress('margin', '');\n          compress2('border', 'border-width', 'border-style', 'border-color');\n          if (styles.border === 'medium none') {\n            delete styles.border;\n          }\n          if (styles['border-image'] === 'none') {\n            delete styles['border-image'];\n          }\n        }\n        return styles;\n      },\n      serialize: (styles, elementName) => {\n        let css = '';\n        const serializeStyles = (elemName, validStyleList) => {\n          const styleList = validStyleList[elemName];\n          if (styleList) {\n            for (let i = 0, l = styleList.length; i < l; i++) {\n              const name = styleList[i];\n              const value = styles[name];\n              if (value) {\n                css += (css.length > 0 ? ' ' : '') + name + ': ' + value + ';';\n              }\n            }\n          }\n        };\n        const isValid = (name, elemName) => {\n          if (!invalidStyles || !elemName) {\n            return true;\n          }\n          let styleMap = invalidStyles['*'];\n          if (styleMap && styleMap[name]) {\n            return false;\n          }\n          styleMap = invalidStyles[elemName];\n          return !(styleMap && styleMap[name]);\n        };\n        if (elementName && validStyles) {\n          serializeStyles('*', validStyles);\n          serializeStyles(elementName, validStyles);\n        } else {\n          each$d(styles, (value, name) => {\n            if (value && isValid(name, elementName)) {\n              css += (css.length > 0 ? ' ' : '') + name + ': ' + value + ';';\n            }\n          });\n        }\n        return css;\n      }\n    };\n    return self;\n  };\n  const deprecated = {\n    keyLocation: true,\n    layerX: true,\n    layerY: true,\n    returnValue: true,\n    webkitMovementX: true,\n    webkitMovementY: true,\n    keyIdentifier: true,\n    mozPressure: true\n  };\n  const isNativeEvent = event => event instanceof Event || isFunction(event.initEvent);\n  const hasIsDefaultPrevented = event => event.isDefaultPrevented === always || event.isDefaultPrevented === never;\n  const needsNormalizing = event => isNullable(event.preventDefault) || isNativeEvent(event);\n  const clone$3 = (originalEvent, data) => {\n    const event = data !== null && data !== void 0 ? data : {};\n    for (const name in originalEvent) {\n      if (!has$2(deprecated, name)) {\n        event[name] = originalEvent[name];\n      }\n    }\n    if (isNonNullable(originalEvent.composedPath)) {\n      event.composedPath = () => originalEvent.composedPath();\n    }\n    if (isNonNullable(originalEvent.getModifierState)) {\n      event.getModifierState = keyArg => originalEvent.getModifierState(keyArg);\n    }\n    if (isNonNullable(originalEvent.getTargetRanges)) {\n      event.getTargetRanges = () => originalEvent.getTargetRanges();\n    }\n    return event;\n  };\n  const normalize$3 = (type, originalEvent, fallbackTarget, data) => {\n    var _a;\n    const event = clone$3(originalEvent, data);\n    event.type = type;\n    if (isNullable(event.target)) {\n      event.target = (_a = event.srcElement) !== null && _a !== void 0 ? _a : fallbackTarget;\n    }\n    if (needsNormalizing(originalEvent)) {\n      event.preventDefault = () => {\n        event.defaultPrevented = true;\n        event.isDefaultPrevented = always;\n        if (isFunction(originalEvent.preventDefault)) {\n          originalEvent.preventDefault();\n        }\n      };\n      event.stopPropagation = () => {\n        event.cancelBubble = true;\n        event.isPropagationStopped = always;\n        if (isFunction(originalEvent.stopPropagation)) {\n          originalEvent.stopPropagation();\n        }\n      };\n      event.stopImmediatePropagation = () => {\n        event.isImmediatePropagationStopped = always;\n        event.stopPropagation();\n      };\n      if (!hasIsDefaultPrevented(event)) {\n        event.isDefaultPrevented = event.defaultPrevented === true ? always : never;\n        event.isPropagationStopped = event.cancelBubble === true ? always : never;\n        event.isImmediatePropagationStopped = never;\n      }\n    }\n    return event;\n  };\n  const eventExpandoPrefix = 'mce-data-';\n  const mouseEventRe = /^(?:mouse|contextmenu)|click/;\n  const addEvent = (target, name, callback, capture) => {\n    target.addEventListener(name, callback, capture || false);\n  };\n  const removeEvent = (target, name, callback, capture) => {\n    target.removeEventListener(name, callback, capture || false);\n  };\n  const isMouseEvent = event => isNonNullable(event) && mouseEventRe.test(event.type);\n  const fix = (originalEvent, data) => {\n    const event = normalize$3(originalEvent.type, originalEvent, document, data);\n    if (isMouseEvent(originalEvent) && isUndefined(originalEvent.pageX) && !isUndefined(originalEvent.clientX)) {\n      const eventDoc = event.target.ownerDocument || document;\n      const doc = eventDoc.documentElement;\n      const body = eventDoc.body;\n      const mouseEvent = event;\n      mouseEvent.pageX = originalEvent.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);\n      mouseEvent.pageY = originalEvent.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);\n    }\n    return event;\n  };\n  const bindOnReady = (win, callback, eventUtils) => {\n    const doc = win.document,\n      event = {\n        type: 'ready'\n      };\n    if (eventUtils.domLoaded) {\n      callback(event);\n      return;\n    }\n    const isDocReady = () => {\n      return doc.readyState === 'complete' || doc.readyState === 'interactive' && doc.body;\n    };\n    const readyHandler = () => {\n      removeEvent(win, 'DOMContentLoaded', readyHandler);\n      removeEvent(win, 'load', readyHandler);\n      if (!eventUtils.domLoaded) {\n        eventUtils.domLoaded = true;\n        callback(event);\n      }\n      win = null;\n    };\n    if (isDocReady()) {\n      readyHandler();\n    } else {\n      addEvent(win, 'DOMContentLoaded', readyHandler);\n    }\n    if (!eventUtils.domLoaded) {\n      addEvent(win, 'load', readyHandler);\n    }\n  };\n  class EventUtils {\n    constructor() {\n      this.domLoaded = false;\n      this.events = {};\n      this.count = 1;\n      this.expando = eventExpandoPrefix + (+new Date()).toString(32);\n      this.hasFocusIn = 'onfocusin' in document.documentElement;\n      this.count = 1;\n    }\n    bind(target, names, callback, scope) {\n      const self = this;\n      let callbackList;\n      const win = window;\n      const defaultNativeHandler = evt => {\n        self.executeHandlers(fix(evt || win.event), id);\n      };\n      if (!target || isText$b(target) || isComment(target)) {\n        return callback;\n      }\n      let id;\n      if (!target[self.expando]) {\n        id = self.count++;\n        target[self.expando] = id;\n        self.events[id] = {};\n      } else {\n        id = target[self.expando];\n      }\n      scope = scope || target;\n      const namesList = names.split(' ');\n      let i = namesList.length;\n      while (i--) {\n        let name = namesList[i];\n        let nativeHandler = defaultNativeHandler;\n        let capture = false;\n        let fakeName = false;\n        if (name === 'DOMContentLoaded') {\n          name = 'ready';\n        }\n        if (self.domLoaded && name === 'ready' && target.readyState === 'complete') {\n          callback.call(scope, fix({\n            type: name\n          }));\n          continue;\n        }\n        if (!self.hasFocusIn && (name === 'focusin' || name === 'focusout')) {\n          capture = true;\n          fakeName = name === 'focusin' ? 'focus' : 'blur';\n          nativeHandler = evt => {\n            const event = fix(evt || win.event);\n            event.type = event.type === 'focus' ? 'focusin' : 'focusout';\n            self.executeHandlers(event, id);\n          };\n        }\n        callbackList = self.events[id][name];\n        if (!callbackList) {\n          self.events[id][name] = callbackList = [{\n            func: callback,\n            scope\n          }];\n          callbackList.fakeName = fakeName;\n          callbackList.capture = capture;\n          callbackList.nativeHandler = nativeHandler;\n          if (name === 'ready') {\n            bindOnReady(target, nativeHandler, self);\n          } else {\n            addEvent(target, fakeName || name, nativeHandler, capture);\n          }\n        } else {\n          if (name === 'ready' && self.domLoaded) {\n            callback(fix({\n              type: name\n            }));\n          } else {\n            callbackList.push({\n              func: callback,\n              scope\n            });\n          }\n        }\n      }\n      target = callbackList = null;\n      return callback;\n    }\n    unbind(target, names, callback) {\n      if (!target || isText$b(target) || isComment(target)) {\n        return this;\n      }\n      const id = target[this.expando];\n      if (id) {\n        let eventMap = this.events[id];\n        if (names) {\n          const namesList = names.split(' ');\n          let i = namesList.length;\n          while (i--) {\n            const name = namesList[i];\n            const callbackList = eventMap[name];\n            if (callbackList) {\n              if (callback) {\n                let ci = callbackList.length;\n                while (ci--) {\n                  if (callbackList[ci].func === callback) {\n                    const nativeHandler = callbackList.nativeHandler;\n                    const fakeName = callbackList.fakeName,\n                      capture = callbackList.capture;\n                    const newCallbackList = callbackList.slice(0, ci).concat(callbackList.slice(ci + 1));\n                    newCallbackList.nativeHandler = nativeHandler;\n                    newCallbackList.fakeName = fakeName;\n                    newCallbackList.capture = capture;\n                    eventMap[name] = newCallbackList;\n                  }\n                }\n              }\n              if (!callback || callbackList.length === 0) {\n                delete eventMap[name];\n                removeEvent(target, callbackList.fakeName || name, callbackList.nativeHandler, callbackList.capture);\n              }\n            }\n          }\n        } else {\n          each$d(eventMap, (callbackList, name) => {\n            removeEvent(target, callbackList.fakeName || name, callbackList.nativeHandler, callbackList.capture);\n          });\n          eventMap = {};\n        }\n        for (const name in eventMap) {\n          if (has$2(eventMap, name)) {\n            return this;\n          }\n        }\n        delete this.events[id];\n        try {\n          delete target[this.expando];\n        } catch (ex) {\n          target[this.expando] = null;\n        }\n      }\n      return this;\n    }\n    fire(target, name, args) {\n      return this.dispatch(target, name, args);\n    }\n    dispatch(target, name, args) {\n      if (!target || isText$b(target) || isComment(target)) {\n        return this;\n      }\n      const event = fix({\n        type: name,\n        target\n      }, args);\n      do {\n        const id = target[this.expando];\n        if (id) {\n          this.executeHandlers(event, id);\n        }\n        target = target.parentNode || target.ownerDocument || target.defaultView || target.parentWindow;\n      } while (target && !event.isPropagationStopped());\n      return this;\n    }\n    clean(target) {\n      if (!target || isText$b(target) || isComment(target)) {\n        return this;\n      }\n      if (target[this.expando]) {\n        this.unbind(target);\n      }\n      if (!target.getElementsByTagName) {\n        target = target.document;\n      }\n      if (target && target.getElementsByTagName) {\n        this.unbind(target);\n        const children = target.getElementsByTagName('*');\n        let i = children.length;\n        while (i--) {\n          target = children[i];\n          if (target[this.expando]) {\n            this.unbind(target);\n          }\n        }\n      }\n      return this;\n    }\n    destroy() {\n      this.events = {};\n    }\n    cancel(e) {\n      if (e) {\n        e.preventDefault();\n        e.stopImmediatePropagation();\n      }\n      return false;\n    }\n    executeHandlers(evt, id) {\n      const container = this.events[id];\n      const callbackList = container && container[evt.type];\n      if (callbackList) {\n        for (let i = 0, l = callbackList.length; i < l; i++) {\n          const callback = callbackList[i];\n          if (callback && callback.func.call(callback.scope, evt) === false) {\n            evt.preventDefault();\n          }\n          if (evt.isImmediatePropagationStopped()) {\n            return;\n          }\n        }\n      }\n    }\n  }\n  EventUtils.Event = new EventUtils();\n  const each$a = Tools.each;\n  const grep = Tools.grep;\n  const internalStyleName = 'data-mce-style';\n  const numericalCssMap = Tools.makeMap('fill-opacity font-weight line-height opacity orphans widows z-index zoom', ' ');\n  const legacySetAttribute = (elm, name, value) => {\n    if (isNullable(value) || value === '') {\n      remove$9(elm, name);\n    } else {\n      set$3(elm, name, value);\n    }\n  };\n  const camelCaseToHyphens = name => name.replace(/[A-Z]/g, v => '-' + v.toLowerCase());\n  const findNodeIndex = (node, normalized) => {\n    let idx = 0;\n    if (node) {\n      for (let lastNodeType = node.nodeType, tempNode = node.previousSibling; tempNode; tempNode = tempNode.previousSibling) {\n        const nodeType = tempNode.nodeType;\n        if (normalized && isText$b(tempNode)) {\n          if (nodeType === lastNodeType || !tempNode.data.length) {\n            continue;\n          }\n        }\n        idx++;\n        lastNodeType = nodeType;\n      }\n    }\n    return idx;\n  };\n  const updateInternalStyleAttr = (styles, elm) => {\n    const rawValue = get$9(elm, 'style');\n    const value = styles.serialize(styles.parse(rawValue), name(elm));\n    legacySetAttribute(elm, internalStyleName, value);\n  };\n  const convertStyleToString = (cssValue, cssName) => {\n    if (isNumber(cssValue)) {\n      return has$2(numericalCssMap, cssName) ? cssValue + '' : cssValue + 'px';\n    } else {\n      return cssValue;\n    }\n  };\n  const applyStyle$1 = ($elm, cssName, cssValue) => {\n    const normalizedName = camelCaseToHyphens(cssName);\n    if (isNullable(cssValue) || cssValue === '') {\n      remove$5($elm, normalizedName);\n    } else {\n      set$2($elm, normalizedName, convertStyleToString(cssValue, normalizedName));\n    }\n  };\n  const setupAttrHooks = (styles, settings, getContext) => {\n    const keepValues = settings.keep_values;\n    const keepUrlHook = {\n      set: (elm, value, name) => {\n        const sugarElm = SugarElement.fromDom(elm);\n        if (isFunction(settings.url_converter) && isNonNullable(value)) {\n          value = settings.url_converter.call(settings.url_converter_scope || getContext(), String(value), name, elm);\n        }\n        const internalName = 'data-mce-' + name;\n        legacySetAttribute(sugarElm, internalName, value);\n        legacySetAttribute(sugarElm, name, value);\n      },\n      get: (elm, name) => {\n        const sugarElm = SugarElement.fromDom(elm);\n        return get$9(sugarElm, 'data-mce-' + name) || get$9(sugarElm, name);\n      }\n    };\n    const attrHooks = {\n      style: {\n        set: (elm, value) => {\n          const sugarElm = SugarElement.fromDom(elm);\n          if (keepValues) {\n            legacySetAttribute(sugarElm, internalStyleName, value);\n          }\n          remove$9(sugarElm, 'style');\n          if (isString(value)) {\n            setAll(sugarElm, styles.parse(value));\n          }\n        },\n        get: elm => {\n          const sugarElm = SugarElement.fromDom(elm);\n          const value = get$9(sugarElm, internalStyleName) || get$9(sugarElm, 'style');\n          return styles.serialize(styles.parse(value), name(sugarElm));\n        }\n      }\n    };\n    if (keepValues) {\n      attrHooks.href = attrHooks.src = keepUrlHook;\n    }\n    return attrHooks;\n  };\n  const DOMUtils = (doc, settings = {}) => {\n    const addedStyles = {};\n    const win = window;\n    const files = {};\n    let counter = 0;\n    const stdMode = true;\n    const boxModel = true;\n    const styleSheetLoader = instance.forElement(SugarElement.fromDom(doc), {\n      contentCssCors: settings.contentCssCors,\n      referrerPolicy: settings.referrerPolicy\n    });\n    const boundEvents = [];\n    const schema = settings.schema ? settings.schema : Schema({});\n    const styles = Styles({\n      url_converter: settings.url_converter,\n      url_converter_scope: settings.url_converter_scope\n    }, settings.schema);\n    const events = settings.ownEvents ? new EventUtils() : EventUtils.Event;\n    const blockElementsMap = schema.getBlockElements();\n    const isBlock = node => {\n      if (isString(node)) {\n        return has$2(blockElementsMap, node);\n      } else {\n        return isElement$6(node) && (has$2(blockElementsMap, node.nodeName) || isTransparentBlock(schema, node));\n      }\n    };\n    const get = elm => elm && doc && isString(elm) ? doc.getElementById(elm) : elm;\n    const _get = elm => {\n      const value = get(elm);\n      return isNonNullable(value) ? SugarElement.fromDom(value) : null;\n    };\n    const getAttrib = (elm, name, defaultVal = '') => {\n      let value;\n      const $elm = _get(elm);\n      if (isNonNullable($elm) && isElement$7($elm)) {\n        const hook = attrHooks[name];\n        if (hook && hook.get) {\n          value = hook.get($elm.dom, name);\n        } else {\n          value = get$9($elm, name);\n        }\n      }\n      return isNonNullable(value) ? value : defaultVal;\n    };\n    const getAttribs = elm => {\n      const node = get(elm);\n      return isNullable(node) ? [] : node.attributes;\n    };\n    const setAttrib = (elm, name, value) => {\n      run(elm, e => {\n        if (isElement$6(e)) {\n          const $elm = SugarElement.fromDom(e);\n          const val = value === '' ? null : value;\n          const originalValue = get$9($elm, name);\n          const hook = attrHooks[name];\n          if (hook && hook.set) {\n            hook.set($elm.dom, val, name);\n          } else {\n            legacySetAttribute($elm, name, val);\n          }\n          if (originalValue !== val && settings.onSetAttrib) {\n            settings.onSetAttrib({\n              attrElm: $elm.dom,\n              attrName: name,\n              attrValue: val\n            });\n          }\n        }\n      });\n    };\n    const clone = (node, deep) => {\n      return node.cloneNode(deep);\n    };\n    const getRoot = () => settings.root_element || doc.body;\n    const getViewPort = argWin => {\n      const vp = getBounds(argWin);\n      return {\n        x: vp.x,\n        y: vp.y,\n        w: vp.width,\n        h: vp.height\n      };\n    };\n    const getPos$1 = (elm, rootElm) => getPos(doc.body, get(elm), rootElm);\n    const setStyle = (elm, name, value) => {\n      run(elm, e => {\n        const $elm = SugarElement.fromDom(e);\n        applyStyle$1($elm, name, value);\n        if (settings.update_styles) {\n          updateInternalStyleAttr(styles, $elm);\n        }\n      });\n    };\n    const setStyles = (elm, stylesArg) => {\n      run(elm, e => {\n        const $elm = SugarElement.fromDom(e);\n        each$d(stylesArg, (v, n) => {\n          applyStyle$1($elm, n, v);\n        });\n        if (settings.update_styles) {\n          updateInternalStyleAttr(styles, $elm);\n        }\n      });\n    };\n    const getStyle = (elm, name, computed) => {\n      const $elm = get(elm);\n      if (isNullable($elm) || !isHTMLElement($elm) && !isSVGElement($elm)) {\n        return undefined;\n      }\n      if (computed) {\n        return get$7(SugarElement.fromDom($elm), camelCaseToHyphens(name));\n      } else {\n        name = name.replace(/-(\\D)/g, (a, b) => b.toUpperCase());\n        if (name === 'float') {\n          name = 'cssFloat';\n        }\n        return $elm.style ? $elm.style[name] : undefined;\n      }\n    };\n    const getSize = elm => {\n      const $elm = get(elm);\n      if (!$elm) {\n        return {\n          w: 0,\n          h: 0\n        };\n      }\n      let w = getStyle($elm, 'width');\n      let h = getStyle($elm, 'height');\n      if (!w || w.indexOf('px') === -1) {\n        w = '0';\n      }\n      if (!h || h.indexOf('px') === -1) {\n        h = '0';\n      }\n      return {\n        w: parseInt(w, 10) || $elm.offsetWidth || $elm.clientWidth,\n        h: parseInt(h, 10) || $elm.offsetHeight || $elm.clientHeight\n      };\n    };\n    const getRect = elm => {\n      const $elm = get(elm);\n      const pos = getPos$1($elm);\n      const size = getSize($elm);\n      return {\n        x: pos.x,\n        y: pos.y,\n        w: size.w,\n        h: size.h\n      };\n    };\n    const is = (elm, selector) => {\n      if (!elm) {\n        return false;\n      }\n      const elms = isArray$1(elm) ? elm : [elm];\n      return exists(elms, e => {\n        return is$1(SugarElement.fromDom(e), selector);\n      });\n    };\n    const getParents = (elm, selector, root, collect) => {\n      const result = [];\n      let node = get(elm);\n      collect = collect === undefined;\n      const resolvedRoot = root || (getRoot().nodeName !== 'BODY' ? getRoot().parentNode : null);\n      if (isString(selector)) {\n        if (selector === '*') {\n          selector = isElement$6;\n        } else {\n          const selectorVal = selector;\n          selector = node => is(node, selectorVal);\n        }\n      }\n      while (node) {\n        if (node === resolvedRoot || isNullable(node.nodeType) || isDocument$1(node) || isDocumentFragment(node)) {\n          break;\n        }\n        if (!selector || selector(node)) {\n          if (collect) {\n            result.push(node);\n          } else {\n            return [node];\n          }\n        }\n        node = node.parentNode;\n      }\n      return collect ? result : null;\n    };\n    const getParent = (node, selector, root) => {\n      const parents = getParents(node, selector, root, false);\n      return parents && parents.length > 0 ? parents[0] : null;\n    };\n    const _findSib = (node, selector, name) => {\n      let func = selector;\n      if (node) {\n        if (isString(selector)) {\n          func = node => {\n            return is(node, selector);\n          };\n        }\n        for (let tempNode = node[name]; tempNode; tempNode = tempNode[name]) {\n          if (isFunction(func) && func(tempNode)) {\n            return tempNode;\n          }\n        }\n      }\n      return null;\n    };\n    const getNext = (node, selector) => _findSib(node, selector, 'nextSibling');\n    const getPrev = (node, selector) => _findSib(node, selector, 'previousSibling');\n    const isParentNode = node => isFunction(node.querySelectorAll);\n    const select = (selector, scope) => {\n      var _a, _b;\n      const elm = (_b = (_a = get(scope)) !== null && _a !== void 0 ? _a : settings.root_element) !== null && _b !== void 0 ? _b : doc;\n      return isParentNode(elm) ? from(elm.querySelectorAll(selector)) : [];\n    };\n    const run = function (elm, func, scope) {\n      const context = scope !== null && scope !== void 0 ? scope : this;\n      if (isArray$1(elm)) {\n        const result = [];\n        each$a(elm, (e, i) => {\n          const node = get(e);\n          if (node) {\n            result.push(func.call(context, node, i));\n          }\n        });\n        return result;\n      } else {\n        const node = get(elm);\n        return !node ? false : func.call(context, node);\n      }\n    };\n    const setAttribs = (elm, attrs) => {\n      run(elm, $elm => {\n        each$d(attrs, (value, name) => {\n          setAttrib($elm, name, value);\n        });\n      });\n    };\n    const setHTML = (elm, html) => {\n      run(elm, e => {\n        const $elm = SugarElement.fromDom(e);\n        set$1($elm, html);\n      });\n    };\n    const add = (parentElm, name, attrs, html, create) => run(parentElm, parentElm => {\n      const newElm = isString(name) ? doc.createElement(name) : name;\n      if (isNonNullable(attrs)) {\n        setAttribs(newElm, attrs);\n      }\n      if (html) {\n        if (!isString(html) && html.nodeType) {\n          newElm.appendChild(html);\n        } else if (isString(html)) {\n          setHTML(newElm, html);\n        }\n      }\n      return !create ? parentElm.appendChild(newElm) : newElm;\n    });\n    const create = (name, attrs, html) => add(doc.createElement(name), name, attrs, html, true);\n    const decode = Entities.decode;\n    const encode = Entities.encodeAllRaw;\n    const createHTML = (name, attrs, html = '') => {\n      let outHtml = '<' + name;\n      for (const key in attrs) {\n        if (hasNonNullableKey(attrs, key)) {\n          outHtml += ' ' + key + '=\"' + encode(attrs[key]) + '\"';\n        }\n      }\n      if (isEmpty$3(html) && has$2(schema.getVoidElements(), name)) {\n        return outHtml + ' />';\n      } else {\n        return outHtml + '>' + html + '</' + name + '>';\n      }\n    };\n    const createFragment = html => {\n      const container = doc.createElement('div');\n      const frag = doc.createDocumentFragment();\n      frag.appendChild(container);\n      if (html) {\n        container.innerHTML = html;\n      }\n      let node;\n      while (node = container.firstChild) {\n        frag.appendChild(node);\n      }\n      frag.removeChild(container);\n      return frag;\n    };\n    const remove = (node, keepChildren) => {\n      return run(node, n => {\n        const $node = SugarElement.fromDom(n);\n        if (keepChildren) {\n          each$e(children$1($node), child => {\n            if (isText$c(child) && child.dom.length === 0) {\n              remove$4(child);\n            } else {\n              before$3($node, child);\n            }\n          });\n        }\n        remove$4($node);\n        return $node.dom;\n      });\n    };\n    const removeAllAttribs = e => run(e, e => {\n      const attrs = e.attributes;\n      for (let i = attrs.length - 1; i >= 0; i--) {\n        e.removeAttributeNode(attrs.item(i));\n      }\n    });\n    const parseStyle = cssText => styles.parse(cssText);\n    const serializeStyle = (stylesArg, name) => styles.serialize(stylesArg, name);\n    const addStyle = cssText => {\n      if (self !== DOMUtils.DOM && doc === document) {\n        if (addedStyles[cssText]) {\n          return;\n        }\n        addedStyles[cssText] = true;\n      }\n      let styleElm = doc.getElementById('mceDefaultStyles');\n      if (!styleElm) {\n        styleElm = doc.createElement('style');\n        styleElm.id = 'mceDefaultStyles';\n        styleElm.type = 'text/css';\n        const head = doc.head;\n        if (head.firstChild) {\n          head.insertBefore(styleElm, head.firstChild);\n        } else {\n          head.appendChild(styleElm);\n        }\n      }\n      if (styleElm.styleSheet) {\n        styleElm.styleSheet.cssText += cssText;\n      } else {\n        styleElm.appendChild(doc.createTextNode(cssText));\n      }\n    };\n    const loadCSS = urls => {\n      if (!urls) {\n        urls = '';\n      }\n      each$e(urls.split(','), url => {\n        files[url] = true;\n        styleSheetLoader.load(url).catch(noop);\n      });\n    };\n    const toggleClass = (elm, cls, state) => {\n      run(elm, e => {\n        if (isElement$6(e)) {\n          const $elm = SugarElement.fromDom(e);\n          const classes = cls.split(' ');\n          each$e(classes, c => {\n            if (isNonNullable(state)) {\n              const fn = state ? add$2 : remove$6;\n              fn($elm, c);\n            } else {\n              toggle$1($elm, c);\n            }\n          });\n        }\n      });\n    };\n    const addClass = (elm, cls) => {\n      toggleClass(elm, cls, true);\n    };\n    const removeClass = (elm, cls) => {\n      toggleClass(elm, cls, false);\n    };\n    const hasClass = (elm, cls) => {\n      const $elm = _get(elm);\n      const classes = cls.split(' ');\n      return isNonNullable($elm) && forall(classes, c => has($elm, c));\n    };\n    const show = elm => {\n      run(elm, e => remove$5(SugarElement.fromDom(e), 'display'));\n    };\n    const hide = elm => {\n      run(elm, e => set$2(SugarElement.fromDom(e), 'display', 'none'));\n    };\n    const isHidden = elm => {\n      const $elm = _get(elm);\n      return isNonNullable($elm) && is$2(getRaw($elm, 'display'), 'none');\n    };\n    const uniqueId = prefix => (!prefix ? 'mce_' : prefix) + counter++;\n    const getOuterHTML = elm => {\n      const $elm = _get(elm);\n      if (isNonNullable($elm)) {\n        return isElement$6($elm.dom) ? $elm.dom.outerHTML : getOuter($elm);\n      } else {\n        return '';\n      }\n    };\n    const setOuterHTML = (elm, html) => {\n      run(elm, $elm => {\n        if (isElement$6($elm)) {\n          $elm.outerHTML = html;\n        }\n      });\n    };\n    const insertAfter = (node, reference) => {\n      const referenceNode = get(reference);\n      return run(node, node => {\n        const parent = referenceNode === null || referenceNode === void 0 ? void 0 : referenceNode.parentNode;\n        const nextSibling = referenceNode === null || referenceNode === void 0 ? void 0 : referenceNode.nextSibling;\n        if (parent) {\n          if (nextSibling) {\n            parent.insertBefore(node, nextSibling);\n          } else {\n            parent.appendChild(node);\n          }\n        }\n        return node;\n      });\n    };\n    const replace = (newElm, oldElm, keepChildren) => run(oldElm, elm => {\n      var _a;\n      const replacee = isArray$1(oldElm) ? newElm.cloneNode(true) : newElm;\n      if (keepChildren) {\n        each$a(grep(elm.childNodes), node => {\n          replacee.appendChild(node);\n        });\n      }\n      (_a = elm.parentNode) === null || _a === void 0 ? void 0 : _a.replaceChild(replacee, elm);\n      return elm;\n    });\n    const rename = (elm, name) => {\n      if (elm.nodeName !== name.toUpperCase()) {\n        const newElm = create(name);\n        each$a(getAttribs(elm), attrNode => {\n          setAttrib(newElm, attrNode.nodeName, getAttrib(elm, attrNode.nodeName));\n        });\n        replace(newElm, elm, true);\n        return newElm;\n      } else {\n        return elm;\n      }\n    };\n    const findCommonAncestor = (a, b) => {\n      let ps = a;\n      while (ps) {\n        let pe = b;\n        while (pe && ps !== pe) {\n          pe = pe.parentNode;\n        }\n        if (ps === pe) {\n          break;\n        }\n        ps = ps.parentNode;\n      }\n      if (!ps && a.ownerDocument) {\n        return a.ownerDocument.documentElement;\n      } else {\n        return ps;\n      }\n    };\n    const isEmpty = (node, elements, options) => {\n      if (isPlainObject(elements)) {\n        const isContent = node => {\n          const name = node.nodeName.toLowerCase();\n          return Boolean(elements[name]);\n        };\n        return isEmptyNode(schema, node, {\n          ...options,\n          isContent\n        });\n      } else {\n        return isEmptyNode(schema, node, options);\n      }\n    };\n    const createRng = () => doc.createRange();\n    const split = (parentElm, splitElm, replacementElm) => {\n      let range = createRng();\n      let beforeFragment;\n      let afterFragment;\n      if (parentElm && splitElm && parentElm.parentNode && splitElm.parentNode) {\n        const parentNode = parentElm.parentNode;\n        range.setStart(parentNode, findNodeIndex(parentElm));\n        range.setEnd(splitElm.parentNode, findNodeIndex(splitElm));\n        beforeFragment = range.extractContents();\n        range = createRng();\n        range.setStart(splitElm.parentNode, findNodeIndex(splitElm) + 1);\n        range.setEnd(parentNode, findNodeIndex(parentElm) + 1);\n        afterFragment = range.extractContents();\n        parentNode.insertBefore(trimNode(self, beforeFragment, schema), parentElm);\n        if (replacementElm) {\n          parentNode.insertBefore(replacementElm, parentElm);\n        } else {\n          parentNode.insertBefore(splitElm, parentElm);\n        }\n        parentNode.insertBefore(trimNode(self, afterFragment, schema), parentElm);\n        remove(parentElm);\n        return replacementElm || splitElm;\n      } else {\n        return undefined;\n      }\n    };\n    const bind = (target, name, func, scope) => {\n      if (isArray$1(target)) {\n        let i = target.length;\n        const rv = [];\n        while (i--) {\n          rv[i] = bind(target[i], name, func, scope);\n        }\n        return rv;\n      } else {\n        if (settings.collect && (target === doc || target === win)) {\n          boundEvents.push([target, name, func, scope]);\n        }\n        return events.bind(target, name, func, scope || self);\n      }\n    };\n    const unbind = (target, name, func) => {\n      if (isArray$1(target)) {\n        let i = target.length;\n        const rv = [];\n        while (i--) {\n          rv[i] = unbind(target[i], name, func);\n        }\n        return rv;\n      } else {\n        if (boundEvents.length > 0 && (target === doc || target === win)) {\n          let i = boundEvents.length;\n          while (i--) {\n            const [boundTarget, boundName, boundFunc] = boundEvents[i];\n            if (target === boundTarget && (!name || name === boundName) && (!func || func === boundFunc)) {\n              events.unbind(boundTarget, boundName, boundFunc);\n            }\n          }\n        }\n        return events.unbind(target, name, func);\n      }\n    };\n    const dispatch = (target, name, evt) => events.dispatch(target, name, evt);\n    const fire = (target, name, evt) => events.dispatch(target, name, evt);\n    const getContentEditable = node => {\n      if (node && isHTMLElement(node)) {\n        const contentEditable = node.getAttribute('data-mce-contenteditable');\n        if (contentEditable && contentEditable !== 'inherit') {\n          return contentEditable;\n        }\n        return node.contentEditable !== 'inherit' ? node.contentEditable : null;\n      } else {\n        return null;\n      }\n    };\n    const getContentEditableParent = node => {\n      const root = getRoot();\n      let state = null;\n      for (let tempNode = node; tempNode && tempNode !== root; tempNode = tempNode.parentNode) {\n        state = getContentEditable(tempNode);\n        if (state !== null) {\n          break;\n        }\n      }\n      return state;\n    };\n    const isEditable = node => {\n      if (isNonNullable(node)) {\n        const scope = isElement$6(node) ? node : node.parentElement;\n        return isNonNullable(scope) && isHTMLElement(scope) && isEditable$2(SugarElement.fromDom(scope));\n      } else {\n        return false;\n      }\n    };\n    const destroy = () => {\n      if (boundEvents.length > 0) {\n        let i = boundEvents.length;\n        while (i--) {\n          const [boundTarget, boundName, boundFunc] = boundEvents[i];\n          events.unbind(boundTarget, boundName, boundFunc);\n        }\n      }\n      each$d(files, (_, url) => {\n        styleSheetLoader.unload(url);\n        delete files[url];\n      });\n    };\n    const isChildOf = (node, parent) => {\n      return node === parent || parent.contains(node);\n    };\n    const dumpRng = r => 'startContainer: ' + r.startContainer.nodeName + ', startOffset: ' + r.startOffset + ', endContainer: ' + r.endContainer.nodeName + ', endOffset: ' + r.endOffset;\n    const self = {\n      doc,\n      settings,\n      win,\n      files,\n      stdMode,\n      boxModel,\n      styleSheetLoader,\n      boundEvents,\n      styles,\n      schema,\n      events,\n      isBlock: isBlock,\n      root: null,\n      clone,\n      getRoot,\n      getViewPort,\n      getRect,\n      getSize,\n      getParent,\n      getParents: getParents,\n      get,\n      getNext,\n      getPrev,\n      select,\n      is,\n      add,\n      create,\n      createHTML,\n      createFragment,\n      remove,\n      setStyle,\n      getStyle: getStyle,\n      setStyles,\n      removeAllAttribs,\n      setAttrib,\n      setAttribs,\n      getAttrib,\n      getPos: getPos$1,\n      parseStyle,\n      serializeStyle,\n      addStyle,\n      loadCSS,\n      addClass,\n      removeClass,\n      hasClass,\n      toggleClass,\n      show,\n      hide,\n      isHidden,\n      uniqueId,\n      setHTML,\n      getOuterHTML,\n      setOuterHTML,\n      decode,\n      encode,\n      insertAfter,\n      replace,\n      rename,\n      findCommonAncestor,\n      run,\n      getAttribs,\n      isEmpty,\n      createRng,\n      nodeIndex: findNodeIndex,\n      split,\n      bind: bind,\n      unbind: unbind,\n      fire,\n      dispatch,\n      getContentEditable,\n      getContentEditableParent,\n      isEditable,\n      destroy,\n      isChildOf,\n      dumpRng\n    };\n    const attrHooks = setupAttrHooks(styles, settings, constant(self));\n    return self;\n  };\n  DOMUtils.DOM = DOMUtils(document);\n  DOMUtils.nodeIndex = findNodeIndex;\n  const DOM$b = DOMUtils.DOM;\n  const QUEUED = 0;\n  const LOADING = 1;\n  const LOADED = 2;\n  const FAILED = 3;\n  class ScriptLoader {\n    constructor(settings = {}) {\n      this.states = {};\n      this.queue = [];\n      this.scriptLoadedCallbacks = {};\n      this.queueLoadedCallbacks = [];\n      this.loading = false;\n      this.settings = settings;\n    }\n    _setReferrerPolicy(referrerPolicy) {\n      this.settings.referrerPolicy = referrerPolicy;\n    }\n    loadScript(url) {\n      return new Promise((resolve, reject) => {\n        const dom = DOM$b;\n        let elm;\n        const cleanup = () => {\n          dom.remove(id);\n          if (elm) {\n            elm.onerror = elm.onload = elm = null;\n          }\n        };\n        const done = () => {\n          cleanup();\n          resolve();\n        };\n        const error = () => {\n          cleanup();\n          reject('Failed to load script: ' + url);\n        };\n        const id = dom.uniqueId();\n        elm = document.createElement('script');\n        elm.id = id;\n        elm.type = 'text/javascript';\n        elm.src = Tools._addCacheSuffix(url);\n        if (this.settings.referrerPolicy) {\n          dom.setAttrib(elm, 'referrerpolicy', this.settings.referrerPolicy);\n        }\n        elm.onload = done;\n        elm.onerror = error;\n        (document.getElementsByTagName('head')[0] || document.body).appendChild(elm);\n      });\n    }\n    isDone(url) {\n      return this.states[url] === LOADED;\n    }\n    markDone(url) {\n      this.states[url] = LOADED;\n    }\n    add(url) {\n      const self = this;\n      self.queue.push(url);\n      const state = self.states[url];\n      if (state === undefined) {\n        self.states[url] = QUEUED;\n      }\n      return new Promise((resolve, reject) => {\n        if (!self.scriptLoadedCallbacks[url]) {\n          self.scriptLoadedCallbacks[url] = [];\n        }\n        self.scriptLoadedCallbacks[url].push({\n          resolve,\n          reject\n        });\n      });\n    }\n    load(url) {\n      return this.add(url);\n    }\n    remove(url) {\n      delete this.states[url];\n      delete this.scriptLoadedCallbacks[url];\n    }\n    loadQueue() {\n      const queue = this.queue;\n      this.queue = [];\n      return this.loadScripts(queue);\n    }\n    loadScripts(scripts) {\n      const self = this;\n      const execCallbacks = (name, url) => {\n        get$a(self.scriptLoadedCallbacks, url).each(callbacks => {\n          each$e(callbacks, callback => callback[name](url));\n        });\n        delete self.scriptLoadedCallbacks[url];\n      };\n      const processResults = results => {\n        const failures = filter$5(results, result => result.status === 'rejected');\n        if (failures.length > 0) {\n          return Promise.reject(bind$3(failures, ({\n            reason\n          }) => isArray$1(reason) ? reason : [reason]));\n        } else {\n          return Promise.resolve();\n        }\n      };\n      const load = urls => Promise.allSettled(map$3(urls, url => {\n        if (self.states[url] === LOADED) {\n          execCallbacks('resolve', url);\n          return Promise.resolve();\n        } else if (self.states[url] === FAILED) {\n          execCallbacks('reject', url);\n          return Promise.reject(url);\n        } else {\n          self.states[url] = LOADING;\n          return self.loadScript(url).then(() => {\n            self.states[url] = LOADED;\n            execCallbacks('resolve', url);\n            const queue = self.queue;\n            if (queue.length > 0) {\n              self.queue = [];\n              return load(queue).then(processResults);\n            } else {\n              return Promise.resolve();\n            }\n          }, () => {\n            self.states[url] = FAILED;\n            execCallbacks('reject', url);\n            return Promise.reject(url);\n          });\n        }\n      }));\n      const processQueue = urls => {\n        self.loading = true;\n        return load(urls).then(results => {\n          self.loading = false;\n          const nextQueuedItem = self.queueLoadedCallbacks.shift();\n          Optional.from(nextQueuedItem).each(call);\n          return processResults(results);\n        });\n      };\n      const uniqueScripts = stringArray(scripts);\n      if (self.loading) {\n        return new Promise((resolve, reject) => {\n          self.queueLoadedCallbacks.push(() => {\n            processQueue(uniqueScripts).then(resolve, reject);\n          });\n        });\n      } else {\n        return processQueue(uniqueScripts);\n      }\n    }\n  }\n  ScriptLoader.ScriptLoader = new ScriptLoader();\n  const isDuplicated = (items, item) => {\n    const firstIndex = items.indexOf(item);\n    return firstIndex !== -1 && items.indexOf(item, firstIndex + 1) > firstIndex;\n  };\n  const isRaw = str => isObject(str) && has$2(str, 'raw');\n  const isTokenised = str => isArray$1(str) && str.length > 1;\n  const data = {};\n  const currentCode = Cell('en');\n  const getLanguageData = () => get$a(data, currentCode.get());\n  const getData$1 = () => map$2(data, value => ({\n    ...value\n  }));\n  const setCode = newCode => {\n    if (newCode) {\n      currentCode.set(newCode);\n    }\n  };\n  const getCode = () => currentCode.get();\n  const add$1 = (code, items) => {\n    let langData = data[code];\n    if (!langData) {\n      data[code] = langData = {};\n    }\n    const lcNames = map$3(keys(items), name => name.toLowerCase());\n    each$d(items, (translation, name) => {\n      const lcName = name.toLowerCase();\n      if (lcName !== name && isDuplicated(lcNames, lcName)) {\n        if (!has$2(items, lcName)) {\n          langData[lcName] = translation;\n        }\n        langData[name] = translation;\n      } else {\n        langData[lcName] = translation;\n      }\n    });\n  };\n  const translate = text => {\n    const langData = getLanguageData().getOr({});\n    const toString = obj => {\n      if (isFunction(obj)) {\n        return Object.prototype.toString.call(obj);\n      }\n      return !isEmpty(obj) ? '' + obj : '';\n    };\n    const isEmpty = text => text === '' || text === null || text === undefined;\n    const getLangData = text => {\n      const textStr = toString(text);\n      return has$2(langData, textStr) ? toString(langData[textStr]) : get$a(langData, textStr.toLowerCase()).map(toString).getOr(textStr);\n    };\n    const removeContext = str => str.replace(/{context:\\w+}$/, '');\n    if (isEmpty(text)) {\n      return '';\n    }\n    if (isRaw(text)) {\n      return toString(text.raw);\n    }\n    if (isTokenised(text)) {\n      const values = text.slice(1);\n      const substitued = getLangData(text[0]).replace(/\\{([0-9]+)\\}/g, ($1, $2) => has$2(values, $2) ? toString(values[$2]) : $1);\n      return removeContext(substitued);\n    }\n    return removeContext(getLangData(text));\n  };\n  const isRtl$1 = () => getLanguageData().bind(items => get$a(items, '_dir')).exists(dir => dir === 'rtl');\n  const hasCode = code => has$2(data, code);\n  const I18n = {\n    getData: getData$1,\n    setCode,\n    getCode,\n    add: add$1,\n    translate,\n    isRtl: isRtl$1,\n    hasCode\n  };\n  const AddOnManager = () => {\n    const items = [];\n    const urls = {};\n    const lookup = {};\n    const _listeners = [];\n    const runListeners = (name, state) => {\n      const matchedListeners = filter$5(_listeners, listener => listener.name === name && listener.state === state);\n      each$e(matchedListeners, listener => listener.resolve());\n    };\n    const isLoaded = name => has$2(urls, name);\n    const isAdded = name => has$2(lookup, name);\n    const get = name => {\n      if (lookup[name]) {\n        return lookup[name].instance;\n      }\n      return undefined;\n    };\n    const loadLanguagePack = (name, languages) => {\n      const language = I18n.getCode();\n      const wrappedLanguages = ',' + (languages || '') + ',';\n      if (!language || languages && wrappedLanguages.indexOf(',' + language + ',') === -1) {\n        return;\n      }\n      ScriptLoader.ScriptLoader.add(urls[name] + '/langs/' + language + '.js');\n    };\n    const requireLangPack = (name, languages) => {\n      if (AddOnManager.languageLoad !== false) {\n        if (isLoaded(name)) {\n          loadLanguagePack(name, languages);\n        } else {\n          waitFor(name, 'loaded').then(() => loadLanguagePack(name, languages));\n        }\n      }\n    };\n    const add = (id, addOn) => {\n      items.push(addOn);\n      lookup[id] = {\n        instance: addOn\n      };\n      runListeners(id, 'added');\n      return addOn;\n    };\n    const remove = name => {\n      delete urls[name];\n      delete lookup[name];\n    };\n    const createUrl = (baseUrl, dep) => {\n      if (isString(dep)) {\n        return isString(baseUrl) ? {\n          prefix: '',\n          resource: dep,\n          suffix: ''\n        } : {\n          prefix: baseUrl.prefix,\n          resource: dep,\n          suffix: baseUrl.suffix\n        };\n      } else {\n        return dep;\n      }\n    };\n    const load = (name, addOnUrl) => {\n      if (urls[name]) {\n        return Promise.resolve();\n      }\n      let urlString = isString(addOnUrl) ? addOnUrl : addOnUrl.prefix + addOnUrl.resource + addOnUrl.suffix;\n      if (urlString.indexOf('/') !== 0 && urlString.indexOf('://') === -1) {\n        urlString = AddOnManager.baseURL + '/' + urlString;\n      }\n      urls[name] = urlString.substring(0, urlString.lastIndexOf('/'));\n      const done = () => {\n        runListeners(name, 'loaded');\n        return Promise.resolve();\n      };\n      if (lookup[name]) {\n        return done();\n      } else {\n        return ScriptLoader.ScriptLoader.add(urlString).then(done);\n      }\n    };\n    const waitFor = (name, state = 'added') => {\n      if (state === 'added' && isAdded(name)) {\n        return Promise.resolve();\n      } else if (state === 'loaded' && isLoaded(name)) {\n        return Promise.resolve();\n      } else {\n        return new Promise(resolve => {\n          _listeners.push({\n            name,\n            state,\n            resolve\n          });\n        });\n      }\n    };\n    return {\n      items,\n      urls,\n      lookup,\n      get,\n      requireLangPack,\n      add,\n      remove,\n      createUrl,\n      load,\n      waitFor\n    };\n  };\n  AddOnManager.languageLoad = true;\n  AddOnManager.baseURL = '';\n  AddOnManager.PluginManager = AddOnManager();\n  AddOnManager.ThemeManager = AddOnManager();\n  AddOnManager.ModelManager = AddOnManager();\n  const first$1 = (fn, rate) => {\n    let timer = null;\n    const cancel = () => {\n      if (!isNull(timer)) {\n        clearTimeout(timer);\n        timer = null;\n      }\n    };\n    const throttle = (...args) => {\n      if (isNull(timer)) {\n        timer = setTimeout(() => {\n          timer = null;\n          fn.apply(null, args);\n        }, rate);\n      }\n    };\n    return {\n      cancel,\n      throttle\n    };\n  };\n  const last = (fn, rate) => {\n    let timer = null;\n    const cancel = () => {\n      if (!isNull(timer)) {\n        clearTimeout(timer);\n        timer = null;\n      }\n    };\n    const throttle = (...args) => {\n      cancel();\n      timer = setTimeout(() => {\n        timer = null;\n        fn.apply(null, args);\n      }, rate);\n    };\n    return {\n      cancel,\n      throttle\n    };\n  };\n  const ancestor$1 = (scope, selector, isRoot) => ancestor$3(scope, selector, isRoot).isSome();\n  const annotation = constant('mce-annotation');\n  const dataAnnotation = constant('data-mce-annotation');\n  const dataAnnotationId = constant('data-mce-annotation-uid');\n  const dataAnnotationActive = constant('data-mce-annotation-active');\n  const dataAnnotationClasses = constant('data-mce-annotation-classes');\n  const dataAnnotationAttributes = constant('data-mce-annotation-attrs');\n  const isRoot$1 = root => node => eq(node, root);\n  const identify = (editor, annotationName) => {\n    const rng = editor.selection.getRng();\n    const start = SugarElement.fromDom(rng.startContainer);\n    const root = SugarElement.fromDom(editor.getBody());\n    const selector = annotationName.fold(() => '.' + annotation(), an => `[${dataAnnotation()}=\"${an}\"]`);\n    const newStart = child$1(start, rng.startOffset).getOr(start);\n    const closest = closest$3(newStart, selector, isRoot$1(root));\n    return closest.bind(c => getOpt(c, `${dataAnnotationId()}`).bind(uid => getOpt(c, `${dataAnnotation()}`).map(name => {\n      const elements = findMarkers(editor, uid);\n      return {\n        uid,\n        name,\n        elements\n      };\n    })));\n  };\n  const isAnnotation = elem => isElement$7(elem) && has(elem, annotation());\n  const isBogusElement = (elem, root) => has$1(elem, 'data-mce-bogus') || ancestor$1(elem, '[data-mce-bogus=\"all\"]', isRoot$1(root));\n  const findMarkers = (editor, uid) => {\n    const body = SugarElement.fromDom(editor.getBody());\n    const descendants$1 = descendants(body, `[${dataAnnotationId()}=\"${uid}\"]`);\n    return filter$5(descendants$1, descendant => !isBogusElement(descendant, body));\n  };\n  const findAll = (editor, name) => {\n    const body = SugarElement.fromDom(editor.getBody());\n    const markers = descendants(body, `[${dataAnnotation()}=\"${name}\"]`);\n    const directory = {};\n    each$e(markers, m => {\n      if (!isBogusElement(m, body)) {\n        const uid = get$9(m, dataAnnotationId());\n        const nodesAlready = get$a(directory, uid).getOr([]);\n        directory[uid] = nodesAlready.concat([m]);\n      }\n    });\n    return directory;\n  };\n  const setup$y = (editor, registry) => {\n    const changeCallbacks = Cell({});\n    const initData = () => ({\n      listeners: [],\n      previous: value$2()\n    });\n    const withCallbacks = (name, f) => {\n      updateCallbacks(name, data => {\n        f(data);\n        return data;\n      });\n    };\n    const updateCallbacks = (name, f) => {\n      const callbackMap = changeCallbacks.get();\n      const data = get$a(callbackMap, name).getOrThunk(initData);\n      const outputData = f(data);\n      callbackMap[name] = outputData;\n      changeCallbacks.set(callbackMap);\n    };\n    const fireCallbacks = (name, uid, elements) => {\n      withCallbacks(name, data => {\n        each$e(data.listeners, f => f(true, name, {\n          uid,\n          nodes: map$3(elements, elem => elem.dom)\n        }));\n      });\n    };\n    const fireNoAnnotation = name => {\n      withCallbacks(name, data => {\n        each$e(data.listeners, f => f(false, name));\n      });\n    };\n    const toggleActiveAttr = (uid, state) => {\n      each$e(findMarkers(editor, uid), elem => {\n        if (state) {\n          set$3(elem, dataAnnotationActive(), 'true');\n        } else {\n          remove$9(elem, dataAnnotationActive());\n        }\n      });\n    };\n    const onNodeChange = last(() => {\n      const annotations = sort(registry.getNames());\n      each$e(annotations, name => {\n        updateCallbacks(name, data => {\n          const prev = data.previous.get();\n          identify(editor, Optional.some(name)).fold(() => {\n            prev.each(uid => {\n              fireNoAnnotation(name);\n              data.previous.clear();\n              toggleActiveAttr(uid, false);\n            });\n          }, ({\n            uid,\n            name,\n            elements\n          }) => {\n            if (!is$2(prev, uid)) {\n              prev.each(uid => toggleActiveAttr(uid, false));\n              fireCallbacks(name, uid, elements);\n              data.previous.set(uid);\n              toggleActiveAttr(uid, true);\n            }\n          });\n          return {\n            previous: data.previous,\n            listeners: data.listeners\n          };\n        });\n      });\n    }, 30);\n    editor.on('remove', () => {\n      onNodeChange.cancel();\n    });\n    editor.on('NodeChange', () => {\n      onNodeChange.throttle();\n    });\n    const addListener = (name, f) => {\n      updateCallbacks(name, data => ({\n        previous: data.previous,\n        listeners: data.listeners.concat([f])\n      }));\n    };\n    return {\n      addListener\n    };\n  };\n  const setup$x = (editor, registry) => {\n    const dataAnnotation$1 = dataAnnotation();\n    const identifyParserNode = node => Optional.from(node.attr(dataAnnotation$1)).bind(registry.lookup);\n    const removeDirectAnnotation = node => {\n      var _a, _b;\n      node.attr(dataAnnotationId(), null);\n      node.attr(dataAnnotation(), null);\n      node.attr(dataAnnotationActive(), null);\n      const customAttrNames = Optional.from(node.attr(dataAnnotationAttributes())).map(names => names.split(',')).getOr([]);\n      const customClasses = Optional.from(node.attr(dataAnnotationClasses())).map(names => names.split(',')).getOr([]);\n      each$e(customAttrNames, name => node.attr(name, null));\n      const classList = (_b = (_a = node.attr('class')) === null || _a === void 0 ? void 0 : _a.split(' ')) !== null && _b !== void 0 ? _b : [];\n      const newClassList = difference(classList, [annotation()].concat(customClasses));\n      node.attr('class', newClassList.length > 0 ? newClassList.join(' ') : null);\n      node.attr(dataAnnotationClasses(), null);\n      node.attr(dataAnnotationAttributes(), null);\n    };\n    editor.serializer.addTempAttr(dataAnnotationActive());\n    editor.serializer.addAttributeFilter(dataAnnotation$1, nodes => {\n      for (const node of nodes) {\n        identifyParserNode(node).each(settings => {\n          if (settings.persistent === false) {\n            if (node.name === 'span') {\n              node.unwrap();\n            } else {\n              removeDirectAnnotation(node);\n            }\n          }\n        });\n      }\n    });\n  };\n  const create$b = () => {\n    const annotations = {};\n    const register = (name, settings) => {\n      annotations[name] = {\n        name,\n        settings\n      };\n    };\n    const lookup = name => get$a(annotations, name).map(a => a.settings);\n    const getNames = () => keys(annotations);\n    return {\n      register,\n      lookup,\n      getNames\n    };\n  };\n  const clamp$2 = (value, min, max) => Math.min(Math.max(value, min), max);\n  const random = () => window.crypto.getRandomValues(new Uint32Array(1))[0] / 4294967295;\n  let unique = 0;\n  const generate$1 = prefix => {\n    const date = new Date();\n    const time = date.getTime();\n    const random$1 = Math.floor(random() * 1000000000);\n    unique++;\n    return prefix + '_' + random$1 + unique + String(time);\n  };\n  const add = (element, classes) => {\n    each$e(classes, x => {\n      add$2(element, x);\n    });\n  };\n  const remove$3 = (element, classes) => {\n    each$e(classes, x => {\n      remove$6(element, x);\n    });\n  };\n  const clone$2 = (original, isDeep) => SugarElement.fromDom(original.dom.cloneNode(isDeep));\n  const shallow$1 = original => clone$2(original, false);\n  const deep$1 = original => clone$2(original, true);\n  const shallowAs = (original, tag) => {\n    const nu = SugarElement.fromTag(tag);\n    const attributes = clone$4(original);\n    setAll$1(nu, attributes);\n    return nu;\n  };\n  const mutate = (original, tag) => {\n    const nu = shallowAs(original, tag);\n    after$4(original, nu);\n    const children = children$1(original);\n    append(nu, children);\n    remove$4(original);\n    return nu;\n  };\n  const TextWalker = (startNode, rootNode, isBoundary = never) => {\n    const walker = new DomTreeWalker(startNode, rootNode);\n    const walk = direction => {\n      let next;\n      do {\n        next = walker[direction]();\n      } while (next && !isText$b(next) && !isBoundary(next));\n      return Optional.from(next).filter(isText$b);\n    };\n    return {\n      current: () => Optional.from(walker.current()).filter(isText$b),\n      next: () => walk('next'),\n      prev: () => walk('prev'),\n      prev2: () => walk('prev2')\n    };\n  };\n  const TextSeeker = (dom, isBoundary) => {\n    const isBlockBoundary = isBoundary ? isBoundary : node => dom.isBlock(node) || isBr$6(node) || isContentEditableFalse$b(node);\n    const walk = (node, offset, walker, process) => {\n      if (isText$b(node)) {\n        const newOffset = process(node, offset, node.data);\n        if (newOffset !== -1) {\n          return Optional.some({\n            container: node,\n            offset: newOffset\n          });\n        }\n      }\n      return walker().bind(next => walk(next.container, next.offset, walker, process));\n    };\n    const backwards = (node, offset, process, root) => {\n      const walker = TextWalker(node, root !== null && root !== void 0 ? root : dom.getRoot(), isBlockBoundary);\n      return walk(node, offset, () => walker.prev().map(prev => ({\n        container: prev,\n        offset: prev.length\n      })), process).getOrNull();\n    };\n    const forwards = (node, offset, process, root) => {\n      const walker = TextWalker(node, root !== null && root !== void 0 ? root : dom.getRoot(), isBlockBoundary);\n      return walk(node, offset, () => walker.next().map(next => ({\n        container: next,\n        offset: 0\n      })), process).getOrNull();\n    };\n    return {\n      backwards,\n      forwards\n    };\n  };\n  const NodeValue = (is, name) => {\n    const get = element => {\n      if (!is(element)) {\n        throw new Error('Can only get ' + name + ' value of a ' + name + ' node');\n      }\n      return getOption(element).getOr('');\n    };\n    const getOption = element => is(element) ? Optional.from(element.dom.nodeValue) : Optional.none();\n    const set = (element, value) => {\n      if (!is(element)) {\n        throw new Error('Can only set raw ' + name + ' value of a ' + name + ' node');\n      }\n      element.dom.nodeValue = value;\n    };\n    return {\n      get,\n      getOption,\n      set\n    };\n  };\n  const api$1 = NodeValue(isText$c, 'text');\n  const get$3 = element => api$1.get(element);\n  const getOption = element => api$1.getOption(element);\n  const set = (element, value) => api$1.set(element, value);\n  const tableCells = ['td', 'th'];\n  const tableSections = ['thead', 'tbody', 'tfoot'];\n  const textBlocks = ['h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'p', 'div', 'address', 'pre', 'form', 'blockquote', 'center', 'dir', 'fieldset', 'header', 'footer', 'article', 'section', 'hgroup', 'aside', 'nav', 'figure'];\n  const listItems$1 = ['li', 'dd', 'dt'];\n  const lists = ['ul', 'ol', 'dl'];\n  const wsElements = ['pre', 'script', 'textarea', 'style'];\n  const lazyLookup = items => {\n    let lookup;\n    return node => {\n      lookup = lookup ? lookup : mapToObject(items, always);\n      return has$2(lookup, name(node));\n    };\n  };\n  const isTable$1 = node => name(node) === 'table';\n  const isBr$5 = node => isElement$7(node) && name(node) === 'br';\n  const isTextBlock$2 = lazyLookup(textBlocks);\n  const isList = lazyLookup(lists);\n  const isListItem$1 = lazyLookup(listItems$1);\n  const isTableSection = lazyLookup(tableSections);\n  const isTableCell$2 = lazyLookup(tableCells);\n  const isWsPreserveElement = lazyLookup(wsElements);\n  const getLastChildren$1 = elm => {\n    const children = [];\n    let rawNode = elm.dom;\n    while (rawNode) {\n      children.push(SugarElement.fromDom(rawNode));\n      rawNode = rawNode.lastChild;\n    }\n    return children;\n  };\n  const removeTrailingBr = elm => {\n    const allBrs = descendants(elm, 'br');\n    const brs = filter$5(getLastChildren$1(elm).slice(-1), isBr$5);\n    if (allBrs.length === brs.length) {\n      each$e(brs, remove$4);\n    }\n  };\n  const createPaddingBr = () => {\n    const br = SugarElement.fromTag('br');\n    set$3(br, 'data-mce-bogus', '1');\n    return br;\n  };\n  const fillWithPaddingBr = elm => {\n    empty(elm);\n    append$1(elm, createPaddingBr());\n  };\n  const trimBlockTrailingBr = (elm, schema) => {\n    lastChild(elm).each(lastChild => {\n      prevSibling(lastChild).each(lastChildPrevSibling => {\n        if (schema.isBlock(name(elm)) && isBr$5(lastChild) && schema.isBlock(name(lastChildPrevSibling))) {\n          remove$4(lastChild);\n        }\n      });\n    });\n  };\n  const ZWSP$1 = zeroWidth;\n  const isZwsp = isZwsp$2;\n  const trim$2 = removeZwsp;\n  const insert$5 = editor => editor.insertContent(ZWSP$1, {\n    preserve_zwsp: true\n  });\n  const isElement$5 = isElement$6;\n  const isText$9 = isText$b;\n  const isCaretContainerBlock$1 = node => {\n    if (isText$9(node)) {\n      node = node.parentNode;\n    }\n    return isElement$5(node) && node.hasAttribute('data-mce-caret');\n  };\n  const isCaretContainerInline = node => isText$9(node) && isZwsp(node.data);\n  const isCaretContainer$2 = node => isCaretContainerBlock$1(node) || isCaretContainerInline(node);\n  const hasContent = node => node.firstChild !== node.lastChild || !isBr$6(node.firstChild);\n  const insertInline$1 = (node, before) => {\n    var _a;\n    const doc = (_a = node.ownerDocument) !== null && _a !== void 0 ? _a : document;\n    const textNode = doc.createTextNode(ZWSP$1);\n    const parentNode = node.parentNode;\n    if (!before) {\n      const sibling = node.nextSibling;\n      if (isText$9(sibling)) {\n        if (isCaretContainer$2(sibling)) {\n          return sibling;\n        }\n        if (startsWithCaretContainer$1(sibling)) {\n          sibling.splitText(1);\n          return sibling;\n        }\n      }\n      if (node.nextSibling) {\n        parentNode === null || parentNode === void 0 ? void 0 : parentNode.insertBefore(textNode, node.nextSibling);\n      } else {\n        parentNode === null || parentNode === void 0 ? void 0 : parentNode.appendChild(textNode);\n      }\n    } else {\n      const sibling = node.previousSibling;\n      if (isText$9(sibling)) {\n        if (isCaretContainer$2(sibling)) {\n          return sibling;\n        }\n        if (endsWithCaretContainer$1(sibling)) {\n          return sibling.splitText(sibling.data.length - 1);\n        }\n      }\n      parentNode === null || parentNode === void 0 ? void 0 : parentNode.insertBefore(textNode, node);\n    }\n    return textNode;\n  };\n  const isBeforeInline = pos => {\n    const container = pos.container();\n    if (!isText$b(container)) {\n      return false;\n    }\n    return container.data.charAt(pos.offset()) === ZWSP$1 || pos.isAtStart() && isCaretContainerInline(container.previousSibling);\n  };\n  const isAfterInline = pos => {\n    const container = pos.container();\n    if (!isText$b(container)) {\n      return false;\n    }\n    return container.data.charAt(pos.offset() - 1) === ZWSP$1 || pos.isAtEnd() && isCaretContainerInline(container.nextSibling);\n  };\n  const insertBlock = (blockName, node, before) => {\n    var _a;\n    const doc = (_a = node.ownerDocument) !== null && _a !== void 0 ? _a : document;\n    const blockNode = doc.createElement(blockName);\n    blockNode.setAttribute('data-mce-caret', before ? 'before' : 'after');\n    blockNode.setAttribute('data-mce-bogus', 'all');\n    blockNode.appendChild(createPaddingBr().dom);\n    const parentNode = node.parentNode;\n    if (!before) {\n      if (node.nextSibling) {\n        parentNode === null || parentNode === void 0 ? void 0 : parentNode.insertBefore(blockNode, node.nextSibling);\n      } else {\n        parentNode === null || parentNode === void 0 ? void 0 : parentNode.appendChild(blockNode);\n      }\n    } else {\n      parentNode === null || parentNode === void 0 ? void 0 : parentNode.insertBefore(blockNode, node);\n    }\n    return blockNode;\n  };\n  const startsWithCaretContainer$1 = node => isText$9(node) && node.data[0] === ZWSP$1;\n  const endsWithCaretContainer$1 = node => isText$9(node) && node.data[node.data.length - 1] === ZWSP$1;\n  const trimBogusBr = elm => {\n    var _a;\n    const brs = elm.getElementsByTagName('br');\n    const lastBr = brs[brs.length - 1];\n    if (isBogus$1(lastBr)) {\n      (_a = lastBr.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(lastBr);\n    }\n  };\n  const showCaretContainerBlock = caretContainer => {\n    if (caretContainer && caretContainer.hasAttribute('data-mce-caret')) {\n      trimBogusBr(caretContainer);\n      caretContainer.removeAttribute('data-mce-caret');\n      caretContainer.removeAttribute('data-mce-bogus');\n      caretContainer.removeAttribute('style');\n      caretContainer.removeAttribute('data-mce-style');\n      caretContainer.removeAttribute('_moz_abspos');\n      return caretContainer;\n    }\n    return null;\n  };\n  const isRangeInCaretContainerBlock = range => isCaretContainerBlock$1(range.startContainer);\n  const round$2 = Math.round;\n  const clone$1 = rect => {\n    if (!rect) {\n      return {\n        left: 0,\n        top: 0,\n        bottom: 0,\n        right: 0,\n        width: 0,\n        height: 0\n      };\n    }\n    return {\n      left: round$2(rect.left),\n      top: round$2(rect.top),\n      bottom: round$2(rect.bottom),\n      right: round$2(rect.right),\n      width: round$2(rect.width),\n      height: round$2(rect.height)\n    };\n  };\n  const collapse = (rect, toStart) => {\n    rect = clone$1(rect);\n    if (toStart) {\n      rect.right = rect.left;\n    } else {\n      rect.left = rect.left + rect.width;\n      rect.right = rect.left;\n    }\n    rect.width = 0;\n    return rect;\n  };\n  const isEqual = (rect1, rect2) => rect1.left === rect2.left && rect1.top === rect2.top && rect1.bottom === rect2.bottom && rect1.right === rect2.right;\n  const isValidOverflow = (overflowY, rect1, rect2) => overflowY >= 0 && overflowY <= Math.min(rect1.height, rect2.height) / 2;\n  const isAbove$1 = (rect1, rect2) => {\n    const halfHeight = Math.min(rect2.height / 2, rect1.height / 2);\n    if (rect1.bottom - halfHeight < rect2.top) {\n      return true;\n    }\n    if (rect1.top > rect2.bottom) {\n      return false;\n    }\n    return isValidOverflow(rect2.top - rect1.bottom, rect1, rect2);\n  };\n  const isBelow$1 = (rect1, rect2) => {\n    if (rect1.top > rect2.bottom) {\n      return true;\n    }\n    if (rect1.bottom < rect2.top) {\n      return false;\n    }\n    return isValidOverflow(rect2.bottom - rect1.top, rect1, rect2);\n  };\n  const containsXY = (rect, clientX, clientY) => clientX >= rect.left && clientX <= rect.right && clientY >= rect.top && clientY <= rect.bottom;\n  const boundingClientRectFromRects = rects => {\n    return foldl(rects, (acc, rect) => {\n      return acc.fold(() => Optional.some(rect), prevRect => {\n        const left = Math.min(rect.left, prevRect.left);\n        const top = Math.min(rect.top, prevRect.top);\n        const right = Math.max(rect.right, prevRect.right);\n        const bottom = Math.max(rect.bottom, prevRect.bottom);\n        return Optional.some({\n          top,\n          right,\n          bottom,\n          left,\n          width: right - left,\n          height: bottom - top\n        });\n      });\n    }, Optional.none());\n  };\n  const distanceToRectEdgeFromXY = (rect, x, y) => {\n    const cx = Math.max(Math.min(x, rect.left + rect.width), rect.left);\n    const cy = Math.max(Math.min(y, rect.top + rect.height), rect.top);\n    return Math.sqrt((x - cx) * (x - cx) + (y - cy) * (y - cy));\n  };\n  const overlapY = (r1, r2) => Math.max(0, Math.min(r1.bottom, r2.bottom) - Math.max(r1.top, r2.top));\n  const getSelectedNode = range => {\n    const startContainer = range.startContainer,\n      startOffset = range.startOffset;\n    if (startContainer === range.endContainer && startContainer.hasChildNodes() && range.endOffset === startOffset + 1) {\n      return startContainer.childNodes[startOffset];\n    }\n    return null;\n  };\n  const getNode$1 = (container, offset) => {\n    if (isElement$6(container) && container.hasChildNodes()) {\n      const childNodes = container.childNodes;\n      const safeOffset = clamp$2(offset, 0, childNodes.length - 1);\n      return childNodes[safeOffset];\n    } else {\n      return container;\n    }\n  };\n  const getNodeUnsafe = (container, offset) => {\n    if (offset < 0 && isElement$6(container) && container.hasChildNodes()) {\n      return undefined;\n    } else {\n      return getNode$1(container, offset);\n    }\n  };\n  const extendingChars = new RegExp('[\\u0300-\\u036f\\u0483-\\u0487\\u0488-\\u0489\\u0591-\\u05bd\\u05bf\\u05c1-\\u05c2\\u05c4-\\u05c5\\u05c7\\u0610-\\u061a' + '\\u064b-\\u065f\\u0670\\u06d6-\\u06dc\\u06df-\\u06e4\\u06e7-\\u06e8\\u06ea-\\u06ed\\u0711\\u0730-\\u074a\\u07a6-\\u07b0' + '\\u07eb-\\u07f3\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0859-\\u085b\\u08e3-\\u0902\\u093a\\u093c' + '\\u0941-\\u0948\\u094d\\u0951-\\u0957\\u0962-\\u0963\\u0981\\u09bc\\u09be\\u09c1-\\u09c4\\u09cd\\u09d7\\u09e2-\\u09e3' + '\\u0a01-\\u0a02\\u0a3c\\u0a41-\\u0a42\\u0a47-\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a70-\\u0a71\\u0a75\\u0a81-\\u0a82\\u0abc' + '\\u0ac1-\\u0ac5\\u0ac7-\\u0ac8\\u0acd\\u0ae2-\\u0ae3\\u0b01\\u0b3c\\u0b3e\\u0b3f\\u0b41-\\u0b44\\u0b4d\\u0b56\\u0b57' + '\\u0b62-\\u0b63\\u0b82\\u0bbe\\u0bc0\\u0bcd\\u0bd7\\u0c00\\u0c3e-\\u0c40\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55-\\u0c56' + '\\u0c62-\\u0c63\\u0c81\\u0cbc\\u0cbf\\u0cc2\\u0cc6\\u0ccc-\\u0ccd\\u0cd5-\\u0cd6\\u0ce2-\\u0ce3\\u0d01\\u0d3e\\u0d41-\\u0d44' + '\\u0d4d\\u0d57\\u0d62-\\u0d63\\u0dca\\u0dcf\\u0dd2-\\u0dd4\\u0dd6\\u0ddf\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0eb1\\u0eb4-\\u0eb9' + '\\u0ebb-\\u0ebc\\u0ec8-\\u0ecd\\u0f18-\\u0f19\\u0f35\\u0f37\\u0f39\\u0f71-\\u0f7e\\u0f80-\\u0f84\\u0f86-\\u0f87\\u0f8d-\\u0f97' + '\\u0f99-\\u0fbc\\u0fc6\\u102d-\\u1030\\u1032-\\u1037\\u1039-\\u103a\\u103d-\\u103e\\u1058-\\u1059\\u105e-\\u1060\\u1071-\\u1074' + '\\u1082\\u1085-\\u1086\\u108d\\u109d\\u135d-\\u135f\\u1712-\\u1714\\u1732-\\u1734\\u1752-\\u1753\\u1772-\\u1773\\u17b4-\\u17b5' + '\\u17b7-\\u17bd\\u17c6\\u17c9-\\u17d3\\u17dd\\u180b-\\u180d\\u18a9\\u1920-\\u1922\\u1927-\\u1928\\u1932\\u1939-\\u193b\\u1a17-\\u1a18' + '\\u1a1b\\u1a56\\u1a58-\\u1a5e\\u1a60\\u1a62\\u1a65-\\u1a6c\\u1a73-\\u1a7c\\u1a7f\\u1ab0-\\u1abd\\u1ABE\\u1b00-\\u1b03\\u1b34' + '\\u1b36-\\u1b3a\\u1b3c\\u1b42\\u1b6b-\\u1b73\\u1b80-\\u1b81\\u1ba2-\\u1ba5\\u1ba8-\\u1ba9\\u1bab-\\u1bad\\u1be6\\u1be8-\\u1be9' + '\\u1bed\\u1bef-\\u1bf1\\u1c2c-\\u1c33\\u1c36-\\u1c37\\u1cd0-\\u1cd2\\u1cd4-\\u1ce0\\u1ce2-\\u1ce8\\u1ced\\u1cf4\\u1cf8-\\u1cf9' + '\\u1dc0-\\u1df5\\u1dfc-\\u1dff\\u200c-\\u200d\\u20d0-\\u20dc\\u20DD-\\u20E0\\u20e1\\u20E2-\\u20E4\\u20e5-\\u20f0\\u2cef-\\u2cf1' + '\\u2d7f\\u2de0-\\u2dff\\u302a-\\u302d\\u302e-\\u302f\\u3099-\\u309a\\ua66f\\uA670-\\uA672\\ua674-\\ua67d\\ua69e-\\ua69f\\ua6f0-\\ua6f1' + '\\ua802\\ua806\\ua80b\\ua825-\\ua826\\ua8c4\\ua8e0-\\ua8f1\\ua926-\\ua92d\\ua947-\\ua951\\ua980-\\ua982\\ua9b3\\ua9b6-\\ua9b9\\ua9bc' + '\\ua9e5\\uaa29-\\uaa2e\\uaa31-\\uaa32\\uaa35-\\uaa36\\uaa43\\uaa4c\\uaa7c\\uaab0\\uaab2-\\uaab4\\uaab7-\\uaab8\\uaabe-\\uaabf\\uaac1' + '\\uaaec-\\uaaed\\uaaf6\\uabe5\\uabe8\\uabed\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe2f\\uff9e-\\uff9f]');\n  const isExtendingChar = ch => isString(ch) && ch.charCodeAt(0) >= 768 && extendingChars.test(ch);\n  const or = (...args) => {\n    return x => {\n      for (let i = 0; i < args.length; i++) {\n        if (args[i](x)) {\n          return true;\n        }\n      }\n      return false;\n    };\n  };\n  const and = (...args) => {\n    return x => {\n      for (let i = 0; i < args.length; i++) {\n        if (!args[i](x)) {\n          return false;\n        }\n      }\n      return true;\n    };\n  };\n  const isContentEditableTrue$2 = isContentEditableTrue$3;\n  const isContentEditableFalse$a = isContentEditableFalse$b;\n  const isBr$4 = isBr$6;\n  const isText$8 = isText$b;\n  const isInvalidTextElement = matchNodeNames(['script', 'style', 'textarea']);\n  const isAtomicInline = matchNodeNames(['img', 'input', 'textarea', 'hr', 'iframe', 'video', 'audio', 'object', 'embed']);\n  const isTable = matchNodeNames(['table']);\n  const isCaretContainer$1 = isCaretContainer$2;\n  const isCaretCandidate$3 = node => {\n    if (isCaretContainer$1(node)) {\n      return false;\n    }\n    if (isText$8(node)) {\n      return !isInvalidTextElement(node.parentNode);\n    }\n    return isAtomicInline(node) || isBr$4(node) || isTable(node) || isNonUiContentEditableFalse(node);\n  };\n  const isUnselectable = node => isElement$6(node) && node.getAttribute('unselectable') === 'true';\n  const isNonUiContentEditableFalse = node => !isUnselectable(node) && isContentEditableFalse$a(node);\n  const isInEditable = (node, root) => {\n    for (let tempNode = node.parentNode; tempNode && tempNode !== root; tempNode = tempNode.parentNode) {\n      if (isNonUiContentEditableFalse(tempNode)) {\n        return false;\n      }\n      if (isContentEditableTrue$2(tempNode)) {\n        return true;\n      }\n    }\n    return true;\n  };\n  const isAtomicContentEditableFalse = node => {\n    if (!isNonUiContentEditableFalse(node)) {\n      return false;\n    }\n    return !foldl(from(node.getElementsByTagName('*')), (result, elm) => {\n      return result || isContentEditableTrue$2(elm);\n    }, false);\n  };\n  const isAtomic$1 = node => isAtomicInline(node) || isAtomicContentEditableFalse(node);\n  const isEditableCaretCandidate$1 = (node, root) => isCaretCandidate$3(node) && isInEditable(node, root);\n  const isElement$4 = isElement$6;\n  const isCaretCandidate$2 = isCaretCandidate$3;\n  const isBlock$2 = matchStyleValues('display', 'block table');\n  const isFloated = matchStyleValues('float', 'left right');\n  const isValidElementCaretCandidate = and(isElement$4, isCaretCandidate$2, not(isFloated));\n  const isNotPre = not(matchStyleValues('white-space', 'pre pre-line pre-wrap'));\n  const isText$7 = isText$b;\n  const isBr$3 = isBr$6;\n  const nodeIndex$1 = DOMUtils.nodeIndex;\n  const resolveIndex$1 = getNodeUnsafe;\n  const createRange$1 = doc => doc ? doc.createRange() : DOMUtils.DOM.createRng();\n  const isWhiteSpace$1 = chr => isString(chr) && /[\\r\\n\\t ]/.test(chr);\n  const isRange = rng => !!rng.setStart && !!rng.setEnd;\n  const isHiddenWhiteSpaceRange = range => {\n    const container = range.startContainer;\n    const offset = range.startOffset;\n    if (isWhiteSpace$1(range.toString()) && isNotPre(container.parentNode) && isText$b(container)) {\n      const text = container.data;\n      if (isWhiteSpace$1(text[offset - 1]) || isWhiteSpace$1(text[offset + 1])) {\n        return true;\n      }\n    }\n    return false;\n  };\n  const getBrClientRect = brNode => {\n    const doc = brNode.ownerDocument;\n    const rng = createRange$1(doc);\n    const nbsp$1 = doc.createTextNode(nbsp);\n    const parentNode = brNode.parentNode;\n    parentNode.insertBefore(nbsp$1, brNode);\n    rng.setStart(nbsp$1, 0);\n    rng.setEnd(nbsp$1, 1);\n    const clientRect = clone$1(rng.getBoundingClientRect());\n    parentNode.removeChild(nbsp$1);\n    return clientRect;\n  };\n  const getBoundingClientRectWebKitText = rng => {\n    const sc = rng.startContainer;\n    const ec = rng.endContainer;\n    const so = rng.startOffset;\n    const eo = rng.endOffset;\n    if (sc === ec && isText$b(ec) && so === 0 && eo === 1) {\n      const newRng = rng.cloneRange();\n      newRng.setEndAfter(ec);\n      return getBoundingClientRect$1(newRng);\n    } else {\n      return null;\n    }\n  };\n  const isZeroRect = r => r.left === 0 && r.right === 0 && r.top === 0 && r.bottom === 0;\n  const getBoundingClientRect$1 = item => {\n    var _a;\n    let clientRect;\n    const clientRects = item.getClientRects();\n    if (clientRects.length > 0) {\n      clientRect = clone$1(clientRects[0]);\n    } else {\n      clientRect = clone$1(item.getBoundingClientRect());\n    }\n    if (!isRange(item) && isBr$3(item) && isZeroRect(clientRect)) {\n      return getBrClientRect(item);\n    }\n    if (isZeroRect(clientRect) && isRange(item)) {\n      return (_a = getBoundingClientRectWebKitText(item)) !== null && _a !== void 0 ? _a : clientRect;\n    }\n    return clientRect;\n  };\n  const collapseAndInflateWidth = (clientRect, toStart) => {\n    const newClientRect = collapse(clientRect, toStart);\n    newClientRect.width = 1;\n    newClientRect.right = newClientRect.left + 1;\n    return newClientRect;\n  };\n  const getCaretPositionClientRects = caretPosition => {\n    const clientRects = [];\n    const addUniqueAndValidRect = clientRect => {\n      if (clientRect.height === 0) {\n        return;\n      }\n      if (clientRects.length > 0) {\n        if (isEqual(clientRect, clientRects[clientRects.length - 1])) {\n          return;\n        }\n      }\n      clientRects.push(clientRect);\n    };\n    const addCharacterOffset = (container, offset) => {\n      const range = createRange$1(container.ownerDocument);\n      if (offset < container.data.length) {\n        if (isExtendingChar(container.data[offset])) {\n          return;\n        }\n        if (isExtendingChar(container.data[offset - 1])) {\n          range.setStart(container, offset);\n          range.setEnd(container, offset + 1);\n          if (!isHiddenWhiteSpaceRange(range)) {\n            addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect$1(range), false));\n            return;\n          }\n        }\n      }\n      if (offset > 0) {\n        range.setStart(container, offset - 1);\n        range.setEnd(container, offset);\n        if (!isHiddenWhiteSpaceRange(range)) {\n          addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect$1(range), false));\n        }\n      }\n      if (offset < container.data.length) {\n        range.setStart(container, offset);\n        range.setEnd(container, offset + 1);\n        if (!isHiddenWhiteSpaceRange(range)) {\n          addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect$1(range), true));\n        }\n      }\n    };\n    const container = caretPosition.container();\n    const offset = caretPosition.offset();\n    if (isText$7(container)) {\n      addCharacterOffset(container, offset);\n      return clientRects;\n    }\n    if (isElement$4(container)) {\n      if (caretPosition.isAtEnd()) {\n        const node = resolveIndex$1(container, offset);\n        if (isText$7(node)) {\n          addCharacterOffset(node, node.data.length);\n        }\n        if (isValidElementCaretCandidate(node) && !isBr$3(node)) {\n          addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect$1(node), false));\n        }\n      } else {\n        const node = resolveIndex$1(container, offset);\n        if (isText$7(node)) {\n          addCharacterOffset(node, 0);\n        }\n        if (isValidElementCaretCandidate(node) && caretPosition.isAtEnd()) {\n          addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect$1(node), false));\n          return clientRects;\n        }\n        const beforeNode = resolveIndex$1(caretPosition.container(), caretPosition.offset() - 1);\n        if (isValidElementCaretCandidate(beforeNode) && !isBr$3(beforeNode)) {\n          if (isBlock$2(beforeNode) || isBlock$2(node) || !isValidElementCaretCandidate(node)) {\n            addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect$1(beforeNode), false));\n          }\n        }\n        if (isValidElementCaretCandidate(node)) {\n          addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect$1(node), true));\n        }\n      }\n    }\n    return clientRects;\n  };\n  const CaretPosition = (container, offset, clientRects) => {\n    const isAtStart = () => {\n      if (isText$7(container)) {\n        return offset === 0;\n      }\n      return offset === 0;\n    };\n    const isAtEnd = () => {\n      if (isText$7(container)) {\n        return offset >= container.data.length;\n      }\n      return offset >= container.childNodes.length;\n    };\n    const toRange = () => {\n      const range = createRange$1(container.ownerDocument);\n      range.setStart(container, offset);\n      range.setEnd(container, offset);\n      return range;\n    };\n    const getClientRects = () => {\n      if (!clientRects) {\n        clientRects = getCaretPositionClientRects(CaretPosition(container, offset));\n      }\n      return clientRects;\n    };\n    const isVisible = () => getClientRects().length > 0;\n    const isEqual = caretPosition => caretPosition && container === caretPosition.container() && offset === caretPosition.offset();\n    const getNode = before => resolveIndex$1(container, before ? offset - 1 : offset);\n    return {\n      container: constant(container),\n      offset: constant(offset),\n      toRange,\n      getClientRects,\n      isVisible,\n      isAtStart,\n      isAtEnd,\n      isEqual,\n      getNode\n    };\n  };\n  CaretPosition.fromRangeStart = range => CaretPosition(range.startContainer, range.startOffset);\n  CaretPosition.fromRangeEnd = range => CaretPosition(range.endContainer, range.endOffset);\n  CaretPosition.after = node => CaretPosition(node.parentNode, nodeIndex$1(node) + 1);\n  CaretPosition.before = node => CaretPosition(node.parentNode, nodeIndex$1(node));\n  CaretPosition.isAbove = (pos1, pos2) => lift2(head(pos2.getClientRects()), last$2(pos1.getClientRects()), isAbove$1).getOr(false);\n  CaretPosition.isBelow = (pos1, pos2) => lift2(last$2(pos2.getClientRects()), head(pos1.getClientRects()), isBelow$1).getOr(false);\n  CaretPosition.isAtStart = pos => pos ? pos.isAtStart() : false;\n  CaretPosition.isAtEnd = pos => pos ? pos.isAtEnd() : false;\n  CaretPosition.isTextPosition = pos => pos ? isText$b(pos.container()) : false;\n  CaretPosition.isElementPosition = pos => !CaretPosition.isTextPosition(pos);\n  const trimEmptyTextNode$1 = (dom, node) => {\n    if (isText$b(node) && node.data.length === 0) {\n      dom.remove(node);\n    }\n  };\n  const insertNode = (dom, rng, node) => {\n    rng.insertNode(node);\n    trimEmptyTextNode$1(dom, node.previousSibling);\n    trimEmptyTextNode$1(dom, node.nextSibling);\n  };\n  const insertFragment = (dom, rng, frag) => {\n    const firstChild = Optional.from(frag.firstChild);\n    const lastChild = Optional.from(frag.lastChild);\n    rng.insertNode(frag);\n    firstChild.each(child => trimEmptyTextNode$1(dom, child.previousSibling));\n    lastChild.each(child => trimEmptyTextNode$1(dom, child.nextSibling));\n  };\n  const rangeInsertNode = (dom, rng, node) => {\n    if (isDocumentFragment(node)) {\n      insertFragment(dom, rng, node);\n    } else {\n      insertNode(dom, rng, node);\n    }\n  };\n  const isText$6 = isText$b;\n  const isBogus = isBogus$1;\n  const nodeIndex = DOMUtils.nodeIndex;\n  const normalizedParent = node => {\n    const parentNode = node.parentNode;\n    if (isBogus(parentNode)) {\n      return normalizedParent(parentNode);\n    }\n    return parentNode;\n  };\n  const getChildNodes = node => {\n    if (!node) {\n      return [];\n    }\n    return reduce(node.childNodes, (result, node) => {\n      if (isBogus(node) && node.nodeName !== 'BR') {\n        result = result.concat(getChildNodes(node));\n      } else {\n        result.push(node);\n      }\n      return result;\n    }, []);\n  };\n  const normalizedTextOffset = (node, offset) => {\n    let tempNode = node;\n    while (tempNode = tempNode.previousSibling) {\n      if (!isText$6(tempNode)) {\n        break;\n      }\n      offset += tempNode.data.length;\n    }\n    return offset;\n  };\n  const equal = a => b => a === b;\n  const normalizedNodeIndex = node => {\n    let nodes, index;\n    nodes = getChildNodes(normalizedParent(node));\n    index = findIndex$1(nodes, equal(node), node);\n    nodes = nodes.slice(0, index + 1);\n    const numTextFragments = reduce(nodes, (result, node, i) => {\n      if (isText$6(node) && isText$6(nodes[i - 1])) {\n        result++;\n      }\n      return result;\n    }, 0);\n    nodes = filter$3(nodes, matchNodeNames([node.nodeName]));\n    index = findIndex$1(nodes, equal(node), node);\n    return index - numTextFragments;\n  };\n  const createPathItem = node => {\n    const name = isText$6(node) ? 'text()' : node.nodeName.toLowerCase();\n    return name + '[' + normalizedNodeIndex(node) + ']';\n  };\n  const parentsUntil$1 = (root, node, predicate) => {\n    const parents = [];\n    for (let tempNode = node.parentNode; tempNode && tempNode !== root; tempNode = tempNode.parentNode) {\n      if (predicate && predicate(tempNode)) {\n        break;\n      }\n      parents.push(tempNode);\n    }\n    return parents;\n  };\n  const create$a = (root, caretPosition) => {\n    let path = [];\n    let container = caretPosition.container();\n    let offset = caretPosition.offset();\n    let outputOffset;\n    if (isText$6(container)) {\n      outputOffset = normalizedTextOffset(container, offset);\n    } else {\n      const childNodes = container.childNodes;\n      if (offset >= childNodes.length) {\n        outputOffset = 'after';\n        offset = childNodes.length - 1;\n      } else {\n        outputOffset = 'before';\n      }\n      container = childNodes[offset];\n    }\n    path.push(createPathItem(container));\n    let parents = parentsUntil$1(root, container);\n    parents = filter$3(parents, not(isBogus$1));\n    path = path.concat(map$1(parents, node => {\n      return createPathItem(node);\n    }));\n    return path.reverse().join('/') + ',' + outputOffset;\n  };\n  const resolvePathItem = (node, name, index) => {\n    let nodes = getChildNodes(node);\n    nodes = filter$3(nodes, (node, index) => {\n      return !isText$6(node) || !isText$6(nodes[index - 1]);\n    });\n    nodes = filter$3(nodes, matchNodeNames([name]));\n    return nodes[index];\n  };\n  const findTextPosition = (container, offset) => {\n    let node = container;\n    let targetOffset = 0;\n    while (isText$6(node)) {\n      const dataLen = node.data.length;\n      if (offset >= targetOffset && offset <= targetOffset + dataLen) {\n        container = node;\n        offset = offset - targetOffset;\n        break;\n      }\n      if (!isText$6(node.nextSibling)) {\n        container = node;\n        offset = dataLen;\n        break;\n      }\n      targetOffset += dataLen;\n      node = node.nextSibling;\n    }\n    if (isText$6(container) && offset > container.data.length) {\n      offset = container.data.length;\n    }\n    return CaretPosition(container, offset);\n  };\n  const resolve$1 = (root, path) => {\n    if (!path) {\n      return null;\n    }\n    const parts = path.split(',');\n    const paths = parts[0].split('/');\n    const offset = parts.length > 1 ? parts[1] : 'before';\n    const container = reduce(paths, (result, value) => {\n      const match = /([\\w\\-\\(\\)]+)\\[([0-9]+)\\]/.exec(value);\n      if (!match) {\n        return null;\n      }\n      if (match[1] === 'text()') {\n        match[1] = '#text';\n      }\n      return resolvePathItem(result, match[1], parseInt(match[2], 10));\n    }, root);\n    if (!container) {\n      return null;\n    }\n    if (!isText$6(container) && container.parentNode) {\n      let nodeOffset;\n      if (offset === 'after') {\n        nodeOffset = nodeIndex(container) + 1;\n      } else {\n        nodeOffset = nodeIndex(container);\n      }\n      return CaretPosition(container.parentNode, nodeOffset);\n    }\n    return findTextPosition(container, parseInt(offset, 10));\n  };\n  const isContentEditableFalse$9 = isContentEditableFalse$b;\n  const getNormalizedTextOffset$1 = (trim, container, offset) => {\n    let trimmedOffset = trim(container.data.slice(0, offset)).length;\n    for (let node = container.previousSibling; node && isText$b(node); node = node.previousSibling) {\n      trimmedOffset += trim(node.data).length;\n    }\n    return trimmedOffset;\n  };\n  const getPoint = (dom, trim, normalized, rng, start) => {\n    const container = start ? rng.startContainer : rng.endContainer;\n    let offset = start ? rng.startOffset : rng.endOffset;\n    const point = [];\n    const root = dom.getRoot();\n    if (isText$b(container)) {\n      point.push(normalized ? getNormalizedTextOffset$1(trim, container, offset) : offset);\n    } else {\n      let after = 0;\n      const childNodes = container.childNodes;\n      if (offset >= childNodes.length && childNodes.length) {\n        after = 1;\n        offset = Math.max(0, childNodes.length - 1);\n      }\n      point.push(dom.nodeIndex(childNodes[offset], normalized) + after);\n    }\n    for (let node = container; node && node !== root; node = node.parentNode) {\n      point.push(dom.nodeIndex(node, normalized));\n    }\n    return point;\n  };\n  const getLocation = (trim, selection, normalized, rng) => {\n    const dom = selection.dom;\n    const start = getPoint(dom, trim, normalized, rng, true);\n    const forward = selection.isForward();\n    const fakeCaret = isRangeInCaretContainerBlock(rng) ? {\n      isFakeCaret: true\n    } : {};\n    if (!selection.isCollapsed()) {\n      const end = getPoint(dom, trim, normalized, rng, false);\n      return {\n        start,\n        end,\n        forward,\n        ...fakeCaret\n      };\n    } else {\n      return {\n        start,\n        forward,\n        ...fakeCaret\n      };\n    }\n  };\n  const findIndex = (dom, name, element) => {\n    let count = 0;\n    Tools.each(dom.select(name), node => {\n      if (node.getAttribute('data-mce-bogus') === 'all') {\n        return;\n      } else if (node === element) {\n        return false;\n      } else {\n        count++;\n        return;\n      }\n    });\n    return count;\n  };\n  const moveEndPoint$1 = (rng, start) => {\n    let container = start ? rng.startContainer : rng.endContainer;\n    let offset = start ? rng.startOffset : rng.endOffset;\n    if (isElement$6(container) && container.nodeName === 'TR') {\n      const childNodes = container.childNodes;\n      container = childNodes[Math.min(start ? offset : offset - 1, childNodes.length - 1)];\n      if (container) {\n        offset = start ? 0 : container.childNodes.length;\n        if (start) {\n          rng.setStart(container, offset);\n        } else {\n          rng.setEnd(container, offset);\n        }\n      }\n    }\n  };\n  const normalizeTableCellSelection = rng => {\n    moveEndPoint$1(rng, true);\n    moveEndPoint$1(rng, false);\n    return rng;\n  };\n  const findSibling = (node, offset) => {\n    if (isElement$6(node)) {\n      node = getNode$1(node, offset);\n      if (isContentEditableFalse$9(node)) {\n        return node;\n      }\n    }\n    if (isCaretContainer$2(node)) {\n      if (isText$b(node) && isCaretContainerBlock$1(node)) {\n        node = node.parentNode;\n      }\n      let sibling = node.previousSibling;\n      if (isContentEditableFalse$9(sibling)) {\n        return sibling;\n      }\n      sibling = node.nextSibling;\n      if (isContentEditableFalse$9(sibling)) {\n        return sibling;\n      }\n    }\n    return undefined;\n  };\n  const findAdjacentContentEditableFalseElm = rng => {\n    return findSibling(rng.startContainer, rng.startOffset) || findSibling(rng.endContainer, rng.endOffset);\n  };\n  const getOffsetBookmark = (trim, normalized, selection) => {\n    const element = selection.getNode();\n    const rng = selection.getRng();\n    if (element.nodeName === 'IMG' || isContentEditableFalse$9(element)) {\n      const name = element.nodeName;\n      return {\n        name,\n        index: findIndex(selection.dom, name, element)\n      };\n    }\n    const sibling = findAdjacentContentEditableFalseElm(rng);\n    if (sibling) {\n      const name = sibling.tagName;\n      return {\n        name,\n        index: findIndex(selection.dom, name, sibling)\n      };\n    }\n    return getLocation(trim, selection, normalized, rng);\n  };\n  const getCaretBookmark = selection => {\n    const rng = selection.getRng();\n    return {\n      start: create$a(selection.dom.getRoot(), CaretPosition.fromRangeStart(rng)),\n      end: create$a(selection.dom.getRoot(), CaretPosition.fromRangeEnd(rng)),\n      forward: selection.isForward()\n    };\n  };\n  const getRangeBookmark = selection => {\n    return {\n      rng: selection.getRng(),\n      forward: selection.isForward()\n    };\n  };\n  const createBookmarkSpan = (dom, id, filled) => {\n    const args = {\n      'data-mce-type': 'bookmark',\n      id,\n      'style': 'overflow:hidden;line-height:0px'\n    };\n    return filled ? dom.create('span', args, '&#xFEFF;') : dom.create('span', args);\n  };\n  const getPersistentBookmark = (selection, filled) => {\n    const dom = selection.dom;\n    let rng = selection.getRng();\n    const id = dom.uniqueId();\n    const collapsed = selection.isCollapsed();\n    const element = selection.getNode();\n    const name = element.nodeName;\n    const forward = selection.isForward();\n    if (name === 'IMG') {\n      return {\n        name,\n        index: findIndex(dom, name, element)\n      };\n    }\n    const rng2 = normalizeTableCellSelection(rng.cloneRange());\n    if (!collapsed) {\n      rng2.collapse(false);\n      const endBookmarkNode = createBookmarkSpan(dom, id + '_end', filled);\n      rangeInsertNode(dom, rng2, endBookmarkNode);\n    }\n    rng = normalizeTableCellSelection(rng);\n    rng.collapse(true);\n    const startBookmarkNode = createBookmarkSpan(dom, id + '_start', filled);\n    rangeInsertNode(dom, rng, startBookmarkNode);\n    selection.moveToBookmark({\n      id,\n      keep: true,\n      forward\n    });\n    return {\n      id,\n      forward\n    };\n  };\n  const getBookmark$3 = (selection, type, normalized = false) => {\n    if (type === 2) {\n      return getOffsetBookmark(trim$2, normalized, selection);\n    } else if (type === 3) {\n      return getCaretBookmark(selection);\n    } else if (type) {\n      return getRangeBookmark(selection);\n    } else {\n      return getPersistentBookmark(selection, false);\n    }\n  };\n  const getUndoBookmark = curry(getOffsetBookmark, identity, true);\n  const value$1 = value => {\n    const applyHelper = fn => fn(value);\n    const constHelper = constant(value);\n    const outputHelper = () => output;\n    const output = {\n      tag: true,\n      inner: value,\n      fold: (_onError, onValue) => onValue(value),\n      isValue: always,\n      isError: never,\n      map: mapper => Result.value(mapper(value)),\n      mapError: outputHelper,\n      bind: applyHelper,\n      exists: applyHelper,\n      forall: applyHelper,\n      getOr: constHelper,\n      or: outputHelper,\n      getOrThunk: constHelper,\n      orThunk: outputHelper,\n      getOrDie: constHelper,\n      each: fn => {\n        fn(value);\n      },\n      toOptional: () => Optional.some(value)\n    };\n    return output;\n  };\n  const error = error => {\n    const outputHelper = () => output;\n    const output = {\n      tag: false,\n      inner: error,\n      fold: (onError, _onValue) => onError(error),\n      isValue: never,\n      isError: always,\n      map: outputHelper,\n      mapError: mapper => Result.error(mapper(error)),\n      bind: outputHelper,\n      exists: never,\n      forall: always,\n      getOr: identity,\n      or: identity,\n      getOrThunk: apply$1,\n      orThunk: apply$1,\n      getOrDie: die(String(error)),\n      each: noop,\n      toOptional: Optional.none\n    };\n    return output;\n  };\n  const fromOption = (optional, err) => optional.fold(() => error(err), value$1);\n  const Result = {\n    value: value$1,\n    error,\n    fromOption\n  };\n  const generate = cases => {\n    if (!isArray$1(cases)) {\n      throw new Error('cases must be an array');\n    }\n    if (cases.length === 0) {\n      throw new Error('there must be at least one case');\n    }\n    const constructors = [];\n    const adt = {};\n    each$e(cases, (acase, count) => {\n      const keys$1 = keys(acase);\n      if (keys$1.length !== 1) {\n        throw new Error('one and only one name per case');\n      }\n      const key = keys$1[0];\n      const value = acase[key];\n      if (adt[key] !== undefined) {\n        throw new Error('duplicate key detected:' + key);\n      } else if (key === 'cata') {\n        throw new Error('cannot have a case named cata (sorry)');\n      } else if (!isArray$1(value)) {\n        throw new Error('case arguments must be an array');\n      }\n      constructors.push(key);\n      adt[key] = (...args) => {\n        const argLength = args.length;\n        if (argLength !== value.length) {\n          throw new Error('Wrong number of arguments to case ' + key + '. Expected ' + value.length + ' (' + value + '), got ' + argLength);\n        }\n        const match = branches => {\n          const branchKeys = keys(branches);\n          if (constructors.length !== branchKeys.length) {\n            throw new Error('Wrong number of arguments to match. Expected: ' + constructors.join(',') + '\\nActual: ' + branchKeys.join(','));\n          }\n          const allReqd = forall(constructors, reqKey => {\n            return contains$2(branchKeys, reqKey);\n          });\n          if (!allReqd) {\n            throw new Error('Not all branches were specified when using match. Specified: ' + branchKeys.join(', ') + '\\nRequired: ' + constructors.join(', '));\n          }\n          return branches[key].apply(null, args);\n        };\n        return {\n          fold: (...foldArgs) => {\n            if (foldArgs.length !== cases.length) {\n              throw new Error('Wrong number of arguments to fold. Expected ' + cases.length + ', got ' + foldArgs.length);\n            }\n            const target = foldArgs[count];\n            return target.apply(null, args);\n          },\n          match,\n          log: label => {\n            console.log(label, {\n              constructors,\n              constructor: key,\n              params: args\n            });\n          }\n        };\n      };\n    });\n    return adt;\n  };\n  const Adt = {\n    generate\n  };\n  Adt.generate([{\n    bothErrors: ['error1', 'error2']\n  }, {\n    firstError: ['error1', 'value2']\n  }, {\n    secondError: ['value1', 'error2']\n  }, {\n    bothValues: ['value1', 'value2']\n  }]);\n  const partition$1 = results => {\n    const errors = [];\n    const values = [];\n    each$e(results, result => {\n      result.fold(err => {\n        errors.push(err);\n      }, value => {\n        values.push(value);\n      });\n    });\n    return {\n      errors,\n      values\n    };\n  };\n  const isInlinePattern = pattern => pattern.type === 'inline-command' || pattern.type === 'inline-format';\n  const isBlockPattern = pattern => pattern.type === 'block-command' || pattern.type === 'block-format';\n  const hasBlockTrigger = (pattern, trigger) => (pattern.type === 'block-command' || pattern.type === 'block-format') && pattern.trigger === trigger;\n  const normalizePattern = pattern => {\n    var _a;\n    const err = message => Result.error({\n      message,\n      pattern\n    });\n    const formatOrCmd = (name, onFormat, onCommand) => {\n      if (pattern.format !== undefined) {\n        let formats;\n        if (isArray$1(pattern.format)) {\n          if (!forall(pattern.format, isString)) {\n            return err(name + ' pattern has non-string items in the `format` array');\n          }\n          formats = pattern.format;\n        } else if (isString(pattern.format)) {\n          formats = [pattern.format];\n        } else {\n          return err(name + ' pattern has non-string `format` parameter');\n        }\n        return Result.value(onFormat(formats));\n      } else if (pattern.cmd !== undefined) {\n        if (!isString(pattern.cmd)) {\n          return err(name + ' pattern has non-string `cmd` parameter');\n        }\n        return Result.value(onCommand(pattern.cmd, pattern.value));\n      } else {\n        return err(name + ' pattern is missing both `format` and `cmd` parameters');\n      }\n    };\n    if (!isObject(pattern)) {\n      return err('Raw pattern is not an object');\n    }\n    if (!isString(pattern.start)) {\n      return err('Raw pattern is missing `start` parameter');\n    }\n    if (pattern.end !== undefined) {\n      if (!isString(pattern.end)) {\n        return err('Inline pattern has non-string `end` parameter');\n      }\n      if (pattern.start.length === 0 && pattern.end.length === 0) {\n        return err('Inline pattern has empty `start` and `end` parameters');\n      }\n      let start = pattern.start;\n      let end = pattern.end;\n      if (end.length === 0) {\n        end = start;\n        start = '';\n      }\n      return formatOrCmd('Inline', format => ({\n        type: 'inline-format',\n        start,\n        end,\n        format\n      }), (cmd, value) => ({\n        type: 'inline-command',\n        start,\n        end,\n        cmd,\n        value\n      }));\n    } else if (pattern.replacement !== undefined) {\n      if (!isString(pattern.replacement)) {\n        return err('Replacement pattern has non-string `replacement` parameter');\n      }\n      if (pattern.start.length === 0) {\n        return err('Replacement pattern has empty `start` parameter');\n      }\n      return Result.value({\n        type: 'inline-command',\n        start: '',\n        end: pattern.start,\n        cmd: 'mceInsertContent',\n        value: pattern.replacement\n      });\n    } else {\n      const trigger = (_a = pattern.trigger) !== null && _a !== void 0 ? _a : 'space';\n      if (pattern.start.length === 0) {\n        return err('Block pattern has empty `start` parameter');\n      }\n      return formatOrCmd('Block', formats => ({\n        type: 'block-format',\n        start: pattern.start,\n        format: formats[0],\n        trigger\n      }), (command, commandValue) => ({\n        type: 'block-command',\n        start: pattern.start,\n        cmd: command,\n        value: commandValue,\n        trigger\n      }));\n    }\n  };\n  const getBlockPatterns = patterns => filter$5(patterns, isBlockPattern);\n  const getInlinePatterns = patterns => filter$5(patterns, isInlinePattern);\n  const createPatternSet = (patterns, dynamicPatternsLookup) => ({\n    inlinePatterns: getInlinePatterns(patterns),\n    blockPatterns: getBlockPatterns(patterns),\n    dynamicPatternsLookup\n  });\n  const filterByTrigger = (patterns, trigger) => {\n    return {\n      ...patterns,\n      blockPatterns: filter$5(patterns.blockPatterns, pattern => hasBlockTrigger(pattern, trigger))\n    };\n  };\n  const fromRawPatterns = patterns => {\n    const normalized = partition$1(map$3(patterns, normalizePattern));\n    each$e(normalized.errors, err => console.error(err.message, err.pattern));\n    return normalized.values;\n  };\n  const fromRawPatternsLookup = lookupFn => {\n    return ctx => {\n      const rawPatterns = lookupFn(ctx);\n      return fromRawPatterns(rawPatterns);\n    };\n  };\n  const deviceDetection$1 = detect$1().deviceType;\n  const isTouch = deviceDetection$1.isTouch();\n  const DOM$a = DOMUtils.DOM;\n  const getHash = value => {\n    const items = value.indexOf('=') > 0 ? value.split(/[;,](?![^=;,]*(?:[;,]|$))/) : value.split(',');\n    return foldl(items, (output, item) => {\n      const arr = item.split('=');\n      const key = arr[0];\n      const val = arr.length > 1 ? arr[1] : key;\n      output[trim$4(key)] = trim$4(val);\n      return output;\n    }, {});\n  };\n  const isRegExp = x => is$4(x, RegExp);\n  const option = name => editor => editor.options.get(name);\n  const stringOrObjectProcessor = value => isString(value) || isObject(value);\n  const bodyOptionProcessor = (editor, defaultValue = '') => value => {\n    const valid = isString(value);\n    if (valid) {\n      if (value.indexOf('=') !== -1) {\n        const bodyObj = getHash(value);\n        return {\n          value: get$a(bodyObj, editor.id).getOr(defaultValue),\n          valid\n        };\n      } else {\n        return {\n          value,\n          valid\n        };\n      }\n    } else {\n      return {\n        valid: false,\n        message: 'Must be a string.'\n      };\n    }\n  };\n  const register$7 = editor => {\n    const registerOption = editor.options.register;\n    registerOption('id', {\n      processor: 'string',\n      default: editor.id\n    });\n    registerOption('selector', {\n      processor: 'string'\n    });\n    registerOption('target', {\n      processor: 'object'\n    });\n    registerOption('suffix', {\n      processor: 'string'\n    });\n    registerOption('cache_suffix', {\n      processor: 'string'\n    });\n    registerOption('base_url', {\n      processor: 'string'\n    });\n    registerOption('referrer_policy', {\n      processor: 'string',\n      default: ''\n    });\n    registerOption('language_load', {\n      processor: 'boolean',\n      default: true\n    });\n    registerOption('inline', {\n      processor: 'boolean',\n      default: false\n    });\n    registerOption('iframe_attrs', {\n      processor: 'object',\n      default: {}\n    });\n    registerOption('doctype', {\n      processor: 'string',\n      default: '<!DOCTYPE html>'\n    });\n    registerOption('document_base_url', {\n      processor: 'string',\n      default: editor.documentBaseUrl\n    });\n    registerOption('body_id', {\n      processor: bodyOptionProcessor(editor, 'tinymce'),\n      default: 'tinymce'\n    });\n    registerOption('body_class', {\n      processor: bodyOptionProcessor(editor),\n      default: ''\n    });\n    registerOption('content_security_policy', {\n      processor: 'string',\n      default: ''\n    });\n    registerOption('br_in_pre', {\n      processor: 'boolean',\n      default: true\n    });\n    registerOption('forced_root_block', {\n      processor: value => {\n        const valid = isString(value) && isNotEmpty(value);\n        if (valid) {\n          return {\n            value,\n            valid\n          };\n        } else {\n          return {\n            valid: false,\n            message: 'Must be a non-empty string.'\n          };\n        }\n      },\n      default: 'p'\n    });\n    registerOption('forced_root_block_attrs', {\n      processor: 'object',\n      default: {}\n    });\n    registerOption('newline_behavior', {\n      processor: value => {\n        const valid = contains$2(['block', 'linebreak', 'invert', 'default'], value);\n        return valid ? {\n          value,\n          valid\n        } : {\n          valid: false,\n          message: 'Must be one of: block, linebreak, invert or default.'\n        };\n      },\n      default: 'default'\n    });\n    registerOption('br_newline_selector', {\n      processor: 'string',\n      default: '.mce-toc h2,figcaption,caption'\n    });\n    registerOption('no_newline_selector', {\n      processor: 'string',\n      default: ''\n    });\n    registerOption('keep_styles', {\n      processor: 'boolean',\n      default: true\n    });\n    registerOption('end_container_on_empty_block', {\n      processor: value => {\n        if (isBoolean(value)) {\n          return {\n            valid: true,\n            value\n          };\n        } else if (isString(value)) {\n          return {\n            valid: true,\n            value\n          };\n        } else {\n          return {\n            valid: false,\n            message: 'Must be boolean or a string'\n          };\n        }\n      },\n      default: 'blockquote'\n    });\n    registerOption('font_size_style_values', {\n      processor: 'string',\n      default: 'xx-small,x-small,small,medium,large,x-large,xx-large'\n    });\n    registerOption('font_size_legacy_values', {\n      processor: 'string',\n      default: 'xx-small,small,medium,large,x-large,xx-large,300%'\n    });\n    registerOption('font_size_classes', {\n      processor: 'string',\n      default: ''\n    });\n    registerOption('automatic_uploads', {\n      processor: 'boolean',\n      default: true\n    });\n    registerOption('images_reuse_filename', {\n      processor: 'boolean',\n      default: false\n    });\n    registerOption('images_replace_blob_uris', {\n      processor: 'boolean',\n      default: true\n    });\n    registerOption('icons', {\n      processor: 'string',\n      default: ''\n    });\n    registerOption('icons_url', {\n      processor: 'string',\n      default: ''\n    });\n    registerOption('images_upload_url', {\n      processor: 'string',\n      default: ''\n    });\n    registerOption('images_upload_base_path', {\n      processor: 'string',\n      default: ''\n    });\n    registerOption('images_upload_credentials', {\n      processor: 'boolean',\n      default: false\n    });\n    registerOption('images_upload_handler', {\n      processor: 'function'\n    });\n    registerOption('language', {\n      processor: 'string',\n      default: 'en'\n    });\n    registerOption('language_url', {\n      processor: 'string',\n      default: ''\n    });\n    registerOption('entity_encoding', {\n      processor: 'string',\n      default: 'named'\n    });\n    registerOption('indent', {\n      processor: 'boolean',\n      default: true\n    });\n    registerOption('indent_before', {\n      processor: 'string',\n      default: 'p,h1,h2,h3,h4,h5,h6,blockquote,div,title,style,pre,script,td,th,ul,ol,li,dl,dt,dd,area,table,thead,' + 'tfoot,tbody,tr,section,details,summary,article,hgroup,aside,figure,figcaption,option,optgroup,datalist'\n    });\n    registerOption('indent_after', {\n      processor: 'string',\n      default: 'p,h1,h2,h3,h4,h5,h6,blockquote,div,title,style,pre,script,td,th,ul,ol,li,dl,dt,dd,area,table,thead,' + 'tfoot,tbody,tr,section,details,summary,article,hgroup,aside,figure,figcaption,option,optgroup,datalist'\n    });\n    registerOption('indent_use_margin', {\n      processor: 'boolean',\n      default: false\n    });\n    registerOption('indentation', {\n      processor: 'string',\n      default: '40px'\n    });\n    registerOption('content_css', {\n      processor: value => {\n        const valid = value === false || isString(value) || isArrayOf(value, isString);\n        if (valid) {\n          if (isString(value)) {\n            return {\n              value: map$3(value.split(','), trim$4),\n              valid\n            };\n          } else if (isArray$1(value)) {\n            return {\n              value,\n              valid\n            };\n          } else if (value === false) {\n            return {\n              value: [],\n              valid\n            };\n          } else {\n            return {\n              value,\n              valid\n            };\n          }\n        } else {\n          return {\n            valid: false,\n            message: 'Must be false, a string or an array of strings.'\n          };\n        }\n      },\n      default: isInline$1(editor) ? [] : ['default']\n    });\n    registerOption('content_style', {\n      processor: 'string'\n    });\n    registerOption('content_css_cors', {\n      processor: 'boolean',\n      default: false\n    });\n    registerOption('font_css', {\n      processor: value => {\n        const valid = isString(value) || isArrayOf(value, isString);\n        if (valid) {\n          const newValue = isArray$1(value) ? value : map$3(value.split(','), trim$4);\n          return {\n            value: newValue,\n            valid\n          };\n        } else {\n          return {\n            valid: false,\n            message: 'Must be a string or an array of strings.'\n          };\n        }\n      },\n      default: []\n    });\n    registerOption('inline_boundaries', {\n      processor: 'boolean',\n      default: true\n    });\n    registerOption('inline_boundaries_selector', {\n      processor: 'string',\n      default: 'a[href],code,span.mce-annotation'\n    });\n    registerOption('object_resizing', {\n      processor: value => {\n        const valid = isBoolean(value) || isString(value);\n        if (valid) {\n          if (value === false || deviceDetection$1.isiPhone() || deviceDetection$1.isiPad()) {\n            return {\n              value: '',\n              valid\n            };\n          } else {\n            return {\n              value: value === true ? 'table,img,figure.image,div,video,iframe' : value,\n              valid\n            };\n          }\n        } else {\n          return {\n            valid: false,\n            message: 'Must be boolean or a string'\n          };\n        }\n      },\n      default: !isTouch\n    });\n    registerOption('resize_img_proportional', {\n      processor: 'boolean',\n      default: true\n    });\n    registerOption('event_root', {\n      processor: 'string'\n    });\n    registerOption('service_message', {\n      processor: 'string'\n    });\n    registerOption('theme', {\n      processor: value => value === false || isString(value) || isFunction(value),\n      default: 'silver'\n    });\n    registerOption('theme_url', {\n      processor: 'string'\n    });\n    registerOption('formats', {\n      processor: 'object'\n    });\n    registerOption('format_empty_lines', {\n      processor: 'boolean',\n      default: false\n    });\n    registerOption('format_noneditable_selector', {\n      processor: 'string',\n      default: ''\n    });\n    registerOption('preview_styles', {\n      processor: value => {\n        const valid = value === false || isString(value);\n        if (valid) {\n          return {\n            value: value === false ? '' : value,\n            valid\n          };\n        } else {\n          return {\n            valid: false,\n            message: 'Must be false or a string'\n          };\n        }\n      },\n      default: 'font-family font-size font-weight font-style text-decoration text-transform color background-color border border-radius outline text-shadow'\n    });\n    registerOption('custom_ui_selector', {\n      processor: 'string',\n      default: ''\n    });\n    registerOption('hidden_input', {\n      processor: 'boolean',\n      default: true\n    });\n    registerOption('submit_patch', {\n      processor: 'boolean',\n      default: true\n    });\n    registerOption('encoding', {\n      processor: 'string'\n    });\n    registerOption('add_form_submit_trigger', {\n      processor: 'boolean',\n      default: true\n    });\n    registerOption('add_unload_trigger', {\n      processor: 'boolean',\n      default: true\n    });\n    registerOption('custom_undo_redo_levels', {\n      processor: 'number',\n      default: 0\n    });\n    registerOption('disable_nodechange', {\n      processor: 'boolean',\n      default: false\n    });\n    registerOption('readonly', {\n      processor: 'boolean',\n      default: false\n    });\n    registerOption('editable_root', {\n      processor: 'boolean',\n      default: true\n    });\n    registerOption('plugins', {\n      processor: 'string[]',\n      default: []\n    });\n    registerOption('external_plugins', {\n      processor: 'object'\n    });\n    registerOption('forced_plugins', {\n      processor: 'string[]'\n    });\n    registerOption('model', {\n      processor: 'string',\n      default: editor.hasPlugin('rtc') ? 'plugin' : 'dom'\n    });\n    registerOption('model_url', {\n      processor: 'string'\n    });\n    registerOption('block_unsupported_drop', {\n      processor: 'boolean',\n      default: true\n    });\n    registerOption('visual', {\n      processor: 'boolean',\n      default: true\n    });\n    registerOption('visual_table_class', {\n      processor: 'string',\n      default: 'mce-item-table'\n    });\n    registerOption('visual_anchor_class', {\n      processor: 'string',\n      default: 'mce-item-anchor'\n    });\n    registerOption('iframe_aria_text', {\n      processor: 'string',\n      default: 'Rich Text Area. Press ALT-0 for help.'\n    });\n    registerOption('setup', {\n      processor: 'function'\n    });\n    registerOption('init_instance_callback', {\n      processor: 'function'\n    });\n    registerOption('url_converter', {\n      processor: 'function',\n      default: editor.convertURL\n    });\n    registerOption('url_converter_scope', {\n      processor: 'object',\n      default: editor\n    });\n    registerOption('urlconverter_callback', {\n      processor: 'function'\n    });\n    registerOption('allow_conditional_comments', {\n      processor: 'boolean',\n      default: false\n    });\n    registerOption('allow_html_data_urls', {\n      processor: 'boolean',\n      default: false\n    });\n    registerOption('allow_svg_data_urls', {\n      processor: 'boolean'\n    });\n    registerOption('allow_html_in_named_anchor', {\n      processor: 'boolean',\n      default: false\n    });\n    registerOption('allow_script_urls', {\n      processor: 'boolean',\n      default: false\n    });\n    registerOption('allow_unsafe_link_target', {\n      processor: 'boolean',\n      default: false\n    });\n    registerOption('allow_mathml_annotation_encodings', {\n      processor: value => {\n        const valid = isArrayOf(value, isString);\n        return valid ? {\n          value,\n          valid\n        } : {\n          valid: false,\n          message: 'Must be an array of strings.'\n        };\n      },\n      default: []\n    });\n    registerOption('convert_fonts_to_spans', {\n      processor: 'boolean',\n      default: true,\n      deprecated: true\n    });\n    registerOption('fix_list_elements', {\n      processor: 'boolean',\n      default: false\n    });\n    registerOption('preserve_cdata', {\n      processor: 'boolean',\n      default: false\n    });\n    registerOption('remove_trailing_brs', {\n      processor: 'boolean',\n      default: true\n    });\n    registerOption('pad_empty_with_br', {\n      processor: 'boolean',\n      default: false\n    });\n    registerOption('inline_styles', {\n      processor: 'boolean',\n      default: true,\n      deprecated: true\n    });\n    registerOption('element_format', {\n      processor: 'string',\n      default: 'html'\n    });\n    registerOption('entities', {\n      processor: 'string'\n    });\n    registerOption('schema', {\n      processor: 'string',\n      default: 'html5'\n    });\n    registerOption('convert_urls', {\n      processor: 'boolean',\n      default: true\n    });\n    registerOption('relative_urls', {\n      processor: 'boolean',\n      default: true\n    });\n    registerOption('remove_script_host', {\n      processor: 'boolean',\n      default: true\n    });\n    registerOption('custom_elements', {\n      processor: stringOrObjectProcessor\n    });\n    registerOption('extended_valid_elements', {\n      processor: 'string'\n    });\n    registerOption('invalid_elements', {\n      processor: 'string'\n    });\n    registerOption('invalid_styles', {\n      processor: stringOrObjectProcessor\n    });\n    registerOption('valid_children', {\n      processor: 'string'\n    });\n    registerOption('valid_classes', {\n      processor: stringOrObjectProcessor\n    });\n    registerOption('valid_elements', {\n      processor: 'string'\n    });\n    registerOption('valid_styles', {\n      processor: stringOrObjectProcessor\n    });\n    registerOption('verify_html', {\n      processor: 'boolean',\n      default: true\n    });\n    registerOption('auto_focus', {\n      processor: value => isString(value) || value === true\n    });\n    registerOption('browser_spellcheck', {\n      processor: 'boolean',\n      default: false\n    });\n    registerOption('protect', {\n      processor: 'array'\n    });\n    registerOption('images_file_types', {\n      processor: 'string',\n      default: 'jpeg,jpg,jpe,jfi,jif,jfif,png,gif,bmp,webp'\n    });\n    registerOption('deprecation_warnings', {\n      processor: 'boolean',\n      default: true\n    });\n    registerOption('a11y_advanced_options', {\n      processor: 'boolean',\n      default: false\n    });\n    registerOption('api_key', {\n      processor: 'string'\n    });\n    registerOption('license_key', {\n      processor: 'string'\n    });\n    registerOption('paste_block_drop', {\n      processor: 'boolean',\n      default: false\n    });\n    registerOption('paste_data_images', {\n      processor: 'boolean',\n      default: true\n    });\n    registerOption('paste_preprocess', {\n      processor: 'function'\n    });\n    registerOption('paste_postprocess', {\n      processor: 'function'\n    });\n    registerOption('paste_webkit_styles', {\n      processor: 'string',\n      default: 'none'\n    });\n    registerOption('paste_remove_styles_if_webkit', {\n      processor: 'boolean',\n      default: true\n    });\n    registerOption('paste_merge_formats', {\n      processor: 'boolean',\n      default: true\n    });\n    registerOption('smart_paste', {\n      processor: 'boolean',\n      default: true\n    });\n    registerOption('paste_as_text', {\n      processor: 'boolean',\n      default: false\n    });\n    registerOption('paste_tab_spaces', {\n      processor: 'number',\n      default: 4\n    });\n    registerOption('text_patterns', {\n      processor: value => {\n        if (isArrayOf(value, isObject) || value === false) {\n          const patterns = value === false ? [] : value;\n          return {\n            value: fromRawPatterns(patterns),\n            valid: true\n          };\n        } else {\n          return {\n            valid: false,\n            message: 'Must be an array of objects or false.'\n          };\n        }\n      },\n      default: [{\n        start: '*',\n        end: '*',\n        format: 'italic'\n      }, {\n        start: '**',\n        end: '**',\n        format: 'bold'\n      }, {\n        start: '#',\n        format: 'h1',\n        trigger: 'space'\n      }, {\n        start: '##',\n        format: 'h2',\n        trigger: 'space'\n      }, {\n        start: '###',\n        format: 'h3',\n        trigger: 'space'\n      }, {\n        start: '####',\n        format: 'h4',\n        trigger: 'space'\n      }, {\n        start: '#####',\n        format: 'h5',\n        trigger: 'space'\n      }, {\n        start: '######',\n        format: 'h6',\n        trigger: 'space'\n      }, {\n        start: '1.',\n        cmd: 'InsertOrderedList',\n        trigger: 'space'\n      }, {\n        start: '*',\n        cmd: 'InsertUnorderedList',\n        trigger: 'space'\n      }, {\n        start: '-',\n        cmd: 'InsertUnorderedList',\n        trigger: 'space'\n      }, {\n        start: '>',\n        cmd: 'mceBlockQuote',\n        trigger: 'space'\n      }, {\n        start: '---',\n        cmd: 'InsertHorizontalRule',\n        trigger: 'space'\n      }]\n    });\n    registerOption('text_patterns_lookup', {\n      processor: value => {\n        if (isFunction(value)) {\n          return {\n            value: fromRawPatternsLookup(value),\n            valid: true\n          };\n        } else {\n          return {\n            valid: false,\n            message: 'Must be a single function'\n          };\n        }\n      },\n      default: _ctx => []\n    });\n    registerOption('noneditable_class', {\n      processor: 'string',\n      default: 'mceNonEditable'\n    });\n    registerOption('editable_class', {\n      processor: 'string',\n      default: 'mceEditable'\n    });\n    registerOption('noneditable_regexp', {\n      processor: value => {\n        if (isArrayOf(value, isRegExp)) {\n          return {\n            value,\n            valid: true\n          };\n        } else if (isRegExp(value)) {\n          return {\n            value: [value],\n            valid: true\n          };\n        } else {\n          return {\n            valid: false,\n            message: 'Must be a RegExp or an array of RegExp.'\n          };\n        }\n      },\n      default: []\n    });\n    registerOption('table_tab_navigation', {\n      processor: 'boolean',\n      default: true\n    });\n    registerOption('highlight_on_focus', {\n      processor: 'boolean',\n      default: true\n    });\n    registerOption('xss_sanitization', {\n      processor: 'boolean',\n      default: true\n    });\n    registerOption('details_initial_state', {\n      processor: value => {\n        const valid = contains$2(['inherited', 'collapsed', 'expanded'], value);\n        return valid ? {\n          value,\n          valid\n        } : {\n          valid: false,\n          message: 'Must be one of: inherited, collapsed, or expanded.'\n        };\n      },\n      default: 'inherited'\n    });\n    registerOption('details_serialized_state', {\n      processor: value => {\n        const valid = contains$2(['inherited', 'collapsed', 'expanded'], value);\n        return valid ? {\n          value,\n          valid\n        } : {\n          valid: false,\n          message: 'Must be one of: inherited, collapsed, or expanded.'\n        };\n      },\n      default: 'inherited'\n    });\n    registerOption('init_content_sync', {\n      processor: 'boolean',\n      default: false\n    });\n    registerOption('newdocument_content', {\n      processor: 'string',\n      default: ''\n    });\n    registerOption('sandbox_iframes', {\n      processor: 'boolean',\n      default: true\n    });\n    registerOption('sandbox_iframes_exclusions', {\n      processor: 'string[]',\n      default: ['youtube.com', 'youtu.be', 'vimeo.com', 'player.vimeo.com', 'dailymotion.com', 'embed.music.apple.com', 'open.spotify.com', 'giphy.com', 'dai.ly', 'codepen.io']\n    });\n    registerOption('convert_unsafe_embeds', {\n      processor: 'boolean',\n      default: true\n    });\n    editor.on('ScriptsLoaded', () => {\n      registerOption('directionality', {\n        processor: 'string',\n        default: I18n.isRtl() ? 'rtl' : undefined\n      });\n      registerOption('placeholder', {\n        processor: 'string',\n        default: DOM$a.getAttrib(editor.getElement(), 'placeholder')\n      });\n    });\n  };\n  const getIframeAttrs = option('iframe_attrs');\n  const getDocType = option('doctype');\n  const getDocumentBaseUrl = option('document_base_url');\n  const getBodyId = option('body_id');\n  const getBodyClass = option('body_class');\n  const getContentSecurityPolicy = option('content_security_policy');\n  const shouldPutBrInPre$1 = option('br_in_pre');\n  const getForcedRootBlock = option('forced_root_block');\n  const getForcedRootBlockAttrs = option('forced_root_block_attrs');\n  const getNewlineBehavior = option('newline_behavior');\n  const getBrNewLineSelector = option('br_newline_selector');\n  const getNoNewLineSelector = option('no_newline_selector');\n  const shouldKeepStyles = option('keep_styles');\n  const shouldEndContainerOnEmptyBlock = option('end_container_on_empty_block');\n  const isAutomaticUploadsEnabled = option('automatic_uploads');\n  const shouldReuseFileName = option('images_reuse_filename');\n  const shouldReplaceBlobUris = option('images_replace_blob_uris');\n  const getIconPackName = option('icons');\n  const getIconsUrl = option('icons_url');\n  const getImageUploadUrl = option('images_upload_url');\n  const getImageUploadBasePath = option('images_upload_base_path');\n  const getImagesUploadCredentials = option('images_upload_credentials');\n  const getImagesUploadHandler = option('images_upload_handler');\n  const shouldUseContentCssCors = option('content_css_cors');\n  const getReferrerPolicy = option('referrer_policy');\n  const getLanguageCode = option('language');\n  const getLanguageUrl = option('language_url');\n  const shouldIndentUseMargin = option('indent_use_margin');\n  const getIndentation = option('indentation');\n  const getContentCss = option('content_css');\n  const getContentStyle = option('content_style');\n  const getFontCss = option('font_css');\n  const getDirectionality = option('directionality');\n  const getInlineBoundarySelector = option('inline_boundaries_selector');\n  const getObjectResizing = option('object_resizing');\n  const getResizeImgProportional = option('resize_img_proportional');\n  const getPlaceholder = option('placeholder');\n  const getEventRoot = option('event_root');\n  const getServiceMessage = option('service_message');\n  const getTheme = option('theme');\n  const getThemeUrl = option('theme_url');\n  const getModel = option('model');\n  const getModelUrl = option('model_url');\n  const isInlineBoundariesEnabled = option('inline_boundaries');\n  const getFormats = option('formats');\n  const getPreviewStyles = option('preview_styles');\n  const canFormatEmptyLines = option('format_empty_lines');\n  const getFormatNoneditableSelector = option('format_noneditable_selector');\n  const getCustomUiSelector = option('custom_ui_selector');\n  const isInline$1 = option('inline');\n  const hasHiddenInput = option('hidden_input');\n  const shouldPatchSubmit = option('submit_patch');\n  const shouldAddFormSubmitTrigger = option('add_form_submit_trigger');\n  const shouldAddUnloadTrigger = option('add_unload_trigger');\n  const getCustomUndoRedoLevels = option('custom_undo_redo_levels');\n  const shouldDisableNodeChange = option('disable_nodechange');\n  const isReadOnly$1 = option('readonly');\n  const hasEditableRoot$1 = option('editable_root');\n  const hasContentCssCors = option('content_css_cors');\n  const getPlugins = option('plugins');\n  const getExternalPlugins$1 = option('external_plugins');\n  const shouldBlockUnsupportedDrop = option('block_unsupported_drop');\n  const isVisualAidsEnabled = option('visual');\n  const getVisualAidsTableClass = option('visual_table_class');\n  const getVisualAidsAnchorClass = option('visual_anchor_class');\n  const getIframeAriaText = option('iframe_aria_text');\n  const getSetupCallback = option('setup');\n  const getInitInstanceCallback = option('init_instance_callback');\n  const getUrlConverterCallback = option('urlconverter_callback');\n  const getAutoFocus = option('auto_focus');\n  const shouldBrowserSpellcheck = option('browser_spellcheck');\n  const getProtect = option('protect');\n  const shouldPasteBlockDrop = option('paste_block_drop');\n  const shouldPasteDataImages = option('paste_data_images');\n  const getPastePreProcess = option('paste_preprocess');\n  const getPastePostProcess = option('paste_postprocess');\n  const getNewDocumentContent = option('newdocument_content');\n  const getPasteWebkitStyles = option('paste_webkit_styles');\n  const shouldPasteRemoveWebKitStyles = option('paste_remove_styles_if_webkit');\n  const shouldPasteMergeFormats = option('paste_merge_formats');\n  const isSmartPasteEnabled = option('smart_paste');\n  const isPasteAsTextEnabled = option('paste_as_text');\n  const getPasteTabSpaces = option('paste_tab_spaces');\n  const shouldAllowHtmlDataUrls = option('allow_html_data_urls');\n  const getTextPatterns = option('text_patterns');\n  const getTextPatternsLookup = option('text_patterns_lookup');\n  const getNonEditableClass = option('noneditable_class');\n  const getEditableClass = option('editable_class');\n  const getNonEditableRegExps = option('noneditable_regexp');\n  const shouldPreserveCData = option('preserve_cdata');\n  const shouldHighlightOnFocus = option('highlight_on_focus');\n  const shouldSanitizeXss = option('xss_sanitization');\n  const shouldUseDocumentWrite = option('init_content_sync');\n  const hasTextPatternsLookup = editor => editor.options.isSet('text_patterns_lookup');\n  const getFontStyleValues = editor => Tools.explode(editor.options.get('font_size_style_values'));\n  const getFontSizeClasses = editor => Tools.explode(editor.options.get('font_size_classes'));\n  const isEncodingXml = editor => editor.options.get('encoding') === 'xml';\n  const getAllowedImageFileTypes = editor => Tools.explode(editor.options.get('images_file_types'));\n  const hasTableTabNavigation = option('table_tab_navigation');\n  const getDetailsInitialState = option('details_initial_state');\n  const getDetailsSerializedState = option('details_serialized_state');\n  const shouldSandboxIframes = option('sandbox_iframes');\n  const getSandboxIframesExclusions = editor => editor.options.get('sandbox_iframes_exclusions');\n  const shouldConvertUnsafeEmbeds = option('convert_unsafe_embeds');\n  const getLicenseKey = option('license_key');\n  const getApiKey = option('api_key');\n  const isElement$3 = isElement$6;\n  const isText$5 = isText$b;\n  const removeNode$1 = node => {\n    const parentNode = node.parentNode;\n    if (parentNode) {\n      parentNode.removeChild(node);\n    }\n  };\n  const trimCount = text => {\n    const trimmedText = trim$2(text);\n    return {\n      count: text.length - trimmedText.length,\n      text: trimmedText\n    };\n  };\n  const deleteZwspChars = caretContainer => {\n    let idx;\n    while ((idx = caretContainer.data.lastIndexOf(ZWSP$1)) !== -1) {\n      caretContainer.deleteData(idx, 1);\n    }\n  };\n  const removeUnchanged = (caretContainer, pos) => {\n    remove$2(caretContainer);\n    return pos;\n  };\n  const removeTextAndReposition = (caretContainer, pos) => {\n    const before = trimCount(caretContainer.data.substr(0, pos.offset()));\n    const after = trimCount(caretContainer.data.substr(pos.offset()));\n    const text = before.text + after.text;\n    if (text.length > 0) {\n      deleteZwspChars(caretContainer);\n      return CaretPosition(caretContainer, pos.offset() - before.count);\n    } else {\n      return pos;\n    }\n  };\n  const removeElementAndReposition = (caretContainer, pos) => {\n    const parentNode = pos.container();\n    const newPosition = indexOf$1(from(parentNode.childNodes), caretContainer).map(index => {\n      return index < pos.offset() ? CaretPosition(parentNode, pos.offset() - 1) : pos;\n    }).getOr(pos);\n    remove$2(caretContainer);\n    return newPosition;\n  };\n  const removeTextCaretContainer = (caretContainer, pos) => isText$5(caretContainer) && pos.container() === caretContainer ? removeTextAndReposition(caretContainer, pos) : removeUnchanged(caretContainer, pos);\n  const removeElementCaretContainer = (caretContainer, pos) => pos.container() === caretContainer.parentNode ? removeElementAndReposition(caretContainer, pos) : removeUnchanged(caretContainer, pos);\n  const removeAndReposition = (container, pos) => CaretPosition.isTextPosition(pos) ? removeTextCaretContainer(container, pos) : removeElementCaretContainer(container, pos);\n  const remove$2 = caretContainerNode => {\n    if (isElement$3(caretContainerNode) && isCaretContainer$2(caretContainerNode)) {\n      if (hasContent(caretContainerNode)) {\n        caretContainerNode.removeAttribute('data-mce-caret');\n      } else {\n        removeNode$1(caretContainerNode);\n      }\n    }\n    if (isText$5(caretContainerNode)) {\n      deleteZwspChars(caretContainerNode);\n      if (caretContainerNode.data.length === 0) {\n        removeNode$1(caretContainerNode);\n      }\n    }\n  };\n  const isContentEditableFalse$8 = isContentEditableFalse$b;\n  const isMedia$1 = isMedia$2;\n  const isTableCell$1 = isTableCell$3;\n  const inlineFakeCaretSelector = '*[contentEditable=false],video,audio,embed,object';\n  const getAbsoluteClientRect = (root, element, before) => {\n    const clientRect = collapse(element.getBoundingClientRect(), before);\n    let scrollX;\n    let scrollY;\n    if (root.tagName === 'BODY') {\n      const docElm = root.ownerDocument.documentElement;\n      scrollX = root.scrollLeft || docElm.scrollLeft;\n      scrollY = root.scrollTop || docElm.scrollTop;\n    } else {\n      const rootRect = root.getBoundingClientRect();\n      scrollX = root.scrollLeft - rootRect.left;\n      scrollY = root.scrollTop - rootRect.top;\n    }\n    clientRect.left += scrollX;\n    clientRect.right += scrollX;\n    clientRect.top += scrollY;\n    clientRect.bottom += scrollY;\n    clientRect.width = 1;\n    let margin = element.offsetWidth - element.clientWidth;\n    if (margin > 0) {\n      if (before) {\n        margin *= -1;\n      }\n      clientRect.left += margin;\n      clientRect.right += margin;\n    }\n    return clientRect;\n  };\n  const trimInlineCaretContainers = root => {\n    var _a, _b;\n    const fakeCaretTargetNodes = descendants(SugarElement.fromDom(root), inlineFakeCaretSelector);\n    for (let i = 0; i < fakeCaretTargetNodes.length; i++) {\n      const node = fakeCaretTargetNodes[i].dom;\n      let sibling = node.previousSibling;\n      if (endsWithCaretContainer$1(sibling)) {\n        const data = sibling.data;\n        if (data.length === 1) {\n          (_a = sibling.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(sibling);\n        } else {\n          sibling.deleteData(data.length - 1, 1);\n        }\n      }\n      sibling = node.nextSibling;\n      if (startsWithCaretContainer$1(sibling)) {\n        const data = sibling.data;\n        if (data.length === 1) {\n          (_b = sibling.parentNode) === null || _b === void 0 ? void 0 : _b.removeChild(sibling);\n        } else {\n          sibling.deleteData(0, 1);\n        }\n      }\n    }\n  };\n  const FakeCaret = (editor, root, isBlock, hasFocus) => {\n    const lastVisualCaret = value$2();\n    let cursorInterval;\n    let caretContainerNode;\n    const caretBlock = getForcedRootBlock(editor);\n    const dom = editor.dom;\n    const show = (before, element) => {\n      let rng;\n      hide();\n      if (isTableCell$1(element)) {\n        return null;\n      }\n      if (isBlock(element)) {\n        const caretContainer = insertBlock(caretBlock, element, before);\n        const clientRect = getAbsoluteClientRect(root, element, before);\n        dom.setStyle(caretContainer, 'top', clientRect.top);\n        dom.setStyle(caretContainer, 'caret-color', 'transparent');\n        caretContainerNode = caretContainer;\n        const caret = dom.create('div', {\n          'class': 'mce-visual-caret',\n          'data-mce-bogus': 'all'\n        });\n        dom.setStyles(caret, {\n          ...clientRect\n        });\n        dom.add(root, caret);\n        lastVisualCaret.set({\n          caret,\n          element,\n          before\n        });\n        if (before) {\n          dom.addClass(caret, 'mce-visual-caret-before');\n        }\n        startBlink();\n        rng = element.ownerDocument.createRange();\n        rng.setStart(caretContainer, 0);\n        rng.setEnd(caretContainer, 0);\n      } else {\n        caretContainerNode = insertInline$1(element, before);\n        rng = element.ownerDocument.createRange();\n        if (isInlineFakeCaretTarget(caretContainerNode.nextSibling)) {\n          rng.setStart(caretContainerNode, 0);\n          rng.setEnd(caretContainerNode, 0);\n        } else {\n          rng.setStart(caretContainerNode, 1);\n          rng.setEnd(caretContainerNode, 1);\n        }\n        return rng;\n      }\n      return rng;\n    };\n    const hide = () => {\n      trimInlineCaretContainers(root);\n      if (caretContainerNode) {\n        remove$2(caretContainerNode);\n        caretContainerNode = null;\n      }\n      lastVisualCaret.on(caretState => {\n        dom.remove(caretState.caret);\n        lastVisualCaret.clear();\n      });\n      if (cursorInterval) {\n        clearInterval(cursorInterval);\n        cursorInterval = undefined;\n      }\n    };\n    const startBlink = () => {\n      cursorInterval = setInterval(() => {\n        lastVisualCaret.on(caretState => {\n          if (hasFocus()) {\n            dom.toggleClass(caretState.caret, 'mce-visual-caret-hidden');\n          } else {\n            dom.addClass(caretState.caret, 'mce-visual-caret-hidden');\n          }\n        });\n      }, 500);\n    };\n    const reposition = () => {\n      lastVisualCaret.on(caretState => {\n        const clientRect = getAbsoluteClientRect(root, caretState.element, caretState.before);\n        dom.setStyles(caretState.caret, {\n          ...clientRect\n        });\n      });\n    };\n    const destroy = () => clearInterval(cursorInterval);\n    const getCss = () => '.mce-visual-caret {' + 'position: absolute;' + 'background-color: black;' + 'background-color: currentcolor;' + '}' + '.mce-visual-caret-hidden {' + 'display: none;' + '}' + '*[data-mce-caret] {' + 'position: absolute;' + 'left: -1000px;' + 'right: auto;' + 'top: 0;' + 'margin: 0;' + 'padding: 0;' + '}';\n    return {\n      show,\n      hide,\n      getCss,\n      reposition,\n      destroy\n    };\n  };\n  const isFakeCaretTableBrowser = () => Env.browser.isFirefox();\n  const isInlineFakeCaretTarget = node => isContentEditableFalse$8(node) || isMedia$1(node);\n  const isFakeCaretTarget = node => {\n    const isTarget = isInlineFakeCaretTarget(node) || isTable$2(node) && isFakeCaretTableBrowser();\n    return isTarget && parentElement(SugarElement.fromDom(node)).exists(isEditable$2);\n  };\n  const isContentEditableTrue$1 = isContentEditableTrue$3;\n  const isContentEditableFalse$7 = isContentEditableFalse$b;\n  const isMedia = isMedia$2;\n  const isBlockLike = matchStyleValues('display', 'block table table-cell table-row table-caption list-item');\n  const isCaretContainer = isCaretContainer$2;\n  const isCaretContainerBlock = isCaretContainerBlock$1;\n  const isElement$2 = isElement$6;\n  const isText$4 = isText$b;\n  const isCaretCandidate$1 = isCaretCandidate$3;\n  const isForwards = direction => direction > 0;\n  const isBackwards = direction => direction < 0;\n  const skipCaretContainers = (walk, shallow) => {\n    let node;\n    while (node = walk(shallow)) {\n      if (!isCaretContainerBlock(node)) {\n        return node;\n      }\n    }\n    return null;\n  };\n  const findNode = (node, direction, predicateFn, rootNode, shallow) => {\n    const walker = new DomTreeWalker(node, rootNode);\n    const isCefOrCaretContainer = isContentEditableFalse$7(node) || isCaretContainerBlock(node);\n    let tempNode;\n    if (isBackwards(direction)) {\n      if (isCefOrCaretContainer) {\n        tempNode = skipCaretContainers(walker.prev.bind(walker), true);\n        if (predicateFn(tempNode)) {\n          return tempNode;\n        }\n      }\n      while (tempNode = skipCaretContainers(walker.prev.bind(walker), shallow)) {\n        if (predicateFn(tempNode)) {\n          return tempNode;\n        }\n      }\n    }\n    if (isForwards(direction)) {\n      if (isCefOrCaretContainer) {\n        tempNode = skipCaretContainers(walker.next.bind(walker), true);\n        if (predicateFn(tempNode)) {\n          return tempNode;\n        }\n      }\n      while (tempNode = skipCaretContainers(walker.next.bind(walker), shallow)) {\n        if (predicateFn(tempNode)) {\n          return tempNode;\n        }\n      }\n    }\n    return null;\n  };\n  const getEditingHost = (node, rootNode) => {\n    const isCETrue = node => isContentEditableTrue$1(node.dom);\n    const isRoot = node => node.dom === rootNode;\n    return ancestor$4(SugarElement.fromDom(node), isCETrue, isRoot).map(elm => elm.dom).getOr(rootNode);\n  };\n  const getParentBlock$3 = (node, rootNode) => {\n    while (node && node !== rootNode) {\n      if (isBlockLike(node)) {\n        return node;\n      }\n      node = node.parentNode;\n    }\n    return null;\n  };\n  const isInSameBlock = (caretPosition1, caretPosition2, rootNode) => getParentBlock$3(caretPosition1.container(), rootNode) === getParentBlock$3(caretPosition2.container(), rootNode);\n  const getChildNodeAtRelativeOffset = (relativeOffset, caretPosition) => {\n    if (!caretPosition) {\n      return Optional.none();\n    }\n    const container = caretPosition.container();\n    const offset = caretPosition.offset();\n    if (!isElement$2(container)) {\n      return Optional.none();\n    }\n    return Optional.from(container.childNodes[offset + relativeOffset]);\n  };\n  const beforeAfter = (before, node) => {\n    var _a;\n    const doc = (_a = node.ownerDocument) !== null && _a !== void 0 ? _a : document;\n    const range = doc.createRange();\n    if (before) {\n      range.setStartBefore(node);\n      range.setEndBefore(node);\n    } else {\n      range.setStartAfter(node);\n      range.setEndAfter(node);\n    }\n    return range;\n  };\n  const isNodesInSameBlock = (root, node1, node2) => getParentBlock$3(node1, root) === getParentBlock$3(node2, root);\n  const lean = (left, root, node) => {\n    const siblingName = left ? 'previousSibling' : 'nextSibling';\n    let tempNode = node;\n    while (tempNode && tempNode !== root) {\n      let sibling = tempNode[siblingName];\n      if (sibling && isCaretContainer(sibling)) {\n        sibling = sibling[siblingName];\n      }\n      if (isContentEditableFalse$7(sibling) || isMedia(sibling)) {\n        if (isNodesInSameBlock(root, sibling, tempNode)) {\n          return sibling;\n        }\n        break;\n      }\n      if (isCaretCandidate$1(sibling)) {\n        break;\n      }\n      tempNode = tempNode.parentNode;\n    }\n    return null;\n  };\n  const before$2 = curry(beforeAfter, true);\n  const after$2 = curry(beforeAfter, false);\n  const normalizeRange = (direction, root, range) => {\n    let node;\n    const leanLeft = curry(lean, true, root);\n    const leanRight = curry(lean, false, root);\n    const container = range.startContainer;\n    const offset = range.startOffset;\n    if (isCaretContainerBlock$1(container)) {\n      const block = isText$4(container) ? container.parentNode : container;\n      const location = block.getAttribute('data-mce-caret');\n      if (location === 'before') {\n        node = block.nextSibling;\n        if (isFakeCaretTarget(node)) {\n          return before$2(node);\n        }\n      }\n      if (location === 'after') {\n        node = block.previousSibling;\n        if (isFakeCaretTarget(node)) {\n          return after$2(node);\n        }\n      }\n    }\n    if (!range.collapsed) {\n      return range;\n    }\n    if (isText$b(container)) {\n      if (isCaretContainer(container)) {\n        if (direction === 1) {\n          node = leanRight(container);\n          if (node) {\n            return before$2(node);\n          }\n          node = leanLeft(container);\n          if (node) {\n            return after$2(node);\n          }\n        }\n        if (direction === -1) {\n          node = leanLeft(container);\n          if (node) {\n            return after$2(node);\n          }\n          node = leanRight(container);\n          if (node) {\n            return before$2(node);\n          }\n        }\n        return range;\n      }\n      if (endsWithCaretContainer$1(container) && offset >= container.data.length - 1) {\n        if (direction === 1) {\n          node = leanRight(container);\n          if (node) {\n            return before$2(node);\n          }\n        }\n        return range;\n      }\n      if (startsWithCaretContainer$1(container) && offset <= 1) {\n        if (direction === -1) {\n          node = leanLeft(container);\n          if (node) {\n            return after$2(node);\n          }\n        }\n        return range;\n      }\n      if (offset === container.data.length) {\n        node = leanRight(container);\n        if (node) {\n          return before$2(node);\n        }\n        return range;\n      }\n      if (offset === 0) {\n        node = leanLeft(container);\n        if (node) {\n          return after$2(node);\n        }\n        return range;\n      }\n    }\n    return range;\n  };\n  const getRelativeCefElm = (forward, caretPosition) => getChildNodeAtRelativeOffset(forward ? 0 : -1, caretPosition).filter(isContentEditableFalse$7);\n  const getNormalizedRangeEndPoint = (direction, root, range) => {\n    const normalizedRange = normalizeRange(direction, root, range);\n    return direction === -1 ? CaretPosition.fromRangeStart(normalizedRange) : CaretPosition.fromRangeEnd(normalizedRange);\n  };\n  const getElementFromPosition = pos => Optional.from(pos.getNode()).map(SugarElement.fromDom);\n  const getElementFromPrevPosition = pos => Optional.from(pos.getNode(true)).map(SugarElement.fromDom);\n  const getVisualCaretPosition = (walkFn, caretPosition) => {\n    let pos = caretPosition;\n    while (pos = walkFn(pos)) {\n      if (pos.isVisible()) {\n        return pos;\n      }\n    }\n    return pos;\n  };\n  const isMoveInsideSameBlock = (from, to) => {\n    const inSameBlock = isInSameBlock(from, to);\n    if (!inSameBlock && isBr$6(from.getNode())) {\n      return true;\n    }\n    return inSameBlock;\n  };\n  var HDirection;\n  (function (HDirection) {\n    HDirection[HDirection['Backwards'] = -1] = 'Backwards';\n    HDirection[HDirection['Forwards'] = 1] = 'Forwards';\n  })(HDirection || (HDirection = {}));\n  const isContentEditableFalse$6 = isContentEditableFalse$b;\n  const isText$3 = isText$b;\n  const isElement$1 = isElement$6;\n  const isBr$2 = isBr$6;\n  const isCaretCandidate = isCaretCandidate$3;\n  const isAtomic = isAtomic$1;\n  const isEditableCaretCandidate = isEditableCaretCandidate$1;\n  const getParents$3 = (node, root) => {\n    const parents = [];\n    let tempNode = node;\n    while (tempNode && tempNode !== root) {\n      parents.push(tempNode);\n      tempNode = tempNode.parentNode;\n    }\n    return parents;\n  };\n  const nodeAtIndex = (container, offset) => {\n    if (container.hasChildNodes() && offset < container.childNodes.length) {\n      return container.childNodes[offset];\n    }\n    return null;\n  };\n  const getCaretCandidatePosition = (direction, node) => {\n    if (isForwards(direction)) {\n      if (isCaretCandidate(node.previousSibling) && !isText$3(node.previousSibling)) {\n        return CaretPosition.before(node);\n      }\n      if (isText$3(node)) {\n        return CaretPosition(node, 0);\n      }\n    }\n    if (isBackwards(direction)) {\n      if (isCaretCandidate(node.nextSibling) && !isText$3(node.nextSibling)) {\n        return CaretPosition.after(node);\n      }\n      if (isText$3(node)) {\n        return CaretPosition(node, node.data.length);\n      }\n    }\n    if (isBackwards(direction)) {\n      if (isBr$2(node)) {\n        return CaretPosition.before(node);\n      }\n      return CaretPosition.after(node);\n    }\n    return CaretPosition.before(node);\n  };\n  const moveForwardFromBr = (root, nextNode) => {\n    const nextSibling = nextNode.nextSibling;\n    if (nextSibling && isCaretCandidate(nextSibling)) {\n      if (isText$3(nextSibling)) {\n        return CaretPosition(nextSibling, 0);\n      } else {\n        return CaretPosition.before(nextSibling);\n      }\n    } else {\n      return findCaretPosition$1(HDirection.Forwards, CaretPosition.after(nextNode), root);\n    }\n  };\n  const findCaretPosition$1 = (direction, startPos, root) => {\n    let node;\n    let nextNode;\n    let innerNode;\n    let caretPosition;\n    if (!isElement$1(root) || !startPos) {\n      return null;\n    }\n    if (startPos.isEqual(CaretPosition.after(root)) && root.lastChild) {\n      caretPosition = CaretPosition.after(root.lastChild);\n      if (isBackwards(direction) && isCaretCandidate(root.lastChild) && isElement$1(root.lastChild)) {\n        return isBr$2(root.lastChild) ? CaretPosition.before(root.lastChild) : caretPosition;\n      }\n    } else {\n      caretPosition = startPos;\n    }\n    const container = caretPosition.container();\n    let offset = caretPosition.offset();\n    if (isText$3(container)) {\n      if (isBackwards(direction) && offset > 0) {\n        return CaretPosition(container, --offset);\n      }\n      if (isForwards(direction) && offset < container.length) {\n        return CaretPosition(container, ++offset);\n      }\n      node = container;\n    } else {\n      if (isBackwards(direction) && offset > 0) {\n        nextNode = nodeAtIndex(container, offset - 1);\n        if (isCaretCandidate(nextNode)) {\n          if (!isAtomic(nextNode)) {\n            innerNode = findNode(nextNode, direction, isEditableCaretCandidate, nextNode);\n            if (innerNode) {\n              if (isText$3(innerNode)) {\n                return CaretPosition(innerNode, innerNode.data.length);\n              }\n              return CaretPosition.after(innerNode);\n            }\n          }\n          if (isText$3(nextNode)) {\n            return CaretPosition(nextNode, nextNode.data.length);\n          }\n          return CaretPosition.before(nextNode);\n        }\n      }\n      if (isForwards(direction) && offset < container.childNodes.length) {\n        nextNode = nodeAtIndex(container, offset);\n        if (isCaretCandidate(nextNode)) {\n          if (isBr$2(nextNode)) {\n            return moveForwardFromBr(root, nextNode);\n          }\n          if (!isAtomic(nextNode)) {\n            innerNode = findNode(nextNode, direction, isEditableCaretCandidate, nextNode);\n            if (innerNode) {\n              if (isText$3(innerNode)) {\n                return CaretPosition(innerNode, 0);\n              }\n              return CaretPosition.before(innerNode);\n            }\n          }\n          if (isText$3(nextNode)) {\n            return CaretPosition(nextNode, 0);\n          }\n          return CaretPosition.after(nextNode);\n        }\n      }\n      node = nextNode ? nextNode : caretPosition.getNode();\n    }\n    if (node && (isForwards(direction) && caretPosition.isAtEnd() || isBackwards(direction) && caretPosition.isAtStart())) {\n      node = findNode(node, direction, always, root, true);\n      if (isEditableCaretCandidate(node, root)) {\n        return getCaretCandidatePosition(direction, node);\n      }\n    }\n    nextNode = node ? findNode(node, direction, isEditableCaretCandidate, root) : node;\n    const rootContentEditableFalseElm = last$1(filter$5(getParents$3(container, root), isContentEditableFalse$6));\n    if (rootContentEditableFalseElm && (!nextNode || !rootContentEditableFalseElm.contains(nextNode))) {\n      if (isForwards(direction)) {\n        caretPosition = CaretPosition.after(rootContentEditableFalseElm);\n      } else {\n        caretPosition = CaretPosition.before(rootContentEditableFalseElm);\n      }\n      return caretPosition;\n    }\n    if (nextNode) {\n      return getCaretCandidatePosition(direction, nextNode);\n    }\n    return null;\n  };\n  const CaretWalker = root => ({\n    next: caretPosition => {\n      return findCaretPosition$1(HDirection.Forwards, caretPosition, root);\n    },\n    prev: caretPosition => {\n      return findCaretPosition$1(HDirection.Backwards, caretPosition, root);\n    }\n  });\n  const walkToPositionIn = (forward, root, start) => {\n    const position = forward ? CaretPosition.before(start) : CaretPosition.after(start);\n    return fromPosition(forward, root, position);\n  };\n  const afterElement = node => isBr$6(node) ? CaretPosition.before(node) : CaretPosition.after(node);\n  const isBeforeOrStart = position => {\n    if (CaretPosition.isTextPosition(position)) {\n      return position.offset() === 0;\n    } else {\n      return isCaretCandidate$3(position.getNode());\n    }\n  };\n  const isAfterOrEnd = position => {\n    if (CaretPosition.isTextPosition(position)) {\n      const container = position.container();\n      return position.offset() === container.data.length;\n    } else {\n      return isCaretCandidate$3(position.getNode(true));\n    }\n  };\n  const isBeforeAfterSameElement = (from, to) => !CaretPosition.isTextPosition(from) && !CaretPosition.isTextPosition(to) && from.getNode() === to.getNode(true);\n  const isAtBr = position => !CaretPosition.isTextPosition(position) && isBr$6(position.getNode());\n  const shouldSkipPosition = (forward, from, to) => {\n    if (forward) {\n      return !isBeforeAfterSameElement(from, to) && !isAtBr(from) && isAfterOrEnd(from) && isBeforeOrStart(to);\n    } else {\n      return !isBeforeAfterSameElement(to, from) && isBeforeOrStart(from) && isAfterOrEnd(to);\n    }\n  };\n  const fromPosition = (forward, root, pos) => {\n    const walker = CaretWalker(root);\n    return Optional.from(forward ? walker.next(pos) : walker.prev(pos));\n  };\n  const navigate = (forward, root, from) => fromPosition(forward, root, from).bind(to => {\n    if (isInSameBlock(from, to, root) && shouldSkipPosition(forward, from, to)) {\n      return fromPosition(forward, root, to);\n    } else {\n      return Optional.some(to);\n    }\n  });\n  const navigateIgnore = (forward, root, from, ignoreFilter) => navigate(forward, root, from).bind(pos => ignoreFilter(pos) ? navigateIgnore(forward, root, pos, ignoreFilter) : Optional.some(pos));\n  const positionIn = (forward, element) => {\n    const startNode = forward ? element.firstChild : element.lastChild;\n    if (isText$b(startNode)) {\n      return Optional.some(CaretPosition(startNode, forward ? 0 : startNode.data.length));\n    } else if (startNode) {\n      if (isCaretCandidate$3(startNode)) {\n        return Optional.some(forward ? CaretPosition.before(startNode) : afterElement(startNode));\n      } else {\n        return walkToPositionIn(forward, element, startNode);\n      }\n    } else {\n      return Optional.none();\n    }\n  };\n  const nextPosition = curry(fromPosition, true);\n  const prevPosition = curry(fromPosition, false);\n  const firstPositionIn = curry(positionIn, true);\n  const lastPositionIn = curry(positionIn, false);\n  const CARET_ID = '_mce_caret';\n  const isCaretNode = node => isElement$6(node) && node.id === CARET_ID;\n  const getParentCaretContainer = (body, node) => {\n    let currentNode = node;\n    while (currentNode && currentNode !== body) {\n      if (isCaretNode(currentNode)) {\n        return currentNode;\n      }\n      currentNode = currentNode.parentNode;\n    }\n    return null;\n  };\n  const isStringPathBookmark = bookmark => isString(bookmark.start);\n  const isRangeBookmark = bookmark => has$2(bookmark, 'rng');\n  const isIdBookmark = bookmark => has$2(bookmark, 'id');\n  const isIndexBookmark = bookmark => has$2(bookmark, 'name');\n  const isPathBookmark = bookmark => Tools.isArray(bookmark.start);\n  const isForwardBookmark = bookmark => !isIndexBookmark(bookmark) && isBoolean(bookmark.forward) ? bookmark.forward : true;\n  const addBogus = (dom, node) => {\n    if (isElement$6(node) && dom.isBlock(node) && !node.innerHTML) {\n      node.innerHTML = '<br data-mce-bogus=\"1\" />';\n    }\n    return node;\n  };\n  const resolveCaretPositionBookmark = (dom, bookmark) => {\n    const startPos = Optional.from(resolve$1(dom.getRoot(), bookmark.start));\n    const endPos = Optional.from(resolve$1(dom.getRoot(), bookmark.end));\n    return lift2(startPos, endPos, (start, end) => {\n      const range = dom.createRng();\n      range.setStart(start.container(), start.offset());\n      range.setEnd(end.container(), end.offset());\n      return {\n        range,\n        forward: isForwardBookmark(bookmark)\n      };\n    });\n  };\n  const insertZwsp = (node, rng) => {\n    var _a;\n    const doc = (_a = node.ownerDocument) !== null && _a !== void 0 ? _a : document;\n    const textNode = doc.createTextNode(ZWSP$1);\n    node.appendChild(textNode);\n    rng.setStart(textNode, 0);\n    rng.setEnd(textNode, 0);\n  };\n  const isEmpty$1 = node => !node.hasChildNodes();\n  const tryFindRangePosition = (node, rng) => lastPositionIn(node).fold(never, pos => {\n    rng.setStart(pos.container(), pos.offset());\n    rng.setEnd(pos.container(), pos.offset());\n    return true;\n  });\n  const padEmptyCaretContainer = (root, node, rng) => {\n    if (isEmpty$1(node) && getParentCaretContainer(root, node)) {\n      insertZwsp(node, rng);\n      return true;\n    } else {\n      return false;\n    }\n  };\n  const setEndPoint = (dom, start, bookmark, rng) => {\n    const point = bookmark[start ? 'start' : 'end'];\n    const root = dom.getRoot();\n    if (point) {\n      let node = root;\n      let offset = point[0];\n      for (let i = point.length - 1; node && i >= 1; i--) {\n        const children = node.childNodes;\n        if (padEmptyCaretContainer(root, node, rng)) {\n          return true;\n        }\n        if (point[i] > children.length - 1) {\n          if (padEmptyCaretContainer(root, node, rng)) {\n            return true;\n          }\n          return tryFindRangePosition(node, rng);\n        }\n        node = children[point[i]];\n      }\n      if (isText$b(node)) {\n        offset = Math.min(point[0], node.data.length);\n      }\n      if (isElement$6(node)) {\n        offset = Math.min(point[0], node.childNodes.length);\n      }\n      if (start) {\n        rng.setStart(node, offset);\n      } else {\n        rng.setEnd(node, offset);\n      }\n    }\n    return true;\n  };\n  const isValidTextNode = node => isText$b(node) && node.data.length > 0;\n  const restoreEndPoint = (dom, suffix, bookmark) => {\n    const marker = dom.get(bookmark.id + '_' + suffix);\n    const markerParent = marker === null || marker === void 0 ? void 0 : marker.parentNode;\n    const keep = bookmark.keep;\n    if (marker && markerParent) {\n      let container;\n      let offset;\n      if (suffix === 'start') {\n        if (!keep) {\n          container = markerParent;\n          offset = dom.nodeIndex(marker);\n        } else {\n          if (marker.hasChildNodes()) {\n            container = marker.firstChild;\n            offset = 1;\n          } else if (isValidTextNode(marker.nextSibling)) {\n            container = marker.nextSibling;\n            offset = 0;\n          } else if (isValidTextNode(marker.previousSibling)) {\n            container = marker.previousSibling;\n            offset = marker.previousSibling.data.length;\n          } else {\n            container = markerParent;\n            offset = dom.nodeIndex(marker) + 1;\n          }\n        }\n      } else {\n        if (!keep) {\n          container = markerParent;\n          offset = dom.nodeIndex(marker);\n        } else {\n          if (marker.hasChildNodes()) {\n            container = marker.firstChild;\n            offset = 1;\n          } else if (isValidTextNode(marker.previousSibling)) {\n            container = marker.previousSibling;\n            offset = marker.previousSibling.data.length;\n          } else {\n            container = markerParent;\n            offset = dom.nodeIndex(marker);\n          }\n        }\n      }\n      if (!keep) {\n        const prev = marker.previousSibling;\n        const next = marker.nextSibling;\n        Tools.each(Tools.grep(marker.childNodes), node => {\n          if (isText$b(node)) {\n            node.data = node.data.replace(/\\uFEFF/g, '');\n          }\n        });\n        let otherMarker;\n        while (otherMarker = dom.get(bookmark.id + '_' + suffix)) {\n          dom.remove(otherMarker, true);\n        }\n        if (isText$b(next) && isText$b(prev) && !Env.browser.isOpera()) {\n          const idx = prev.data.length;\n          prev.appendData(next.data);\n          dom.remove(next);\n          container = prev;\n          offset = idx;\n        }\n      }\n      return Optional.some(CaretPosition(container, offset));\n    } else {\n      return Optional.none();\n    }\n  };\n  const resolvePaths = (dom, bookmark) => {\n    const range = dom.createRng();\n    if (setEndPoint(dom, true, bookmark, range) && setEndPoint(dom, false, bookmark, range)) {\n      return Optional.some({\n        range,\n        forward: isForwardBookmark(bookmark)\n      });\n    } else {\n      return Optional.none();\n    }\n  };\n  const resolveId = (dom, bookmark) => {\n    const startPos = restoreEndPoint(dom, 'start', bookmark);\n    const endPos = restoreEndPoint(dom, 'end', bookmark);\n    return lift2(startPos, endPos.or(startPos), (spos, epos) => {\n      const range = dom.createRng();\n      range.setStart(addBogus(dom, spos.container()), spos.offset());\n      range.setEnd(addBogus(dom, epos.container()), epos.offset());\n      return {\n        range,\n        forward: isForwardBookmark(bookmark)\n      };\n    });\n  };\n  const resolveIndex = (dom, bookmark) => Optional.from(dom.select(bookmark.name)[bookmark.index]).map(elm => {\n    const range = dom.createRng();\n    range.selectNode(elm);\n    return {\n      range,\n      forward: true\n    };\n  });\n  const resolve = (selection, bookmark) => {\n    const dom = selection.dom;\n    if (bookmark) {\n      if (isPathBookmark(bookmark)) {\n        return resolvePaths(dom, bookmark);\n      } else if (isStringPathBookmark(bookmark)) {\n        return resolveCaretPositionBookmark(dom, bookmark);\n      } else if (isIdBookmark(bookmark)) {\n        return resolveId(dom, bookmark);\n      } else if (isIndexBookmark(bookmark)) {\n        return resolveIndex(dom, bookmark);\n      } else if (isRangeBookmark(bookmark)) {\n        return Optional.some({\n          range: bookmark.rng,\n          forward: isForwardBookmark(bookmark)\n        });\n      }\n    }\n    return Optional.none();\n  };\n  const getBookmark$2 = (selection, type, normalized) => {\n    return getBookmark$3(selection, type, normalized);\n  };\n  const moveToBookmark = (selection, bookmark) => {\n    resolve(selection, bookmark).each(({\n      range,\n      forward\n    }) => {\n      selection.setRng(range, forward);\n    });\n  };\n  const isBookmarkNode$1 = node => {\n    return isElement$6(node) && node.tagName === 'SPAN' && node.getAttribute('data-mce-type') === 'bookmark';\n  };\n  const is = expected => actual => expected === actual;\n  const isNbsp = is(nbsp);\n  const isWhiteSpace = chr => chr !== '' && ' \\f\\n\\r\\t\\x0B'.indexOf(chr) !== -1;\n  const isContent = chr => !isWhiteSpace(chr) && !isNbsp(chr) && !isZwsp$2(chr);\n  const getRanges$1 = selection => {\n    const ranges = [];\n    if (selection) {\n      for (let i = 0; i < selection.rangeCount; i++) {\n        ranges.push(selection.getRangeAt(i));\n      }\n    }\n    return ranges;\n  };\n  const getSelectedNodes = ranges => {\n    return bind$3(ranges, range => {\n      const node = getSelectedNode(range);\n      return node ? [SugarElement.fromDom(node)] : [];\n    });\n  };\n  const hasMultipleRanges = selection => {\n    return getRanges$1(selection).length > 1;\n  };\n  const getCellsFromRanges = ranges => filter$5(getSelectedNodes(ranges), isTableCell$2);\n  const getCellsFromElement = elm => descendants(elm, 'td[data-mce-selected],th[data-mce-selected]');\n  const getCellsFromElementOrRanges = (ranges, element) => {\n    const selectedCells = getCellsFromElement(element);\n    return selectedCells.length > 0 ? selectedCells : getCellsFromRanges(ranges);\n  };\n  const getCellsFromEditor = editor => getCellsFromElementOrRanges(getRanges$1(editor.selection.getSel()), SugarElement.fromDom(editor.getBody()));\n  const getClosestTable = (cell, isRoot) => ancestor$3(cell, 'table', isRoot);\n  const getStartNode = rng => {\n    const sc = rng.startContainer,\n      so = rng.startOffset;\n    if (isText$b(sc)) {\n      return so === 0 ? Optional.some(SugarElement.fromDom(sc)) : Optional.none();\n    } else {\n      return Optional.from(sc.childNodes[so]).map(SugarElement.fromDom);\n    }\n  };\n  const getEndNode = rng => {\n    const ec = rng.endContainer,\n      eo = rng.endOffset;\n    if (isText$b(ec)) {\n      return eo === ec.data.length ? Optional.some(SugarElement.fromDom(ec)) : Optional.none();\n    } else {\n      return Optional.from(ec.childNodes[eo - 1]).map(SugarElement.fromDom);\n    }\n  };\n  const getFirstChildren = node => {\n    return firstChild(node).fold(constant([node]), child => {\n      return [node].concat(getFirstChildren(child));\n    });\n  };\n  const getLastChildren = node => {\n    return lastChild(node).fold(constant([node]), child => {\n      if (name(child) === 'br') {\n        return prevSibling(child).map(sibling => {\n          return [node].concat(getLastChildren(sibling));\n        }).getOr([]);\n      } else {\n        return [node].concat(getLastChildren(child));\n      }\n    });\n  };\n  const hasAllContentsSelected = (elm, rng) => {\n    return lift2(getStartNode(rng), getEndNode(rng), (startNode, endNode) => {\n      const start = find$2(getFirstChildren(elm), curry(eq, startNode));\n      const end = find$2(getLastChildren(elm), curry(eq, endNode));\n      return start.isSome() && end.isSome();\n    }).getOr(false);\n  };\n  const moveEndPoint = (dom, rng, node, start) => {\n    const root = node;\n    const walker = new DomTreeWalker(node, root);\n    const moveCaretBeforeOnEnterElementsMap = filter$4(dom.schema.getMoveCaretBeforeOnEnterElements(), (_, name) => !contains$2(['td', 'th', 'table'], name.toLowerCase()));\n    let currentNode = node;\n    do {\n      if (isText$b(currentNode) && Tools.trim(currentNode.data).length !== 0) {\n        if (start) {\n          rng.setStart(currentNode, 0);\n        } else {\n          rng.setEnd(currentNode, currentNode.data.length);\n        }\n        return;\n      }\n      if (moveCaretBeforeOnEnterElementsMap[currentNode.nodeName]) {\n        if (start) {\n          rng.setStartBefore(currentNode);\n        } else {\n          if (currentNode.nodeName === 'BR') {\n            rng.setEndBefore(currentNode);\n          } else {\n            rng.setEndAfter(currentNode);\n          }\n        }\n        return;\n      }\n    } while (currentNode = start ? walker.next() : walker.prev());\n    if (root.nodeName === 'BODY') {\n      if (start) {\n        rng.setStart(root, 0);\n      } else {\n        rng.setEnd(root, root.childNodes.length);\n      }\n    }\n  };\n  const hasAnyRanges = editor => {\n    const sel = editor.selection.getSel();\n    return isNonNullable(sel) && sel.rangeCount > 0;\n  };\n  const runOnRanges = (editor, executor) => {\n    const fakeSelectionNodes = getCellsFromEditor(editor);\n    if (fakeSelectionNodes.length > 0) {\n      each$e(fakeSelectionNodes, elem => {\n        const node = elem.dom;\n        const fakeNodeRng = editor.dom.createRng();\n        fakeNodeRng.setStartBefore(node);\n        fakeNodeRng.setEndAfter(node);\n        executor(fakeNodeRng, true);\n      });\n    } else {\n      executor(editor.selection.getRng(), false);\n    }\n  };\n  const preserve = (selection, fillBookmark, executor) => {\n    const bookmark = getPersistentBookmark(selection, fillBookmark);\n    executor(bookmark);\n    selection.moveToBookmark(bookmark);\n  };\n  const isNode = node => isNumber(node === null || node === void 0 ? void 0 : node.nodeType);\n  const isElementNode$1 = node => isElement$6(node) && !isBookmarkNode$1(node) && !isCaretNode(node) && !isBogus$1(node);\n  const isElementDirectlySelected = (dom, node) => {\n    if (isElementNode$1(node) && !/^(TD|TH)$/.test(node.nodeName)) {\n      const selectedAttr = dom.getAttrib(node, 'data-mce-selected');\n      const value = parseInt(selectedAttr, 10);\n      return !isNaN(value) && value > 0;\n    } else {\n      return false;\n    }\n  };\n  const preserveSelection = (editor, action, shouldMoveStart) => {\n    const {\n      selection,\n      dom\n    } = editor;\n    const selectedNodeBeforeAction = selection.getNode();\n    const isSelectedBeforeNodeNoneditable = isContentEditableFalse$b(selectedNodeBeforeAction);\n    preserve(selection, true, () => {\n      action();\n    });\n    const isBeforeNodeStillNoneditable = isSelectedBeforeNodeNoneditable && isContentEditableFalse$b(selectedNodeBeforeAction);\n    if (isBeforeNodeStillNoneditable && dom.isChildOf(selectedNodeBeforeAction, editor.getBody())) {\n      editor.selection.select(selectedNodeBeforeAction);\n    } else if (shouldMoveStart(selection.getStart())) {\n      moveStartToNearestText(dom, selection);\n    }\n  };\n  const moveStartToNearestText = (dom, selection) => {\n    var _a, _b;\n    const rng = selection.getRng();\n    const {\n      startContainer,\n      startOffset\n    } = rng;\n    const selectedNode = selection.getNode();\n    if (isElementDirectlySelected(dom, selectedNode)) {\n      return;\n    }\n    if (isElement$6(startContainer)) {\n      const nodes = startContainer.childNodes;\n      const root = dom.getRoot();\n      let walker;\n      if (startOffset < nodes.length) {\n        const startNode = nodes[startOffset];\n        walker = new DomTreeWalker(startNode, (_a = dom.getParent(startNode, dom.isBlock)) !== null && _a !== void 0 ? _a : root);\n      } else {\n        const startNode = nodes[nodes.length - 1];\n        walker = new DomTreeWalker(startNode, (_b = dom.getParent(startNode, dom.isBlock)) !== null && _b !== void 0 ? _b : root);\n        walker.next(true);\n      }\n      for (let node = walker.current(); node; node = walker.next()) {\n        if (dom.getContentEditable(node) === 'false') {\n          return;\n        } else if (isText$b(node) && !isWhiteSpaceNode$1(node)) {\n          rng.setStart(node, 0);\n          selection.setRng(rng);\n          return;\n        }\n      }\n    }\n  };\n  const getNonWhiteSpaceSibling = (node, next, inc) => {\n    if (node) {\n      const nextName = next ? 'nextSibling' : 'previousSibling';\n      for (node = inc ? node : node[nextName]; node; node = node[nextName]) {\n        if (isElement$6(node) || !isWhiteSpaceNode$1(node)) {\n          return node;\n        }\n      }\n    }\n    return undefined;\n  };\n  const isTextBlock$1 = (schema, node) => !!schema.getTextBlockElements()[node.nodeName.toLowerCase()] || isTransparentBlock(schema, node);\n  const isValid = (ed, parent, child) => {\n    return ed.schema.isValidChild(parent, child);\n  };\n  const isWhiteSpaceNode$1 = (node, allowSpaces = false) => {\n    if (isNonNullable(node) && isText$b(node)) {\n      const data = allowSpaces ? node.data.replace(/ /g, '\\xA0') : node.data;\n      return isWhitespaceText(data);\n    } else {\n      return false;\n    }\n  };\n  const isEmptyTextNode$1 = node => {\n    return isNonNullable(node) && isText$b(node) && node.length === 0;\n  };\n  const isWrapNoneditableTarget = (editor, node) => {\n    const baseDataSelector = '[data-mce-cef-wrappable]';\n    const formatNoneditableSelector = getFormatNoneditableSelector(editor);\n    const selector = isEmpty$3(formatNoneditableSelector) ? baseDataSelector : `${baseDataSelector},${formatNoneditableSelector}`;\n    return is$1(SugarElement.fromDom(node), selector);\n  };\n  const isWrappableNoneditable = (editor, node) => {\n    const dom = editor.dom;\n    return isElementNode$1(node) && dom.getContentEditable(node) === 'false' && isWrapNoneditableTarget(editor, node) && dom.select('[contenteditable=\"true\"]', node).length === 0;\n  };\n  const replaceVars = (value, vars) => {\n    if (isFunction(value)) {\n      return value(vars);\n    } else if (isNonNullable(vars)) {\n      value = value.replace(/%(\\w+)/g, (str, name) => {\n        return vars[name] || str;\n      });\n    }\n    return value;\n  };\n  const isEq$5 = (str1, str2) => {\n    str1 = str1 || '';\n    str2 = str2 || '';\n    str1 = '' + (str1.nodeName || str1);\n    str2 = '' + (str2.nodeName || str2);\n    return str1.toLowerCase() === str2.toLowerCase();\n  };\n  const normalizeStyleValue = (value, name) => {\n    if (isNullable(value)) {\n      return null;\n    } else {\n      let strValue = String(value);\n      if (name === 'color' || name === 'backgroundColor') {\n        strValue = rgbaToHexString(strValue);\n      }\n      if (name === 'fontWeight' && value === 700) {\n        strValue = 'bold';\n      }\n      if (name === 'fontFamily') {\n        strValue = strValue.replace(/[\\'\\\"]/g, '').replace(/,\\s+/g, ',');\n      }\n      return strValue;\n    }\n  };\n  const getStyle = (dom, node, name) => {\n    const style = dom.getStyle(node, name);\n    return normalizeStyleValue(style, name);\n  };\n  const getTextDecoration = (dom, node) => {\n    let decoration;\n    dom.getParent(node, n => {\n      if (isElement$6(n)) {\n        decoration = dom.getStyle(n, 'text-decoration');\n        return !!decoration && decoration !== 'none';\n      } else {\n        return false;\n      }\n    });\n    return decoration;\n  };\n  const getParents$2 = (dom, node, selector) => {\n    return dom.getParents(node, selector, dom.getRoot());\n  };\n  const isFormatPredicate = (editor, formatName, predicate) => {\n    const formats = editor.formatter.get(formatName);\n    return isNonNullable(formats) && exists(formats, predicate);\n  };\n  const isVariableFormatName = (editor, formatName) => {\n    const hasVariableValues = format => {\n      const isVariableValue = val => isFunction(val) || val.length > 1 && val.charAt(0) === '%';\n      return exists(['styles', 'attributes'], key => get$a(format, key).exists(field => {\n        const fieldValues = isArray$1(field) ? field : values(field);\n        return exists(fieldValues, isVariableValue);\n      }));\n    };\n    return isFormatPredicate(editor, formatName, hasVariableValues);\n  };\n  const areSimilarFormats = (editor, formatName, otherFormatName) => {\n    const validKeys = ['inline', 'block', 'selector', 'attributes', 'styles', 'classes'];\n    const filterObj = format => filter$4(format, (_, key) => exists(validKeys, validKey => validKey === key));\n    return isFormatPredicate(editor, formatName, fmt1 => {\n      const filteredFmt1 = filterObj(fmt1);\n      return isFormatPredicate(editor, otherFormatName, fmt2 => {\n        const filteredFmt2 = filterObj(fmt2);\n        return equal$1(filteredFmt1, filteredFmt2);\n      });\n    });\n  };\n  const isBlockFormat = format => hasNonNullableKey(format, 'block');\n  const isWrappingBlockFormat = format => isBlockFormat(format) && format.wrapper === true;\n  const isNonWrappingBlockFormat = format => isBlockFormat(format) && format.wrapper !== true;\n  const isSelectorFormat = format => hasNonNullableKey(format, 'selector');\n  const isInlineFormat = format => hasNonNullableKey(format, 'inline');\n  const isMixedFormat = format => isSelectorFormat(format) && isInlineFormat(format) && is$2(get$a(format, 'mixed'), true);\n  const shouldExpandToSelector = format => isSelectorFormat(format) && format.expand !== false && !isInlineFormat(format);\n  const getEmptyCaretContainers = node => {\n    const nodes = [];\n    let tempNode = node;\n    while (tempNode) {\n      if (isText$b(tempNode) && tempNode.data !== ZWSP$1 || tempNode.childNodes.length > 1) {\n        return [];\n      }\n      if (isElement$6(tempNode)) {\n        nodes.push(tempNode);\n      }\n      tempNode = tempNode.firstChild;\n    }\n    return nodes;\n  };\n  const isCaretContainerEmpty = node => {\n    return getEmptyCaretContainers(node).length > 0;\n  };\n  const isEmptyCaretFormatElement = element => {\n    return isCaretNode(element.dom) && isCaretContainerEmpty(element.dom);\n  };\n  const isBookmarkNode = isBookmarkNode$1;\n  const getParents$1 = getParents$2;\n  const isWhiteSpaceNode = isWhiteSpaceNode$1;\n  const isTextBlock = isTextBlock$1;\n  const isBogusBr = node => {\n    return isBr$6(node) && node.getAttribute('data-mce-bogus') && !node.nextSibling;\n  };\n  const findParentContentEditable = (dom, node) => {\n    let parent = node;\n    while (parent) {\n      if (isElement$6(parent) && dom.getContentEditable(parent)) {\n        return dom.getContentEditable(parent) === 'false' ? parent : node;\n      }\n      parent = parent.parentNode;\n    }\n    return node;\n  };\n  const walkText = (start, node, offset, predicate) => {\n    const str = node.data;\n    if (start) {\n      for (let i = offset; i > 0; i--) {\n        if (predicate(str.charAt(i - 1))) {\n          return i;\n        }\n      }\n    } else {\n      for (let i = offset; i < str.length; i++) {\n        if (predicate(str.charAt(i))) {\n          return i;\n        }\n      }\n    }\n    return -1;\n  };\n  const findSpace = (start, node, offset) => walkText(start, node, offset, c => isNbsp(c) || isWhiteSpace(c));\n  const findContent = (start, node, offset) => walkText(start, node, offset, isContent);\n  const findWordEndPoint = (dom, body, container, offset, start, includeTrailingSpaces) => {\n    let lastTextNode;\n    const rootNode = dom.getParent(container, dom.isBlock) || body;\n    const walk = (container, offset, pred) => {\n      const textSeeker = TextSeeker(dom);\n      const walker = start ? textSeeker.backwards : textSeeker.forwards;\n      return Optional.from(walker(container, offset, (text, textOffset) => {\n        if (isBookmarkNode(text.parentNode)) {\n          return -1;\n        } else {\n          lastTextNode = text;\n          return pred(start, text, textOffset);\n        }\n      }, rootNode));\n    };\n    const spaceResult = walk(container, offset, findSpace);\n    return spaceResult.bind(result => includeTrailingSpaces ? walk(result.container, result.offset + (start ? -1 : 0), findContent) : Optional.some(result)).orThunk(() => lastTextNode ? Optional.some({\n      container: lastTextNode,\n      offset: start ? 0 : lastTextNode.length\n    }) : Optional.none());\n  };\n  const findSelectorEndPoint = (dom, formatList, rng, container, siblingName) => {\n    const sibling = container[siblingName];\n    if (isText$b(container) && isEmpty$3(container.data) && sibling) {\n      container = sibling;\n    }\n    const parents = getParents$1(dom, container);\n    for (let i = 0; i < parents.length; i++) {\n      for (let y = 0; y < formatList.length; y++) {\n        const curFormat = formatList[y];\n        if (isNonNullable(curFormat.collapsed) && curFormat.collapsed !== rng.collapsed) {\n          continue;\n        }\n        if (isSelectorFormat(curFormat) && dom.is(parents[i], curFormat.selector)) {\n          return parents[i];\n        }\n      }\n    }\n    return container;\n  };\n  const findBlockEndPoint = (dom, formatList, container, siblingName) => {\n    var _a;\n    let node = container;\n    const root = dom.getRoot();\n    const format = formatList[0];\n    if (isBlockFormat(format)) {\n      node = format.wrapper ? null : dom.getParent(container, format.block, root);\n    }\n    if (!node) {\n      const scopeRoot = (_a = dom.getParent(container, 'LI,TD,TH,SUMMARY')) !== null && _a !== void 0 ? _a : root;\n      node = dom.getParent(isText$b(container) ? container.parentNode : container, node => node !== root && isTextBlock(dom.schema, node), scopeRoot);\n    }\n    if (node && isBlockFormat(format) && format.wrapper) {\n      node = getParents$1(dom, node, 'ul,ol').reverse()[0] || node;\n    }\n    if (!node) {\n      node = container;\n      while (node && node[siblingName] && !dom.isBlock(node[siblingName])) {\n        node = node[siblingName];\n        if (isEq$5(node, 'br')) {\n          break;\n        }\n      }\n    }\n    return node || container;\n  };\n  const isAtBlockBoundary$1 = (dom, root, container, siblingName) => {\n    const parent = container.parentNode;\n    if (isNonNullable(container[siblingName])) {\n      return false;\n    } else if (parent === root || isNullable(parent) || dom.isBlock(parent)) {\n      return true;\n    } else {\n      return isAtBlockBoundary$1(dom, root, parent, siblingName);\n    }\n  };\n  const findParentContainer = (dom, formatList, container, offset, start) => {\n    let parent = container;\n    const siblingName = start ? 'previousSibling' : 'nextSibling';\n    const root = dom.getRoot();\n    if (isText$b(container) && !isWhiteSpaceNode(container)) {\n      if (start ? offset > 0 : offset < container.data.length) {\n        return container;\n      }\n    }\n    while (parent) {\n      if (!formatList[0].block_expand && dom.isBlock(parent)) {\n        return parent;\n      }\n      for (let sibling = parent[siblingName]; sibling; sibling = sibling[siblingName]) {\n        const allowSpaces = isText$b(sibling) && !isAtBlockBoundary$1(dom, root, sibling, siblingName);\n        if (!isBookmarkNode(sibling) && !isBogusBr(sibling) && !isWhiteSpaceNode(sibling, allowSpaces)) {\n          return parent;\n        }\n      }\n      if (parent === root || parent.parentNode === root) {\n        container = parent;\n        break;\n      }\n      parent = parent.parentNode;\n    }\n    return container;\n  };\n  const isSelfOrParentBookmark = container => isBookmarkNode(container.parentNode) || isBookmarkNode(container);\n  const expandRng = (dom, rng, formatList, includeTrailingSpace = false) => {\n    let {\n      startContainer,\n      startOffset,\n      endContainer,\n      endOffset\n    } = rng;\n    const format = formatList[0];\n    if (isElement$6(startContainer) && startContainer.hasChildNodes()) {\n      startContainer = getNode$1(startContainer, startOffset);\n      if (isText$b(startContainer)) {\n        startOffset = 0;\n      }\n    }\n    if (isElement$6(endContainer) && endContainer.hasChildNodes()) {\n      endContainer = getNode$1(endContainer, rng.collapsed ? endOffset : endOffset - 1);\n      if (isText$b(endContainer)) {\n        endOffset = endContainer.data.length;\n      }\n    }\n    startContainer = findParentContentEditable(dom, startContainer);\n    endContainer = findParentContentEditable(dom, endContainer);\n    if (isSelfOrParentBookmark(startContainer)) {\n      startContainer = isBookmarkNode(startContainer) ? startContainer : startContainer.parentNode;\n      if (rng.collapsed) {\n        startContainer = startContainer.previousSibling || startContainer;\n      } else {\n        startContainer = startContainer.nextSibling || startContainer;\n      }\n      if (isText$b(startContainer)) {\n        startOffset = rng.collapsed ? startContainer.length : 0;\n      }\n    }\n    if (isSelfOrParentBookmark(endContainer)) {\n      endContainer = isBookmarkNode(endContainer) ? endContainer : endContainer.parentNode;\n      if (rng.collapsed) {\n        endContainer = endContainer.nextSibling || endContainer;\n      } else {\n        endContainer = endContainer.previousSibling || endContainer;\n      }\n      if (isText$b(endContainer)) {\n        endOffset = rng.collapsed ? 0 : endContainer.length;\n      }\n    }\n    if (rng.collapsed) {\n      const startPoint = findWordEndPoint(dom, dom.getRoot(), startContainer, startOffset, true, includeTrailingSpace);\n      startPoint.each(({\n        container,\n        offset\n      }) => {\n        startContainer = container;\n        startOffset = offset;\n      });\n      const endPoint = findWordEndPoint(dom, dom.getRoot(), endContainer, endOffset, false, includeTrailingSpace);\n      endPoint.each(({\n        container,\n        offset\n      }) => {\n        endContainer = container;\n        endOffset = offset;\n      });\n    }\n    if (isInlineFormat(format) || format.block_expand) {\n      if (!isInlineFormat(format) || !isText$b(startContainer) || startOffset === 0) {\n        startContainer = findParentContainer(dom, formatList, startContainer, startOffset, true);\n      }\n      if (!isInlineFormat(format) || !isText$b(endContainer) || endOffset === endContainer.data.length) {\n        endContainer = findParentContainer(dom, formatList, endContainer, endOffset, false);\n      }\n    }\n    if (shouldExpandToSelector(format)) {\n      startContainer = findSelectorEndPoint(dom, formatList, rng, startContainer, 'previousSibling');\n      endContainer = findSelectorEndPoint(dom, formatList, rng, endContainer, 'nextSibling');\n    }\n    if (isBlockFormat(format) || isSelectorFormat(format)) {\n      startContainer = findBlockEndPoint(dom, formatList, startContainer, 'previousSibling');\n      endContainer = findBlockEndPoint(dom, formatList, endContainer, 'nextSibling');\n      if (isBlockFormat(format)) {\n        if (!dom.isBlock(startContainer)) {\n          startContainer = findParentContainer(dom, formatList, startContainer, startOffset, true);\n          if (isText$b(startContainer)) {\n            startOffset = 0;\n          }\n        }\n        if (!dom.isBlock(endContainer)) {\n          endContainer = findParentContainer(dom, formatList, endContainer, endOffset, false);\n          if (isText$b(endContainer)) {\n            endOffset = endContainer.data.length;\n          }\n        }\n      }\n    }\n    if (isElement$6(startContainer) && startContainer.parentNode) {\n      startOffset = dom.nodeIndex(startContainer);\n      startContainer = startContainer.parentNode;\n    }\n    if (isElement$6(endContainer) && endContainer.parentNode) {\n      endOffset = dom.nodeIndex(endContainer) + 1;\n      endContainer = endContainer.parentNode;\n    }\n    return {\n      startContainer,\n      startOffset,\n      endContainer,\n      endOffset\n    };\n  };\n  const walk$3 = (dom, rng, callback) => {\n    var _a;\n    const startOffset = rng.startOffset;\n    const startContainer = getNode$1(rng.startContainer, startOffset);\n    const endOffset = rng.endOffset;\n    const endContainer = getNode$1(rng.endContainer, endOffset - 1);\n    const exclude = nodes => {\n      const firstNode = nodes[0];\n      if (isText$b(firstNode) && firstNode === startContainer && startOffset >= firstNode.data.length) {\n        nodes.splice(0, 1);\n      }\n      const lastNode = nodes[nodes.length - 1];\n      if (endOffset === 0 && nodes.length > 0 && lastNode === endContainer && isText$b(lastNode)) {\n        nodes.splice(nodes.length - 1, 1);\n      }\n      return nodes;\n    };\n    const collectSiblings = (node, name, endNode) => {\n      const siblings = [];\n      for (; node && node !== endNode; node = node[name]) {\n        siblings.push(node);\n      }\n      return siblings;\n    };\n    const findEndPoint = (node, root) => dom.getParent(node, node => node.parentNode === root, root);\n    const walkBoundary = (startNode, endNode, next) => {\n      const siblingName = next ? 'nextSibling' : 'previousSibling';\n      for (let node = startNode, parent = node.parentNode; node && node !== endNode; node = parent) {\n        parent = node.parentNode;\n        const siblings = collectSiblings(node === startNode ? node : node[siblingName], siblingName);\n        if (siblings.length) {\n          if (!next) {\n            siblings.reverse();\n          }\n          callback(exclude(siblings));\n        }\n      }\n    };\n    if (startContainer === endContainer) {\n      return callback(exclude([startContainer]));\n    }\n    const ancestor = (_a = dom.findCommonAncestor(startContainer, endContainer)) !== null && _a !== void 0 ? _a : dom.getRoot();\n    if (dom.isChildOf(startContainer, endContainer)) {\n      return walkBoundary(startContainer, ancestor, true);\n    }\n    if (dom.isChildOf(endContainer, startContainer)) {\n      return walkBoundary(endContainer, ancestor);\n    }\n    const startPoint = findEndPoint(startContainer, ancestor) || startContainer;\n    const endPoint = findEndPoint(endContainer, ancestor) || endContainer;\n    walkBoundary(startContainer, startPoint, true);\n    const siblings = collectSiblings(startPoint === startContainer ? startPoint : startPoint.nextSibling, 'nextSibling', endPoint === endContainer ? endPoint.nextSibling : endPoint);\n    if (siblings.length) {\n      callback(exclude(siblings));\n    }\n    walkBoundary(endContainer, endPoint);\n  };\n  const validBlocks = ['pre[class*=language-][contenteditable=\"false\"]', 'figure.image', 'div[data-ephox-embed-iri]', 'div.tiny-pageembed', 'div.mce-toc', 'div[data-mce-toc]'];\n  const isZeroWidth = elem => isText$c(elem) && get$3(elem) === ZWSP$1;\n  const context = (editor, elem, wrapName, nodeName) => parent(elem).fold(() => 'skipping', parent => {\n    if (nodeName === 'br' || isZeroWidth(elem)) {\n      return 'valid';\n    } else if (isAnnotation(elem)) {\n      return 'existing';\n    } else if (isCaretNode(elem.dom)) {\n      return 'caret';\n    } else if (exists(validBlocks, selector => is$1(elem, selector))) {\n      return 'valid-block';\n    } else if (!isValid(editor, wrapName, nodeName) || !isValid(editor, name(parent), wrapName)) {\n      return 'invalid-child';\n    } else {\n      return 'valid';\n    }\n  });\n  const applyWordGrab = (editor, rng) => {\n    const r = expandRng(editor.dom, rng, [{\n      inline: 'span'\n    }]);\n    rng.setStart(r.startContainer, r.startOffset);\n    rng.setEnd(r.endContainer, r.endOffset);\n    editor.selection.setRng(rng);\n  };\n  const applyAnnotation = (elem, masterUId, data, annotationName, decorate, directAnnotation) => {\n    const {\n      uid = masterUId,\n      ...otherData\n    } = data;\n    add$2(elem, annotation());\n    set$3(elem, `${dataAnnotationId()}`, uid);\n    set$3(elem, `${dataAnnotation()}`, annotationName);\n    const {\n      attributes = {},\n      classes = []\n    } = decorate(uid, otherData);\n    setAll$1(elem, attributes);\n    add(elem, classes);\n    if (directAnnotation) {\n      if (classes.length > 0) {\n        set$3(elem, `${dataAnnotationClasses()}`, classes.join(','));\n      }\n      const attributeNames = keys(attributes);\n      if (attributeNames.length > 0) {\n        set$3(elem, `${dataAnnotationAttributes()}`, attributeNames.join(','));\n      }\n    }\n  };\n  const removeDirectAnnotation = elem => {\n    remove$6(elem, annotation());\n    remove$9(elem, `${dataAnnotationId()}`);\n    remove$9(elem, `${dataAnnotation()}`);\n    remove$9(elem, `${dataAnnotationActive()}`);\n    const customAttrNames = getOpt(elem, `${dataAnnotationAttributes()}`).map(names => names.split(',')).getOr([]);\n    const customClasses = getOpt(elem, `${dataAnnotationClasses()}`).map(names => names.split(',')).getOr([]);\n    each$e(customAttrNames, name => remove$9(elem, name));\n    remove$3(elem, customClasses);\n    remove$9(elem, `${dataAnnotationClasses()}`);\n    remove$9(elem, `${dataAnnotationAttributes()}`);\n  };\n  const makeAnnotation = (eDoc, uid, data, annotationName, decorate) => {\n    const master = SugarElement.fromTag('span', eDoc);\n    applyAnnotation(master, uid, data, annotationName, decorate, false);\n    return master;\n  };\n  const annotate = (editor, rng, uid, annotationName, decorate, data) => {\n    const newWrappers = [];\n    const master = makeAnnotation(editor.getDoc(), uid, data, annotationName, decorate);\n    const wrapper = value$2();\n    const finishWrapper = () => {\n      wrapper.clear();\n    };\n    const getOrOpenWrapper = () => wrapper.get().getOrThunk(() => {\n      const nu = shallow$1(master);\n      newWrappers.push(nu);\n      wrapper.set(nu);\n      return nu;\n    });\n    const processElements = elems => {\n      each$e(elems, processElement);\n    };\n    const processElement = elem => {\n      const ctx = context(editor, elem, 'span', name(elem));\n      switch (ctx) {\n        case 'invalid-child':\n          {\n            finishWrapper();\n            const children = children$1(elem);\n            processElements(children);\n            finishWrapper();\n            break;\n          }\n        case 'valid-block':\n          {\n            finishWrapper();\n            applyAnnotation(elem, uid, data, annotationName, decorate, true);\n            break;\n          }\n        case 'valid':\n          {\n            const w = getOrOpenWrapper();\n            wrap$2(elem, w);\n            break;\n          }\n      }\n    };\n    const processNodes = nodes => {\n      const elems = map$3(nodes, SugarElement.fromDom);\n      processElements(elems);\n    };\n    walk$3(editor.dom, rng, nodes => {\n      finishWrapper();\n      processNodes(nodes);\n    });\n    return newWrappers;\n  };\n  const annotateWithBookmark = (editor, name, settings, data) => {\n    editor.undoManager.transact(() => {\n      const selection = editor.selection;\n      const initialRng = selection.getRng();\n      const hasFakeSelection = getCellsFromEditor(editor).length > 0;\n      const masterUid = generate$1('mce-annotation');\n      if (initialRng.collapsed && !hasFakeSelection) {\n        applyWordGrab(editor, initialRng);\n      }\n      if (selection.getRng().collapsed && !hasFakeSelection) {\n        const wrapper = makeAnnotation(editor.getDoc(), masterUid, data, name, settings.decorate);\n        set$1(wrapper, nbsp);\n        selection.getRng().insertNode(wrapper.dom);\n        selection.select(wrapper.dom);\n      } else {\n        preserve(selection, false, () => {\n          runOnRanges(editor, selectionRng => {\n            annotate(editor, selectionRng, masterUid, name, settings.decorate, data);\n          });\n        });\n      }\n    });\n  };\n  const Annotator = editor => {\n    const registry = create$b();\n    setup$x(editor, registry);\n    const changes = setup$y(editor, registry);\n    const isSpan = isTag('span');\n    const removeAnnotations = elements => {\n      each$e(elements, element => {\n        if (isSpan(element)) {\n          unwrap(element);\n        } else {\n          removeDirectAnnotation(element);\n        }\n      });\n    };\n    return {\n      register: (name, settings) => {\n        registry.register(name, settings);\n      },\n      annotate: (name, data) => {\n        registry.lookup(name).each(settings => {\n          annotateWithBookmark(editor, name, settings, data);\n        });\n      },\n      annotationChanged: (name, callback) => {\n        changes.addListener(name, callback);\n      },\n      remove: name => {\n        identify(editor, Optional.some(name)).each(({\n          elements\n        }) => {\n          const bookmark = editor.selection.getBookmark();\n          removeAnnotations(elements);\n          editor.selection.moveToBookmark(bookmark);\n        });\n      },\n      removeAll: name => {\n        const bookmark = editor.selection.getBookmark();\n        each$d(findAll(editor, name), (elements, _) => {\n          removeAnnotations(elements);\n        });\n        editor.selection.moveToBookmark(bookmark);\n      },\n      getAll: name => {\n        const directory = findAll(editor, name);\n        return map$2(directory, elems => map$3(elems, elem => elem.dom));\n      }\n    };\n  };\n  const BookmarkManager = selection => {\n    return {\n      getBookmark: curry(getBookmark$2, selection),\n      moveToBookmark: curry(moveToBookmark, selection)\n    };\n  };\n  BookmarkManager.isBookmarkNode = isBookmarkNode$1;\n  const isXYWithinRange = (clientX, clientY, range) => {\n    if (range.collapsed) {\n      return false;\n    } else {\n      return exists(range.getClientRects(), rect => containsXY(rect, clientX, clientY));\n    }\n  };\n  const firePreProcess = (editor, args) => editor.dispatch('PreProcess', args);\n  const firePostProcess = (editor, args) => editor.dispatch('PostProcess', args);\n  const fireRemove = editor => {\n    editor.dispatch('remove');\n  };\n  const fireDetach = editor => {\n    editor.dispatch('detach');\n  };\n  const fireSwitchMode = (editor, mode) => {\n    editor.dispatch('SwitchMode', {\n      mode\n    });\n  };\n  const fireObjectResizeStart = (editor, target, width, height, origin) => {\n    editor.dispatch('ObjectResizeStart', {\n      target,\n      width,\n      height,\n      origin\n    });\n  };\n  const fireObjectResized = (editor, target, width, height, origin) => {\n    editor.dispatch('ObjectResized', {\n      target,\n      width,\n      height,\n      origin\n    });\n  };\n  const firePreInit = editor => {\n    editor.dispatch('PreInit');\n  };\n  const firePostRender = editor => {\n    editor.dispatch('PostRender');\n  };\n  const fireInit = editor => {\n    editor.dispatch('Init');\n  };\n  const firePlaceholderToggle = (editor, state) => {\n    editor.dispatch('PlaceholderToggle', {\n      state\n    });\n  };\n  const fireError = (editor, errorType, error) => {\n    editor.dispatch(errorType, error);\n  };\n  const fireFormatApply = (editor, format, node, vars) => {\n    editor.dispatch('FormatApply', {\n      format,\n      node,\n      vars\n    });\n  };\n  const fireFormatRemove = (editor, format, node, vars) => {\n    editor.dispatch('FormatRemove', {\n      format,\n      node,\n      vars\n    });\n  };\n  const fireBeforeSetContent = (editor, args) => editor.dispatch('BeforeSetContent', args);\n  const fireSetContent = (editor, args) => editor.dispatch('SetContent', args);\n  const fireBeforeGetContent = (editor, args) => editor.dispatch('BeforeGetContent', args);\n  const fireGetContent = (editor, args) => editor.dispatch('GetContent', args);\n  const fireAutocompleterStart = (editor, args) => {\n    editor.dispatch('AutocompleterStart', args);\n  };\n  const fireAutocompleterUpdate = (editor, args) => {\n    editor.dispatch('AutocompleterUpdate', args);\n  };\n  const fireAutocompleterUpdateActiveRange = (editor, args) => {\n    editor.dispatch('AutocompleterUpdateActiveRange', args);\n  };\n  const fireAutocompleterEnd = editor => {\n    editor.dispatch('AutocompleterEnd');\n  };\n  const firePastePreProcess = (editor, html, internal) => editor.dispatch('PastePreProcess', {\n    content: html,\n    internal\n  });\n  const firePastePostProcess = (editor, node, internal) => editor.dispatch('PastePostProcess', {\n    node,\n    internal\n  });\n  const firePastePlainTextToggle = (editor, state) => editor.dispatch('PastePlainTextToggle', {\n    state\n  });\n  const fireEditableRootStateChange = (editor, state) => editor.dispatch('EditableRootStateChange', {\n    state\n  });\n  const VK = {\n    BACKSPACE: 8,\n    DELETE: 46,\n    DOWN: 40,\n    ENTER: 13,\n    ESC: 27,\n    LEFT: 37,\n    RIGHT: 39,\n    SPACEBAR: 32,\n    TAB: 9,\n    UP: 38,\n    PAGE_UP: 33,\n    PAGE_DOWN: 34,\n    END: 35,\n    HOME: 36,\n    modifierPressed: e => {\n      return e.shiftKey || e.ctrlKey || e.altKey || VK.metaKeyPressed(e);\n    },\n    metaKeyPressed: e => {\n      return Env.os.isMacOS() || Env.os.isiOS() ? e.metaKey : e.ctrlKey && !e.altKey;\n    }\n  };\n  const elementSelectionAttr = 'data-mce-selected';\n  const controlElmSelector = 'table,img,figure.image,hr,video,span.mce-preview-object,details';\n  const abs = Math.abs;\n  const round$1 = Math.round;\n  const resizeHandles = {\n    nw: [0, 0, -1, -1],\n    ne: [1, 0, 1, -1],\n    se: [1, 1, 1, 1],\n    sw: [0, 1, -1, 1]\n  };\n  const isTouchEvent = evt => evt.type === 'longpress' || evt.type.indexOf('touch') === 0;\n  const ControlSelection = (selection, editor) => {\n    const dom = editor.dom;\n    const editableDoc = editor.getDoc();\n    const rootDocument = document;\n    const rootElement = editor.getBody();\n    let selectedElm, selectedElmGhost, resizeHelper, selectedHandle, resizeBackdrop;\n    let startX, startY, selectedElmX, selectedElmY, startW, startH, ratio, resizeStarted;\n    let width;\n    let height;\n    let startScrollWidth;\n    let startScrollHeight;\n    const isImage = elm => isNonNullable(elm) && (isImg(elm) || dom.is(elm, 'figure.image'));\n    const isMedia = elm => isMedia$2(elm) || dom.hasClass(elm, 'mce-preview-object');\n    const isEventOnImageOutsideRange = (evt, range) => {\n      if (isTouchEvent(evt)) {\n        const touch = evt.touches[0];\n        return isImage(evt.target) && !isXYWithinRange(touch.clientX, touch.clientY, range);\n      } else {\n        return isImage(evt.target) && !isXYWithinRange(evt.clientX, evt.clientY, range);\n      }\n    };\n    const contextMenuSelectImage = evt => {\n      const target = evt.target;\n      if (isEventOnImageOutsideRange(evt, editor.selection.getRng()) && !evt.isDefaultPrevented()) {\n        editor.selection.select(target);\n      }\n    };\n    const getResizeTargets = elm => {\n      if (dom.hasClass(elm, 'mce-preview-object') && isNonNullable(elm.firstElementChild)) {\n        return [elm, elm.firstElementChild];\n      } else if (dom.is(elm, 'figure.image')) {\n        return [elm.querySelector('img')];\n      } else {\n        return [elm];\n      }\n    };\n    const isResizable = elm => {\n      const selector = getObjectResizing(editor);\n      if (!selector || editor.mode.isReadOnly()) {\n        return false;\n      }\n      if (elm.getAttribute('data-mce-resize') === 'false') {\n        return false;\n      }\n      if (elm === editor.getBody()) {\n        return false;\n      }\n      if (dom.hasClass(elm, 'mce-preview-object') && isNonNullable(elm.firstElementChild)) {\n        return is$1(SugarElement.fromDom(elm.firstElementChild), selector);\n      } else {\n        return is$1(SugarElement.fromDom(elm), selector);\n      }\n    };\n    const createGhostElement = (dom, elm) => {\n      if (isMedia(elm)) {\n        return dom.create('img', {\n          src: Env.transparentSrc\n        });\n      } else if (isTable$2(elm)) {\n        const isNorth = startsWith(selectedHandle.name, 'n');\n        const rowSelect = isNorth ? head : last$2;\n        const tableElm = elm.cloneNode(true);\n        rowSelect(dom.select('tr', tableElm)).each(tr => {\n          const cells = dom.select('td,th', tr);\n          dom.setStyle(tr, 'height', null);\n          each$e(cells, cell => dom.setStyle(cell, 'height', null));\n        });\n        return tableElm;\n      } else {\n        return elm.cloneNode(true);\n      }\n    };\n    const setSizeProp = (element, name, value) => {\n      if (isNonNullable(value)) {\n        const targets = getResizeTargets(element);\n        each$e(targets, target => {\n          if (target.style[name] || !editor.schema.isValid(target.nodeName.toLowerCase(), name)) {\n            dom.setStyle(target, name, value);\n          } else {\n            dom.setAttrib(target, name, '' + value);\n          }\n        });\n      }\n    };\n    const setGhostElmSize = (ghostElm, width, height) => {\n      setSizeProp(ghostElm, 'width', width);\n      setSizeProp(ghostElm, 'height', height);\n    };\n    const resizeGhostElement = e => {\n      let deltaX, deltaY, proportional;\n      let resizeHelperX, resizeHelperY;\n      deltaX = e.screenX - startX;\n      deltaY = e.screenY - startY;\n      width = deltaX * selectedHandle[2] + startW;\n      height = deltaY * selectedHandle[3] + startH;\n      width = width < 5 ? 5 : width;\n      height = height < 5 ? 5 : height;\n      if ((isImage(selectedElm) || isMedia(selectedElm)) && getResizeImgProportional(editor) !== false) {\n        proportional = !VK.modifierPressed(e);\n      } else {\n        proportional = VK.modifierPressed(e);\n      }\n      if (proportional) {\n        if (abs(deltaX) > abs(deltaY)) {\n          height = round$1(width * ratio);\n          width = round$1(height / ratio);\n        } else {\n          width = round$1(height / ratio);\n          height = round$1(width * ratio);\n        }\n      }\n      setGhostElmSize(selectedElmGhost, width, height);\n      resizeHelperX = selectedHandle.startPos.x + deltaX;\n      resizeHelperY = selectedHandle.startPos.y + deltaY;\n      resizeHelperX = resizeHelperX > 0 ? resizeHelperX : 0;\n      resizeHelperY = resizeHelperY > 0 ? resizeHelperY : 0;\n      dom.setStyles(resizeHelper, {\n        left: resizeHelperX,\n        top: resizeHelperY,\n        display: 'block'\n      });\n      resizeHelper.innerHTML = width + ' &times; ' + height;\n      if (selectedHandle[2] < 0 && selectedElmGhost.clientWidth <= width) {\n        dom.setStyle(selectedElmGhost, 'left', selectedElmX + (startW - width));\n      }\n      if (selectedHandle[3] < 0 && selectedElmGhost.clientHeight <= height) {\n        dom.setStyle(selectedElmGhost, 'top', selectedElmY + (startH - height));\n      }\n      deltaX = rootElement.scrollWidth - startScrollWidth;\n      deltaY = rootElement.scrollHeight - startScrollHeight;\n      if (deltaX + deltaY !== 0) {\n        dom.setStyles(resizeHelper, {\n          left: resizeHelperX - deltaX,\n          top: resizeHelperY - deltaY\n        });\n      }\n      if (!resizeStarted) {\n        fireObjectResizeStart(editor, selectedElm, startW, startH, 'corner-' + selectedHandle.name);\n        resizeStarted = true;\n      }\n    };\n    const endGhostResize = () => {\n      const wasResizeStarted = resizeStarted;\n      resizeStarted = false;\n      if (wasResizeStarted) {\n        setSizeProp(selectedElm, 'width', width);\n        setSizeProp(selectedElm, 'height', height);\n      }\n      dom.unbind(editableDoc, 'mousemove', resizeGhostElement);\n      dom.unbind(editableDoc, 'mouseup', endGhostResize);\n      if (rootDocument !== editableDoc) {\n        dom.unbind(rootDocument, 'mousemove', resizeGhostElement);\n        dom.unbind(rootDocument, 'mouseup', endGhostResize);\n      }\n      dom.remove(selectedElmGhost);\n      dom.remove(resizeHelper);\n      dom.remove(resizeBackdrop);\n      showResizeRect(selectedElm);\n      if (wasResizeStarted) {\n        fireObjectResized(editor, selectedElm, width, height, 'corner-' + selectedHandle.name);\n        dom.setAttrib(selectedElm, 'style', dom.getAttrib(selectedElm, 'style'));\n      }\n      editor.nodeChanged();\n    };\n    const showResizeRect = targetElm => {\n      unbindResizeHandleEvents();\n      const position = dom.getPos(targetElm, rootElement);\n      const selectedElmX = position.x;\n      const selectedElmY = position.y;\n      const rect = targetElm.getBoundingClientRect();\n      const targetWidth = rect.width || rect.right - rect.left;\n      const targetHeight = rect.height || rect.bottom - rect.top;\n      if (selectedElm !== targetElm) {\n        hideResizeRect();\n        selectedElm = targetElm;\n        width = height = 0;\n      }\n      const e = editor.dispatch('ObjectSelected', {\n        target: targetElm\n      });\n      if (isResizable(targetElm) && !e.isDefaultPrevented()) {\n        each$d(resizeHandles, (handle, name) => {\n          const startDrag = e => {\n            const target = getResizeTargets(selectedElm)[0];\n            startX = e.screenX;\n            startY = e.screenY;\n            startW = target.clientWidth;\n            startH = target.clientHeight;\n            ratio = startH / startW;\n            selectedHandle = handle;\n            selectedHandle.name = name;\n            selectedHandle.startPos = {\n              x: targetWidth * handle[0] + selectedElmX,\n              y: targetHeight * handle[1] + selectedElmY\n            };\n            startScrollWidth = rootElement.scrollWidth;\n            startScrollHeight = rootElement.scrollHeight;\n            resizeBackdrop = dom.add(rootElement, 'div', {\n              'class': 'mce-resize-backdrop',\n              'data-mce-bogus': 'all'\n            });\n            dom.setStyles(resizeBackdrop, {\n              position: 'fixed',\n              left: '0',\n              top: '0',\n              width: '100%',\n              height: '100%'\n            });\n            selectedElmGhost = createGhostElement(dom, selectedElm);\n            dom.addClass(selectedElmGhost, 'mce-clonedresizable');\n            dom.setAttrib(selectedElmGhost, 'data-mce-bogus', 'all');\n            selectedElmGhost.contentEditable = 'false';\n            dom.setStyles(selectedElmGhost, {\n              left: selectedElmX,\n              top: selectedElmY,\n              margin: 0\n            });\n            setGhostElmSize(selectedElmGhost, targetWidth, targetHeight);\n            selectedElmGhost.removeAttribute(elementSelectionAttr);\n            rootElement.appendChild(selectedElmGhost);\n            dom.bind(editableDoc, 'mousemove', resizeGhostElement);\n            dom.bind(editableDoc, 'mouseup', endGhostResize);\n            if (rootDocument !== editableDoc) {\n              dom.bind(rootDocument, 'mousemove', resizeGhostElement);\n              dom.bind(rootDocument, 'mouseup', endGhostResize);\n            }\n            resizeHelper = dom.add(rootElement, 'div', {\n              'class': 'mce-resize-helper',\n              'data-mce-bogus': 'all'\n            }, startW + ' &times; ' + startH);\n          };\n          let handleElm = dom.get('mceResizeHandle' + name);\n          if (handleElm) {\n            dom.remove(handleElm);\n          }\n          handleElm = dom.add(rootElement, 'div', {\n            'id': 'mceResizeHandle' + name,\n            'data-mce-bogus': 'all',\n            'class': 'mce-resizehandle',\n            'unselectable': true,\n            'style': 'cursor:' + name + '-resize; margin:0; padding:0'\n          });\n          dom.bind(handleElm, 'mousedown', e => {\n            e.stopImmediatePropagation();\n            e.preventDefault();\n            startDrag(e);\n          });\n          handle.elm = handleElm;\n          dom.setStyles(handleElm, {\n            left: targetWidth * handle[0] + selectedElmX - handleElm.offsetWidth / 2,\n            top: targetHeight * handle[1] + selectedElmY - handleElm.offsetHeight / 2\n          });\n        });\n      } else {\n        hideResizeRect(false);\n      }\n    };\n    const throttledShowResizeRect = first$1(showResizeRect, 0);\n    const hideResizeRect = (removeSelected = true) => {\n      throttledShowResizeRect.cancel();\n      unbindResizeHandleEvents();\n      if (selectedElm && removeSelected) {\n        selectedElm.removeAttribute(elementSelectionAttr);\n      }\n      each$d(resizeHandles, (value, name) => {\n        const handleElm = dom.get('mceResizeHandle' + name);\n        if (handleElm) {\n          dom.unbind(handleElm);\n          dom.remove(handleElm);\n        }\n      });\n    };\n    const isChildOrEqual = (node, parent) => dom.isChildOf(node, parent);\n    const updateResizeRect = e => {\n      if (resizeStarted || editor.removed || editor.composing) {\n        return;\n      }\n      const targetElm = e.type === 'mousedown' ? e.target : selection.getNode();\n      const controlElm = closest$3(SugarElement.fromDom(targetElm), controlElmSelector).map(e => e.dom).filter(e => dom.isEditable(e.parentElement) || e.nodeName === 'IMG' && dom.isEditable(e)).getOrUndefined();\n      const selectedValue = isNonNullable(controlElm) ? dom.getAttrib(controlElm, elementSelectionAttr, '1') : '1';\n      each$e(dom.select(`img[${elementSelectionAttr}],hr[${elementSelectionAttr}]`), img => {\n        img.removeAttribute(elementSelectionAttr);\n      });\n      if (isNonNullable(controlElm) && isChildOrEqual(controlElm, rootElement) && editor.hasFocus()) {\n        disableGeckoResize();\n        const startElm = selection.getStart(true);\n        if (isChildOrEqual(startElm, controlElm) && isChildOrEqual(selection.getEnd(true), controlElm)) {\n          dom.setAttrib(controlElm, elementSelectionAttr, selectedValue);\n          throttledShowResizeRect.throttle(controlElm);\n          return;\n        }\n      }\n      hideResizeRect();\n    };\n    const unbindResizeHandleEvents = () => {\n      each$d(resizeHandles, handle => {\n        if (handle.elm) {\n          dom.unbind(handle.elm);\n          delete handle.elm;\n        }\n      });\n    };\n    const disableGeckoResize = () => {\n      try {\n        editor.getDoc().execCommand('enableObjectResizing', false, 'false');\n      } catch (ex) {}\n    };\n    editor.on('init', () => {\n      disableGeckoResize();\n      editor.on('NodeChange ResizeEditor ResizeWindow ResizeContent drop', updateResizeRect);\n      editor.on('keyup compositionend', e => {\n        if (selectedElm && selectedElm.nodeName === 'TABLE') {\n          updateResizeRect(e);\n        }\n      });\n      editor.on('hide blur', hideResizeRect);\n      editor.on('contextmenu longpress', contextMenuSelectImage, true);\n    });\n    editor.on('remove', unbindResizeHandleEvents);\n    const destroy = () => {\n      throttledShowResizeRect.cancel();\n      selectedElm = selectedElmGhost = resizeBackdrop = null;\n    };\n    return {\n      isResizable,\n      showResizeRect,\n      hideResizeRect,\n      updateResizeRect,\n      destroy\n    };\n  };\n  const setStart = (rng, situ) => {\n    situ.fold(e => {\n      rng.setStartBefore(e.dom);\n    }, (e, o) => {\n      rng.setStart(e.dom, o);\n    }, e => {\n      rng.setStartAfter(e.dom);\n    });\n  };\n  const setFinish = (rng, situ) => {\n    situ.fold(e => {\n      rng.setEndBefore(e.dom);\n    }, (e, o) => {\n      rng.setEnd(e.dom, o);\n    }, e => {\n      rng.setEndAfter(e.dom);\n    });\n  };\n  const relativeToNative = (win, startSitu, finishSitu) => {\n    const range = win.document.createRange();\n    setStart(range, startSitu);\n    setFinish(range, finishSitu);\n    return range;\n  };\n  const exactToNative = (win, start, soffset, finish, foffset) => {\n    const rng = win.document.createRange();\n    rng.setStart(start.dom, soffset);\n    rng.setEnd(finish.dom, foffset);\n    return rng;\n  };\n  const adt$3 = Adt.generate([{\n    ltr: ['start', 'soffset', 'finish', 'foffset']\n  }, {\n    rtl: ['start', 'soffset', 'finish', 'foffset']\n  }]);\n  const fromRange = (win, type, range) => type(SugarElement.fromDom(range.startContainer), range.startOffset, SugarElement.fromDom(range.endContainer), range.endOffset);\n  const getRanges = (win, selection) => selection.match({\n    domRange: rng => {\n      return {\n        ltr: constant(rng),\n        rtl: Optional.none\n      };\n    },\n    relative: (startSitu, finishSitu) => {\n      return {\n        ltr: cached(() => relativeToNative(win, startSitu, finishSitu)),\n        rtl: cached(() => Optional.some(relativeToNative(win, finishSitu, startSitu)))\n      };\n    },\n    exact: (start, soffset, finish, foffset) => {\n      return {\n        ltr: cached(() => exactToNative(win, start, soffset, finish, foffset)),\n        rtl: cached(() => Optional.some(exactToNative(win, finish, foffset, start, soffset)))\n      };\n    }\n  });\n  const doDiagnose = (win, ranges) => {\n    const rng = ranges.ltr();\n    if (rng.collapsed) {\n      const reversed = ranges.rtl().filter(rev => rev.collapsed === false);\n      return reversed.map(rev => adt$3.rtl(SugarElement.fromDom(rev.endContainer), rev.endOffset, SugarElement.fromDom(rev.startContainer), rev.startOffset)).getOrThunk(() => fromRange(win, adt$3.ltr, rng));\n    } else {\n      return fromRange(win, adt$3.ltr, rng);\n    }\n  };\n  const diagnose = (win, selection) => {\n    const ranges = getRanges(win, selection);\n    return doDiagnose(win, ranges);\n  };\n  adt$3.ltr;\n  adt$3.rtl;\n  const create$9 = (start, soffset, finish, foffset) => ({\n    start,\n    soffset,\n    finish,\n    foffset\n  });\n  const SimRange = {\n    create: create$9\n  };\n  const caretPositionFromPoint = (doc, x, y) => {\n    var _a;\n    return Optional.from((_a = doc.caretPositionFromPoint) === null || _a === void 0 ? void 0 : _a.call(doc, x, y)).bind(pos => {\n      if (pos.offsetNode === null) {\n        return Optional.none();\n      }\n      const r = doc.createRange();\n      r.setStart(pos.offsetNode, pos.offset);\n      r.collapse();\n      return Optional.some(r);\n    });\n  };\n  const caretRangeFromPoint = (doc, x, y) => {\n    var _a;\n    return Optional.from((_a = doc.caretRangeFromPoint) === null || _a === void 0 ? void 0 : _a.call(doc, x, y));\n  };\n  const availableSearch = (doc, x, y) => {\n    if (doc.caretPositionFromPoint) {\n      return caretPositionFromPoint(doc, x, y);\n    } else if (doc.caretRangeFromPoint) {\n      return caretRangeFromPoint(doc, x, y);\n    } else {\n      return Optional.none();\n    }\n  };\n  const fromPoint$1 = (win, x, y) => {\n    const doc = win.document;\n    return availableSearch(doc, x, y).map(rng => SimRange.create(SugarElement.fromDom(rng.startContainer), rng.startOffset, SugarElement.fromDom(rng.endContainer), rng.endOffset));\n  };\n  const adt$2 = Adt.generate([{\n    before: ['element']\n  }, {\n    on: ['element', 'offset']\n  }, {\n    after: ['element']\n  }]);\n  const cata = (subject, onBefore, onOn, onAfter) => subject.fold(onBefore, onOn, onAfter);\n  const getStart$2 = situ => situ.fold(identity, identity, identity);\n  const before$1 = adt$2.before;\n  const on = adt$2.on;\n  const after$1 = adt$2.after;\n  const Situ = {\n    before: before$1,\n    on,\n    after: after$1,\n    cata,\n    getStart: getStart$2\n  };\n  const adt$1 = Adt.generate([{\n    domRange: ['rng']\n  }, {\n    relative: ['startSitu', 'finishSitu']\n  }, {\n    exact: ['start', 'soffset', 'finish', 'foffset']\n  }]);\n  const exactFromRange = simRange => adt$1.exact(simRange.start, simRange.soffset, simRange.finish, simRange.foffset);\n  const getStart$1 = selection => selection.match({\n    domRange: rng => SugarElement.fromDom(rng.startContainer),\n    relative: (startSitu, _finishSitu) => Situ.getStart(startSitu),\n    exact: (start, _soffset, _finish, _foffset) => start\n  });\n  const domRange = adt$1.domRange;\n  const relative = adt$1.relative;\n  const exact = adt$1.exact;\n  const getWin = selection => {\n    const start = getStart$1(selection);\n    return defaultView(start);\n  };\n  const range = SimRange.create;\n  const SimSelection = {\n    domRange,\n    relative,\n    exact,\n    exactFromRange,\n    getWin,\n    range\n  };\n  const beforeSpecial = (element, offset) => {\n    const name$1 = name(element);\n    if ('input' === name$1) {\n      return Situ.after(element);\n    } else if (!contains$2(['br', 'img'], name$1)) {\n      return Situ.on(element, offset);\n    } else {\n      return offset === 0 ? Situ.before(element) : Situ.after(element);\n    }\n  };\n  const preprocessRelative = (startSitu, finishSitu) => {\n    const start = startSitu.fold(Situ.before, beforeSpecial, Situ.after);\n    const finish = finishSitu.fold(Situ.before, beforeSpecial, Situ.after);\n    return SimSelection.relative(start, finish);\n  };\n  const preprocessExact = (start, soffset, finish, foffset) => {\n    const startSitu = beforeSpecial(start, soffset);\n    const finishSitu = beforeSpecial(finish, foffset);\n    return SimSelection.relative(startSitu, finishSitu);\n  };\n  const preprocess = selection => selection.match({\n    domRange: rng => {\n      const start = SugarElement.fromDom(rng.startContainer);\n      const finish = SugarElement.fromDom(rng.endContainer);\n      return preprocessExact(start, rng.startOffset, finish, rng.endOffset);\n    },\n    relative: preprocessRelative,\n    exact: preprocessExact\n  });\n  const fromElements = (elements, scope) => {\n    const doc = scope || document;\n    const fragment = doc.createDocumentFragment();\n    each$e(elements, element => {\n      fragment.appendChild(element.dom);\n    });\n    return SugarElement.fromDom(fragment);\n  };\n  const toNative = selection => {\n    const win = SimSelection.getWin(selection).dom;\n    const getDomRange = (start, soffset, finish, foffset) => exactToNative(win, start, soffset, finish, foffset);\n    const filtered = preprocess(selection);\n    return diagnose(win, filtered).match({\n      ltr: getDomRange,\n      rtl: getDomRange\n    });\n  };\n  const getAtPoint = (win, x, y) => fromPoint$1(win, x, y);\n  const fromPoint = (clientX, clientY, doc) => {\n    const win = defaultView(SugarElement.fromDom(doc));\n    return getAtPoint(win.dom, clientX, clientY).map(simRange => {\n      const rng = doc.createRange();\n      rng.setStart(simRange.start.dom, simRange.soffset);\n      rng.setEnd(simRange.finish.dom, simRange.foffset);\n      return rng;\n    }).getOrUndefined();\n  };\n  const isEq$4 = (rng1, rng2) => {\n    return isNonNullable(rng1) && isNonNullable(rng2) && rng1.startContainer === rng2.startContainer && rng1.startOffset === rng2.startOffset && rng1.endContainer === rng2.endContainer && rng1.endOffset === rng2.endOffset;\n  };\n  const findParent = (node, rootNode, predicate) => {\n    let currentNode = node;\n    while (currentNode && currentNode !== rootNode) {\n      if (predicate(currentNode)) {\n        return currentNode;\n      }\n      currentNode = currentNode.parentNode;\n    }\n    return null;\n  };\n  const hasParent$1 = (node, rootNode, predicate) => findParent(node, rootNode, predicate) !== null;\n  const hasParentWithName = (node, rootNode, name) => hasParent$1(node, rootNode, node => node.nodeName === name);\n  const isCeFalseCaretContainer = (node, rootNode) => isCaretContainer$2(node) && !hasParent$1(node, rootNode, isCaretNode);\n  const hasBrBeforeAfter = (dom, node, left) => {\n    const parentNode = node.parentNode;\n    if (parentNode) {\n      const walker = new DomTreeWalker(node, dom.getParent(parentNode, dom.isBlock) || dom.getRoot());\n      let currentNode;\n      while (currentNode = walker[left ? 'prev' : 'next']()) {\n        if (isBr$6(currentNode)) {\n          return true;\n        }\n      }\n    }\n    return false;\n  };\n  const isPrevNode = (node, name) => {\n    var _a;\n    return ((_a = node.previousSibling) === null || _a === void 0 ? void 0 : _a.nodeName) === name;\n  };\n  const hasContentEditableFalseParent$1 = (root, node) => {\n    let currentNode = node;\n    while (currentNode && currentNode !== root) {\n      if (isContentEditableFalse$b(currentNode)) {\n        return true;\n      }\n      currentNode = currentNode.parentNode;\n    }\n    return false;\n  };\n  const findTextNodeRelative = (dom, isAfterNode, collapsed, left, startNode) => {\n    const body = dom.getRoot();\n    const nonEmptyElementsMap = dom.schema.getNonEmptyElements();\n    const parentNode = startNode.parentNode;\n    let lastInlineElement;\n    let node;\n    if (!parentNode) {\n      return Optional.none();\n    }\n    const parentBlockContainer = dom.getParent(parentNode, dom.isBlock) || body;\n    if (left && isBr$6(startNode) && isAfterNode && dom.isEmpty(parentBlockContainer)) {\n      return Optional.some(CaretPosition(parentNode, dom.nodeIndex(startNode)));\n    }\n    const walker = new DomTreeWalker(startNode, parentBlockContainer);\n    while (node = walker[left ? 'prev' : 'next']()) {\n      if (dom.getContentEditableParent(node) === 'false' || isCeFalseCaretContainer(node, body)) {\n        return Optional.none();\n      }\n      if (isText$b(node) && node.data.length > 0) {\n        if (!hasParentWithName(node, body, 'A')) {\n          return Optional.some(CaretPosition(node, left ? node.data.length : 0));\n        }\n        return Optional.none();\n      }\n      if (dom.isBlock(node) || nonEmptyElementsMap[node.nodeName.toLowerCase()]) {\n        return Optional.none();\n      }\n      lastInlineElement = node;\n    }\n    if (isComment(lastInlineElement)) {\n      return Optional.none();\n    }\n    if (collapsed && lastInlineElement) {\n      return Optional.some(CaretPosition(lastInlineElement, 0));\n    }\n    return Optional.none();\n  };\n  const normalizeEndPoint = (dom, collapsed, start, rng) => {\n    const body = dom.getRoot();\n    let node;\n    let normalized = false;\n    let container = start ? rng.startContainer : rng.endContainer;\n    let offset = start ? rng.startOffset : rng.endOffset;\n    const isAfterNode = isElement$6(container) && offset === container.childNodes.length;\n    const nonEmptyElementsMap = dom.schema.getNonEmptyElements();\n    let directionLeft = start;\n    if (isCaretContainer$2(container)) {\n      return Optional.none();\n    }\n    if (isElement$6(container) && offset > container.childNodes.length - 1) {\n      directionLeft = false;\n    }\n    if (isDocument$1(container)) {\n      container = body;\n      offset = 0;\n    }\n    if (container === body) {\n      if (directionLeft) {\n        node = container.childNodes[offset > 0 ? offset - 1 : 0];\n        if (node) {\n          if (isCaretContainer$2(node)) {\n            return Optional.none();\n          }\n          if (nonEmptyElementsMap[node.nodeName] || isTable$2(node)) {\n            return Optional.none();\n          }\n        }\n      }\n      if (container.hasChildNodes()) {\n        offset = Math.min(!directionLeft && offset > 0 ? offset - 1 : offset, container.childNodes.length - 1);\n        container = container.childNodes[offset];\n        offset = isText$b(container) && isAfterNode ? container.data.length : 0;\n        if (!collapsed && container === body.lastChild && isTable$2(container)) {\n          return Optional.none();\n        }\n        if (hasContentEditableFalseParent$1(body, container) || isCaretContainer$2(container)) {\n          return Optional.none();\n        }\n        if (isDetails(container)) {\n          return Optional.none();\n        }\n        if (container.hasChildNodes() && !isTable$2(container)) {\n          node = container;\n          const walker = new DomTreeWalker(container, body);\n          do {\n            if (isContentEditableFalse$b(node) || isCaretContainer$2(node)) {\n              normalized = false;\n              break;\n            }\n            if (isText$b(node) && node.data.length > 0) {\n              offset = directionLeft ? 0 : node.data.length;\n              container = node;\n              normalized = true;\n              break;\n            }\n            if (nonEmptyElementsMap[node.nodeName.toLowerCase()] && !isTableCellOrCaption(node)) {\n              offset = dom.nodeIndex(node);\n              container = node.parentNode;\n              if (!directionLeft) {\n                offset++;\n              }\n              normalized = true;\n              break;\n            }\n          } while (node = directionLeft ? walker.next() : walker.prev());\n        }\n      }\n    }\n    if (collapsed) {\n      if (isText$b(container) && offset === 0) {\n        findTextNodeRelative(dom, isAfterNode, collapsed, true, container).each(pos => {\n          container = pos.container();\n          offset = pos.offset();\n          normalized = true;\n        });\n      }\n      if (isElement$6(container)) {\n        node = container.childNodes[offset];\n        if (!node) {\n          node = container.childNodes[offset - 1];\n        }\n        if (node && isBr$6(node) && !isPrevNode(node, 'A') && !hasBrBeforeAfter(dom, node, false) && !hasBrBeforeAfter(dom, node, true)) {\n          findTextNodeRelative(dom, isAfterNode, collapsed, true, node).each(pos => {\n            container = pos.container();\n            offset = pos.offset();\n            normalized = true;\n          });\n        }\n      }\n    }\n    if (directionLeft && !collapsed && isText$b(container) && offset === container.data.length) {\n      findTextNodeRelative(dom, isAfterNode, collapsed, false, container).each(pos => {\n        container = pos.container();\n        offset = pos.offset();\n        normalized = true;\n      });\n    }\n    return normalized && container ? Optional.some(CaretPosition(container, offset)) : Optional.none();\n  };\n  const normalize$2 = (dom, rng) => {\n    const collapsed = rng.collapsed,\n      normRng = rng.cloneRange();\n    const startPos = CaretPosition.fromRangeStart(rng);\n    normalizeEndPoint(dom, collapsed, true, normRng).each(pos => {\n      if (!collapsed || !CaretPosition.isAbove(startPos, pos)) {\n        normRng.setStart(pos.container(), pos.offset());\n      }\n    });\n    if (!collapsed) {\n      normalizeEndPoint(dom, collapsed, false, normRng).each(pos => {\n        normRng.setEnd(pos.container(), pos.offset());\n      });\n    }\n    if (collapsed) {\n      normRng.collapse(true);\n    }\n    return isEq$4(rng, normRng) ? Optional.none() : Optional.some(normRng);\n  };\n  const splitText = (node, offset) => {\n    return node.splitText(offset);\n  };\n  const split = rng => {\n    let startContainer = rng.startContainer,\n      startOffset = rng.startOffset,\n      endContainer = rng.endContainer,\n      endOffset = rng.endOffset;\n    if (startContainer === endContainer && isText$b(startContainer)) {\n      if (startOffset > 0 && startOffset < startContainer.data.length) {\n        endContainer = splitText(startContainer, startOffset);\n        startContainer = endContainer.previousSibling;\n        if (endOffset > startOffset) {\n          endOffset = endOffset - startOffset;\n          const newContainer = splitText(endContainer, endOffset).previousSibling;\n          startContainer = endContainer = newContainer;\n          endOffset = newContainer.data.length;\n          startOffset = 0;\n        } else {\n          endOffset = 0;\n        }\n      }\n    } else {\n      if (isText$b(startContainer) && startOffset > 0 && startOffset < startContainer.data.length) {\n        startContainer = splitText(startContainer, startOffset);\n        startOffset = 0;\n      }\n      if (isText$b(endContainer) && endOffset > 0 && endOffset < endContainer.data.length) {\n        const newContainer = splitText(endContainer, endOffset).previousSibling;\n        endContainer = newContainer;\n        endOffset = newContainer.data.length;\n      }\n    }\n    return {\n      startContainer,\n      startOffset,\n      endContainer,\n      endOffset\n    };\n  };\n  const RangeUtils = dom => {\n    const walk = (rng, callback) => {\n      return walk$3(dom, rng, callback);\n    };\n    const split$1 = split;\n    const normalize = rng => {\n      return normalize$2(dom, rng).fold(never, normalizedRng => {\n        rng.setStart(normalizedRng.startContainer, normalizedRng.startOffset);\n        rng.setEnd(normalizedRng.endContainer, normalizedRng.endOffset);\n        return true;\n      });\n    };\n    const expand = (rng, options = {\n      type: 'word'\n    }) => {\n      if (options.type === 'word') {\n        const rangeLike = expandRng(dom, rng, [{\n          inline: 'span'\n        }]);\n        const newRange = dom.createRng();\n        newRange.setStart(rangeLike.startContainer, rangeLike.startOffset);\n        newRange.setEnd(rangeLike.endContainer, rangeLike.endOffset);\n        return newRange;\n      }\n      return rng;\n    };\n    return {\n      walk,\n      split: split$1,\n      expand,\n      normalize\n    };\n  };\n  RangeUtils.compareRanges = isEq$4;\n  RangeUtils.getCaretRangeFromPoint = fromPoint;\n  RangeUtils.getSelectedNode = getSelectedNode;\n  RangeUtils.getNode = getNode$1;\n  const Dimension = (name, getOffset) => {\n    const set = (element, h) => {\n      if (!isNumber(h) && !h.match(/^[0-9]+$/)) {\n        throw new Error(name + '.set accepts only positive integer values. Value was ' + h);\n      }\n      const dom = element.dom;\n      if (isSupported(dom)) {\n        dom.style[name] = h + 'px';\n      }\n    };\n    const get = element => {\n      const r = getOffset(element);\n      if (r <= 0 || r === null) {\n        const css = get$7(element, name);\n        return parseFloat(css) || 0;\n      }\n      return r;\n    };\n    const getOuter = get;\n    const aggregate = (element, properties) => foldl(properties, (acc, property) => {\n      const val = get$7(element, property);\n      const value = val === undefined ? 0 : parseInt(val, 10);\n      return isNaN(value) ? acc : acc + value;\n    }, 0);\n    const max = (element, value, properties) => {\n      const cumulativeInclusions = aggregate(element, properties);\n      const absoluteMax = value > cumulativeInclusions ? value - cumulativeInclusions : 0;\n      return absoluteMax;\n    };\n    return {\n      set,\n      get,\n      getOuter,\n      aggregate,\n      max\n    };\n  };\n  const api = Dimension('height', element => {\n    const dom = element.dom;\n    return inBody(element) ? dom.getBoundingClientRect().height : dom.offsetHeight;\n  });\n  const get$2 = element => api.get(element);\n  const getDocument = () => SugarElement.fromDom(document);\n  const walkUp = (navigation, doc) => {\n    const frame = navigation.view(doc);\n    return frame.fold(constant([]), f => {\n      const parent = navigation.owner(f);\n      const rest = walkUp(navigation, parent);\n      return [f].concat(rest);\n    });\n  };\n  const pathTo = (element, navigation) => {\n    const d = navigation.owner(element);\n    return walkUp(navigation, d);\n  };\n  const view = doc => {\n    var _a;\n    const element = doc.dom === document ? Optional.none() : Optional.from((_a = doc.dom.defaultView) === null || _a === void 0 ? void 0 : _a.frameElement);\n    return element.map(SugarElement.fromDom);\n  };\n  const owner = element => documentOrOwner(element);\n  var Navigation = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    view: view,\n    owner: owner\n  });\n  const find = element => {\n    const doc = getDocument();\n    const scroll = get$5(doc);\n    const frames = pathTo(element, Navigation);\n    const offset = viewport(element);\n    const r = foldr(frames, (b, a) => {\n      const loc = viewport(a);\n      return {\n        left: b.left + loc.left,\n        top: b.top + loc.top\n      };\n    }, {\n      left: 0,\n      top: 0\n    });\n    return SugarPosition(r.left + offset.left + scroll.left, r.top + offset.top + scroll.top);\n  };\n  const excludeFromDescend = element => name(element) === 'textarea';\n  const fireScrollIntoViewEvent = (editor, data) => {\n    const scrollEvent = editor.dispatch('ScrollIntoView', data);\n    return scrollEvent.isDefaultPrevented();\n  };\n  const fireAfterScrollIntoViewEvent = (editor, data) => {\n    editor.dispatch('AfterScrollIntoView', data);\n  };\n  const descend = (element, offset) => {\n    const children = children$1(element);\n    if (children.length === 0 || excludeFromDescend(element)) {\n      return {\n        element,\n        offset\n      };\n    } else if (offset < children.length && !excludeFromDescend(children[offset])) {\n      return {\n        element: children[offset],\n        offset: 0\n      };\n    } else {\n      const last = children[children.length - 1];\n      if (excludeFromDescend(last)) {\n        return {\n          element,\n          offset\n        };\n      } else {\n        if (name(last) === 'img') {\n          return {\n            element: last,\n            offset: 1\n          };\n        } else if (isText$c(last)) {\n          return {\n            element: last,\n            offset: get$3(last).length\n          };\n        } else {\n          return {\n            element: last,\n            offset: children$1(last).length\n          };\n        }\n      }\n    }\n  };\n  const markerInfo = (element, cleanupFun) => {\n    const pos = absolute(element);\n    const height = get$2(element);\n    return {\n      element,\n      bottom: pos.top + height,\n      height,\n      pos,\n      cleanup: cleanupFun\n    };\n  };\n  const createMarker$1 = (element, offset) => {\n    const startPoint = descend(element, offset);\n    const span = SugarElement.fromHtml('<span data-mce-bogus=\"all\" style=\"display: inline-block;\">' + ZWSP$1 + '</span>');\n    before$3(startPoint.element, span);\n    return markerInfo(span, () => remove$4(span));\n  };\n  const elementMarker = element => markerInfo(SugarElement.fromDom(element), noop);\n  const withMarker = (editor, f, rng, alignToTop) => {\n    preserveWith(editor, (_s, _e) => applyWithMarker(editor, f, rng, alignToTop), rng);\n  };\n  const withScrollEvents = (editor, doc, f, marker, alignToTop) => {\n    const data = {\n      elm: marker.element.dom,\n      alignToTop\n    };\n    if (fireScrollIntoViewEvent(editor, data)) {\n      return;\n    }\n    const scrollTop = get$5(doc).top;\n    f(editor, doc, scrollTop, marker, alignToTop);\n    fireAfterScrollIntoViewEvent(editor, data);\n  };\n  const applyWithMarker = (editor, f, rng, alignToTop) => {\n    const body = SugarElement.fromDom(editor.getBody());\n    const doc = SugarElement.fromDom(editor.getDoc());\n    reflow(body);\n    const marker = createMarker$1(SugarElement.fromDom(rng.startContainer), rng.startOffset);\n    withScrollEvents(editor, doc, f, marker, alignToTop);\n    marker.cleanup();\n  };\n  const withElement = (editor, element, f, alignToTop) => {\n    const doc = SugarElement.fromDom(editor.getDoc());\n    withScrollEvents(editor, doc, f, elementMarker(element), alignToTop);\n  };\n  const preserveWith = (editor, f, rng) => {\n    const startElement = rng.startContainer;\n    const startOffset = rng.startOffset;\n    const endElement = rng.endContainer;\n    const endOffset = rng.endOffset;\n    f(SugarElement.fromDom(startElement), SugarElement.fromDom(endElement));\n    const newRng = editor.dom.createRng();\n    newRng.setStart(startElement, startOffset);\n    newRng.setEnd(endElement, endOffset);\n    editor.selection.setRng(rng);\n  };\n  const scrollToMarker = (editor, marker, viewHeight, alignToTop, doc) => {\n    const pos = marker.pos;\n    if (alignToTop) {\n      to(pos.left, pos.top, doc);\n    } else {\n      const y = pos.top - viewHeight + marker.height;\n      to(-editor.getBody().getBoundingClientRect().left, y, doc);\n    }\n  };\n  const intoWindowIfNeeded = (editor, doc, scrollTop, viewHeight, marker, alignToTop) => {\n    const viewportBottom = viewHeight + scrollTop;\n    const markerTop = marker.pos.top;\n    const markerBottom = marker.bottom;\n    const largerThanViewport = markerBottom - markerTop >= viewHeight;\n    if (markerTop < scrollTop) {\n      scrollToMarker(editor, marker, viewHeight, alignToTop !== false, doc);\n    } else if (markerTop > viewportBottom) {\n      const align = largerThanViewport ? alignToTop !== false : alignToTop === true;\n      scrollToMarker(editor, marker, viewHeight, align, doc);\n    } else if (markerBottom > viewportBottom && !largerThanViewport) {\n      scrollToMarker(editor, marker, viewHeight, alignToTop === true, doc);\n    }\n  };\n  const intoWindow = (editor, doc, scrollTop, marker, alignToTop) => {\n    const viewHeight = defaultView(doc).dom.innerHeight;\n    intoWindowIfNeeded(editor, doc, scrollTop, viewHeight, marker, alignToTop);\n  };\n  const intoFrame = (editor, doc, scrollTop, marker, alignToTop) => {\n    const frameViewHeight = defaultView(doc).dom.innerHeight;\n    intoWindowIfNeeded(editor, doc, scrollTop, frameViewHeight, marker, alignToTop);\n    const op = find(marker.element);\n    const viewportBounds = getBounds(window);\n    if (op.top < viewportBounds.y) {\n      intoView(marker.element, alignToTop !== false);\n    } else if (op.top > viewportBounds.bottom) {\n      intoView(marker.element, alignToTop === true);\n    }\n  };\n  const rangeIntoWindow = (editor, rng, alignToTop) => withMarker(editor, intoWindow, rng, alignToTop);\n  const elementIntoWindow = (editor, element, alignToTop) => withElement(editor, element, intoWindow, alignToTop);\n  const rangeIntoFrame = (editor, rng, alignToTop) => withMarker(editor, intoFrame, rng, alignToTop);\n  const elementIntoFrame = (editor, element, alignToTop) => withElement(editor, element, intoFrame, alignToTop);\n  const scrollElementIntoView = (editor, element, alignToTop) => {\n    const scroller = editor.inline ? elementIntoWindow : elementIntoFrame;\n    scroller(editor, element, alignToTop);\n  };\n  const scrollRangeIntoView = (editor, rng, alignToTop) => {\n    const scroller = editor.inline ? rangeIntoWindow : rangeIntoFrame;\n    scroller(editor, rng, alignToTop);\n  };\n  const focus$1 = (element, preventScroll = false) => element.dom.focus({\n    preventScroll\n  });\n  const hasFocus$1 = element => {\n    const root = getRootNode(element).dom;\n    return element.dom === root.activeElement;\n  };\n  const active$1 = (root = getDocument()) => Optional.from(root.dom.activeElement).map(SugarElement.fromDom);\n  const search = element => active$1(getRootNode(element)).filter(e => element.dom.contains(e.dom));\n  const clamp$1 = (offset, element) => {\n    const max = isText$c(element) ? get$3(element).length : children$1(element).length + 1;\n    if (offset > max) {\n      return max;\n    } else if (offset < 0) {\n      return 0;\n    }\n    return offset;\n  };\n  const normalizeRng = rng => SimSelection.range(rng.start, clamp$1(rng.soffset, rng.start), rng.finish, clamp$1(rng.foffset, rng.finish));\n  const isOrContains = (root, elm) => !isRestrictedNode(elm.dom) && (contains(root, elm) || eq(root, elm));\n  const isRngInRoot = root => rng => isOrContains(root, rng.start) && isOrContains(root, rng.finish);\n  const shouldStore = editor => editor.inline || Env.browser.isFirefox();\n  const nativeRangeToSelectionRange = r => SimSelection.range(SugarElement.fromDom(r.startContainer), r.startOffset, SugarElement.fromDom(r.endContainer), r.endOffset);\n  const readRange = win => {\n    const selection = win.getSelection();\n    const rng = !selection || selection.rangeCount === 0 ? Optional.none() : Optional.from(selection.getRangeAt(0));\n    return rng.map(nativeRangeToSelectionRange);\n  };\n  const getBookmark$1 = root => {\n    const win = defaultView(root);\n    return readRange(win.dom).filter(isRngInRoot(root));\n  };\n  const validate = (root, bookmark) => Optional.from(bookmark).filter(isRngInRoot(root)).map(normalizeRng);\n  const bookmarkToNativeRng = bookmark => {\n    const rng = document.createRange();\n    try {\n      rng.setStart(bookmark.start.dom, bookmark.soffset);\n      rng.setEnd(bookmark.finish.dom, bookmark.foffset);\n      return Optional.some(rng);\n    } catch (_) {\n      return Optional.none();\n    }\n  };\n  const store = editor => {\n    const newBookmark = shouldStore(editor) ? getBookmark$1(SugarElement.fromDom(editor.getBody())) : Optional.none();\n    editor.bookmark = newBookmark.isSome() ? newBookmark : editor.bookmark;\n  };\n  const getRng = editor => {\n    const bookmark = editor.bookmark ? editor.bookmark : Optional.none();\n    return bookmark.bind(x => validate(SugarElement.fromDom(editor.getBody()), x)).bind(bookmarkToNativeRng);\n  };\n  const restore = editor => {\n    getRng(editor).each(rng => editor.selection.setRng(rng));\n  };\n  const isEditorUIElement$1 = elm => {\n    const className = elm.className.toString();\n    return className.indexOf('tox-') !== -1 || className.indexOf('mce-') !== -1;\n  };\n  const FocusManager = {\n    isEditorUIElement: isEditorUIElement$1\n  };\n  const wrappedSetTimeout = (callback, time) => {\n    if (!isNumber(time)) {\n      time = 0;\n    }\n    return setTimeout(callback, time);\n  };\n  const wrappedSetInterval = (callback, time) => {\n    if (!isNumber(time)) {\n      time = 0;\n    }\n    return setInterval(callback, time);\n  };\n  const Delay = {\n    setEditorTimeout: (editor, callback, time) => {\n      return wrappedSetTimeout(() => {\n        if (!editor.removed) {\n          callback();\n        }\n      }, time);\n    },\n    setEditorInterval: (editor, callback, time) => {\n      const timer = wrappedSetInterval(() => {\n        if (!editor.removed) {\n          callback();\n        } else {\n          clearInterval(timer);\n        }\n      }, time);\n      return timer;\n    }\n  };\n  const isManualNodeChange = e => {\n    return e.type === 'nodechange' && e.selectionChange;\n  };\n  const registerPageMouseUp = (editor, throttledStore) => {\n    const mouseUpPage = () => {\n      throttledStore.throttle();\n    };\n    DOMUtils.DOM.bind(document, 'mouseup', mouseUpPage);\n    editor.on('remove', () => {\n      DOMUtils.DOM.unbind(document, 'mouseup', mouseUpPage);\n    });\n  };\n  const registerMouseUp = (editor, throttledStore) => {\n    editor.on('mouseup touchend', _e => {\n      throttledStore.throttle();\n    });\n  };\n  const registerEditorEvents = (editor, throttledStore) => {\n    registerMouseUp(editor, throttledStore);\n    editor.on('keyup NodeChange AfterSetSelectionRange', e => {\n      if (!isManualNodeChange(e)) {\n        store(editor);\n      }\n    });\n  };\n  const register$6 = editor => {\n    const throttledStore = first$1(() => {\n      store(editor);\n    }, 0);\n    editor.on('init', () => {\n      if (editor.inline) {\n        registerPageMouseUp(editor, throttledStore);\n      }\n      registerEditorEvents(editor, throttledStore);\n    });\n    editor.on('remove', () => {\n      throttledStore.cancel();\n    });\n  };\n  let documentFocusInHandler;\n  const DOM$9 = DOMUtils.DOM;\n  const isEditorUIElement = elm => {\n    return isElement$6(elm) && FocusManager.isEditorUIElement(elm);\n  };\n  const isEditorContentAreaElement = elm => {\n    const classList = elm.classList;\n    if (classList !== undefined) {\n      return classList.contains('tox-edit-area') || classList.contains('tox-edit-area__iframe') || classList.contains('mce-content-body');\n    } else {\n      return false;\n    }\n  };\n  const isUIElement = (editor, elm) => {\n    const customSelector = getCustomUiSelector(editor);\n    const parent = DOM$9.getParent(elm, elm => {\n      return isEditorUIElement(elm) || (customSelector ? editor.dom.is(elm, customSelector) : false);\n    });\n    return parent !== null;\n  };\n  const getActiveElement = editor => {\n    try {\n      const root = getRootNode(SugarElement.fromDom(editor.getElement()));\n      return active$1(root).fold(() => document.body, x => x.dom);\n    } catch (ex) {\n      return document.body;\n    }\n  };\n  const registerEvents$1 = (editorManager, e) => {\n    const editor = e.editor;\n    register$6(editor);\n    const toggleContentAreaOnFocus = (editor, fn) => {\n      if (shouldHighlightOnFocus(editor) && editor.inline !== true) {\n        const contentArea = SugarElement.fromDom(editor.getContainer());\n        fn(contentArea, 'tox-edit-focus');\n      }\n    };\n    editor.on('focusin', () => {\n      const focusedEditor = editorManager.focusedEditor;\n      if (isEditorContentAreaElement(getActiveElement(editor))) {\n        toggleContentAreaOnFocus(editor, add$2);\n      }\n      if (focusedEditor !== editor) {\n        if (focusedEditor) {\n          focusedEditor.dispatch('blur', {\n            focusedEditor: editor\n          });\n        }\n        editorManager.setActive(editor);\n        editorManager.focusedEditor = editor;\n        editor.dispatch('focus', {\n          blurredEditor: focusedEditor\n        });\n        editor.focus(true);\n      }\n    });\n    editor.on('focusout', () => {\n      Delay.setEditorTimeout(editor, () => {\n        const focusedEditor = editorManager.focusedEditor;\n        if (!isEditorContentAreaElement(getActiveElement(editor)) || focusedEditor !== editor) {\n          toggleContentAreaOnFocus(editor, remove$6);\n        }\n        if (!isUIElement(editor, getActiveElement(editor)) && focusedEditor === editor) {\n          editor.dispatch('blur', {\n            focusedEditor: null\n          });\n          editorManager.focusedEditor = null;\n        }\n      });\n    });\n    if (!documentFocusInHandler) {\n      documentFocusInHandler = e => {\n        const activeEditor = editorManager.activeEditor;\n        if (activeEditor) {\n          getOriginalEventTarget(e).each(target => {\n            const elem = target;\n            if (elem.ownerDocument === document) {\n              if (elem !== document.body && !isUIElement(activeEditor, elem) && editorManager.focusedEditor === activeEditor) {\n                activeEditor.dispatch('blur', {\n                  focusedEditor: null\n                });\n                editorManager.focusedEditor = null;\n              }\n            }\n          });\n        }\n      };\n      DOM$9.bind(document, 'focusin', documentFocusInHandler);\n    }\n  };\n  const unregisterDocumentEvents = (editorManager, e) => {\n    if (editorManager.focusedEditor === e.editor) {\n      editorManager.focusedEditor = null;\n    }\n    if (!editorManager.activeEditor && documentFocusInHandler) {\n      DOM$9.unbind(document, 'focusin', documentFocusInHandler);\n      documentFocusInHandler = null;\n    }\n  };\n  const setup$w = editorManager => {\n    editorManager.on('AddEditor', curry(registerEvents$1, editorManager));\n    editorManager.on('RemoveEditor', curry(unregisterDocumentEvents, editorManager));\n  };\n  const getContentEditableHost = (editor, node) => editor.dom.getParent(node, node => editor.dom.getContentEditable(node) === 'true');\n  const hasContentEditableFalseParent = (editor, node) => editor.dom.getParent(node, node => editor.dom.getContentEditable(node) === 'false') !== null;\n  const getCollapsedNode = rng => rng.collapsed ? Optional.from(getNode$1(rng.startContainer, rng.startOffset)).map(SugarElement.fromDom) : Optional.none();\n  const getFocusInElement = (root, rng) => getCollapsedNode(rng).bind(node => {\n    if (isTableSection(node)) {\n      return Optional.some(node);\n    } else if (!contains(root, node)) {\n      return Optional.some(root);\n    } else {\n      return Optional.none();\n    }\n  });\n  const normalizeSelection = (editor, rng) => {\n    getFocusInElement(SugarElement.fromDom(editor.getBody()), rng).bind(elm => {\n      return firstPositionIn(elm.dom);\n    }).fold(() => {\n      editor.selection.normalize();\n    }, caretPos => editor.selection.setRng(caretPos.toRange()));\n  };\n  const focusBody = body => {\n    if (body.setActive) {\n      try {\n        body.setActive();\n      } catch (ex) {\n        body.focus();\n      }\n    } else {\n      body.focus();\n    }\n  };\n  const hasElementFocus = elm => hasFocus$1(elm) || search(elm).isSome();\n  const hasIframeFocus = editor => isNonNullable(editor.iframeElement) && hasFocus$1(SugarElement.fromDom(editor.iframeElement));\n  const hasInlineFocus = editor => {\n    const rawBody = editor.getBody();\n    return rawBody && hasElementFocus(SugarElement.fromDom(rawBody));\n  };\n  const hasUiFocus = editor => {\n    const dos = getRootNode(SugarElement.fromDom(editor.getElement()));\n    return active$1(dos).filter(elem => !isEditorContentAreaElement(elem.dom) && isUIElement(editor, elem.dom)).isSome();\n  };\n  const hasFocus = editor => editor.inline ? hasInlineFocus(editor) : hasIframeFocus(editor);\n  const hasEditorOrUiFocus = editor => hasFocus(editor) || hasUiFocus(editor);\n  const focusEditor = editor => {\n    const selection = editor.selection;\n    const body = editor.getBody();\n    let rng = selection.getRng();\n    editor.quirks.refreshContentEditable();\n    const restoreBookmark = editor => {\n      getRng(editor).each(bookmarkRng => {\n        editor.selection.setRng(bookmarkRng);\n        rng = bookmarkRng;\n      });\n    };\n    if (!hasFocus(editor) && editor.hasEditableRoot()) {\n      restoreBookmark(editor);\n    }\n    const contentEditableHost = getContentEditableHost(editor, selection.getNode());\n    if (contentEditableHost && editor.dom.isChildOf(contentEditableHost, body)) {\n      if (!hasContentEditableFalseParent(editor, contentEditableHost)) {\n        focusBody(body);\n      }\n      focusBody(contentEditableHost);\n      if (!editor.hasEditableRoot()) {\n        restoreBookmark(editor);\n      }\n      normalizeSelection(editor, rng);\n      activateEditor(editor);\n      return;\n    }\n    if (!editor.inline) {\n      if (!Env.browser.isOpera()) {\n        focusBody(body);\n      }\n      editor.getWin().focus();\n    }\n    if (Env.browser.isFirefox() || editor.inline) {\n      focusBody(body);\n      normalizeSelection(editor, rng);\n    }\n    activateEditor(editor);\n  };\n  const activateEditor = editor => editor.editorManager.setActive(editor);\n  const focus = (editor, skipFocus) => {\n    if (editor.removed) {\n      return;\n    }\n    if (skipFocus) {\n      activateEditor(editor);\n    } else {\n      focusEditor(editor);\n    }\n  };\n  const isEditableRange = (dom, rng) => {\n    if (rng.collapsed) {\n      return dom.isEditable(rng.startContainer);\n    } else {\n      return dom.isEditable(rng.startContainer) && dom.isEditable(rng.endContainer);\n    }\n  };\n  const getEndpointElement = (root, rng, start, real, resolve) => {\n    const container = start ? rng.startContainer : rng.endContainer;\n    const offset = start ? rng.startOffset : rng.endOffset;\n    return Optional.from(container).map(SugarElement.fromDom).map(elm => !real || !rng.collapsed ? child$1(elm, resolve(elm, offset)).getOr(elm) : elm).bind(elm => isElement$7(elm) ? Optional.some(elm) : parent(elm).filter(isElement$7)).map(elm => elm.dom).getOr(root);\n  };\n  const getStart = (root, rng, real = false) => getEndpointElement(root, rng, true, real, (elm, offset) => Math.min(childNodesCount(elm), offset));\n  const getEnd = (root, rng, real = false) => getEndpointElement(root, rng, false, real, (elm, offset) => offset > 0 ? offset - 1 : offset);\n  const skipEmptyTextNodes = (node, forwards) => {\n    const orig = node;\n    while (node && isText$b(node) && node.length === 0) {\n      node = forwards ? node.nextSibling : node.previousSibling;\n    }\n    return node || orig;\n  };\n  const getNode = (root, rng) => {\n    if (!rng) {\n      return root;\n    }\n    let startContainer = rng.startContainer;\n    let endContainer = rng.endContainer;\n    const startOffset = rng.startOffset;\n    const endOffset = rng.endOffset;\n    let node = rng.commonAncestorContainer;\n    if (!rng.collapsed) {\n      if (startContainer === endContainer) {\n        if (endOffset - startOffset < 2) {\n          if (startContainer.hasChildNodes()) {\n            node = startContainer.childNodes[startOffset];\n          }\n        }\n      }\n      if (isText$b(startContainer) && isText$b(endContainer)) {\n        if (startContainer.length === startOffset) {\n          startContainer = skipEmptyTextNodes(startContainer.nextSibling, true);\n        } else {\n          startContainer = startContainer.parentNode;\n        }\n        if (endOffset === 0) {\n          endContainer = skipEmptyTextNodes(endContainer.previousSibling, false);\n        } else {\n          endContainer = endContainer.parentNode;\n        }\n        if (startContainer && startContainer === endContainer) {\n          node = startContainer;\n        }\n      }\n    }\n    const elm = isText$b(node) ? node.parentNode : node;\n    return isHTMLElement(elm) ? elm : root;\n  };\n  const getSelectedBlocks = (dom, rng, startElm, endElm) => {\n    const selectedBlocks = [];\n    const root = dom.getRoot();\n    const start = dom.getParent(startElm || getStart(root, rng, rng.collapsed), dom.isBlock);\n    const end = dom.getParent(endElm || getEnd(root, rng, rng.collapsed), dom.isBlock);\n    if (start && start !== root) {\n      selectedBlocks.push(start);\n    }\n    if (start && end && start !== end) {\n      let node;\n      const walker = new DomTreeWalker(start, root);\n      while ((node = walker.next()) && node !== end) {\n        if (dom.isBlock(node)) {\n          selectedBlocks.push(node);\n        }\n      }\n    }\n    if (end && start !== end && end !== root) {\n      selectedBlocks.push(end);\n    }\n    return selectedBlocks;\n  };\n  const select = (dom, node, content) => Optional.from(node).bind(node => Optional.from(node.parentNode).map(parent => {\n    const idx = dom.nodeIndex(node);\n    const rng = dom.createRng();\n    rng.setStart(parent, idx);\n    rng.setEnd(parent, idx + 1);\n    if (content) {\n      moveEndPoint(dom, rng, node, true);\n      moveEndPoint(dom, rng, node, false);\n    }\n    return rng;\n  }));\n  const processRanges = (editor, ranges) => map$3(ranges, range => {\n    const evt = editor.dispatch('GetSelectionRange', {\n      range\n    });\n    return evt.range !== range ? evt.range : range;\n  });\n  const typeLookup = {\n    '#text': 3,\n    '#comment': 8,\n    '#cdata': 4,\n    '#pi': 7,\n    '#doctype': 10,\n    '#document-fragment': 11\n  };\n  const walk$2 = (node, root, prev) => {\n    const startName = prev ? 'lastChild' : 'firstChild';\n    const siblingName = prev ? 'prev' : 'next';\n    if (node[startName]) {\n      return node[startName];\n    }\n    if (node !== root) {\n      let sibling = node[siblingName];\n      if (sibling) {\n        return sibling;\n      }\n      for (let parent = node.parent; parent && parent !== root; parent = parent.parent) {\n        sibling = parent[siblingName];\n        if (sibling) {\n          return sibling;\n        }\n      }\n    }\n    return undefined;\n  };\n  const isEmptyTextNode = node => {\n    var _a;\n    const text = (_a = node.value) !== null && _a !== void 0 ? _a : '';\n    if (!isWhitespaceText(text)) {\n      return false;\n    }\n    const parentNode = node.parent;\n    if (parentNode && (parentNode.name !== 'span' || parentNode.attr('style')) && /^[ ]+$/.test(text)) {\n      return false;\n    }\n    return true;\n  };\n  const isNonEmptyElement = node => {\n    const isNamedAnchor = node.name === 'a' && !node.attr('href') && node.attr('id');\n    return node.attr('name') || node.attr('id') && !node.firstChild || node.attr('data-mce-bookmark') || isNamedAnchor;\n  };\n  class AstNode {\n    static create(name, attrs) {\n      const node = new AstNode(name, typeLookup[name] || 1);\n      if (attrs) {\n        each$d(attrs, (value, attrName) => {\n          node.attr(attrName, value);\n        });\n      }\n      return node;\n    }\n    constructor(name, type) {\n      this.name = name;\n      this.type = type;\n      if (type === 1) {\n        this.attributes = [];\n        this.attributes.map = {};\n      }\n    }\n    replace(node) {\n      const self = this;\n      if (node.parent) {\n        node.remove();\n      }\n      self.insert(node, self);\n      self.remove();\n      return self;\n    }\n    attr(name, value) {\n      const self = this;\n      if (!isString(name)) {\n        if (isNonNullable(name)) {\n          each$d(name, (value, key) => {\n            self.attr(key, value);\n          });\n        }\n        return self;\n      }\n      const attrs = self.attributes;\n      if (attrs) {\n        if (value !== undefined) {\n          if (value === null) {\n            if (name in attrs.map) {\n              delete attrs.map[name];\n              let i = attrs.length;\n              while (i--) {\n                if (attrs[i].name === name) {\n                  attrs.splice(i, 1);\n                  return self;\n                }\n              }\n            }\n            return self;\n          }\n          if (name in attrs.map) {\n            let i = attrs.length;\n            while (i--) {\n              if (attrs[i].name === name) {\n                attrs[i].value = value;\n                break;\n              }\n            }\n          } else {\n            attrs.push({\n              name,\n              value\n            });\n          }\n          attrs.map[name] = value;\n          return self;\n        }\n        return attrs.map[name];\n      }\n      return undefined;\n    }\n    clone() {\n      const self = this;\n      const clone = new AstNode(self.name, self.type);\n      const selfAttrs = self.attributes;\n      if (selfAttrs) {\n        const cloneAttrs = [];\n        cloneAttrs.map = {};\n        for (let i = 0, l = selfAttrs.length; i < l; i++) {\n          const selfAttr = selfAttrs[i];\n          if (selfAttr.name !== 'id') {\n            cloneAttrs[cloneAttrs.length] = {\n              name: selfAttr.name,\n              value: selfAttr.value\n            };\n            cloneAttrs.map[selfAttr.name] = selfAttr.value;\n          }\n        }\n        clone.attributes = cloneAttrs;\n      }\n      clone.value = self.value;\n      return clone;\n    }\n    wrap(wrapper) {\n      const self = this;\n      if (self.parent) {\n        self.parent.insert(wrapper, self);\n        wrapper.append(self);\n      }\n      return self;\n    }\n    unwrap() {\n      const self = this;\n      for (let node = self.firstChild; node;) {\n        const next = node.next;\n        self.insert(node, self, true);\n        node = next;\n      }\n      self.remove();\n    }\n    remove() {\n      const self = this,\n        parent = self.parent,\n        next = self.next,\n        prev = self.prev;\n      if (parent) {\n        if (parent.firstChild === self) {\n          parent.firstChild = next;\n          if (next) {\n            next.prev = null;\n          }\n        } else if (prev) {\n          prev.next = next;\n        }\n        if (parent.lastChild === self) {\n          parent.lastChild = prev;\n          if (prev) {\n            prev.next = null;\n          }\n        } else if (next) {\n          next.prev = prev;\n        }\n        self.parent = self.next = self.prev = null;\n      }\n      return self;\n    }\n    append(node) {\n      const self = this;\n      if (node.parent) {\n        node.remove();\n      }\n      const last = self.lastChild;\n      if (last) {\n        last.next = node;\n        node.prev = last;\n        self.lastChild = node;\n      } else {\n        self.lastChild = self.firstChild = node;\n      }\n      node.parent = self;\n      return node;\n    }\n    insert(node, refNode, before) {\n      if (node.parent) {\n        node.remove();\n      }\n      const parent = refNode.parent || this;\n      if (before) {\n        if (refNode === parent.firstChild) {\n          parent.firstChild = node;\n        } else if (refNode.prev) {\n          refNode.prev.next = node;\n        }\n        node.prev = refNode.prev;\n        node.next = refNode;\n        refNode.prev = node;\n      } else {\n        if (refNode === parent.lastChild) {\n          parent.lastChild = node;\n        } else if (refNode.next) {\n          refNode.next.prev = node;\n        }\n        node.next = refNode.next;\n        node.prev = refNode;\n        refNode.next = node;\n      }\n      node.parent = parent;\n      return node;\n    }\n    getAll(name) {\n      const self = this;\n      const collection = [];\n      for (let node = self.firstChild; node; node = walk$2(node, self)) {\n        if (node.name === name) {\n          collection.push(node);\n        }\n      }\n      return collection;\n    }\n    children() {\n      const self = this;\n      const collection = [];\n      for (let node = self.firstChild; node; node = node.next) {\n        collection.push(node);\n      }\n      return collection;\n    }\n    empty() {\n      const self = this;\n      if (self.firstChild) {\n        const nodes = [];\n        for (let node = self.firstChild; node; node = walk$2(node, self)) {\n          nodes.push(node);\n        }\n        let i = nodes.length;\n        while (i--) {\n          const node = nodes[i];\n          node.parent = node.firstChild = node.lastChild = node.next = node.prev = null;\n        }\n      }\n      self.firstChild = self.lastChild = null;\n      return self;\n    }\n    isEmpty(elements, whitespace = {}, predicate) {\n      var _a;\n      const self = this;\n      let node = self.firstChild;\n      if (isNonEmptyElement(self)) {\n        return false;\n      }\n      if (node) {\n        do {\n          if (node.type === 1) {\n            if (node.attr('data-mce-bogus')) {\n              continue;\n            }\n            if (elements[node.name]) {\n              return false;\n            }\n            if (isNonEmptyElement(node)) {\n              return false;\n            }\n          }\n          if (node.type === 8) {\n            return false;\n          }\n          if (node.type === 3 && !isEmptyTextNode(node)) {\n            return false;\n          }\n          if (node.type === 3 && node.parent && whitespace[node.parent.name] && isWhitespaceText((_a = node.value) !== null && _a !== void 0 ? _a : '')) {\n            return false;\n          }\n          if (predicate && predicate(node)) {\n            return false;\n          }\n        } while (node = walk$2(node, self));\n      }\n      return true;\n    }\n    walk(prev) {\n      return walk$2(this, null, prev);\n    }\n  }\n  const unescapedTextParents = Tools.makeMap('NOSCRIPT STYLE SCRIPT XMP IFRAME NOEMBED NOFRAMES PLAINTEXT', ' ');\n  const containsZwsp = node => isString(node.nodeValue) && node.nodeValue.includes(ZWSP$1);\n  const getTemporaryNodeSelector = tempAttrs => `${tempAttrs.length === 0 ? '' : `${map$3(tempAttrs, attr => `[${attr}]`).join(',')},`}[data-mce-bogus=\"all\"]`;\n  const getTemporaryNodes = (tempAttrs, body) => body.querySelectorAll(getTemporaryNodeSelector(tempAttrs));\n  const createZwspCommentWalker = body => document.createTreeWalker(body, NodeFilter.SHOW_COMMENT, node => containsZwsp(node) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP);\n  const createUnescapedZwspTextWalker = body => document.createTreeWalker(body, NodeFilter.SHOW_TEXT, node => {\n    if (containsZwsp(node)) {\n      const parent = node.parentNode;\n      return parent && has$2(unescapedTextParents, parent.nodeName) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;\n    } else {\n      return NodeFilter.FILTER_SKIP;\n    }\n  });\n  const hasZwspComment = body => createZwspCommentWalker(body).nextNode() !== null;\n  const hasUnescapedZwspText = body => createUnescapedZwspTextWalker(body).nextNode() !== null;\n  const hasTemporaryNode = (tempAttrs, body) => body.querySelector(getTemporaryNodeSelector(tempAttrs)) !== null;\n  const trimTemporaryNodes = (tempAttrs, body) => {\n    each$e(getTemporaryNodes(tempAttrs, body), elm => {\n      const element = SugarElement.fromDom(elm);\n      if (get$9(element, 'data-mce-bogus') === 'all') {\n        remove$4(element);\n      } else {\n        each$e(tempAttrs, attr => {\n          if (has$1(element, attr)) {\n            remove$9(element, attr);\n          }\n        });\n      }\n    });\n  };\n  const emptyAllNodeValuesInWalker = walker => {\n    let curr = walker.nextNode();\n    while (curr !== null) {\n      curr.nodeValue = null;\n      curr = walker.nextNode();\n    }\n  };\n  const emptyZwspComments = compose(emptyAllNodeValuesInWalker, createZwspCommentWalker);\n  const emptyUnescapedZwspTexts = compose(emptyAllNodeValuesInWalker, createUnescapedZwspTextWalker);\n  const trim$1 = (body, tempAttrs) => {\n    const conditionalTrims = [{\n      condition: curry(hasTemporaryNode, tempAttrs),\n      action: curry(trimTemporaryNodes, tempAttrs)\n    }, {\n      condition: hasZwspComment,\n      action: emptyZwspComments\n    }, {\n      condition: hasUnescapedZwspText,\n      action: emptyUnescapedZwspTexts\n    }];\n    let trimmed = body;\n    let cloned = false;\n    each$e(conditionalTrims, ({\n      condition,\n      action\n    }) => {\n      if (condition(trimmed)) {\n        if (!cloned) {\n          trimmed = body.cloneNode(true);\n          cloned = true;\n        }\n        action(trimmed);\n      }\n    });\n    return trimmed;\n  };\n  const cleanupBogusElements = parent => {\n    const bogusElements = descendants(parent, '[data-mce-bogus]');\n    each$e(bogusElements, elem => {\n      const bogusValue = get$9(elem, 'data-mce-bogus');\n      if (bogusValue === 'all') {\n        remove$4(elem);\n      } else if (isBr$5(elem)) {\n        before$3(elem, SugarElement.fromText(zeroWidth));\n        remove$4(elem);\n      } else {\n        unwrap(elem);\n      }\n    });\n  };\n  const cleanupInputNames = parent => {\n    const inputs = descendants(parent, 'input');\n    each$e(inputs, input => {\n      remove$9(input, 'name');\n    });\n  };\n  const trimEmptyContents = (editor, html) => {\n    const blockName = getForcedRootBlock(editor);\n    const emptyRegExp = new RegExp(`^(<${blockName}[^>]*>(&nbsp;|&#160;|\\\\s|\\u00a0|<br \\\\/>|)<\\\\/${blockName}>[\\r\\n]*|<br \\\\/>[\\r\\n]*)$`);\n    return html.replace(emptyRegExp, '');\n  };\n  const getPlainTextContent = (editor, body) => {\n    const doc = editor.getDoc();\n    const dos = getRootNode(SugarElement.fromDom(editor.getBody()));\n    const offscreenDiv = SugarElement.fromTag('div', doc);\n    set$3(offscreenDiv, 'data-mce-bogus', 'all');\n    setAll(offscreenDiv, {\n      position: 'fixed',\n      left: '-9999999px',\n      top: '0'\n    });\n    set$1(offscreenDiv, body.innerHTML);\n    cleanupBogusElements(offscreenDiv);\n    cleanupInputNames(offscreenDiv);\n    const root = getContentContainer(dos);\n    append$1(root, offscreenDiv);\n    const content = trim$2(offscreenDiv.dom.innerText);\n    remove$4(offscreenDiv);\n    return content;\n  };\n  const getContentFromBody = (editor, args, body) => {\n    let content;\n    if (args.format === 'raw') {\n      content = Tools.trim(trim$2(trim$1(body, editor.serializer.getTempAttrs()).innerHTML));\n    } else if (args.format === 'text') {\n      content = getPlainTextContent(editor, body);\n    } else if (args.format === 'tree') {\n      content = editor.serializer.serialize(body, args);\n    } else {\n      content = trimEmptyContents(editor, editor.serializer.serialize(body, args));\n    }\n    const shouldTrim = args.format !== 'text' && !isWsPreserveElement(SugarElement.fromDom(body));\n    return shouldTrim && isString(content) ? Tools.trim(content) : content;\n  };\n  const getContentInternal = (editor, args) => Optional.from(editor.getBody()).fold(constant(args.format === 'tree' ? new AstNode('body', 11) : ''), body => getContentFromBody(editor, args, body));\n  const makeMap$1 = Tools.makeMap;\n  const Writer = settings => {\n    const html = [];\n    settings = settings || {};\n    const indent = settings.indent;\n    const indentBefore = makeMap$1(settings.indent_before || '');\n    const indentAfter = makeMap$1(settings.indent_after || '');\n    const encode = Entities.getEncodeFunc(settings.entity_encoding || 'raw', settings.entities);\n    const htmlOutput = settings.element_format !== 'xhtml';\n    return {\n      start: (name, attrs, empty) => {\n        if (indent && indentBefore[name] && html.length > 0) {\n          const value = html[html.length - 1];\n          if (value.length > 0 && value !== '\\n') {\n            html.push('\\n');\n          }\n        }\n        html.push('<', name);\n        if (attrs) {\n          for (let i = 0, l = attrs.length; i < l; i++) {\n            const attr = attrs[i];\n            html.push(' ', attr.name, '=\"', encode(attr.value, true), '\"');\n          }\n        }\n        if (!empty || htmlOutput) {\n          html[html.length] = '>';\n        } else {\n          html[html.length] = ' />';\n        }\n        if (empty && indent && indentAfter[name] && html.length > 0) {\n          const value = html[html.length - 1];\n          if (value.length > 0 && value !== '\\n') {\n            html.push('\\n');\n          }\n        }\n      },\n      end: name => {\n        let value;\n        html.push('</', name, '>');\n        if (indent && indentAfter[name] && html.length > 0) {\n          value = html[html.length - 1];\n          if (value.length > 0 && value !== '\\n') {\n            html.push('\\n');\n          }\n        }\n      },\n      text: (text, raw) => {\n        if (text.length > 0) {\n          html[html.length] = raw ? text : encode(text);\n        }\n      },\n      cdata: text => {\n        html.push('<![CDATA[', text, ']]>');\n      },\n      comment: text => {\n        html.push('<!--', text, '-->');\n      },\n      pi: (name, text) => {\n        if (text) {\n          html.push('<?', name, ' ', encode(text), '?>');\n        } else {\n          html.push('<?', name, '?>');\n        }\n        if (indent) {\n          html.push('\\n');\n        }\n      },\n      doctype: text => {\n        html.push('<!DOCTYPE', text, '>', indent ? '\\n' : '');\n      },\n      reset: () => {\n        html.length = 0;\n      },\n      getContent: () => {\n        return html.join('').replace(/\\n$/, '');\n      }\n    };\n  };\n  const HtmlSerializer = (settings = {}, schema = Schema()) => {\n    const writer = Writer(settings);\n    settings.validate = 'validate' in settings ? settings.validate : true;\n    const serialize = node => {\n      const validate = settings.validate;\n      const handlers = {\n        3: node => {\n          var _a;\n          writer.text((_a = node.value) !== null && _a !== void 0 ? _a : '', node.raw);\n        },\n        8: node => {\n          var _a;\n          writer.comment((_a = node.value) !== null && _a !== void 0 ? _a : '');\n        },\n        7: node => {\n          writer.pi(node.name, node.value);\n        },\n        10: node => {\n          var _a;\n          writer.doctype((_a = node.value) !== null && _a !== void 0 ? _a : '');\n        },\n        4: node => {\n          var _a;\n          writer.cdata((_a = node.value) !== null && _a !== void 0 ? _a : '');\n        },\n        11: node => {\n          let tempNode = node;\n          if (tempNode = tempNode.firstChild) {\n            do {\n              walk(tempNode);\n            } while (tempNode = tempNode.next);\n          }\n        }\n      };\n      writer.reset();\n      const walk = node => {\n        var _a;\n        const handler = handlers[node.type];\n        if (!handler) {\n          const name = node.name;\n          const isEmpty = name in schema.getVoidElements();\n          let attrs = node.attributes;\n          if (validate && attrs && attrs.length > 1) {\n            const sortedAttrs = [];\n            sortedAttrs.map = {};\n            const elementRule = schema.getElementRule(node.name);\n            if (elementRule) {\n              for (let i = 0, l = elementRule.attributesOrder.length; i < l; i++) {\n                const attrName = elementRule.attributesOrder[i];\n                if (attrName in attrs.map) {\n                  const attrValue = attrs.map[attrName];\n                  sortedAttrs.map[attrName] = attrValue;\n                  sortedAttrs.push({\n                    name: attrName,\n                    value: attrValue\n                  });\n                }\n              }\n              for (let i = 0, l = attrs.length; i < l; i++) {\n                const attrName = attrs[i].name;\n                if (!(attrName in sortedAttrs.map)) {\n                  const attrValue = attrs.map[attrName];\n                  sortedAttrs.map[attrName] = attrValue;\n                  sortedAttrs.push({\n                    name: attrName,\n                    value: attrValue\n                  });\n                }\n              }\n              attrs = sortedAttrs;\n            }\n          }\n          writer.start(name, attrs, isEmpty);\n          if (isNonHtmlElementRootName(name)) {\n            if (isString(node.value)) {\n              writer.text(node.value, true);\n            }\n            writer.end(name);\n          } else {\n            if (!isEmpty) {\n              let child = node.firstChild;\n              if (child) {\n                if ((name === 'pre' || name === 'textarea') && child.type === 3 && ((_a = child.value) === null || _a === void 0 ? void 0 : _a[0]) === '\\n') {\n                  writer.text('\\n', true);\n                }\n                do {\n                  walk(child);\n                } while (child = child.next);\n              }\n              writer.end(name);\n            }\n          }\n        } else {\n          handler(node);\n        }\n      };\n      if (node.type === 1 && !settings.inner) {\n        walk(node);\n      } else if (node.type === 3) {\n        handlers[3](node);\n      } else {\n        handlers[11](node);\n      }\n      return writer.getContent();\n    };\n    return {\n      serialize\n    };\n  };\n  const nonInheritableStyles = new Set();\n  (() => {\n    const nonInheritableStylesArr = ['margin', 'margin-left', 'margin-right', 'margin-top', 'margin-bottom', 'padding', 'padding-left', 'padding-right', 'padding-top', 'padding-bottom', 'border', 'border-width', 'border-style', 'border-color', 'background', 'background-attachment', 'background-clip', 'background-image', 'background-origin', 'background-position', 'background-repeat', 'background-size', 'float', 'position', 'left', 'right', 'top', 'bottom', 'z-index', 'display', 'transform', 'width', 'max-width', 'min-width', 'height', 'max-height', 'min-height', 'overflow', 'overflow-x', 'overflow-y', 'text-overflow', 'vertical-align', 'transition', 'transition-delay', 'transition-duration', 'transition-property', 'transition-timing-function'];\n    each$e(nonInheritableStylesArr, style => {\n      nonInheritableStyles.add(style);\n    });\n  })();\n  const conditionalNonInheritableStyles = new Set();\n  (() => {\n    const conditionalNonInheritableStylesArr = ['background-color'];\n    each$e(conditionalNonInheritableStylesArr, style => {\n      conditionalNonInheritableStyles.add(style);\n    });\n  })();\n  const shorthandStyleProps = ['font', 'text-decoration', 'text-emphasis'];\n  const getStyles$1 = (dom, node) => dom.parseStyle(dom.getAttrib(node, 'style'));\n  const getStyleProps = (dom, node) => keys(getStyles$1(dom, node));\n  const isNonInheritableStyle = style => nonInheritableStyles.has(style);\n  const isConditionalNonInheritableStyle = style => conditionalNonInheritableStyles.has(style);\n  const hasNonInheritableStyles = (dom, node) => exists(getStyleProps(dom, node), style => isNonInheritableStyle(style));\n  const hasConditionalNonInheritableStyles = (dom, node) => hasNonInheritableStyles(dom, node) && exists(getStyleProps(dom, node), style => isConditionalNonInheritableStyle(style));\n  const getLonghandStyleProps = styles => filter$5(styles, style => exists(shorthandStyleProps, prop => startsWith(style, prop)));\n  const hasStyleConflict = (dom, node, parentNode) => {\n    const nodeStyleProps = getStyleProps(dom, node);\n    const parentNodeStyleProps = getStyleProps(dom, parentNode);\n    const valueMismatch = prop => {\n      var _a, _b;\n      const nodeValue = (_a = dom.getStyle(node, prop)) !== null && _a !== void 0 ? _a : '';\n      const parentValue = (_b = dom.getStyle(parentNode, prop)) !== null && _b !== void 0 ? _b : '';\n      return isNotEmpty(nodeValue) && isNotEmpty(parentValue) && nodeValue !== parentValue;\n    };\n    return exists(nodeStyleProps, nodeStyleProp => {\n      const propExists = props => exists(props, prop => prop === nodeStyleProp);\n      if (!propExists(parentNodeStyleProps) && propExists(shorthandStyleProps)) {\n        const longhandProps = getLonghandStyleProps(parentNodeStyleProps);\n        return exists(longhandProps, valueMismatch);\n      } else {\n        return valueMismatch(nodeStyleProp);\n      }\n    });\n  };\n  const isChar = (forward, predicate, pos) => Optional.from(pos.container()).filter(isText$b).exists(text => {\n    const delta = forward ? 0 : -1;\n    return predicate(text.data.charAt(pos.offset() + delta));\n  });\n  const isBeforeSpace = curry(isChar, true, isWhiteSpace);\n  const isAfterSpace = curry(isChar, false, isWhiteSpace);\n  const isEmptyText = pos => {\n    const container = pos.container();\n    return isText$b(container) && (container.data.length === 0 || isZwsp(container.data) && BookmarkManager.isBookmarkNode(container.parentNode));\n  };\n  const matchesElementPosition = (before, predicate) => pos => getChildNodeAtRelativeOffset(before ? 0 : -1, pos).filter(predicate).isSome();\n  const isImageBlock = node => isImg(node) && get$7(SugarElement.fromDom(node), 'display') === 'block';\n  const isCefNode = node => isContentEditableFalse$b(node) && !isBogusAll(node);\n  const isBeforeImageBlock = matchesElementPosition(true, isImageBlock);\n  const isAfterImageBlock = matchesElementPosition(false, isImageBlock);\n  const isBeforeMedia = matchesElementPosition(true, isMedia$2);\n  const isAfterMedia = matchesElementPosition(false, isMedia$2);\n  const isBeforeTable = matchesElementPosition(true, isTable$2);\n  const isAfterTable = matchesElementPosition(false, isTable$2);\n  const isBeforeContentEditableFalse = matchesElementPosition(true, isCefNode);\n  const isAfterContentEditableFalse = matchesElementPosition(false, isCefNode);\n  const dropLast = xs => xs.slice(0, -1);\n  const parentsUntil = (start, root, predicate) => {\n    if (contains(root, start)) {\n      return dropLast(parents$1(start, elm => {\n        return predicate(elm) || eq(elm, root);\n      }));\n    } else {\n      return [];\n    }\n  };\n  const parents = (start, root) => parentsUntil(start, root, never);\n  const parentsAndSelf = (start, root) => [start].concat(parents(start, root));\n  const navigateIgnoreEmptyTextNodes = (forward, root, from) => navigateIgnore(forward, root, from, isEmptyText);\n  const isBlock$1 = schema => el => schema.isBlock(name(el));\n  const getClosestBlock$1 = (root, pos, schema) => find$2(parentsAndSelf(SugarElement.fromDom(pos.container()), root), isBlock$1(schema));\n  const isAtBeforeAfterBlockBoundary = (forward, root, pos, schema) => navigateIgnoreEmptyTextNodes(forward, root.dom, pos).forall(newPos => getClosestBlock$1(root, pos, schema).fold(() => !isInSameBlock(newPos, pos, root.dom), fromBlock => !isInSameBlock(newPos, pos, root.dom) && contains(fromBlock, SugarElement.fromDom(newPos.container()))));\n  const isAtBlockBoundary = (forward, root, pos, schema) => getClosestBlock$1(root, pos, schema).fold(() => navigateIgnoreEmptyTextNodes(forward, root.dom, pos).forall(newPos => !isInSameBlock(newPos, pos, root.dom)), parent => navigateIgnoreEmptyTextNodes(forward, parent.dom, pos).isNone());\n  const isAtStartOfBlock = curry(isAtBlockBoundary, false);\n  const isAtEndOfBlock = curry(isAtBlockBoundary, true);\n  const isBeforeBlock = curry(isAtBeforeAfterBlockBoundary, false);\n  const isAfterBlock = curry(isAtBeforeAfterBlockBoundary, true);\n  const isBr$1 = pos => getElementFromPosition(pos).exists(isBr$5);\n  const findBr = (forward, root, pos, schema) => {\n    const parentBlocks = filter$5(parentsAndSelf(SugarElement.fromDom(pos.container()), root), el => schema.isBlock(name(el)));\n    const scope = head(parentBlocks).getOr(root);\n    return fromPosition(forward, scope.dom, pos).filter(isBr$1);\n  };\n  const isBeforeBr$1 = (root, pos, schema) => getElementFromPosition(pos).exists(isBr$5) || findBr(true, root, pos, schema).isSome();\n  const isAfterBr = (root, pos, schema) => getElementFromPrevPosition(pos).exists(isBr$5) || findBr(false, root, pos, schema).isSome();\n  const findPreviousBr = curry(findBr, false);\n  const findNextBr = curry(findBr, true);\n  const isInMiddleOfText = pos => CaretPosition.isTextPosition(pos) && !pos.isAtStart() && !pos.isAtEnd();\n  const getClosestBlock = (root, pos, schema) => {\n    const parentBlocks = filter$5(parentsAndSelf(SugarElement.fromDom(pos.container()), root), el => schema.isBlock(name(el)));\n    return head(parentBlocks).getOr(root);\n  };\n  const hasSpaceBefore = (root, pos, schema) => {\n    if (isInMiddleOfText(pos)) {\n      return isAfterSpace(pos);\n    } else {\n      return isAfterSpace(pos) || prevPosition(getClosestBlock(root, pos, schema).dom, pos).exists(isAfterSpace);\n    }\n  };\n  const hasSpaceAfter = (root, pos, schema) => {\n    if (isInMiddleOfText(pos)) {\n      return isBeforeSpace(pos);\n    } else {\n      return isBeforeSpace(pos) || nextPosition(getClosestBlock(root, pos, schema).dom, pos).exists(isBeforeSpace);\n    }\n  };\n  const isPreValue = value => contains$2(['pre', 'pre-wrap'], value);\n  const isInPre = pos => getElementFromPosition(pos).bind(elm => closest$4(elm, isElement$7)).exists(elm => isPreValue(get$7(elm, 'white-space')));\n  const isAtBeginningOfBody = (root, pos) => prevPosition(root.dom, pos).isNone();\n  const isAtEndOfBody = (root, pos) => nextPosition(root.dom, pos).isNone();\n  const isAtLineBoundary = (root, pos, schema) => isAtBeginningOfBody(root, pos) || isAtEndOfBody(root, pos) || isAtStartOfBlock(root, pos, schema) || isAtEndOfBlock(root, pos, schema) || isAfterBr(root, pos, schema) || isBeforeBr$1(root, pos, schema);\n  const isCefBlock = node => isNonNullable(node) && isContentEditableFalse$b(node) && isBlockLike(node);\n  const isSiblingCefBlock = (root, direction) => container => {\n    return isCefBlock(new DomTreeWalker(container, root)[direction]());\n  };\n  const isBeforeCefBlock = (root, pos) => {\n    const nextPos = nextPosition(root.dom, pos).getOr(pos);\n    const isNextCefBlock = isSiblingCefBlock(root.dom, 'next');\n    return pos.isAtEnd() && (isNextCefBlock(pos.container()) || isNextCefBlock(nextPos.container()));\n  };\n  const isAfterCefBlock = (root, pos) => {\n    const prevPos = prevPosition(root.dom, pos).getOr(pos);\n    const isPrevCefBlock = isSiblingCefBlock(root.dom, 'prev');\n    return pos.isAtStart() && (isPrevCefBlock(pos.container()) || isPrevCefBlock(prevPos.container()));\n  };\n  const needsToHaveNbsp = (root, pos, schema) => {\n    if (isInPre(pos)) {\n      return false;\n    } else {\n      return isAtLineBoundary(root, pos, schema) || hasSpaceBefore(root, pos, schema) || hasSpaceAfter(root, pos, schema);\n    }\n  };\n  const needsToBeNbspLeft = (root, pos, schema) => {\n    if (isInPre(pos)) {\n      return false;\n    } else {\n      return isAtStartOfBlock(root, pos, schema) || isBeforeBlock(root, pos, schema) || isAfterBr(root, pos, schema) || hasSpaceBefore(root, pos, schema) || isAfterCefBlock(root, pos);\n    }\n  };\n  const leanRight = pos => {\n    const container = pos.container();\n    const offset = pos.offset();\n    if (isText$b(container) && offset < container.data.length) {\n      return CaretPosition(container, offset + 1);\n    } else {\n      return pos;\n    }\n  };\n  const needsToBeNbspRight = (root, pos, schema) => {\n    if (isInPre(pos)) {\n      return false;\n    } else {\n      return isAtEndOfBlock(root, pos, schema) || isAfterBlock(root, pos, schema) || isBeforeBr$1(root, pos, schema) || hasSpaceAfter(root, pos, schema) || isBeforeCefBlock(root, pos);\n    }\n  };\n  const needsToBeNbsp = (root, pos, schema) => needsToBeNbspLeft(root, pos, schema) || needsToBeNbspRight(root, leanRight(pos), schema);\n  const isNbspAt = (text, offset) => isNbsp(text.charAt(offset));\n  const isWhiteSpaceAt = (text, offset) => isWhiteSpace(text.charAt(offset));\n  const hasNbsp = pos => {\n    const container = pos.container();\n    return isText$b(container) && contains$1(container.data, nbsp);\n  };\n  const normalizeNbspMiddle = text => {\n    const chars = text.split('');\n    return map$3(chars, (chr, i) => {\n      if (isNbsp(chr) && i > 0 && i < chars.length - 1 && isContent(chars[i - 1]) && isContent(chars[i + 1])) {\n        return ' ';\n      } else {\n        return chr;\n      }\n    }).join('');\n  };\n  const normalizeNbspAtStart = (root, node, makeNbsp, schema) => {\n    const text = node.data;\n    const firstPos = CaretPosition(node, 0);\n    if (!makeNbsp && isNbspAt(text, 0) && !needsToBeNbsp(root, firstPos, schema)) {\n      node.data = ' ' + text.slice(1);\n      return true;\n    } else if (makeNbsp && isWhiteSpaceAt(text, 0) && needsToBeNbspLeft(root, firstPos, schema)) {\n      node.data = nbsp + text.slice(1);\n      return true;\n    } else {\n      return false;\n    }\n  };\n  const normalizeNbspInMiddleOfTextNode = node => {\n    const text = node.data;\n    const newText = normalizeNbspMiddle(text);\n    if (newText !== text) {\n      node.data = newText;\n      return true;\n    } else {\n      return false;\n    }\n  };\n  const normalizeNbspAtEnd = (root, node, makeNbsp, schema) => {\n    const text = node.data;\n    const lastPos = CaretPosition(node, text.length - 1);\n    if (!makeNbsp && isNbspAt(text, text.length - 1) && !needsToBeNbsp(root, lastPos, schema)) {\n      node.data = text.slice(0, -1) + ' ';\n      return true;\n    } else if (makeNbsp && isWhiteSpaceAt(text, text.length - 1) && needsToBeNbspRight(root, lastPos, schema)) {\n      node.data = text.slice(0, -1) + nbsp;\n      return true;\n    } else {\n      return false;\n    }\n  };\n  const normalizeNbsps$1 = (root, pos, schema) => {\n    const container = pos.container();\n    if (!isText$b(container)) {\n      return Optional.none();\n    }\n    if (hasNbsp(pos)) {\n      const normalized = normalizeNbspAtStart(root, container, false, schema) || normalizeNbspInMiddleOfTextNode(container) || normalizeNbspAtEnd(root, container, false, schema);\n      return someIf(normalized, pos);\n    } else if (needsToBeNbsp(root, pos, schema)) {\n      const normalized = normalizeNbspAtStart(root, container, true, schema) || normalizeNbspAtEnd(root, container, true, schema);\n      return someIf(normalized, pos);\n    } else {\n      return Optional.none();\n    }\n  };\n  const normalizeNbspsInEditor = editor => {\n    const root = SugarElement.fromDom(editor.getBody());\n    if (editor.selection.isCollapsed()) {\n      normalizeNbsps$1(root, CaretPosition.fromRangeStart(editor.selection.getRng()), editor.schema).each(pos => {\n        editor.selection.setRng(pos.toRange());\n      });\n    }\n  };\n  const normalize$1 = (node, offset, count, schema) => {\n    if (count === 0) {\n      return;\n    }\n    const elm = SugarElement.fromDom(node);\n    const root = ancestor$4(elm, el => schema.isBlock(name(el))).getOr(elm);\n    const whitespace = node.data.slice(offset, offset + count);\n    const isEndOfContent = offset + count >= node.data.length && needsToBeNbspRight(root, CaretPosition(node, node.data.length), schema);\n    const isStartOfContent = offset === 0 && needsToBeNbspLeft(root, CaretPosition(node, 0), schema);\n    node.replaceData(offset, count, normalize$4(whitespace, 4, isStartOfContent, isEndOfContent));\n  };\n  const normalizeWhitespaceAfter = (node, offset, schema) => {\n    const content = node.data.slice(offset);\n    const whitespaceCount = content.length - lTrim(content).length;\n    normalize$1(node, offset, whitespaceCount, schema);\n  };\n  const normalizeWhitespaceBefore = (node, offset, schema) => {\n    const content = node.data.slice(0, offset);\n    const whitespaceCount = content.length - rTrim(content).length;\n    normalize$1(node, offset - whitespaceCount, whitespaceCount, schema);\n  };\n  const mergeTextNodes = (prevNode, nextNode, schema, normalizeWhitespace, mergeToPrev = true) => {\n    const whitespaceOffset = rTrim(prevNode.data).length;\n    const newNode = mergeToPrev ? prevNode : nextNode;\n    const removeNode = mergeToPrev ? nextNode : prevNode;\n    if (mergeToPrev) {\n      newNode.appendData(removeNode.data);\n    } else {\n      newNode.insertData(0, removeNode.data);\n    }\n    remove$4(SugarElement.fromDom(removeNode));\n    if (normalizeWhitespace) {\n      normalizeWhitespaceAfter(newNode, whitespaceOffset, schema);\n    }\n    return newNode;\n  };\n  const needsReposition = (pos, elm) => {\n    const container = pos.container();\n    const offset = pos.offset();\n    return !CaretPosition.isTextPosition(pos) && container === elm.parentNode && offset > CaretPosition.before(elm).offset();\n  };\n  const reposition = (elm, pos) => needsReposition(pos, elm) ? CaretPosition(pos.container(), pos.offset() - 1) : pos;\n  const beforeOrStartOf = node => isText$b(node) ? CaretPosition(node, 0) : CaretPosition.before(node);\n  const afterOrEndOf = node => isText$b(node) ? CaretPosition(node, node.data.length) : CaretPosition.after(node);\n  const getPreviousSiblingCaretPosition = elm => {\n    if (isCaretCandidate$3(elm.previousSibling)) {\n      return Optional.some(afterOrEndOf(elm.previousSibling));\n    } else {\n      return elm.previousSibling ? lastPositionIn(elm.previousSibling) : Optional.none();\n    }\n  };\n  const getNextSiblingCaretPosition = elm => {\n    if (isCaretCandidate$3(elm.nextSibling)) {\n      return Optional.some(beforeOrStartOf(elm.nextSibling));\n    } else {\n      return elm.nextSibling ? firstPositionIn(elm.nextSibling) : Optional.none();\n    }\n  };\n  const findCaretPositionBackwardsFromElm = (rootElement, elm) => {\n    return Optional.from(elm.previousSibling ? elm.previousSibling : elm.parentNode).bind(node => prevPosition(rootElement, CaretPosition.before(node))).orThunk(() => nextPosition(rootElement, CaretPosition.after(elm)));\n  };\n  const findCaretPositionForwardsFromElm = (rootElement, elm) => nextPosition(rootElement, CaretPosition.after(elm)).orThunk(() => prevPosition(rootElement, CaretPosition.before(elm)));\n  const findCaretPositionBackwards = (rootElement, elm) => getPreviousSiblingCaretPosition(elm).orThunk(() => getNextSiblingCaretPosition(elm)).orThunk(() => findCaretPositionBackwardsFromElm(rootElement, elm));\n  const findCaretPositionForward = (rootElement, elm) => getNextSiblingCaretPosition(elm).orThunk(() => getPreviousSiblingCaretPosition(elm)).orThunk(() => findCaretPositionForwardsFromElm(rootElement, elm));\n  const findCaretPosition = (forward, rootElement, elm) => forward ? findCaretPositionForward(rootElement, elm) : findCaretPositionBackwards(rootElement, elm);\n  const findCaretPosOutsideElmAfterDelete = (forward, rootElement, elm) => findCaretPosition(forward, rootElement, elm).map(curry(reposition, elm));\n  const setSelection$1 = (editor, forward, pos) => {\n    pos.fold(() => {\n      editor.focus();\n    }, pos => {\n      editor.selection.setRng(pos.toRange(), forward);\n    });\n  };\n  const eqRawNode = rawNode => elm => elm.dom === rawNode;\n  const isBlock = (editor, elm) => elm && has$2(editor.schema.getBlockElements(), name(elm));\n  const paddEmptyBlock = (schema, elm, preserveEmptyCaret) => {\n    if (isEmpty$2(schema, elm)) {\n      const br = SugarElement.fromHtml('<br data-mce-bogus=\"1\">');\n      if (preserveEmptyCaret) {\n        each$e(children$1(elm), node => {\n          if (!isEmptyCaretFormatElement(node)) {\n            remove$4(node);\n          }\n        });\n      } else {\n        empty(elm);\n      }\n      append$1(elm, br);\n      return Optional.some(CaretPosition.before(br.dom));\n    } else {\n      return Optional.none();\n    }\n  };\n  const deleteNormalized = (elm, afterDeletePosOpt, schema, normalizeWhitespace) => {\n    const prevTextOpt = prevSibling(elm).filter(isText$c);\n    const nextTextOpt = nextSibling(elm).filter(isText$c);\n    remove$4(elm);\n    return lift3(prevTextOpt, nextTextOpt, afterDeletePosOpt, (prev, next, pos) => {\n      const prevNode = prev.dom,\n        nextNode = next.dom;\n      const offset = prevNode.data.length;\n      mergeTextNodes(prevNode, nextNode, schema, normalizeWhitespace);\n      return pos.container() === nextNode ? CaretPosition(prevNode, offset) : pos;\n    }).orThunk(() => {\n      if (normalizeWhitespace) {\n        prevTextOpt.each(elm => normalizeWhitespaceBefore(elm.dom, elm.dom.length, schema));\n        nextTextOpt.each(elm => normalizeWhitespaceAfter(elm.dom, 0, schema));\n      }\n      return afterDeletePosOpt;\n    });\n  };\n  const isInlineElement = (editor, element) => has$2(editor.schema.getTextInlineElements(), name(element));\n  const deleteElement$2 = (editor, forward, elm, moveCaret = true, preserveEmptyCaret = false) => {\n    const afterDeletePos = findCaretPosOutsideElmAfterDelete(forward, editor.getBody(), elm.dom);\n    const parentBlock = ancestor$4(elm, curry(isBlock, editor), eqRawNode(editor.getBody()));\n    const normalizedAfterDeletePos = deleteNormalized(elm, afterDeletePos, editor.schema, isInlineElement(editor, elm));\n    if (editor.dom.isEmpty(editor.getBody())) {\n      editor.setContent('');\n      editor.selection.setCursorLocation();\n    } else {\n      parentBlock.bind(elm => paddEmptyBlock(editor.schema, elm, preserveEmptyCaret)).fold(() => {\n        if (moveCaret) {\n          setSelection$1(editor, forward, normalizedAfterDeletePos);\n        }\n      }, paddPos => {\n        if (moveCaret) {\n          setSelection$1(editor, forward, Optional.some(paddPos));\n        }\n      });\n    }\n  };\n  const strongRtl = /[\\u0591-\\u07FF\\uFB1D-\\uFDFF\\uFE70-\\uFEFC]/;\n  const hasStrongRtl = text => strongRtl.test(text);\n  const isInlineTarget = (editor, elm) => is$1(SugarElement.fromDom(elm), getInlineBoundarySelector(editor)) && !isTransparentBlock(editor.schema, elm) && editor.dom.isEditable(elm);\n  const isRtl = element => {\n    var _a;\n    return DOMUtils.DOM.getStyle(element, 'direction', true) === 'rtl' || hasStrongRtl((_a = element.textContent) !== null && _a !== void 0 ? _a : '');\n  };\n  const findInlineParents = (isInlineTarget, rootNode, pos) => filter$5(DOMUtils.DOM.getParents(pos.container(), '*', rootNode), isInlineTarget);\n  const findRootInline = (isInlineTarget, rootNode, pos) => {\n    const parents = findInlineParents(isInlineTarget, rootNode, pos);\n    return Optional.from(parents[parents.length - 1]);\n  };\n  const hasSameParentBlock = (rootNode, node1, node2) => {\n    const block1 = getParentBlock$3(node1, rootNode);\n    const block2 = getParentBlock$3(node2, rootNode);\n    return isNonNullable(block1) && block1 === block2;\n  };\n  const isAtZwsp = pos => isBeforeInline(pos) || isAfterInline(pos);\n  const normalizePosition = (forward, pos) => {\n    const container = pos.container(),\n      offset = pos.offset();\n    if (forward) {\n      if (isCaretContainerInline(container)) {\n        if (isText$b(container.nextSibling)) {\n          return CaretPosition(container.nextSibling, 0);\n        } else {\n          return CaretPosition.after(container);\n        }\n      } else {\n        return isBeforeInline(pos) ? CaretPosition(container, offset + 1) : pos;\n      }\n    } else {\n      if (isCaretContainerInline(container)) {\n        if (isText$b(container.previousSibling)) {\n          return CaretPosition(container.previousSibling, container.previousSibling.data.length);\n        } else {\n          return CaretPosition.before(container);\n        }\n      } else {\n        return isAfterInline(pos) ? CaretPosition(container, offset - 1) : pos;\n      }\n    }\n  };\n  const normalizeForwards = curry(normalizePosition, true);\n  const normalizeBackwards = curry(normalizePosition, false);\n  const execCommandIgnoreInputEvents = (editor, command) => {\n    const inputBlocker = e => e.stopImmediatePropagation();\n    editor.on('beforeinput input', inputBlocker, true);\n    editor.getDoc().execCommand(command);\n    editor.off('beforeinput input', inputBlocker);\n  };\n  const execEditorDeleteCommand = editor => {\n    editor.execCommand('delete');\n  };\n  const execNativeDeleteCommand = editor => execCommandIgnoreInputEvents(editor, 'Delete');\n  const execNativeForwardDeleteCommand = editor => execCommandIgnoreInputEvents(editor, 'ForwardDelete');\n  const isBeforeRoot = rootNode => elm => is$2(parent(elm), rootNode, eq);\n  const isTextBlockOrListItem = element => isTextBlock$2(element) || isListItem$1(element);\n  const getParentBlock$2 = (rootNode, elm) => {\n    if (contains(rootNode, elm)) {\n      return closest$4(elm, isTextBlockOrListItem, isBeforeRoot(rootNode));\n    } else {\n      return Optional.none();\n    }\n  };\n  const paddEmptyBody = (editor, moveSelection = true) => {\n    if (editor.dom.isEmpty(editor.getBody())) {\n      editor.setContent('', {\n        no_selection: !moveSelection\n      });\n    }\n  };\n  const willDeleteLastPositionInElement = (forward, fromPos, elm) => lift2(firstPositionIn(elm), lastPositionIn(elm), (firstPos, lastPos) => {\n    const normalizedFirstPos = normalizePosition(true, firstPos);\n    const normalizedLastPos = normalizePosition(false, lastPos);\n    const normalizedFromPos = normalizePosition(false, fromPos);\n    if (forward) {\n      return nextPosition(elm, normalizedFromPos).exists(nextPos => nextPos.isEqual(normalizedLastPos) && fromPos.isEqual(normalizedFirstPos));\n    } else {\n      return prevPosition(elm, normalizedFromPos).exists(prevPos => prevPos.isEqual(normalizedFirstPos) && fromPos.isEqual(normalizedLastPos));\n    }\n  }).getOr(true);\n  const freefallRtl = root => {\n    const child = isComment$1(root) ? prevSibling(root) : lastChild(root);\n    return child.bind(freefallRtl).orThunk(() => Optional.some(root));\n  };\n  const deleteRangeContents = (editor, rng, root, moveSelection = true) => {\n    var _a;\n    rng.deleteContents();\n    const lastNode = freefallRtl(root).getOr(root);\n    const lastBlock = SugarElement.fromDom((_a = editor.dom.getParent(lastNode.dom, editor.dom.isBlock)) !== null && _a !== void 0 ? _a : root.dom);\n    if (lastBlock.dom === editor.getBody()) {\n      paddEmptyBody(editor, moveSelection);\n    } else if (isEmpty$2(editor.schema, lastBlock, {\n      checkRootAsContent: false\n    })) {\n      fillWithPaddingBr(lastBlock);\n      if (moveSelection) {\n        editor.selection.setCursorLocation(lastBlock.dom, 0);\n      }\n    }\n    if (!eq(root, lastBlock)) {\n      const additionalCleanupNodes = is$2(parent(lastBlock), root) ? [] : siblings(lastBlock);\n      each$e(additionalCleanupNodes.concat(children$1(root)), node => {\n        if (!eq(node, lastBlock) && !contains(node, lastBlock) && isEmpty$2(editor.schema, node)) {\n          remove$4(node);\n        }\n      });\n    }\n  };\n  const isRootFromElement = root => cur => eq(root, cur);\n  const getTableCells = table => descendants(table, 'td,th');\n  const getTable$1 = (node, isRoot) => getClosestTable(SugarElement.fromDom(node), isRoot);\n  const selectionInTableWithNestedTable = details => {\n    return lift2(details.startTable, details.endTable, (startTable, endTable) => {\n      const isStartTableParentOfEndTable = descendant(startTable, t => eq(t, endTable));\n      const isEndTableParentOfStartTable = descendant(endTable, t => eq(t, startTable));\n      return !isStartTableParentOfEndTable && !isEndTableParentOfStartTable ? details : {\n        ...details,\n        startTable: isStartTableParentOfEndTable ? Optional.none() : details.startTable,\n        endTable: isEndTableParentOfStartTable ? Optional.none() : details.endTable,\n        isSameTable: false,\n        isMultiTable: false\n      };\n    }).getOr(details);\n  };\n  const adjustQuirksInDetails = details => {\n    return selectionInTableWithNestedTable(details);\n  };\n  const getTableDetailsFromRange = (rng, isRoot) => {\n    const startTable = getTable$1(rng.startContainer, isRoot);\n    const endTable = getTable$1(rng.endContainer, isRoot);\n    const isStartInTable = startTable.isSome();\n    const isEndInTable = endTable.isSome();\n    const isSameTable = lift2(startTable, endTable, eq).getOr(false);\n    const isMultiTable = !isSameTable && isStartInTable && isEndInTable;\n    return adjustQuirksInDetails({\n      startTable,\n      endTable,\n      isStartInTable,\n      isEndInTable,\n      isSameTable,\n      isMultiTable\n    });\n  };\n  const tableCellRng = (start, end) => ({\n    start,\n    end\n  });\n  const tableSelection = (rng, table, cells) => ({\n    rng,\n    table,\n    cells\n  });\n  const deleteAction = Adt.generate([{\n    singleCellTable: ['rng', 'cell']\n  }, {\n    fullTable: ['table']\n  }, {\n    partialTable: ['cells', 'outsideDetails']\n  }, {\n    multiTable: ['startTableCells', 'endTableCells', 'betweenRng']\n  }]);\n  const getClosestCell$1 = (container, isRoot) => closest$3(SugarElement.fromDom(container), 'td,th', isRoot);\n  const isExpandedCellRng = cellRng => !eq(cellRng.start, cellRng.end);\n  const getTableFromCellRng = (cellRng, isRoot) => getClosestTable(cellRng.start, isRoot).bind(startParentTable => getClosestTable(cellRng.end, isRoot).bind(endParentTable => someIf(eq(startParentTable, endParentTable), startParentTable)));\n  const isSingleCellTable = (cellRng, isRoot) => !isExpandedCellRng(cellRng) && getTableFromCellRng(cellRng, isRoot).exists(table => {\n    const rows = table.dom.rows;\n    return rows.length === 1 && rows[0].cells.length === 1;\n  });\n  const getCellRng = (rng, isRoot) => {\n    const startCell = getClosestCell$1(rng.startContainer, isRoot);\n    const endCell = getClosestCell$1(rng.endContainer, isRoot);\n    return lift2(startCell, endCell, tableCellRng);\n  };\n  const getCellRangeFromStartTable = isRoot => startCell => getClosestTable(startCell, isRoot).bind(table => last$2(getTableCells(table)).map(endCell => tableCellRng(startCell, endCell)));\n  const getCellRangeFromEndTable = isRoot => endCell => getClosestTable(endCell, isRoot).bind(table => head(getTableCells(table)).map(startCell => tableCellRng(startCell, endCell)));\n  const getTableSelectionFromCellRng = isRoot => cellRng => getTableFromCellRng(cellRng, isRoot).map(table => tableSelection(cellRng, table, getTableCells(table)));\n  const getTableSelections = (cellRng, selectionDetails, rng, isRoot) => {\n    if (rng.collapsed || !cellRng.forall(isExpandedCellRng)) {\n      return Optional.none();\n    } else if (selectionDetails.isSameTable) {\n      const sameTableSelection = cellRng.bind(getTableSelectionFromCellRng(isRoot));\n      return Optional.some({\n        start: sameTableSelection,\n        end: sameTableSelection\n      });\n    } else {\n      const startCell = getClosestCell$1(rng.startContainer, isRoot);\n      const endCell = getClosestCell$1(rng.endContainer, isRoot);\n      const startTableSelection = startCell.bind(getCellRangeFromStartTable(isRoot)).bind(getTableSelectionFromCellRng(isRoot));\n      const endTableSelection = endCell.bind(getCellRangeFromEndTable(isRoot)).bind(getTableSelectionFromCellRng(isRoot));\n      return Optional.some({\n        start: startTableSelection,\n        end: endTableSelection\n      });\n    }\n  };\n  const getCellIndex = (cells, cell) => findIndex$2(cells, x => eq(x, cell));\n  const getSelectedCells = tableSelection => lift2(getCellIndex(tableSelection.cells, tableSelection.rng.start), getCellIndex(tableSelection.cells, tableSelection.rng.end), (startIndex, endIndex) => tableSelection.cells.slice(startIndex, endIndex + 1));\n  const isSingleCellTableContentSelected = (optCellRng, rng, isRoot) => optCellRng.exists(cellRng => isSingleCellTable(cellRng, isRoot) && hasAllContentsSelected(cellRng.start, rng));\n  const unselectCells = (rng, selectionDetails) => {\n    const {\n      startTable,\n      endTable\n    } = selectionDetails;\n    const otherContentRng = rng.cloneRange();\n    startTable.each(table => otherContentRng.setStartAfter(table.dom));\n    endTable.each(table => otherContentRng.setEndBefore(table.dom));\n    return otherContentRng;\n  };\n  const handleSingleTable = (cellRng, selectionDetails, rng, isRoot) => getTableSelections(cellRng, selectionDetails, rng, isRoot).bind(({\n    start,\n    end\n  }) => start.or(end)).bind(tableSelection => {\n    const {\n      isSameTable\n    } = selectionDetails;\n    const selectedCells = getSelectedCells(tableSelection).getOr([]);\n    if (isSameTable && tableSelection.cells.length === selectedCells.length) {\n      return Optional.some(deleteAction.fullTable(tableSelection.table));\n    } else if (selectedCells.length > 0) {\n      if (isSameTable) {\n        return Optional.some(deleteAction.partialTable(selectedCells, Optional.none()));\n      } else {\n        const otherContentRng = unselectCells(rng, selectionDetails);\n        return Optional.some(deleteAction.partialTable(selectedCells, Optional.some({\n          ...selectionDetails,\n          rng: otherContentRng\n        })));\n      }\n    } else {\n      return Optional.none();\n    }\n  });\n  const handleMultiTable = (cellRng, selectionDetails, rng, isRoot) => getTableSelections(cellRng, selectionDetails, rng, isRoot).bind(({\n    start,\n    end\n  }) => {\n    const startTableSelectedCells = start.bind(getSelectedCells).getOr([]);\n    const endTableSelectedCells = end.bind(getSelectedCells).getOr([]);\n    if (startTableSelectedCells.length > 0 && endTableSelectedCells.length > 0) {\n      const otherContentRng = unselectCells(rng, selectionDetails);\n      return Optional.some(deleteAction.multiTable(startTableSelectedCells, endTableSelectedCells, otherContentRng));\n    } else {\n      return Optional.none();\n    }\n  });\n  const getActionFromRange = (root, rng) => {\n    const isRoot = isRootFromElement(root);\n    const optCellRng = getCellRng(rng, isRoot);\n    const selectionDetails = getTableDetailsFromRange(rng, isRoot);\n    if (isSingleCellTableContentSelected(optCellRng, rng, isRoot)) {\n      return optCellRng.map(cellRng => deleteAction.singleCellTable(rng, cellRng.start));\n    } else if (selectionDetails.isMultiTable) {\n      return handleMultiTable(optCellRng, selectionDetails, rng, isRoot);\n    } else {\n      return handleSingleTable(optCellRng, selectionDetails, rng, isRoot);\n    }\n  };\n  const cleanCells = cells => each$e(cells, cell => {\n    remove$9(cell, 'contenteditable');\n    fillWithPaddingBr(cell);\n  });\n  const getOutsideBlock = (editor, container) => Optional.from(editor.dom.getParent(container, editor.dom.isBlock)).map(SugarElement.fromDom);\n  const handleEmptyBlock = (editor, startInTable, emptyBlock) => {\n    emptyBlock.each(block => {\n      if (startInTable) {\n        remove$4(block);\n      } else {\n        fillWithPaddingBr(block);\n        editor.selection.setCursorLocation(block.dom, 0);\n      }\n    });\n  };\n  const deleteContentInsideCell = (editor, cell, rng, isFirstCellInSelection) => {\n    const insideTableRng = rng.cloneRange();\n    if (isFirstCellInSelection) {\n      insideTableRng.setStart(rng.startContainer, rng.startOffset);\n      insideTableRng.setEndAfter(cell.dom.lastChild);\n    } else {\n      insideTableRng.setStartBefore(cell.dom.firstChild);\n      insideTableRng.setEnd(rng.endContainer, rng.endOffset);\n    }\n    deleteCellContents(editor, insideTableRng, cell, false).each(action => action());\n  };\n  const collapseAndRestoreCellSelection = editor => {\n    const selectedCells = getCellsFromEditor(editor);\n    const selectedNode = SugarElement.fromDom(editor.selection.getNode());\n    if (isTableCell$3(selectedNode.dom) && isEmpty$2(editor.schema, selectedNode)) {\n      editor.selection.setCursorLocation(selectedNode.dom, 0);\n    } else {\n      editor.selection.collapse(true);\n    }\n    if (selectedCells.length > 1 && exists(selectedCells, cell => eq(cell, selectedNode))) {\n      set$3(selectedNode, 'data-mce-selected', '1');\n    }\n  };\n  const emptySingleTableCells = (editor, cells, outsideDetails) => Optional.some(() => {\n    const editorRng = editor.selection.getRng();\n    const cellsToClean = outsideDetails.bind(({\n      rng,\n      isStartInTable\n    }) => {\n      const outsideBlock = getOutsideBlock(editor, isStartInTable ? rng.endContainer : rng.startContainer);\n      rng.deleteContents();\n      handleEmptyBlock(editor, isStartInTable, outsideBlock.filter(curry(isEmpty$2, editor.schema)));\n      const endPointCell = isStartInTable ? cells[0] : cells[cells.length - 1];\n      deleteContentInsideCell(editor, endPointCell, editorRng, isStartInTable);\n      if (!isEmpty$2(editor.schema, endPointCell)) {\n        return Optional.some(isStartInTable ? cells.slice(1) : cells.slice(0, -1));\n      } else {\n        return Optional.none();\n      }\n    }).getOr(cells);\n    cleanCells(cellsToClean);\n    collapseAndRestoreCellSelection(editor);\n  });\n  const emptyMultiTableCells = (editor, startTableCells, endTableCells, betweenRng) => Optional.some(() => {\n    const rng = editor.selection.getRng();\n    const startCell = startTableCells[0];\n    const endCell = endTableCells[endTableCells.length - 1];\n    deleteContentInsideCell(editor, startCell, rng, true);\n    deleteContentInsideCell(editor, endCell, rng, false);\n    const startTableCellsToClean = isEmpty$2(editor.schema, startCell) ? startTableCells : startTableCells.slice(1);\n    const endTableCellsToClean = isEmpty$2(editor.schema, endCell) ? endTableCells : endTableCells.slice(0, -1);\n    cleanCells(startTableCellsToClean.concat(endTableCellsToClean));\n    betweenRng.deleteContents();\n    collapseAndRestoreCellSelection(editor);\n  });\n  const deleteCellContents = (editor, rng, cell, moveSelection = true) => Optional.some(() => {\n    deleteRangeContents(editor, rng, cell, moveSelection);\n  });\n  const deleteTableElement = (editor, table) => Optional.some(() => deleteElement$2(editor, false, table));\n  const deleteCellRange = (editor, rootElm, rng) => getActionFromRange(rootElm, rng).bind(action => action.fold(curry(deleteCellContents, editor), curry(deleteTableElement, editor), curry(emptySingleTableCells, editor), curry(emptyMultiTableCells, editor)));\n  const deleteCaptionRange = (editor, caption) => emptyElement(editor, caption);\n  const deleteTableRange = (editor, rootElm, rng, startElm) => getParentCaption(rootElm, startElm).fold(() => deleteCellRange(editor, rootElm, rng), caption => deleteCaptionRange(editor, caption));\n  const deleteRange$3 = (editor, startElm, selectedCells) => {\n    const rootNode = SugarElement.fromDom(editor.getBody());\n    const rng = editor.selection.getRng();\n    return selectedCells.length !== 0 ? emptySingleTableCells(editor, selectedCells, Optional.none()) : deleteTableRange(editor, rootNode, rng, startElm);\n  };\n  const getParentCell = (rootElm, elm) => find$2(parentsAndSelf(elm, rootElm), isTableCell$2);\n  const getParentCaption = (rootElm, elm) => find$2(parentsAndSelf(elm, rootElm), isTag('caption'));\n  const deleteBetweenCells = (editor, rootElm, forward, fromCell, from) => navigate(forward, editor.getBody(), from).bind(to => getParentCell(rootElm, SugarElement.fromDom(to.getNode())).bind(toCell => eq(toCell, fromCell) ? Optional.none() : Optional.some(noop)));\n  const emptyElement = (editor, elm) => Optional.some(() => {\n    fillWithPaddingBr(elm);\n    editor.selection.setCursorLocation(elm.dom, 0);\n  });\n  const isDeleteOfLastCharPos = (fromCaption, forward, from, to) => firstPositionIn(fromCaption.dom).bind(first => lastPositionIn(fromCaption.dom).map(last => forward ? from.isEqual(first) && to.isEqual(last) : from.isEqual(last) && to.isEqual(first))).getOr(true);\n  const emptyCaretCaption = (editor, elm) => emptyElement(editor, elm);\n  const validateCaretCaption = (rootElm, fromCaption, to) => getParentCaption(rootElm, SugarElement.fromDom(to.getNode())).fold(() => Optional.some(noop), toCaption => someIf(!eq(toCaption, fromCaption), noop));\n  const deleteCaretInsideCaption = (editor, rootElm, forward, fromCaption, from) => navigate(forward, editor.getBody(), from).fold(() => Optional.some(noop), to => isDeleteOfLastCharPos(fromCaption, forward, from, to) ? emptyCaretCaption(editor, fromCaption) : validateCaretCaption(rootElm, fromCaption, to));\n  const deleteCaretCells = (editor, forward, rootElm, startElm) => {\n    const from = CaretPosition.fromRangeStart(editor.selection.getRng());\n    return getParentCell(rootElm, startElm).bind(fromCell => isEmpty$2(editor.schema, fromCell, {\n      checkRootAsContent: false\n    }) ? emptyElement(editor, fromCell) : deleteBetweenCells(editor, rootElm, forward, fromCell, from));\n  };\n  const deleteCaretCaption = (editor, forward, rootElm, fromCaption) => {\n    const from = CaretPosition.fromRangeStart(editor.selection.getRng());\n    return isEmpty$2(editor.schema, fromCaption) ? emptyElement(editor, fromCaption) : deleteCaretInsideCaption(editor, rootElm, forward, fromCaption, from);\n  };\n  const isNearTable = (forward, pos) => forward ? isBeforeTable(pos) : isAfterTable(pos);\n  const isBeforeOrAfterTable = (editor, forward) => {\n    const fromPos = CaretPosition.fromRangeStart(editor.selection.getRng());\n    return isNearTable(forward, fromPos) || fromPosition(forward, editor.getBody(), fromPos).exists(pos => isNearTable(forward, pos));\n  };\n  const deleteCaret$3 = (editor, forward, startElm) => {\n    const rootElm = SugarElement.fromDom(editor.getBody());\n    return getParentCaption(rootElm, startElm).fold(() => deleteCaretCells(editor, forward, rootElm, startElm).orThunk(() => someIf(isBeforeOrAfterTable(editor, forward), noop)), fromCaption => deleteCaretCaption(editor, forward, rootElm, fromCaption));\n  };\n  const backspaceDelete$b = (editor, forward) => {\n    const startElm = SugarElement.fromDom(editor.selection.getStart(true));\n    const cells = getCellsFromEditor(editor);\n    return editor.selection.isCollapsed() && cells.length === 0 ? deleteCaret$3(editor, forward, startElm) : deleteRange$3(editor, startElm, cells);\n  };\n  const getContentEditableRoot$1 = (root, node) => {\n    let tempNode = node;\n    while (tempNode && tempNode !== root) {\n      if (isContentEditableTrue$3(tempNode) || isContentEditableFalse$b(tempNode)) {\n        return tempNode;\n      }\n      tempNode = tempNode.parentNode;\n    }\n    return null;\n  };\n  const internalAttributesPrefixes = ['data-ephox-', 'data-mce-', 'data-alloy-', 'data-snooker-', '_'];\n  const each$9 = Tools.each;\n  const ElementUtils = editor => {\n    const dom = editor.dom;\n    const internalAttributes = new Set(editor.serializer.getTempAttrs());\n    const compare = (node1, node2) => {\n      if (node1.nodeName !== node2.nodeName || node1.nodeType !== node2.nodeType) {\n        return false;\n      }\n      const getAttribs = node => {\n        const attribs = {};\n        each$9(dom.getAttribs(node), attr => {\n          const name = attr.nodeName.toLowerCase();\n          if (name !== 'style' && !isAttributeInternal(name)) {\n            attribs[name] = dom.getAttrib(node, name);\n          }\n        });\n        return attribs;\n      };\n      const compareObjects = (obj1, obj2) => {\n        for (const name in obj1) {\n          if (has$2(obj1, name)) {\n            const value = obj2[name];\n            if (isUndefined(value)) {\n              return false;\n            }\n            if (obj1[name] !== value) {\n              return false;\n            }\n            delete obj2[name];\n          }\n        }\n        for (const name in obj2) {\n          if (has$2(obj2, name)) {\n            return false;\n          }\n        }\n        return true;\n      };\n      if (isElement$6(node1) && isElement$6(node2)) {\n        if (!compareObjects(getAttribs(node1), getAttribs(node2))) {\n          return false;\n        }\n        if (!compareObjects(dom.parseStyle(dom.getAttrib(node1, 'style')), dom.parseStyle(dom.getAttrib(node2, 'style')))) {\n          return false;\n        }\n      }\n      return !isBookmarkNode$1(node1) && !isBookmarkNode$1(node2);\n    };\n    const isAttributeInternal = attributeName => exists(internalAttributesPrefixes, value => startsWith(attributeName, value)) || internalAttributes.has(attributeName);\n    return {\n      compare,\n      isAttributeInternal\n    };\n  };\n  const isHeading = node => ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'].includes(node.name);\n  const isSummary = node => node.name === 'summary';\n  const traverse = (root, fn) => {\n    let node = root;\n    while (node = node.walk()) {\n      fn(node);\n    }\n  };\n  const matchNode$1 = (nodeFilters, attributeFilters, node, matches) => {\n    const name = node.name;\n    for (let ni = 0, nl = nodeFilters.length; ni < nl; ni++) {\n      const filter = nodeFilters[ni];\n      if (filter.name === name) {\n        const match = matches.nodes[name];\n        if (match) {\n          match.nodes.push(node);\n        } else {\n          matches.nodes[name] = {\n            filter,\n            nodes: [node]\n          };\n        }\n      }\n    }\n    if (node.attributes) {\n      for (let ai = 0, al = attributeFilters.length; ai < al; ai++) {\n        const filter = attributeFilters[ai];\n        const attrName = filter.name;\n        if (attrName in node.attributes.map) {\n          const match = matches.attributes[attrName];\n          if (match) {\n            match.nodes.push(node);\n          } else {\n            matches.attributes[attrName] = {\n              filter,\n              nodes: [node]\n            };\n          }\n        }\n      }\n    }\n  };\n  const findMatchingNodes = (nodeFilters, attributeFilters, node) => {\n    const matches = {\n      nodes: {},\n      attributes: {}\n    };\n    if (node.firstChild) {\n      traverse(node, childNode => {\n        matchNode$1(nodeFilters, attributeFilters, childNode, matches);\n      });\n    }\n    return matches;\n  };\n  const runFilters = (matches, args) => {\n    const run = (matchRecord, filteringAttributes) => {\n      each$d(matchRecord, match => {\n        const nodes = from(match.nodes);\n        each$e(match.filter.callbacks, callback => {\n          for (let i = nodes.length - 1; i >= 0; i--) {\n            const node = nodes[i];\n            const valueMatches = filteringAttributes ? node.attr(match.filter.name) !== undefined : node.name === match.filter.name;\n            if (!valueMatches || isNullable(node.parent)) {\n              nodes.splice(i, 1);\n            }\n          }\n          if (nodes.length > 0) {\n            callback(nodes, match.filter.name, args);\n          }\n        });\n      });\n    };\n    run(matches.nodes, false);\n    run(matches.attributes, true);\n  };\n  const filter$2 = (nodeFilters, attributeFilters, node, args = {}) => {\n    const matches = findMatchingNodes(nodeFilters, attributeFilters, node);\n    runFilters(matches, args);\n  };\n  const paddEmptyNode = (settings, args, isBlock, node) => {\n    const brPreferred = settings.pad_empty_with_br || args.insert;\n    if (brPreferred && isBlock(node)) {\n      const astNode = new AstNode('br', 1);\n      if (args.insert) {\n        astNode.attr('data-mce-bogus', '1');\n      }\n      node.empty().append(astNode);\n    } else {\n      node.empty().append(new AstNode('#text', 3)).value = nbsp;\n    }\n  };\n  const isPaddedWithNbsp = node => {\n    var _a;\n    return hasOnlyChild(node, '#text') && ((_a = node === null || node === void 0 ? void 0 : node.firstChild) === null || _a === void 0 ? void 0 : _a.value) === nbsp;\n  };\n  const hasOnlyChild = (node, name) => {\n    const firstChild = node === null || node === void 0 ? void 0 : node.firstChild;\n    return isNonNullable(firstChild) && firstChild === node.lastChild && firstChild.name === name;\n  };\n  const isPadded = (schema, node) => {\n    const rule = schema.getElementRule(node.name);\n    return (rule === null || rule === void 0 ? void 0 : rule.paddEmpty) === true;\n  };\n  const isEmpty = (schema, nonEmptyElements, whitespaceElements, node) => node.isEmpty(nonEmptyElements, whitespaceElements, node => isPadded(schema, node));\n  const isLineBreakNode = (node, isBlock) => isNonNullable(node) && (isBlock(node) || node.name === 'br');\n  const findClosestEditingHost = scope => {\n    let editableNode;\n    for (let node = scope; node; node = node.parent) {\n      const contentEditable = node.attr('contenteditable');\n      if (contentEditable === 'false') {\n        break;\n      } else if (contentEditable === 'true') {\n        editableNode = node;\n      }\n    }\n    return Optional.from(editableNode);\n  };\n  const removeOrUnwrapInvalidNode = (node, schema, originalNodeParent = node.parent) => {\n    if (schema.getSpecialElements()[node.name]) {\n      node.empty().remove();\n    } else {\n      const children = node.children();\n      for (const childNode of children) {\n        if (originalNodeParent && !schema.isValidChild(originalNodeParent.name, childNode.name)) {\n          removeOrUnwrapInvalidNode(childNode, schema, originalNodeParent);\n        }\n      }\n      node.unwrap();\n    }\n  };\n  const cleanInvalidNodes = (nodes, schema, rootNode, onCreate = noop) => {\n    const textBlockElements = schema.getTextBlockElements();\n    const nonEmptyElements = schema.getNonEmptyElements();\n    const whitespaceElements = schema.getWhitespaceElements();\n    const nonSplittableElements = Tools.makeMap('tr,td,th,tbody,thead,tfoot,table,summary');\n    const fixed = new Set();\n    const isSplittableElement = node => node !== rootNode && !nonSplittableElements[node.name];\n    for (let ni = 0; ni < nodes.length; ni++) {\n      const node = nodes[ni];\n      let parent;\n      let newParent;\n      let tempNode;\n      if (!node.parent || fixed.has(node)) {\n        continue;\n      }\n      if (textBlockElements[node.name] && node.parent.name === 'li') {\n        let sibling = node.next;\n        while (sibling) {\n          if (textBlockElements[sibling.name]) {\n            sibling.name = 'li';\n            fixed.add(sibling);\n            node.parent.insert(sibling, node.parent);\n          } else {\n            break;\n          }\n          sibling = sibling.next;\n        }\n        node.unwrap();\n        continue;\n      }\n      const parents = [node];\n      for (parent = node.parent; parent && !schema.isValidChild(parent.name, node.name) && isSplittableElement(parent); parent = parent.parent) {\n        parents.push(parent);\n      }\n      if (parent && parents.length > 1) {\n        if (!isInvalid(schema, node, parent)) {\n          parents.reverse();\n          newParent = parents[0].clone();\n          onCreate(newParent);\n          let currentNode = newParent;\n          for (let i = 0; i < parents.length - 1; i++) {\n            if (schema.isValidChild(currentNode.name, parents[i].name) && i > 0) {\n              tempNode = parents[i].clone();\n              onCreate(tempNode);\n              currentNode.append(tempNode);\n            } else {\n              tempNode = currentNode;\n            }\n            for (let childNode = parents[i].firstChild; childNode && childNode !== parents[i + 1];) {\n              const nextNode = childNode.next;\n              tempNode.append(childNode);\n              childNode = nextNode;\n            }\n            currentNode = tempNode;\n          }\n          if (!isEmpty(schema, nonEmptyElements, whitespaceElements, newParent)) {\n            parent.insert(newParent, parents[0], true);\n            parent.insert(node, newParent);\n          } else {\n            parent.insert(node, parents[0], true);\n          }\n          parent = parents[0];\n          if (isEmpty(schema, nonEmptyElements, whitespaceElements, parent) || hasOnlyChild(parent, 'br')) {\n            parent.empty().remove();\n          }\n        } else {\n          removeOrUnwrapInvalidNode(node, schema);\n        }\n      } else if (node.parent) {\n        if (node.name === 'li') {\n          let sibling = node.prev;\n          if (sibling && (sibling.name === 'ul' || sibling.name === 'ol')) {\n            sibling.append(node);\n            continue;\n          }\n          sibling = node.next;\n          if (sibling && (sibling.name === 'ul' || sibling.name === 'ol') && sibling.firstChild) {\n            sibling.insert(node, sibling.firstChild, true);\n            continue;\n          }\n          const wrapper = new AstNode('ul', 1);\n          onCreate(wrapper);\n          node.wrap(wrapper);\n          continue;\n        }\n        if (schema.isValidChild(node.parent.name, 'div') && schema.isValidChild('div', node.name)) {\n          const wrapper = new AstNode('div', 1);\n          onCreate(wrapper);\n          node.wrap(wrapper);\n        } else {\n          removeOrUnwrapInvalidNode(node, schema);\n        }\n      }\n    }\n  };\n  const hasClosest = (node, parentName) => {\n    let tempNode = node;\n    while (tempNode) {\n      if (tempNode.name === parentName) {\n        return true;\n      }\n      tempNode = tempNode.parent;\n    }\n    return false;\n  };\n  const isInvalid = (schema, node, parent = node.parent) => {\n    if (!parent) {\n      return false;\n    }\n    if (schema.children[node.name] && !schema.isValidChild(parent.name, node.name)) {\n      return true;\n    }\n    if (node.name === 'a' && hasClosest(parent, 'a')) {\n      return true;\n    }\n    if (isSummary(parent) && isHeading(node)) {\n      return !((parent === null || parent === void 0 ? void 0 : parent.firstChild) === node && (parent === null || parent === void 0 ? void 0 : parent.lastChild) === node);\n    }\n    return false;\n  };\n  const createRange = (sc, so, ec, eo) => {\n    const rng = document.createRange();\n    rng.setStart(sc, so);\n    rng.setEnd(ec, eo);\n    return rng;\n  };\n  const normalizeBlockSelectionRange = rng => {\n    const startPos = CaretPosition.fromRangeStart(rng);\n    const endPos = CaretPosition.fromRangeEnd(rng);\n    const rootNode = rng.commonAncestorContainer;\n    return fromPosition(false, rootNode, endPos).map(newEndPos => {\n      if (!isInSameBlock(startPos, endPos, rootNode) && isInSameBlock(startPos, newEndPos, rootNode)) {\n        return createRange(startPos.container(), startPos.offset(), newEndPos.container(), newEndPos.offset());\n      } else {\n        return rng;\n      }\n    }).getOr(rng);\n  };\n  const normalize = rng => rng.collapsed ? rng : normalizeBlockSelectionRange(rng);\n  const hasOnlyOneChild$1 = node => {\n    return isNonNullable(node.firstChild) && node.firstChild === node.lastChild;\n  };\n  const isPaddingNode = node => {\n    return node.name === 'br' || node.value === nbsp;\n  };\n  const isPaddedEmptyBlock = (schema, node) => {\n    const blockElements = schema.getBlockElements();\n    return blockElements[node.name] && hasOnlyOneChild$1(node) && isPaddingNode(node.firstChild);\n  };\n  const isEmptyFragmentElement = (schema, node) => {\n    const nonEmptyElements = schema.getNonEmptyElements();\n    return isNonNullable(node) && (node.isEmpty(nonEmptyElements) || isPaddedEmptyBlock(schema, node));\n  };\n  const isListFragment = (schema, fragment) => {\n    let firstChild = fragment.firstChild;\n    let lastChild = fragment.lastChild;\n    if (firstChild && firstChild.name === 'meta') {\n      firstChild = firstChild.next;\n    }\n    if (lastChild && lastChild.attr('id') === 'mce_marker') {\n      lastChild = lastChild.prev;\n    }\n    if (isEmptyFragmentElement(schema, lastChild)) {\n      lastChild = lastChild === null || lastChild === void 0 ? void 0 : lastChild.prev;\n    }\n    if (!firstChild || firstChild !== lastChild) {\n      return false;\n    }\n    return firstChild.name === 'ul' || firstChild.name === 'ol';\n  };\n  const cleanupDomFragment = domFragment => {\n    var _a, _b;\n    const firstChild = domFragment.firstChild;\n    const lastChild = domFragment.lastChild;\n    if (firstChild && firstChild.nodeName === 'META') {\n      (_a = firstChild.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(firstChild);\n    }\n    if (lastChild && lastChild.id === 'mce_marker') {\n      (_b = lastChild.parentNode) === null || _b === void 0 ? void 0 : _b.removeChild(lastChild);\n    }\n    return domFragment;\n  };\n  const toDomFragment = (dom, serializer, fragment) => {\n    const html = serializer.serialize(fragment);\n    const domFragment = dom.createFragment(html);\n    return cleanupDomFragment(domFragment);\n  };\n  const listItems = elm => {\n    var _a;\n    return filter$5((_a = elm === null || elm === void 0 ? void 0 : elm.childNodes) !== null && _a !== void 0 ? _a : [], child => {\n      return child.nodeName === 'LI';\n    });\n  };\n  const isPadding = node => {\n    return node.data === nbsp || isBr$6(node);\n  };\n  const isListItemPadded = node => {\n    return isNonNullable(node === null || node === void 0 ? void 0 : node.firstChild) && node.firstChild === node.lastChild && isPadding(node.firstChild);\n  };\n  const isEmptyOrPadded = elm => {\n    return !elm.firstChild || isListItemPadded(elm);\n  };\n  const trimListItems = elms => {\n    return elms.length > 0 && isEmptyOrPadded(elms[elms.length - 1]) ? elms.slice(0, -1) : elms;\n  };\n  const getParentLi = (dom, node) => {\n    const parentBlock = dom.getParent(node, dom.isBlock);\n    return parentBlock && parentBlock.nodeName === 'LI' ? parentBlock : null;\n  };\n  const isParentBlockLi = (dom, node) => {\n    return !!getParentLi(dom, node);\n  };\n  const getSplit = (parentNode, rng) => {\n    const beforeRng = rng.cloneRange();\n    const afterRng = rng.cloneRange();\n    beforeRng.setStartBefore(parentNode);\n    afterRng.setEndAfter(parentNode);\n    return [beforeRng.cloneContents(), afterRng.cloneContents()];\n  };\n  const findFirstIn = (node, rootNode) => {\n    const caretPos = CaretPosition.before(node);\n    const caretWalker = CaretWalker(rootNode);\n    const newCaretPos = caretWalker.next(caretPos);\n    return newCaretPos ? newCaretPos.toRange() : null;\n  };\n  const findLastOf = (node, rootNode) => {\n    const caretPos = CaretPosition.after(node);\n    const caretWalker = CaretWalker(rootNode);\n    const newCaretPos = caretWalker.prev(caretPos);\n    return newCaretPos ? newCaretPos.toRange() : null;\n  };\n  const insertMiddle = (target, elms, rootNode, rng) => {\n    const parts = getSplit(target, rng);\n    const parentElm = target.parentNode;\n    if (parentElm) {\n      parentElm.insertBefore(parts[0], target);\n      Tools.each(elms, li => {\n        parentElm.insertBefore(li, target);\n      });\n      parentElm.insertBefore(parts[1], target);\n      parentElm.removeChild(target);\n    }\n    return findLastOf(elms[elms.length - 1], rootNode);\n  };\n  const insertBefore$2 = (target, elms, rootNode) => {\n    const parentElm = target.parentNode;\n    if (parentElm) {\n      Tools.each(elms, elm => {\n        parentElm.insertBefore(elm, target);\n      });\n    }\n    return findFirstIn(target, rootNode);\n  };\n  const insertAfter$2 = (target, elms, rootNode, dom) => {\n    dom.insertAfter(elms.reverse(), target);\n    return findLastOf(elms[0], rootNode);\n  };\n  const insertAtCaret$1 = (serializer, dom, rng, fragment) => {\n    const domFragment = toDomFragment(dom, serializer, fragment);\n    const liTarget = getParentLi(dom, rng.startContainer);\n    const liElms = trimListItems(listItems(domFragment.firstChild));\n    const BEGINNING = 1,\n      END = 2;\n    const rootNode = dom.getRoot();\n    const isAt = location => {\n      const caretPos = CaretPosition.fromRangeStart(rng);\n      const caretWalker = CaretWalker(dom.getRoot());\n      const newPos = location === BEGINNING ? caretWalker.prev(caretPos) : caretWalker.next(caretPos);\n      const newPosNode = newPos === null || newPos === void 0 ? void 0 : newPos.getNode();\n      return newPosNode ? getParentLi(dom, newPosNode) !== liTarget : true;\n    };\n    if (!liTarget) {\n      return null;\n    } else if (isAt(BEGINNING)) {\n      return insertBefore$2(liTarget, liElms, rootNode);\n    } else if (isAt(END)) {\n      return insertAfter$2(liTarget, liElms, rootNode, dom);\n    } else {\n      return insertMiddle(liTarget, liElms, rootNode, rng);\n    }\n  };\n  const mergeableWrappedElements = ['pre'];\n  const shouldPasteContentOnly = (dom, fragment, parentNode, root) => {\n    var _a;\n    const firstNode = fragment.firstChild;\n    const lastNode = fragment.lastChild;\n    const last = lastNode.attr('data-mce-type') === 'bookmark' ? lastNode.prev : lastNode;\n    const isPastingSingleElement = firstNode === last;\n    const isWrappedElement = contains$2(mergeableWrappedElements, firstNode.name);\n    if (isPastingSingleElement && isWrappedElement) {\n      const isContentEditable = firstNode.attr('contenteditable') !== 'false';\n      const isPastingInTheSameBlockTag = ((_a = dom.getParent(parentNode, dom.isBlock)) === null || _a === void 0 ? void 0 : _a.nodeName.toLowerCase()) === firstNode.name;\n      const isPastingInContentEditable = Optional.from(getContentEditableRoot$1(root, parentNode)).forall(isContentEditableTrue$3);\n      return isContentEditable && isPastingInTheSameBlockTag && isPastingInContentEditable;\n    } else {\n      return false;\n    }\n  };\n  const isTableCell = isTableCell$3;\n  const isTableCellContentSelected = (dom, rng, cell) => {\n    if (isNonNullable(cell)) {\n      const endCell = dom.getParent(rng.endContainer, isTableCell);\n      return cell === endCell && hasAllContentsSelected(SugarElement.fromDom(cell), rng);\n    } else {\n      return false;\n    }\n  };\n  const validInsertion = (editor, value, parentNode) => {\n    var _a;\n    if (parentNode.getAttribute('data-mce-bogus') === 'all') {\n      (_a = parentNode.parentNode) === null || _a === void 0 ? void 0 : _a.insertBefore(editor.dom.createFragment(value), parentNode);\n    } else {\n      const node = parentNode.firstChild;\n      const node2 = parentNode.lastChild;\n      if (!node || node === node2 && node.nodeName === 'BR') {\n        editor.dom.setHTML(parentNode, value);\n      } else {\n        editor.selection.setContent(value, {\n          no_events: true\n        });\n      }\n    }\n  };\n  const trimBrsFromTableCell = (dom, elm, schema) => {\n    Optional.from(dom.getParent(elm, 'td,th')).map(SugarElement.fromDom).each(el => trimBlockTrailingBr(el, schema));\n  };\n  const reduceInlineTextElements = (editor, merge) => {\n    const textInlineElements = editor.schema.getTextInlineElements();\n    const dom = editor.dom;\n    if (merge) {\n      const root = editor.getBody();\n      const elementUtils = ElementUtils(editor);\n      const fragmentSelector = '*[data-mce-fragment]';\n      const fragments = dom.select(fragmentSelector);\n      Tools.each(fragments, node => {\n        const isInline = currentNode => isNonNullable(textInlineElements[currentNode.nodeName.toLowerCase()]);\n        const hasOneChild = currentNode => currentNode.childNodes.length === 1;\n        const hasNoNonInheritableStyles = currentNode => !(hasNonInheritableStyles(dom, currentNode) || hasConditionalNonInheritableStyles(dom, currentNode));\n        if (hasNoNonInheritableStyles(node) && isInline(node) && hasOneChild(node)) {\n          const styles = getStyleProps(dom, node);\n          const isOverridden = (oldStyles, newStyles) => forall(oldStyles, style => contains$2(newStyles, style));\n          const overriddenByAllChildren = childNode => hasOneChild(node) && dom.is(childNode, fragmentSelector) && isInline(childNode) && (childNode.nodeName === node.nodeName && isOverridden(styles, getStyleProps(dom, childNode)) || overriddenByAllChildren(childNode.children[0]));\n          const identicalToParent = parentNode => isNonNullable(parentNode) && parentNode !== root && (elementUtils.compare(node, parentNode) || identicalToParent(parentNode.parentElement));\n          const conflictWithInsertedParent = parentNode => isNonNullable(parentNode) && parentNode !== root && dom.is(parentNode, fragmentSelector) && (hasStyleConflict(dom, node, parentNode) || conflictWithInsertedParent(parentNode.parentElement));\n          if (overriddenByAllChildren(node.children[0]) || identicalToParent(node.parentElement) && !conflictWithInsertedParent(node.parentElement)) {\n            dom.remove(node, true);\n          }\n        }\n      });\n    }\n  };\n  const markFragmentElements = fragment => {\n    let node = fragment;\n    while (node = node.walk()) {\n      if (node.type === 1) {\n        node.attr('data-mce-fragment', '1');\n      }\n    }\n  };\n  const unmarkFragmentElements = elm => {\n    Tools.each(elm.getElementsByTagName('*'), elm => {\n      elm.removeAttribute('data-mce-fragment');\n    });\n  };\n  const isPartOfFragment = node => {\n    return !!node.getAttribute('data-mce-fragment');\n  };\n  const canHaveChildren = (editor, node) => {\n    return isNonNullable(node) && !editor.schema.getVoidElements()[node.nodeName];\n  };\n  const moveSelectionToMarker = (editor, marker) => {\n    var _a, _b, _c;\n    let nextRng;\n    const dom = editor.dom;\n    const selection = editor.selection;\n    if (!marker) {\n      return;\n    }\n    selection.scrollIntoView(marker);\n    const parentEditableElm = getContentEditableRoot$1(editor.getBody(), marker);\n    if (parentEditableElm && dom.getContentEditable(parentEditableElm) === 'false') {\n      dom.remove(marker);\n      selection.select(parentEditableElm);\n      return;\n    }\n    let rng = dom.createRng();\n    const node = marker.previousSibling;\n    if (isText$b(node)) {\n      rng.setStart(node, (_b = (_a = node.nodeValue) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0);\n      const node2 = marker.nextSibling;\n      if (isText$b(node2)) {\n        node.appendData(node2.data);\n        (_c = node2.parentNode) === null || _c === void 0 ? void 0 : _c.removeChild(node2);\n      }\n    } else {\n      rng.setStartBefore(marker);\n      rng.setEndBefore(marker);\n    }\n    const findNextCaretRng = rng => {\n      let caretPos = CaretPosition.fromRangeStart(rng);\n      const caretWalker = CaretWalker(editor.getBody());\n      caretPos = caretWalker.next(caretPos);\n      return caretPos === null || caretPos === void 0 ? void 0 : caretPos.toRange();\n    };\n    const parentBlock = dom.getParent(marker, dom.isBlock);\n    dom.remove(marker);\n    if (parentBlock && dom.isEmpty(parentBlock)) {\n      const isCell = isTableCell(parentBlock);\n      empty(SugarElement.fromDom(parentBlock));\n      rng.setStart(parentBlock, 0);\n      rng.setEnd(parentBlock, 0);\n      if (!isCell && !isPartOfFragment(parentBlock) && (nextRng = findNextCaretRng(rng))) {\n        rng = nextRng;\n        dom.remove(parentBlock);\n      } else {\n        dom.add(parentBlock, dom.create('br', isCell ? {} : {\n          'data-mce-bogus': '1'\n        }));\n      }\n    }\n    selection.setRng(rng);\n  };\n  const deleteSelectedContent = editor => {\n    const dom = editor.dom;\n    const rng = normalize(editor.selection.getRng());\n    editor.selection.setRng(rng);\n    const startCell = dom.getParent(rng.startContainer, isTableCell);\n    if (isTableCellContentSelected(dom, rng, startCell)) {\n      deleteCellContents(editor, rng, SugarElement.fromDom(startCell));\n    } else if (rng.startContainer === rng.endContainer && rng.endOffset - rng.startOffset === 1 && isText$b(rng.startContainer.childNodes[rng.startOffset])) {\n      rng.deleteContents();\n    } else {\n      editor.getDoc().execCommand('Delete', false);\n    }\n  };\n  const findMarkerNode = scope => {\n    for (let markerNode = scope; markerNode; markerNode = markerNode.walk()) {\n      if (markerNode.attr('id') === 'mce_marker') {\n        return Optional.some(markerNode);\n      }\n    }\n    return Optional.none();\n  };\n  const notHeadingsInSummary = (dom, node, fragment) => {\n    var _a;\n    return exists(fragment.children(), isHeading) && ((_a = dom.getParent(node, dom.isBlock)) === null || _a === void 0 ? void 0 : _a.nodeName) === 'SUMMARY';\n  };\n  const insertHtmlAtCaret = (editor, value, details) => {\n    var _a, _b;\n    const selection = editor.selection;\n    const dom = editor.dom;\n    const parser = editor.parser;\n    const merge = details.merge;\n    const serializer = HtmlSerializer({\n      validate: true\n    }, editor.schema);\n    const bookmarkHtml = '<span id=\"mce_marker\" data-mce-type=\"bookmark\">&#xFEFF;</span>';\n    if (!details.preserve_zwsp) {\n      value = trim$2(value);\n    }\n    if (value.indexOf('{$caret}') === -1) {\n      value += '{$caret}';\n    }\n    value = value.replace(/\\{\\$caret\\}/, bookmarkHtml);\n    let rng = selection.getRng();\n    const caretElement = rng.startContainer;\n    const body = editor.getBody();\n    if (caretElement === body && selection.isCollapsed()) {\n      if (dom.isBlock(body.firstChild) && canHaveChildren(editor, body.firstChild) && dom.isEmpty(body.firstChild)) {\n        rng = dom.createRng();\n        rng.setStart(body.firstChild, 0);\n        rng.setEnd(body.firstChild, 0);\n        selection.setRng(rng);\n      }\n    }\n    if (!selection.isCollapsed()) {\n      deleteSelectedContent(editor);\n    }\n    const parentNode = selection.getNode();\n    const parserArgs = {\n      context: parentNode.nodeName.toLowerCase(),\n      data: details.data,\n      insert: true\n    };\n    const fragment = parser.parse(value, parserArgs);\n    if (details.paste === true && isListFragment(editor.schema, fragment) && isParentBlockLi(dom, parentNode)) {\n      rng = insertAtCaret$1(serializer, dom, selection.getRng(), fragment);\n      if (rng) {\n        selection.setRng(rng);\n      }\n      return value;\n    }\n    if (details.paste === true && shouldPasteContentOnly(dom, fragment, parentNode, editor.getBody())) {\n      (_a = fragment.firstChild) === null || _a === void 0 ? void 0 : _a.unwrap();\n    }\n    markFragmentElements(fragment);\n    let node = fragment.lastChild;\n    if (node && node.attr('id') === 'mce_marker') {\n      const marker = node;\n      for (node = node.prev; node; node = node.walk(true)) {\n        if (node.name === 'table') {\n          break;\n        }\n        if (node.type === 3 || !dom.isBlock(node.name)) {\n          if (node.parent && editor.schema.isValidChild(node.parent.name, 'span')) {\n            node.parent.insert(marker, node, node.name === 'br');\n          }\n          break;\n        }\n      }\n    }\n    editor._selectionOverrides.showBlockCaretContainer(parentNode);\n    if (!parserArgs.invalid && !notHeadingsInSummary(dom, parentNode, fragment)) {\n      value = serializer.serialize(fragment);\n      validInsertion(editor, value, parentNode);\n    } else {\n      editor.selection.setContent(bookmarkHtml);\n      let parentNode = selection.getNode();\n      let tempNode;\n      const rootNode = editor.getBody();\n      if (isDocument$1(parentNode)) {\n        parentNode = tempNode = rootNode;\n      } else {\n        tempNode = parentNode;\n      }\n      while (tempNode && tempNode !== rootNode) {\n        parentNode = tempNode;\n        tempNode = tempNode.parentNode;\n      }\n      value = parentNode === rootNode ? rootNode.innerHTML : dom.getOuterHTML(parentNode);\n      const root = parser.parse(value);\n      const markerNode = findMarkerNode(root);\n      const editingHost = markerNode.bind(findClosestEditingHost).getOr(root);\n      markerNode.each(marker => marker.replace(fragment));\n      const toExtract = fragment.children();\n      const parent = (_b = fragment.parent) !== null && _b !== void 0 ? _b : root;\n      fragment.unwrap();\n      const invalidChildren = filter$5(toExtract, node => isInvalid(editor.schema, node, parent));\n      cleanInvalidNodes(invalidChildren, editor.schema, editingHost);\n      filter$2(parser.getNodeFilters(), parser.getAttributeFilters(), root);\n      value = serializer.serialize(root);\n      if (parentNode === rootNode) {\n        dom.setHTML(rootNode, value);\n      } else {\n        dom.setOuterHTML(parentNode, value);\n      }\n    }\n    reduceInlineTextElements(editor, merge);\n    moveSelectionToMarker(editor, dom.get('mce_marker'));\n    unmarkFragmentElements(editor.getBody());\n    trimBrsFromTableCell(dom, selection.getStart(), editor.schema);\n    updateCaret(editor.schema, editor.getBody(), selection.getStart());\n    return value;\n  };\n  const isTreeNode = content => content instanceof AstNode;\n  const moveSelection = editor => {\n    if (hasFocus(editor)) {\n      firstPositionIn(editor.getBody()).each(pos => {\n        const node = pos.getNode();\n        const caretPos = isTable$2(node) ? firstPositionIn(node).getOr(pos) : pos;\n        editor.selection.setRng(caretPos.toRange());\n      });\n    }\n  };\n  const setEditorHtml = (editor, html, noSelection) => {\n    editor.dom.setHTML(editor.getBody(), html);\n    if (noSelection !== true) {\n      moveSelection(editor);\n    }\n  };\n  const setContentString = (editor, body, content, args) => {\n    content = trim$2(content);\n    if (content.length === 0 || /^\\s+$/.test(content)) {\n      const padd = '<br data-mce-bogus=\"1\">';\n      if (body.nodeName === 'TABLE') {\n        content = '<tr><td>' + padd + '</td></tr>';\n      } else if (/^(UL|OL)$/.test(body.nodeName)) {\n        content = '<li>' + padd + '</li>';\n      }\n      const forcedRootBlockName = getForcedRootBlock(editor);\n      if (editor.schema.isValidChild(body.nodeName.toLowerCase(), forcedRootBlockName.toLowerCase())) {\n        content = padd;\n        content = editor.dom.createHTML(forcedRootBlockName, getForcedRootBlockAttrs(editor), content);\n      } else if (!content) {\n        content = padd;\n      }\n      setEditorHtml(editor, content, args.no_selection);\n      return {\n        content,\n        html: content\n      };\n    } else {\n      if (args.format !== 'raw') {\n        content = HtmlSerializer({\n          validate: false\n        }, editor.schema).serialize(editor.parser.parse(content, {\n          isRootContent: true,\n          insert: true\n        }));\n      }\n      const trimmedHtml = isWsPreserveElement(SugarElement.fromDom(body)) ? content : Tools.trim(content);\n      setEditorHtml(editor, trimmedHtml, args.no_selection);\n      return {\n        content: trimmedHtml,\n        html: trimmedHtml\n      };\n    }\n  };\n  const setContentTree = (editor, body, content, args) => {\n    filter$2(editor.parser.getNodeFilters(), editor.parser.getAttributeFilters(), content);\n    const html = HtmlSerializer({\n      validate: false\n    }, editor.schema).serialize(content);\n    const trimmedHtml = trim$2(isWsPreserveElement(SugarElement.fromDom(body)) ? html : Tools.trim(html));\n    setEditorHtml(editor, trimmedHtml, args.no_selection);\n    return {\n      content,\n      html: trimmedHtml\n    };\n  };\n  const setContentInternal = (editor, content, args) => {\n    return Optional.from(editor.getBody()).map(body => {\n      if (isTreeNode(content)) {\n        return setContentTree(editor, body, content, args);\n      } else {\n        return setContentString(editor, body, content, args);\n      }\n    }).getOr({\n      content,\n      html: isTreeNode(args.content) ? '' : args.content\n    });\n  };\n  const ensureIsRoot = isRoot => isFunction(isRoot) ? isRoot : never;\n  const ancestor = (scope, transform, isRoot) => {\n    let element = scope.dom;\n    const stop = ensureIsRoot(isRoot);\n    while (element.parentNode) {\n      element = element.parentNode;\n      const el = SugarElement.fromDom(element);\n      const transformed = transform(el);\n      if (transformed.isSome()) {\n        return transformed;\n      } else if (stop(el)) {\n        break;\n      }\n    }\n    return Optional.none();\n  };\n  const closest$1 = (scope, transform, isRoot) => {\n    const current = transform(scope);\n    const stop = ensureIsRoot(isRoot);\n    return current.orThunk(() => stop(scope) ? Optional.none() : ancestor(scope, transform, stop));\n  };\n  const isEq$3 = isEq$5;\n  const matchesUnInheritedFormatSelector = (ed, node, name) => {\n    const formatList = ed.formatter.get(name);\n    if (formatList) {\n      for (let i = 0; i < formatList.length; i++) {\n        const format = formatList[i];\n        if (isSelectorFormat(format) && format.inherit === false && ed.dom.is(node, format.selector)) {\n          return true;\n        }\n      }\n    }\n    return false;\n  };\n  const matchParents = (editor, node, name, vars, similar) => {\n    const root = editor.dom.getRoot();\n    if (node === root) {\n      return false;\n    }\n    const matchedNode = editor.dom.getParent(node, elm => {\n      if (matchesUnInheritedFormatSelector(editor, elm, name)) {\n        return true;\n      }\n      return elm.parentNode === root || !!matchNode(editor, elm, name, vars, true);\n    });\n    return !!matchNode(editor, matchedNode, name, vars, similar);\n  };\n  const matchName = (dom, node, format) => {\n    if (isInlineFormat(format) && isEq$3(node, format.inline)) {\n      return true;\n    }\n    if (isBlockFormat(format) && isEq$3(node, format.block)) {\n      return true;\n    }\n    if (isSelectorFormat(format)) {\n      return isElement$6(node) && dom.is(node, format.selector);\n    }\n    return false;\n  };\n  const matchItems = (dom, node, format, itemName, similar, vars) => {\n    const items = format[itemName];\n    const matchAttributes = itemName === 'attributes';\n    if (isFunction(format.onmatch)) {\n      return format.onmatch(node, format, itemName);\n    }\n    if (items) {\n      if (!isArrayLike(items)) {\n        for (const key in items) {\n          if (has$2(items, key)) {\n            const value = matchAttributes ? dom.getAttrib(node, key) : getStyle(dom, node, key);\n            const expectedValue = replaceVars(items[key], vars);\n            const isEmptyValue = isNullable(value) || isEmpty$3(value);\n            if (isEmptyValue && isNullable(expectedValue)) {\n              continue;\n            }\n            if (similar && isEmptyValue && !format.exact) {\n              return false;\n            }\n            if ((!similar || format.exact) && !isEq$3(value, normalizeStyleValue(expectedValue, key))) {\n              return false;\n            }\n          }\n        }\n      } else {\n        for (let i = 0; i < items.length; i++) {\n          if (matchAttributes ? dom.getAttrib(node, items[i]) : getStyle(dom, node, items[i])) {\n            return true;\n          }\n        }\n      }\n    }\n    return true;\n  };\n  const matchNode = (ed, node, name, vars, similar) => {\n    const formatList = ed.formatter.get(name);\n    const dom = ed.dom;\n    if (formatList && isElement$6(node)) {\n      for (let i = 0; i < formatList.length; i++) {\n        const format = formatList[i];\n        if (matchName(ed.dom, node, format) && matchItems(dom, node, format, 'attributes', similar, vars) && matchItems(dom, node, format, 'styles', similar, vars)) {\n          const classes = format.classes;\n          if (classes) {\n            for (let x = 0; x < classes.length; x++) {\n              if (!ed.dom.hasClass(node, replaceVars(classes[x], vars))) {\n                return;\n              }\n            }\n          }\n          return format;\n        }\n      }\n    }\n    return undefined;\n  };\n  const match$2 = (editor, name, vars, node, similar) => {\n    if (node) {\n      return matchParents(editor, node, name, vars, similar);\n    }\n    node = editor.selection.getNode();\n    if (matchParents(editor, node, name, vars, similar)) {\n      return true;\n    }\n    const startNode = editor.selection.getStart();\n    if (startNode !== node) {\n      if (matchParents(editor, startNode, name, vars, similar)) {\n        return true;\n      }\n    }\n    return false;\n  };\n  const matchAll = (editor, names, vars) => {\n    const matchedFormatNames = [];\n    const checkedMap = {};\n    const startElement = editor.selection.getStart();\n    editor.dom.getParent(startElement, node => {\n      for (let i = 0; i < names.length; i++) {\n        const name = names[i];\n        if (!checkedMap[name] && matchNode(editor, node, name, vars)) {\n          checkedMap[name] = true;\n          matchedFormatNames.push(name);\n        }\n      }\n    }, editor.dom.getRoot());\n    return matchedFormatNames;\n  };\n  const closest = (editor, names) => {\n    const isRoot = elm => eq(elm, SugarElement.fromDom(editor.getBody()));\n    const match = (elm, name) => matchNode(editor, elm.dom, name) ? Optional.some(name) : Optional.none();\n    return Optional.from(editor.selection.getStart(true)).bind(rawElm => closest$1(SugarElement.fromDom(rawElm), elm => findMap(names, name => match(elm, name)), isRoot)).getOrNull();\n  };\n  const canApply = (editor, name) => {\n    const formatList = editor.formatter.get(name);\n    const dom = editor.dom;\n    if (formatList && editor.selection.isEditable()) {\n      const startNode = editor.selection.getStart();\n      const parents = getParents$2(dom, startNode);\n      for (let x = formatList.length - 1; x >= 0; x--) {\n        const format = formatList[x];\n        if (!isSelectorFormat(format)) {\n          return true;\n        }\n        for (let i = parents.length - 1; i >= 0; i--) {\n          if (dom.is(parents[i], format.selector)) {\n            return true;\n          }\n        }\n      }\n    }\n    return false;\n  };\n  const matchAllOnNode = (editor, node, formatNames) => foldl(formatNames, (acc, name) => {\n    const matchSimilar = isVariableFormatName(editor, name);\n    if (editor.formatter.matchNode(node, name, {}, matchSimilar)) {\n      return acc.concat([name]);\n    } else {\n      return acc;\n    }\n  }, []);\n  const ZWSP = ZWSP$1;\n  const importNode = (ownerDocument, node) => {\n    return ownerDocument.importNode(node, true);\n  };\n  const findFirstTextNode = node => {\n    if (node) {\n      const walker = new DomTreeWalker(node, node);\n      for (let tempNode = walker.current(); tempNode; tempNode = walker.next()) {\n        if (isText$b(tempNode)) {\n          return tempNode;\n        }\n      }\n    }\n    return null;\n  };\n  const createCaretContainer = fill => {\n    const caretContainer = SugarElement.fromTag('span');\n    setAll$1(caretContainer, {\n      'id': CARET_ID,\n      'data-mce-bogus': '1',\n      'data-mce-type': 'format-caret'\n    });\n    if (fill) {\n      append$1(caretContainer, SugarElement.fromText(ZWSP));\n    }\n    return caretContainer;\n  };\n  const trimZwspFromCaretContainer = caretContainerNode => {\n    const textNode = findFirstTextNode(caretContainerNode);\n    if (textNode && textNode.data.charAt(0) === ZWSP) {\n      textNode.deleteData(0, 1);\n    }\n    return textNode;\n  };\n  const removeCaretContainerNode = (editor, node, moveCaret) => {\n    const dom = editor.dom,\n      selection = editor.selection;\n    if (isCaretContainerEmpty(node)) {\n      deleteElement$2(editor, false, SugarElement.fromDom(node), moveCaret, true);\n    } else {\n      const rng = selection.getRng();\n      const block = dom.getParent(node, dom.isBlock);\n      const startContainer = rng.startContainer;\n      const startOffset = rng.startOffset;\n      const endContainer = rng.endContainer;\n      const endOffset = rng.endOffset;\n      const textNode = trimZwspFromCaretContainer(node);\n      dom.remove(node, true);\n      if (startContainer === textNode && startOffset > 0) {\n        rng.setStart(textNode, startOffset - 1);\n      }\n      if (endContainer === textNode && endOffset > 0) {\n        rng.setEnd(textNode, endOffset - 1);\n      }\n      if (block && dom.isEmpty(block)) {\n        fillWithPaddingBr(SugarElement.fromDom(block));\n      }\n      selection.setRng(rng);\n    }\n  };\n  const removeCaretContainer = (editor, node, moveCaret) => {\n    const dom = editor.dom,\n      selection = editor.selection;\n    if (!node) {\n      node = getParentCaretContainer(editor.getBody(), selection.getStart());\n      if (!node) {\n        while (node = dom.get(CARET_ID)) {\n          removeCaretContainerNode(editor, node, moveCaret);\n        }\n      }\n    } else {\n      removeCaretContainerNode(editor, node, moveCaret);\n    }\n  };\n  const insertCaretContainerNode = (editor, caretContainer, formatNode) => {\n    var _a, _b;\n    const dom = editor.dom;\n    const block = dom.getParent(formatNode, curry(isTextBlock$1, editor.schema));\n    if (block && dom.isEmpty(block)) {\n      (_a = formatNode.parentNode) === null || _a === void 0 ? void 0 : _a.replaceChild(caretContainer, formatNode);\n    } else {\n      removeTrailingBr(SugarElement.fromDom(formatNode));\n      if (dom.isEmpty(formatNode)) {\n        (_b = formatNode.parentNode) === null || _b === void 0 ? void 0 : _b.replaceChild(caretContainer, formatNode);\n      } else {\n        dom.insertAfter(caretContainer, formatNode);\n      }\n    }\n  };\n  const appendNode = (parentNode, node) => {\n    parentNode.appendChild(node);\n    return node;\n  };\n  const insertFormatNodesIntoCaretContainer = (formatNodes, caretContainer) => {\n    var _a;\n    const innerMostFormatNode = foldr(formatNodes, (parentNode, formatNode) => {\n      return appendNode(parentNode, formatNode.cloneNode(false));\n    }, caretContainer);\n    const doc = (_a = innerMostFormatNode.ownerDocument) !== null && _a !== void 0 ? _a : document;\n    return appendNode(innerMostFormatNode, doc.createTextNode(ZWSP));\n  };\n  const cleanFormatNode = (editor, caretContainer, formatNode, name, vars, similar) => {\n    const formatter = editor.formatter;\n    const dom = editor.dom;\n    const validFormats = filter$5(keys(formatter.get()), formatName => formatName !== name && !contains$1(formatName, 'removeformat'));\n    const matchedFormats = matchAllOnNode(editor, formatNode, validFormats);\n    const uniqueFormats = filter$5(matchedFormats, fmtName => !areSimilarFormats(editor, fmtName, name));\n    if (uniqueFormats.length > 0) {\n      const clonedFormatNode = formatNode.cloneNode(false);\n      dom.add(caretContainer, clonedFormatNode);\n      formatter.remove(name, vars, clonedFormatNode, similar);\n      dom.remove(clonedFormatNode);\n      return Optional.some(clonedFormatNode);\n    } else {\n      return Optional.none();\n    }\n  };\n  const normalizeNbsps = node => set(node, get$3(node).replace(new RegExp(`${nbsp}$`), ' '));\n  const normalizeNbspsBetween = (editor, caretContainer) => {\n    const handler = () => {\n      if (caretContainer !== null && !editor.dom.isEmpty(caretContainer)) {\n        prevSibling(SugarElement.fromDom(caretContainer)).each(node => {\n          if (isText$c(node)) {\n            normalizeNbsps(node);\n          } else {\n            descendant$2(node, e => isText$c(e)).each(textNode => {\n              if (isText$c(textNode)) {\n                normalizeNbsps(textNode);\n              }\n            });\n          }\n        });\n      }\n    };\n    editor.once('input', e => {\n      if (e.data && !isWhiteSpace(e.data)) {\n        if (!e.isComposing) {\n          handler();\n        } else {\n          editor.once('compositionend', () => {\n            handler();\n          });\n        }\n      }\n    });\n  };\n  const applyCaretFormat = (editor, name, vars) => {\n    let caretContainer;\n    const selection = editor.selection;\n    const formatList = editor.formatter.get(name);\n    if (!formatList) {\n      return;\n    }\n    const selectionRng = selection.getRng();\n    let offset = selectionRng.startOffset;\n    const container = selectionRng.startContainer;\n    const text = container.nodeValue;\n    caretContainer = getParentCaretContainer(editor.getBody(), selection.getStart());\n    const wordcharRegex = /[^\\s\\u00a0\\u00ad\\u200b\\ufeff]/;\n    if (text && offset > 0 && offset < text.length && wordcharRegex.test(text.charAt(offset)) && wordcharRegex.test(text.charAt(offset - 1))) {\n      const bookmark = selection.getBookmark();\n      selectionRng.collapse(true);\n      let rng = expandRng(editor.dom, selectionRng, formatList);\n      rng = split(rng);\n      editor.formatter.apply(name, vars, rng);\n      selection.moveToBookmark(bookmark);\n    } else {\n      let textNode = caretContainer ? findFirstTextNode(caretContainer) : null;\n      if (!caretContainer || (textNode === null || textNode === void 0 ? void 0 : textNode.data) !== ZWSP) {\n        caretContainer = importNode(editor.getDoc(), createCaretContainer(true).dom);\n        textNode = caretContainer.firstChild;\n        selectionRng.insertNode(caretContainer);\n        offset = 1;\n        normalizeNbspsBetween(editor, caretContainer);\n        editor.formatter.apply(name, vars, caretContainer);\n      } else {\n        editor.formatter.apply(name, vars, caretContainer);\n      }\n      selection.setCursorLocation(textNode, offset);\n    }\n  };\n  const removeCaretFormat = (editor, name, vars, similar) => {\n    const dom = editor.dom;\n    const selection = editor.selection;\n    let hasContentAfter = false;\n    const formatList = editor.formatter.get(name);\n    if (!formatList) {\n      return;\n    }\n    const rng = selection.getRng();\n    const container = rng.startContainer;\n    const offset = rng.startOffset;\n    let node = container;\n    if (isText$b(container)) {\n      if (offset !== container.data.length) {\n        hasContentAfter = true;\n      }\n      node = node.parentNode;\n    }\n    const parents = [];\n    let formatNode;\n    while (node) {\n      if (matchNode(editor, node, name, vars, similar)) {\n        formatNode = node;\n        break;\n      }\n      if (node.nextSibling) {\n        hasContentAfter = true;\n      }\n      parents.push(node);\n      node = node.parentNode;\n    }\n    if (!formatNode) {\n      return;\n    }\n    if (hasContentAfter) {\n      const bookmark = selection.getBookmark();\n      rng.collapse(true);\n      let expandedRng = expandRng(dom, rng, formatList, true);\n      expandedRng = split(expandedRng);\n      editor.formatter.remove(name, vars, expandedRng, similar);\n      selection.moveToBookmark(bookmark);\n    } else {\n      const caretContainer = getParentCaretContainer(editor.getBody(), formatNode);\n      const parentsAfter = isNonNullable(caretContainer) ? dom.getParents(formatNode.parentNode, always, caretContainer) : [];\n      const newCaretContainer = createCaretContainer(false).dom;\n      insertCaretContainerNode(editor, newCaretContainer, caretContainer !== null && caretContainer !== void 0 ? caretContainer : formatNode);\n      const cleanedFormatNode = cleanFormatNode(editor, newCaretContainer, formatNode, name, vars, similar);\n      const caretTextNode = insertFormatNodesIntoCaretContainer([...parents, ...cleanedFormatNode.toArray(), ...parentsAfter], newCaretContainer);\n      if (caretContainer) {\n        removeCaretContainerNode(editor, caretContainer, isNonNullable(caretContainer));\n      }\n      selection.setCursorLocation(caretTextNode, 1);\n      normalizeNbspsBetween(editor, newCaretContainer);\n      if (dom.isEmpty(formatNode)) {\n        dom.remove(formatNode);\n      }\n    }\n  };\n  const disableCaretContainer = (editor, keyCode, moveCaret) => {\n    const selection = editor.selection,\n      body = editor.getBody();\n    removeCaretContainer(editor, null, moveCaret);\n    if ((keyCode === 8 || keyCode === 46) && selection.isCollapsed() && selection.getStart().innerHTML === ZWSP) {\n      removeCaretContainer(editor, getParentCaretContainer(body, selection.getStart()), true);\n    }\n    if (keyCode === 37 || keyCode === 39) {\n      removeCaretContainer(editor, getParentCaretContainer(body, selection.getStart()), true);\n    }\n  };\n  const endsWithNbsp = element => isText$b(element) && endsWith(element.data, nbsp);\n  const setup$v = editor => {\n    editor.on('mouseup keydown', e => {\n      disableCaretContainer(editor, e.keyCode, endsWithNbsp(editor.selection.getRng().endContainer));\n    });\n  };\n  const createCaretFormat = formatNodes => {\n    const caretContainer = createCaretContainer(false);\n    const innerMost = insertFormatNodesIntoCaretContainer(formatNodes, caretContainer.dom);\n    return {\n      caretContainer,\n      caretPosition: CaretPosition(innerMost, 0)\n    };\n  };\n  const replaceWithCaretFormat = (targetNode, formatNodes) => {\n    const {\n      caretContainer,\n      caretPosition\n    } = createCaretFormat(formatNodes);\n    before$3(SugarElement.fromDom(targetNode), caretContainer);\n    remove$4(SugarElement.fromDom(targetNode));\n    return caretPosition;\n  };\n  const createCaretFormatAtStart$1 = (rng, formatNodes) => {\n    const {\n      caretContainer,\n      caretPosition\n    } = createCaretFormat(formatNodes);\n    rng.insertNode(caretContainer.dom);\n    return caretPosition;\n  };\n  const isFormatElement = (editor, element) => {\n    if (isCaretNode(element.dom)) {\n      return false;\n    }\n    const inlineElements = editor.schema.getTextInlineElements();\n    return has$2(inlineElements, name(element)) && !isCaretNode(element.dom) && !isBogus$1(element.dom);\n  };\n  const postProcessHooks = {};\n  const isPre = matchNodeNames(['pre']);\n  const addPostProcessHook = (name, hook) => {\n    const hooks = postProcessHooks[name];\n    if (!hooks) {\n      postProcessHooks[name] = [];\n    }\n    postProcessHooks[name].push(hook);\n  };\n  const postProcess$1 = (name, editor) => {\n    if (has$2(postProcessHooks, name)) {\n      each$e(postProcessHooks[name], hook => {\n        hook(editor);\n      });\n    }\n  };\n  addPostProcessHook('pre', editor => {\n    const rng = editor.selection.getRng();\n    const hasPreSibling = blocks => pre => {\n      const prev = pre.previousSibling;\n      return isPre(prev) && contains$2(blocks, prev);\n    };\n    const joinPre = (pre1, pre2) => {\n      const sPre2 = SugarElement.fromDom(pre2);\n      const doc = documentOrOwner(sPre2).dom;\n      remove$4(sPre2);\n      append(SugarElement.fromDom(pre1), [SugarElement.fromTag('br', doc), SugarElement.fromTag('br', doc), ...children$1(sPre2)]);\n    };\n    if (!rng.collapsed) {\n      const blocks = editor.selection.getSelectedBlocks();\n      const preBlocks = filter$5(filter$5(blocks, isPre), hasPreSibling(blocks));\n      each$e(preBlocks, pre => {\n        joinPre(pre.previousSibling, pre);\n      });\n    }\n  });\n  const listItemStyles = ['fontWeight', 'fontStyle', 'color', 'fontSize', 'fontFamily'];\n  const hasListStyles = fmt => isObject(fmt.styles) && exists(keys(fmt.styles), name => contains$2(listItemStyles, name));\n  const findExpandedListItemFormat = formats => find$2(formats, fmt => isInlineFormat(fmt) && fmt.inline === 'span' && hasListStyles(fmt));\n  const getExpandedListItemFormat = (formatter, format) => {\n    const formatList = formatter.get(format);\n    return isArray$1(formatList) ? findExpandedListItemFormat(formatList) : Optional.none();\n  };\n  const isRngStartAtStartOfElement = (rng, elm) => prevPosition(elm, CaretPosition.fromRangeStart(rng)).isNone();\n  const isRngEndAtEndOfElement = (rng, elm) => {\n    return nextPosition(elm, CaretPosition.fromRangeEnd(rng)).exists(pos => !isBr$6(pos.getNode()) || nextPosition(elm, pos).isSome()) === false;\n  };\n  const isEditableListItem = dom => elm => isListItem$2(elm) && dom.isEditable(elm);\n  const getFullySelectedBlocks = selection => {\n    const blocks = selection.getSelectedBlocks();\n    const rng = selection.getRng();\n    if (selection.isCollapsed()) {\n      return [];\n    }\n    if (blocks.length === 1) {\n      return isRngStartAtStartOfElement(rng, blocks[0]) && isRngEndAtEndOfElement(rng, blocks[0]) ? blocks : [];\n    } else {\n      const first = head(blocks).filter(elm => isRngStartAtStartOfElement(rng, elm)).toArray();\n      const last = last$2(blocks).filter(elm => isRngEndAtEndOfElement(rng, elm)).toArray();\n      const middle = blocks.slice(1, -1);\n      return first.concat(middle).concat(last);\n    }\n  };\n  const getFullySelectedListItems = selection => filter$5(getFullySelectedBlocks(selection), isEditableListItem(selection.dom));\n  const getPartiallySelectedListItems = selection => filter$5(selection.getSelectedBlocks(), isEditableListItem(selection.dom));\n  const each$8 = Tools.each;\n  const isElementNode = node => isElement$6(node) && !isBookmarkNode$1(node) && !isCaretNode(node) && !isBogus$1(node);\n  const findElementSibling = (node, siblingName) => {\n    for (let sibling = node; sibling; sibling = sibling[siblingName]) {\n      if (isText$b(sibling) && isNotEmpty(sibling.data)) {\n        return node;\n      }\n      if (isElement$6(sibling) && !isBookmarkNode$1(sibling)) {\n        return sibling;\n      }\n    }\n    return node;\n  };\n  const mergeSiblingsNodes = (editor, prev, next) => {\n    const elementUtils = ElementUtils(editor);\n    const isPrevEditable = isHTMLElement(prev) && editor.dom.isEditable(prev);\n    const isNextEditable = isHTMLElement(next) && editor.dom.isEditable(next);\n    if (isPrevEditable && isNextEditable) {\n      const prevSibling = findElementSibling(prev, 'previousSibling');\n      const nextSibling = findElementSibling(next, 'nextSibling');\n      if (elementUtils.compare(prevSibling, nextSibling)) {\n        for (let sibling = prevSibling.nextSibling; sibling && sibling !== nextSibling;) {\n          const tmpSibling = sibling;\n          sibling = sibling.nextSibling;\n          prevSibling.appendChild(tmpSibling);\n        }\n        editor.dom.remove(nextSibling);\n        Tools.each(Tools.grep(nextSibling.childNodes), node => {\n          prevSibling.appendChild(node);\n        });\n        return prevSibling;\n      }\n    }\n    return next;\n  };\n  const mergeSiblings = (editor, format, vars, node) => {\n    var _a;\n    if (node && format.merge_siblings !== false) {\n      const newNode = (_a = mergeSiblingsNodes(editor, getNonWhiteSpaceSibling(node), node)) !== null && _a !== void 0 ? _a : node;\n      mergeSiblingsNodes(editor, newNode, getNonWhiteSpaceSibling(newNode, true));\n    }\n  };\n  const clearChildStyles = (dom, format, node) => {\n    if (format.clear_child_styles) {\n      const selector = format.links ? '*:not(a)' : '*';\n      each$8(dom.select(selector, node), childNode => {\n        if (isElementNode(childNode) && dom.isEditable(childNode)) {\n          each$8(format.styles, (_value, name) => {\n            dom.setStyle(childNode, name, '');\n          });\n        }\n      });\n    }\n  };\n  const processChildElements = (node, filter, process) => {\n    each$8(node.childNodes, node => {\n      if (isElementNode(node)) {\n        if (filter(node)) {\n          process(node);\n        }\n        if (node.hasChildNodes()) {\n          processChildElements(node, filter, process);\n        }\n      }\n    });\n  };\n  const unwrapEmptySpan = (dom, node) => {\n    if (node.nodeName === 'SPAN' && dom.getAttribs(node).length === 0) {\n      dom.remove(node, true);\n    }\n  };\n  const hasStyle = (dom, name) => node => !!(node && getStyle(dom, node, name));\n  const applyStyle = (dom, name, value) => node => {\n    dom.setStyle(node, name, value);\n    if (node.getAttribute('style') === '') {\n      node.removeAttribute('style');\n    }\n    unwrapEmptySpan(dom, node);\n  };\n  const removeResult = Adt.generate([{\n    keep: []\n  }, {\n    rename: ['name']\n  }, {\n    removed: []\n  }]);\n  const MCE_ATTR_RE = /^(src|href|style)$/;\n  const each$7 = Tools.each;\n  const isEq$2 = isEq$5;\n  const isTableCellOrRow = node => /^(TR|TH|TD)$/.test(node.nodeName);\n  const isChildOfInlineParent = (dom, node, parent) => dom.isChildOf(node, parent) && node !== parent && !dom.isBlock(parent);\n  const getContainer = (ed, rng, start) => {\n    let container = rng[start ? 'startContainer' : 'endContainer'];\n    let offset = rng[start ? 'startOffset' : 'endOffset'];\n    if (isElement$6(container)) {\n      const lastIdx = container.childNodes.length - 1;\n      if (!start && offset) {\n        offset--;\n      }\n      container = container.childNodes[offset > lastIdx ? lastIdx : offset];\n    }\n    if (isText$b(container) && start && offset >= container.data.length) {\n      container = new DomTreeWalker(container, ed.getBody()).next() || container;\n    }\n    if (isText$b(container) && !start && offset === 0) {\n      container = new DomTreeWalker(container, ed.getBody()).prev() || container;\n    }\n    return container;\n  };\n  const normalizeTableSelection = (node, start) => {\n    const prop = start ? 'firstChild' : 'lastChild';\n    const childNode = node[prop];\n    if (isTableCellOrRow(node) && childNode) {\n      if (node.nodeName === 'TR') {\n        return childNode[prop] || childNode;\n      } else {\n        return childNode;\n      }\n    }\n    return node;\n  };\n  const wrap$1 = (dom, node, name, attrs) => {\n    var _a;\n    const wrapper = dom.create(name, attrs);\n    (_a = node.parentNode) === null || _a === void 0 ? void 0 : _a.insertBefore(wrapper, node);\n    wrapper.appendChild(node);\n    return wrapper;\n  };\n  const wrapWithSiblings = (dom, node, next, name, attrs) => {\n    const start = SugarElement.fromDom(node);\n    const wrapper = SugarElement.fromDom(dom.create(name, attrs));\n    const siblings = next ? nextSiblings(start) : prevSiblings(start);\n    append(wrapper, siblings);\n    if (next) {\n      before$3(start, wrapper);\n      prepend(wrapper, start);\n    } else {\n      after$4(start, wrapper);\n      append$1(wrapper, start);\n    }\n    return wrapper.dom;\n  };\n  const isColorFormatAndAnchor = (node, format) => format.links && node.nodeName === 'A';\n  const removeNode = (ed, node, format) => {\n    const parentNode = node.parentNode;\n    let rootBlockElm;\n    const dom = ed.dom;\n    const forcedRootBlock = getForcedRootBlock(ed);\n    if (isBlockFormat(format)) {\n      if (parentNode === dom.getRoot()) {\n        if (!format.list_block || !isEq$2(node, format.list_block)) {\n          each$e(from(node.childNodes), node => {\n            if (isValid(ed, forcedRootBlock, node.nodeName.toLowerCase())) {\n              if (!rootBlockElm) {\n                rootBlockElm = wrap$1(dom, node, forcedRootBlock);\n                dom.setAttribs(rootBlockElm, getForcedRootBlockAttrs(ed));\n              } else {\n                rootBlockElm.appendChild(node);\n              }\n            } else {\n              rootBlockElm = null;\n            }\n          });\n        }\n      }\n    }\n    if (isMixedFormat(format) && !isEq$2(format.inline, node)) {\n      return;\n    }\n    dom.remove(node, true);\n  };\n  const processFormatAttrOrStyle = (name, value, vars) => {\n    if (isNumber(name)) {\n      return {\n        name: value,\n        value: null\n      };\n    } else {\n      return {\n        name,\n        value: replaceVars(value, vars)\n      };\n    }\n  };\n  const removeEmptyStyleAttributeIfNeeded = (dom, elm) => {\n    if (dom.getAttrib(elm, 'style') === '') {\n      elm.removeAttribute('style');\n      elm.removeAttribute('data-mce-style');\n    }\n  };\n  const removeStyles = (dom, elm, format, vars, compareNode) => {\n    let stylesModified = false;\n    each$7(format.styles, (value, name) => {\n      const {\n        name: styleName,\n        value: styleValue\n      } = processFormatAttrOrStyle(name, value, vars);\n      const normalizedStyleValue = normalizeStyleValue(styleValue, styleName);\n      if (format.remove_similar || isNull(styleValue) || !isElement$6(compareNode) || isEq$2(getStyle(dom, compareNode, styleName), normalizedStyleValue)) {\n        dom.setStyle(elm, styleName, '');\n      }\n      stylesModified = true;\n    });\n    if (stylesModified) {\n      removeEmptyStyleAttributeIfNeeded(dom, elm);\n    }\n  };\n  const removeListStyleFormats = (editor, name, vars) => {\n    if (name === 'removeformat') {\n      each$e(getPartiallySelectedListItems(editor.selection), li => {\n        each$e(listItemStyles, name => editor.dom.setStyle(li, name, ''));\n        removeEmptyStyleAttributeIfNeeded(editor.dom, li);\n      });\n    } else {\n      getExpandedListItemFormat(editor.formatter, name).each(liFmt => {\n        each$e(getPartiallySelectedListItems(editor.selection), li => removeStyles(editor.dom, li, liFmt, vars, null));\n      });\n    }\n  };\n  const removeNodeFormatInternal = (ed, format, vars, node, compareNode) => {\n    const dom = ed.dom;\n    const elementUtils = ElementUtils(ed);\n    const schema = ed.schema;\n    if (isInlineFormat(format) && isTransparentElementName(schema, format.inline) && isTransparentBlock(schema, node) && node.parentElement === ed.getBody()) {\n      removeNode(ed, node, format);\n      return removeResult.removed();\n    }\n    if (!format.ceFalseOverride && node && dom.getContentEditableParent(node) === 'false') {\n      return removeResult.keep();\n    }\n    if (node && !matchName(dom, node, format) && !isColorFormatAndAnchor(node, format)) {\n      return removeResult.keep();\n    }\n    const elm = node;\n    const preserveAttributes = format.preserve_attributes;\n    if (isInlineFormat(format) && format.remove === 'all' && isArray$1(preserveAttributes)) {\n      const attrsToPreserve = filter$5(dom.getAttribs(elm), attr => contains$2(preserveAttributes, attr.name.toLowerCase()));\n      dom.removeAllAttribs(elm);\n      each$e(attrsToPreserve, attr => dom.setAttrib(elm, attr.name, attr.value));\n      if (attrsToPreserve.length > 0) {\n        return removeResult.rename('span');\n      }\n    }\n    if (format.remove !== 'all') {\n      removeStyles(dom, elm, format, vars, compareNode);\n      each$7(format.attributes, (value, name) => {\n        const {\n          name: attrName,\n          value: attrValue\n        } = processFormatAttrOrStyle(name, value, vars);\n        if (format.remove_similar || isNull(attrValue) || !isElement$6(compareNode) || isEq$2(dom.getAttrib(compareNode, attrName), attrValue)) {\n          if (attrName === 'class') {\n            const currentValue = dom.getAttrib(elm, attrName);\n            if (currentValue) {\n              let valueOut = '';\n              each$e(currentValue.split(/\\s+/), cls => {\n                if (/mce\\-\\w+/.test(cls)) {\n                  valueOut += (valueOut ? ' ' : '') + cls;\n                }\n              });\n              if (valueOut) {\n                dom.setAttrib(elm, attrName, valueOut);\n                return;\n              }\n            }\n          }\n          if (MCE_ATTR_RE.test(attrName)) {\n            elm.removeAttribute('data-mce-' + attrName);\n          }\n          if (attrName === 'style' && matchNodeNames(['li'])(elm) && dom.getStyle(elm, 'list-style-type') === 'none') {\n            elm.removeAttribute(attrName);\n            dom.setStyle(elm, 'list-style-type', 'none');\n            return;\n          }\n          if (attrName === 'class') {\n            elm.removeAttribute('className');\n          }\n          elm.removeAttribute(attrName);\n        }\n      });\n      each$7(format.classes, value => {\n        value = replaceVars(value, vars);\n        if (!isElement$6(compareNode) || dom.hasClass(compareNode, value)) {\n          dom.removeClass(elm, value);\n        }\n      });\n      const attrs = dom.getAttribs(elm);\n      for (let i = 0; i < attrs.length; i++) {\n        const attrName = attrs[i].nodeName;\n        if (!elementUtils.isAttributeInternal(attrName)) {\n          return removeResult.keep();\n        }\n      }\n    }\n    if (format.remove !== 'none') {\n      removeNode(ed, elm, format);\n      return removeResult.removed();\n    }\n    return removeResult.keep();\n  };\n  const findFormatRoot = (editor, container, name, vars, similar) => {\n    let formatRoot;\n    if (container.parentNode) {\n      each$e(getParents$2(editor.dom, container.parentNode).reverse(), parent => {\n        if (!formatRoot && isElement$6(parent) && parent.id !== '_start' && parent.id !== '_end') {\n          const format = matchNode(editor, parent, name, vars, similar);\n          if (format && format.split !== false) {\n            formatRoot = parent;\n          }\n        }\n      });\n    }\n    return formatRoot;\n  };\n  const removeNodeFormatFromClone = (editor, format, vars, clone) => removeNodeFormatInternal(editor, format, vars, clone, clone).fold(constant(clone), newName => {\n    const fragment = editor.dom.createFragment();\n    fragment.appendChild(clone);\n    return editor.dom.rename(clone, newName);\n  }, constant(null));\n  const wrapAndSplit = (editor, formatList, formatRoot, container, target, split, format, vars) => {\n    var _a, _b;\n    let lastClone;\n    let firstClone;\n    const dom = editor.dom;\n    if (formatRoot) {\n      const formatRootParent = formatRoot.parentNode;\n      for (let parent = container.parentNode; parent && parent !== formatRootParent; parent = parent.parentNode) {\n        let clone = dom.clone(parent, false);\n        for (let i = 0; i < formatList.length; i++) {\n          clone = removeNodeFormatFromClone(editor, formatList[i], vars, clone);\n          if (clone === null) {\n            break;\n          }\n        }\n        if (clone) {\n          if (lastClone) {\n            clone.appendChild(lastClone);\n          }\n          if (!firstClone) {\n            firstClone = clone;\n          }\n          lastClone = clone;\n        }\n      }\n      if (split && (!format.mixed || !dom.isBlock(formatRoot))) {\n        container = (_a = dom.split(formatRoot, container)) !== null && _a !== void 0 ? _a : container;\n      }\n      if (lastClone && firstClone) {\n        (_b = target.parentNode) === null || _b === void 0 ? void 0 : _b.insertBefore(lastClone, target);\n        firstClone.appendChild(target);\n        if (isInlineFormat(format)) {\n          mergeSiblings(editor, format, vars, lastClone);\n        }\n      }\n    }\n    return container;\n  };\n  const removeFormatInternal = (ed, name, vars, node, similar) => {\n    const formatList = ed.formatter.get(name);\n    const format = formatList[0];\n    const dom = ed.dom;\n    const selection = ed.selection;\n    const splitToFormatRoot = container => {\n      const formatRoot = findFormatRoot(ed, container, name, vars, similar);\n      return wrapAndSplit(ed, formatList, formatRoot, container, container, true, format, vars);\n    };\n    const isRemoveBookmarkNode = node => isBookmarkNode$1(node) && isElement$6(node) && (node.id === '_start' || node.id === '_end');\n    const removeFormatOnNode = node => exists(formatList, fmt => removeNodeFormat(ed, fmt, vars, node, node));\n    const process = node => {\n      const children = from(node.childNodes);\n      const removed = removeFormatOnNode(node);\n      const currentNodeMatches = removed || exists(formatList, f => matchName(dom, node, f));\n      const parentNode = node.parentNode;\n      if (!currentNodeMatches && isNonNullable(parentNode) && shouldExpandToSelector(format)) {\n        removeFormatOnNode(parentNode);\n      }\n      if (format.deep) {\n        if (children.length) {\n          for (let i = 0; i < children.length; i++) {\n            process(children[i]);\n          }\n        }\n      }\n      const textDecorations = ['underline', 'line-through', 'overline'];\n      each$e(textDecorations, decoration => {\n        if (isElement$6(node) && ed.dom.getStyle(node, 'text-decoration') === decoration && node.parentNode && getTextDecoration(dom, node.parentNode) === decoration) {\n          removeNodeFormat(ed, {\n            deep: false,\n            exact: true,\n            inline: 'span',\n            styles: {\n              textDecoration: decoration\n            }\n          }, undefined, node);\n        }\n      });\n    };\n    const unwrap = start => {\n      const node = dom.get(start ? '_start' : '_end');\n      if (node) {\n        let out = node[start ? 'firstChild' : 'lastChild'];\n        if (isRemoveBookmarkNode(out)) {\n          out = out[start ? 'firstChild' : 'lastChild'];\n        }\n        if (isText$b(out) && out.data.length === 0) {\n          out = start ? node.previousSibling || node.nextSibling : node.nextSibling || node.previousSibling;\n        }\n        dom.remove(node, true);\n        return out;\n      } else {\n        return null;\n      }\n    };\n    const removeRngStyle = rng => {\n      let startContainer;\n      let endContainer;\n      let expandedRng = expandRng(dom, rng, formatList, rng.collapsed);\n      if (format.split) {\n        expandedRng = split(expandedRng);\n        startContainer = getContainer(ed, expandedRng, true);\n        endContainer = getContainer(ed, expandedRng);\n        if (startContainer !== endContainer) {\n          startContainer = normalizeTableSelection(startContainer, true);\n          endContainer = normalizeTableSelection(endContainer, false);\n          if (isChildOfInlineParent(dom, startContainer, endContainer)) {\n            const marker = Optional.from(startContainer.firstChild).getOr(startContainer);\n            splitToFormatRoot(wrapWithSiblings(dom, marker, true, 'span', {\n              'id': '_start',\n              'data-mce-type': 'bookmark'\n            }));\n            unwrap(true);\n            return;\n          }\n          if (isChildOfInlineParent(dom, endContainer, startContainer)) {\n            const marker = Optional.from(endContainer.lastChild).getOr(endContainer);\n            splitToFormatRoot(wrapWithSiblings(dom, marker, false, 'span', {\n              'id': '_end',\n              'data-mce-type': 'bookmark'\n            }));\n            unwrap(false);\n            return;\n          }\n          startContainer = wrap$1(dom, startContainer, 'span', {\n            'id': '_start',\n            'data-mce-type': 'bookmark'\n          });\n          endContainer = wrap$1(dom, endContainer, 'span', {\n            'id': '_end',\n            'data-mce-type': 'bookmark'\n          });\n          const newRng = dom.createRng();\n          newRng.setStartAfter(startContainer);\n          newRng.setEndBefore(endContainer);\n          walk$3(dom, newRng, nodes => {\n            each$e(nodes, n => {\n              if (!isBookmarkNode$1(n) && !isBookmarkNode$1(n.parentNode)) {\n                splitToFormatRoot(n);\n              }\n            });\n          });\n          splitToFormatRoot(startContainer);\n          splitToFormatRoot(endContainer);\n          startContainer = unwrap(true);\n          endContainer = unwrap();\n        } else {\n          startContainer = endContainer = splitToFormatRoot(startContainer);\n        }\n        expandedRng.startContainer = startContainer.parentNode ? startContainer.parentNode : startContainer;\n        expandedRng.startOffset = dom.nodeIndex(startContainer);\n        expandedRng.endContainer = endContainer.parentNode ? endContainer.parentNode : endContainer;\n        expandedRng.endOffset = dom.nodeIndex(endContainer) + 1;\n      }\n      walk$3(dom, expandedRng, nodes => {\n        each$e(nodes, process);\n      });\n    };\n    if (node) {\n      if (isNode(node)) {\n        const rng = dom.createRng();\n        rng.setStartBefore(node);\n        rng.setEndAfter(node);\n        removeRngStyle(rng);\n      } else {\n        removeRngStyle(node);\n      }\n      fireFormatRemove(ed, name, node, vars);\n      return;\n    }\n    if (!selection.isCollapsed() || !isInlineFormat(format) || getCellsFromEditor(ed).length) {\n      preserveSelection(ed, () => runOnRanges(ed, removeRngStyle), startNode => isInlineFormat(format) && match$2(ed, name, vars, startNode));\n      ed.nodeChanged();\n    } else {\n      removeCaretFormat(ed, name, vars, similar);\n    }\n    removeListStyleFormats(ed, name, vars);\n    fireFormatRemove(ed, name, node, vars);\n  };\n  const removeFormat$1 = (ed, name, vars, node, similar) => {\n    if (node || ed.selection.isEditable()) {\n      removeFormatInternal(ed, name, vars, node, similar);\n    }\n  };\n  const removeNodeFormat = (editor, format, vars, node, compareNode) => {\n    return removeNodeFormatInternal(editor, format, vars, node, compareNode).fold(never, newName => {\n      editor.dom.rename(node, newName);\n      return true;\n    }, always);\n  };\n  const each$6 = Tools.each;\n  const mergeTextDecorationsAndColor = (dom, format, vars, node) => {\n    const processTextDecorationsAndColor = n => {\n      if (isHTMLElement(n) && isElement$6(n.parentNode) && dom.isEditable(n)) {\n        const parentTextDecoration = getTextDecoration(dom, n.parentNode);\n        if (dom.getStyle(n, 'color') && parentTextDecoration) {\n          dom.setStyle(n, 'text-decoration', parentTextDecoration);\n        } else if (dom.getStyle(n, 'text-decoration') === parentTextDecoration) {\n          dom.setStyle(n, 'text-decoration', null);\n        }\n      }\n    };\n    if (format.styles && (format.styles.color || format.styles.textDecoration)) {\n      Tools.walk(node, processTextDecorationsAndColor, 'childNodes');\n      processTextDecorationsAndColor(node);\n    }\n  };\n  const mergeBackgroundColorAndFontSize = (dom, format, vars, node) => {\n    if (format.styles && format.styles.backgroundColor) {\n      const hasFontSize = hasStyle(dom, 'fontSize');\n      processChildElements(node, elm => hasFontSize(elm) && dom.isEditable(elm), applyStyle(dom, 'backgroundColor', replaceVars(format.styles.backgroundColor, vars)));\n    }\n  };\n  const mergeSubSup = (dom, format, vars, node) => {\n    if (isInlineFormat(format) && (format.inline === 'sub' || format.inline === 'sup')) {\n      const hasFontSize = hasStyle(dom, 'fontSize');\n      processChildElements(node, elm => hasFontSize(elm) && dom.isEditable(elm), applyStyle(dom, 'fontSize', ''));\n      const inverseTagDescendants = filter$5(dom.select(format.inline === 'sup' ? 'sub' : 'sup', node), dom.isEditable);\n      dom.remove(inverseTagDescendants, true);\n    }\n  };\n  const mergeWithChildren = (editor, formatList, vars, node) => {\n    each$6(formatList, format => {\n      if (isInlineFormat(format)) {\n        each$6(editor.dom.select(format.inline, node), child => {\n          if (isElementNode(child)) {\n            removeNodeFormat(editor, format, vars, child, format.exact ? child : null);\n          }\n        });\n      }\n      clearChildStyles(editor.dom, format, node);\n    });\n  };\n  const mergeWithParents = (editor, format, name, vars, node) => {\n    const parentNode = node.parentNode;\n    if (matchNode(editor, parentNode, name, vars)) {\n      if (removeNodeFormat(editor, format, vars, node)) {\n        return;\n      }\n    }\n    if (format.merge_with_parents && parentNode) {\n      editor.dom.getParent(parentNode, parent => {\n        if (matchNode(editor, parent, name, vars)) {\n          removeNodeFormat(editor, format, vars, node);\n          return true;\n        } else {\n          return false;\n        }\n      });\n    }\n  };\n  const each$5 = Tools.each;\n  const canFormatBR = (editor, format, node, parentName) => {\n    if (canFormatEmptyLines(editor) && isInlineFormat(format) && node.parentNode) {\n      const validBRParentElements = getTextRootBlockElements(editor.schema);\n      const hasCaretNodeSibling = sibling(SugarElement.fromDom(node), sibling => isCaretNode(sibling.dom));\n      return hasNonNullableKey(validBRParentElements, parentName) && isEmptyNode(editor.schema, node.parentNode, {\n        skipBogus: false,\n        includeZwsp: true\n      }) && !hasCaretNodeSibling;\n    } else {\n      return false;\n    }\n  };\n  const applyStyles = (dom, elm, format, vars) => {\n    each$5(format.styles, (value, name) => {\n      dom.setStyle(elm, name, replaceVars(value, vars));\n    });\n    if (format.styles) {\n      const styleVal = dom.getAttrib(elm, 'style');\n      if (styleVal) {\n        dom.setAttrib(elm, 'data-mce-style', styleVal);\n      }\n    }\n  };\n  const applyFormatAction = (ed, name, vars, node) => {\n    const formatList = ed.formatter.get(name);\n    const format = formatList[0];\n    const isCollapsed = !node && ed.selection.isCollapsed();\n    const dom = ed.dom;\n    const selection = ed.selection;\n    const setElementFormat = (elm, fmt = format) => {\n      if (isFunction(fmt.onformat)) {\n        fmt.onformat(elm, fmt, vars, node);\n      }\n      applyStyles(dom, elm, fmt, vars);\n      each$5(fmt.attributes, (value, name) => {\n        dom.setAttrib(elm, name, replaceVars(value, vars));\n      });\n      each$5(fmt.classes, value => {\n        const newValue = replaceVars(value, vars);\n        if (!dom.hasClass(elm, newValue)) {\n          dom.addClass(elm, newValue);\n        }\n      });\n    };\n    const applyNodeStyle = (formatList, node) => {\n      let found = false;\n      each$5(formatList, format => {\n        if (!isSelectorFormat(format)) {\n          return false;\n        }\n        if (dom.getContentEditable(node) === 'false' && !format.ceFalseOverride) {\n          return true;\n        }\n        if (isNonNullable(format.collapsed) && format.collapsed !== isCollapsed) {\n          return true;\n        }\n        if (dom.is(node, format.selector) && !isCaretNode(node)) {\n          setElementFormat(node, format);\n          found = true;\n          return false;\n        }\n        return true;\n      });\n      return found;\n    };\n    const createWrapElement = wrapName => {\n      if (isString(wrapName)) {\n        const wrapElm = dom.create(wrapName);\n        setElementFormat(wrapElm);\n        return wrapElm;\n      } else {\n        return null;\n      }\n    };\n    const applyRngStyle = (dom, rng, nodeSpecific) => {\n      const newWrappers = [];\n      let contentEditable = true;\n      const wrapName = format.inline || format.block;\n      const wrapElm = createWrapElement(wrapName);\n      const isMatchingWrappingBlock = node => isWrappingBlockFormat(format) && matchNode(ed, node, name, vars);\n      const canRenameBlock = (node, parentName, isEditableDescendant) => {\n        const isValidBlockFormatForNode = isNonWrappingBlockFormat(format) && isTextBlock$1(ed.schema, node) && isValid(ed, parentName, wrapName);\n        return isEditableDescendant && isValidBlockFormatForNode;\n      };\n      const canWrapNode = (node, parentName, isEditableDescendant, isWrappableNoneditableElm) => {\n        const nodeName = node.nodeName.toLowerCase();\n        const isValidWrapNode = isValid(ed, wrapName, nodeName) && isValid(ed, parentName, wrapName);\n        const isZwsp$1 = !nodeSpecific && isText$b(node) && isZwsp(node.data);\n        const isCaret = isCaretNode(node);\n        const isCorrectFormatForNode = !isInlineFormat(format) || !dom.isBlock(node);\n        return (isEditableDescendant || isWrappableNoneditableElm) && isValidWrapNode && !isZwsp$1 && !isCaret && isCorrectFormatForNode;\n      };\n      walk$3(dom, rng, nodes => {\n        let currentWrapElm;\n        const process = node => {\n          let hasContentEditableState = false;\n          let lastContentEditable = contentEditable;\n          let isWrappableNoneditableElm = false;\n          const parentNode = node.parentNode;\n          const parentName = parentNode.nodeName.toLowerCase();\n          const contentEditableValue = dom.getContentEditable(node);\n          if (isNonNullable(contentEditableValue)) {\n            lastContentEditable = contentEditable;\n            contentEditable = contentEditableValue === 'true';\n            hasContentEditableState = true;\n            isWrappableNoneditableElm = isWrappableNoneditable(ed, node);\n          }\n          const isEditableDescendant = contentEditable && !hasContentEditableState;\n          if (isBr$6(node) && !canFormatBR(ed, format, node, parentName)) {\n            currentWrapElm = null;\n            if (isBlockFormat(format)) {\n              dom.remove(node);\n            }\n            return;\n          }\n          if (isMatchingWrappingBlock(node)) {\n            currentWrapElm = null;\n            return;\n          }\n          if (canRenameBlock(node, parentName, isEditableDescendant)) {\n            const elm = dom.rename(node, wrapName);\n            setElementFormat(elm);\n            newWrappers.push(elm);\n            currentWrapElm = null;\n            return;\n          }\n          if (isSelectorFormat(format)) {\n            let found = applyNodeStyle(formatList, node);\n            if (!found && isNonNullable(parentNode) && shouldExpandToSelector(format)) {\n              found = applyNodeStyle(formatList, parentNode);\n            }\n            if (!isInlineFormat(format) || found) {\n              currentWrapElm = null;\n              return;\n            }\n          }\n          if (isNonNullable(wrapElm) && canWrapNode(node, parentName, isEditableDescendant, isWrappableNoneditableElm)) {\n            if (!currentWrapElm) {\n              currentWrapElm = dom.clone(wrapElm, false);\n              parentNode.insertBefore(currentWrapElm, node);\n              newWrappers.push(currentWrapElm);\n            }\n            if (isWrappableNoneditableElm && hasContentEditableState) {\n              contentEditable = lastContentEditable;\n            }\n            currentWrapElm.appendChild(node);\n          } else {\n            currentWrapElm = null;\n            each$e(from(node.childNodes), process);\n            if (hasContentEditableState) {\n              contentEditable = lastContentEditable;\n            }\n            currentWrapElm = null;\n          }\n        };\n        each$e(nodes, process);\n      });\n      if (format.links === true) {\n        each$e(newWrappers, node => {\n          const process = node => {\n            if (node.nodeName === 'A') {\n              setElementFormat(node, format);\n            }\n            each$e(from(node.childNodes), process);\n          };\n          process(node);\n        });\n      }\n      each$e(newWrappers, node => {\n        const getChildCount = node => {\n          let count = 0;\n          each$e(node.childNodes, node => {\n            if (!isEmptyTextNode$1(node) && !isBookmarkNode$1(node)) {\n              count++;\n            }\n          });\n          return count;\n        };\n        const mergeStyles = node => {\n          const childElement = find$2(node.childNodes, isElementNode$1).filter(child => dom.getContentEditable(child) !== 'false' && matchName(dom, child, format));\n          return childElement.map(child => {\n            const clone = dom.clone(child, false);\n            setElementFormat(clone);\n            dom.replace(clone, node, true);\n            dom.remove(child, true);\n            return clone;\n          }).getOr(node);\n        };\n        const childCount = getChildCount(node);\n        if ((newWrappers.length > 1 || !dom.isBlock(node)) && childCount === 0) {\n          dom.remove(node, true);\n          return;\n        }\n        if (isInlineFormat(format) || isBlockFormat(format) && format.wrapper) {\n          if (!format.exact && childCount === 1) {\n            node = mergeStyles(node);\n          }\n          mergeWithChildren(ed, formatList, vars, node);\n          mergeWithParents(ed, format, name, vars, node);\n          mergeBackgroundColorAndFontSize(dom, format, vars, node);\n          mergeTextDecorationsAndColor(dom, format, vars, node);\n          mergeSubSup(dom, format, vars, node);\n          mergeSiblings(ed, format, vars, node);\n        }\n      });\n    };\n    const targetNode = isNode(node) ? node : selection.getNode();\n    if (dom.getContentEditable(targetNode) === 'false' && !isWrappableNoneditable(ed, targetNode)) {\n      node = targetNode;\n      applyNodeStyle(formatList, node);\n      fireFormatApply(ed, name, node, vars);\n      return;\n    }\n    if (format) {\n      if (node) {\n        if (isNode(node)) {\n          if (!applyNodeStyle(formatList, node)) {\n            const rng = dom.createRng();\n            rng.setStartBefore(node);\n            rng.setEndAfter(node);\n            applyRngStyle(dom, expandRng(dom, rng, formatList), true);\n          }\n        } else {\n          applyRngStyle(dom, node, true);\n        }\n      } else {\n        if (!isCollapsed || !isInlineFormat(format) || getCellsFromEditor(ed).length) {\n          selection.setRng(normalize(selection.getRng()));\n          preserveSelection(ed, () => {\n            runOnRanges(ed, (selectionRng, fake) => {\n              const expandedRng = fake ? selectionRng : expandRng(dom, selectionRng, formatList);\n              applyRngStyle(dom, expandedRng, false);\n            });\n          }, always);\n          ed.nodeChanged();\n        } else {\n          applyCaretFormat(ed, name, vars);\n        }\n        getExpandedListItemFormat(ed.formatter, name).each(liFmt => {\n          each$e(getFullySelectedListItems(ed.selection), li => applyStyles(dom, li, liFmt, vars));\n        });\n      }\n      postProcess$1(name, ed);\n    }\n    fireFormatApply(ed, name, node, vars);\n  };\n  const applyFormat$1 = (editor, name, vars, node) => {\n    if (node || editor.selection.isEditable()) {\n      applyFormatAction(editor, name, vars, node);\n    }\n  };\n  const hasVars = value => has$2(value, 'vars');\n  const setup$u = (registeredFormatListeners, editor) => {\n    registeredFormatListeners.set({});\n    editor.on('NodeChange', e => {\n      updateAndFireChangeCallbacks(editor, e.element, registeredFormatListeners.get());\n    });\n    editor.on('FormatApply FormatRemove', e => {\n      const element = Optional.from(e.node).map(nodeOrRange => isNode(nodeOrRange) ? nodeOrRange : nodeOrRange.startContainer).bind(node => isElement$6(node) ? Optional.some(node) : Optional.from(node.parentElement)).getOrThunk(() => fallbackElement(editor));\n      updateAndFireChangeCallbacks(editor, element, registeredFormatListeners.get());\n    });\n  };\n  const fallbackElement = editor => editor.selection.getStart();\n  const matchingNode = (editor, parents, format, similar, vars) => {\n    const isMatchingNode = node => {\n      const matchingFormat = editor.formatter.matchNode(node, format, vars !== null && vars !== void 0 ? vars : {}, similar);\n      return !isUndefined(matchingFormat);\n    };\n    const isUnableToMatch = node => {\n      if (matchesUnInheritedFormatSelector(editor, node, format)) {\n        return true;\n      } else {\n        if (!similar) {\n          return isNonNullable(editor.formatter.matchNode(node, format, vars, true));\n        } else {\n          return false;\n        }\n      }\n    };\n    return findUntil$1(parents, isMatchingNode, isUnableToMatch);\n  };\n  const getParents = (editor, elm) => {\n    const element = elm !== null && elm !== void 0 ? elm : fallbackElement(editor);\n    return filter$5(getParents$2(editor.dom, element), node => isElement$6(node) && !isBogus$1(node));\n  };\n  const updateAndFireChangeCallbacks = (editor, elm, registeredCallbacks) => {\n    const parents = getParents(editor, elm);\n    each$d(registeredCallbacks, (data, format) => {\n      const runIfChanged = spec => {\n        const match = matchingNode(editor, parents, format, spec.similar, hasVars(spec) ? spec.vars : undefined);\n        const isSet = match.isSome();\n        if (spec.state.get() !== isSet) {\n          spec.state.set(isSet);\n          const node = match.getOr(elm);\n          if (hasVars(spec)) {\n            spec.callback(isSet, {\n              node,\n              format,\n              parents\n            });\n          } else {\n            each$e(spec.callbacks, callback => callback(isSet, {\n              node,\n              format,\n              parents\n            }));\n          }\n        }\n      };\n      each$e([data.withSimilar, data.withoutSimilar], runIfChanged);\n      each$e(data.withVars, runIfChanged);\n    });\n  };\n  const addListeners = (editor, registeredFormatListeners, formats, callback, similar, vars) => {\n    const formatChangeItems = registeredFormatListeners.get();\n    each$e(formats.split(','), format => {\n      const group = get$a(formatChangeItems, format).getOrThunk(() => {\n        const base = {\n          withSimilar: {\n            state: Cell(false),\n            similar: true,\n            callbacks: []\n          },\n          withoutSimilar: {\n            state: Cell(false),\n            similar: false,\n            callbacks: []\n          },\n          withVars: []\n        };\n        formatChangeItems[format] = base;\n        return base;\n      });\n      const getCurrent = () => {\n        const parents = getParents(editor);\n        return matchingNode(editor, parents, format, similar, vars).isSome();\n      };\n      if (isUndefined(vars)) {\n        const toAppendTo = similar ? group.withSimilar : group.withoutSimilar;\n        toAppendTo.callbacks.push(callback);\n        if (toAppendTo.callbacks.length === 1) {\n          toAppendTo.state.set(getCurrent());\n        }\n      } else {\n        group.withVars.push({\n          state: Cell(getCurrent()),\n          similar,\n          vars,\n          callback\n        });\n      }\n    });\n    registeredFormatListeners.set(formatChangeItems);\n  };\n  const removeListeners = (registeredFormatListeners, formats, callback) => {\n    const formatChangeItems = registeredFormatListeners.get();\n    each$e(formats.split(','), format => get$a(formatChangeItems, format).each(group => {\n      formatChangeItems[format] = {\n        withSimilar: {\n          ...group.withSimilar,\n          callbacks: filter$5(group.withSimilar.callbacks, cb => cb !== callback)\n        },\n        withoutSimilar: {\n          ...group.withoutSimilar,\n          callbacks: filter$5(group.withoutSimilar.callbacks, cb => cb !== callback)\n        },\n        withVars: filter$5(group.withVars, item => item.callback !== callback)\n      };\n    }));\n    registeredFormatListeners.set(formatChangeItems);\n  };\n  const formatChangedInternal = (editor, registeredFormatListeners, formats, callback, similar, vars) => {\n    addListeners(editor, registeredFormatListeners, formats, callback, similar, vars);\n    return {\n      unbind: () => removeListeners(registeredFormatListeners, formats, callback)\n    };\n  };\n  const toggle = (editor, name, vars, node) => {\n    const fmt = editor.formatter.get(name);\n    if (fmt) {\n      if (match$2(editor, name, vars, node) && (!('toggle' in fmt[0]) || fmt[0].toggle)) {\n        removeFormat$1(editor, name, vars, node);\n      } else {\n        applyFormat$1(editor, name, vars, node);\n      }\n    }\n  };\n  const explode$1 = Tools.explode;\n  const create$8 = () => {\n    const filters = {};\n    const addFilter = (name, callback) => {\n      each$e(explode$1(name), name => {\n        if (!has$2(filters, name)) {\n          filters[name] = {\n            name,\n            callbacks: []\n          };\n        }\n        filters[name].callbacks.push(callback);\n      });\n    };\n    const getFilters = () => values(filters);\n    const removeFilter = (name, callback) => {\n      each$e(explode$1(name), name => {\n        if (has$2(filters, name)) {\n          if (isNonNullable(callback)) {\n            const filter = filters[name];\n            const newCallbacks = filter$5(filter.callbacks, c => c !== callback);\n            if (newCallbacks.length > 0) {\n              filter.callbacks = newCallbacks;\n            } else {\n              delete filters[name];\n            }\n          } else {\n            delete filters[name];\n          }\n        }\n      });\n    };\n    return {\n      addFilter,\n      getFilters,\n      removeFilter\n    };\n  };\n  const removeAttrs = (node, names) => {\n    each$e(names, name => {\n      node.attr(name, null);\n    });\n  };\n  const addFontToSpansFilter = (domParser, styles, fontSizes) => {\n    domParser.addNodeFilter('font', nodes => {\n      each$e(nodes, node => {\n        const props = styles.parse(node.attr('style'));\n        const color = node.attr('color');\n        const face = node.attr('face');\n        const size = node.attr('size');\n        if (color) {\n          props.color = color;\n        }\n        if (face) {\n          props['font-family'] = face;\n        }\n        if (size) {\n          toInt(size).each(num => {\n            props['font-size'] = fontSizes[num - 1];\n          });\n        }\n        node.name = 'span';\n        node.attr('style', styles.serialize(props));\n        removeAttrs(node, ['color', 'face', 'size']);\n      });\n    });\n  };\n  const addStrikeFilter = (domParser, schema, styles) => {\n    domParser.addNodeFilter('strike', nodes => {\n      const convertToSTag = schema.type !== 'html4';\n      each$e(nodes, node => {\n        if (convertToSTag) {\n          node.name = 's';\n        } else {\n          const props = styles.parse(node.attr('style'));\n          props['text-decoration'] = 'line-through';\n          node.name = 'span';\n          node.attr('style', styles.serialize(props));\n        }\n      });\n    });\n  };\n  const addFilters = (domParser, settings, schema) => {\n    var _a;\n    const styles = Styles();\n    if (settings.convert_fonts_to_spans) {\n      addFontToSpansFilter(domParser, styles, Tools.explode((_a = settings.font_size_legacy_values) !== null && _a !== void 0 ? _a : ''));\n    }\n    addStrikeFilter(domParser, schema, styles);\n  };\n  const register$5 = (domParser, settings, schema) => {\n    if (settings.inline_styles) {\n      addFilters(domParser, settings, schema);\n    }\n  };\n  const blobUriToBlob = url => fetch(url).then(res => res.ok ? res.blob() : Promise.reject()).catch(() => Promise.reject({\n    message: `Cannot convert ${url} to Blob. Resource might not exist or is inaccessible.`,\n    uriType: 'blob'\n  }));\n  const extractBase64Data = data => {\n    const matches = /([a-z0-9+\\/=\\s]+)/i.exec(data);\n    return matches ? matches[1] : '';\n  };\n  const parseDataUri = uri => {\n    const [type, ...rest] = uri.split(',');\n    const data = rest.join(',');\n    const matches = /data:([^/]+\\/[^;]+)(;.+)?/.exec(type);\n    if (matches) {\n      const base64Encoded = matches[2] === ';base64';\n      const extractedData = base64Encoded ? extractBase64Data(data) : decodeURIComponent(data);\n      return Optional.some({\n        type: matches[1],\n        data: extractedData,\n        base64Encoded\n      });\n    } else {\n      return Optional.none();\n    }\n  };\n  const buildBlob = (type, data, base64Encoded = true) => {\n    let str = data;\n    if (base64Encoded) {\n      try {\n        str = atob(data);\n      } catch (e) {\n        return Optional.none();\n      }\n    }\n    const arr = new Uint8Array(str.length);\n    for (let i = 0; i < arr.length; i++) {\n      arr[i] = str.charCodeAt(i);\n    }\n    return Optional.some(new Blob([arr], {\n      type\n    }));\n  };\n  const dataUriToBlob = uri => {\n    return new Promise((resolve, reject) => {\n      parseDataUri(uri).bind(({\n        type,\n        data,\n        base64Encoded\n      }) => buildBlob(type, data, base64Encoded)).fold(() => reject('Invalid data URI'), resolve);\n    });\n  };\n  const uriToBlob = url => {\n    if (startsWith(url, 'blob:')) {\n      return blobUriToBlob(url);\n    } else if (startsWith(url, 'data:')) {\n      return dataUriToBlob(url);\n    } else {\n      return Promise.reject('Unknown URI format');\n    }\n  };\n  const blobToDataUri = blob => {\n    return new Promise((resolve, reject) => {\n      const reader = new FileReader();\n      reader.onloadend = () => {\n        resolve(reader.result);\n      };\n      reader.onerror = () => {\n        var _a;\n        reject((_a = reader.error) === null || _a === void 0 ? void 0 : _a.message);\n      };\n      reader.readAsDataURL(blob);\n    });\n  };\n  let count$1 = 0;\n  const uniqueId$1 = prefix => {\n    return (prefix || 'blobid') + count$1++;\n  };\n  const processDataUri = (dataUri, base64Only, generateBlobInfo) => {\n    return parseDataUri(dataUri).bind(({\n      data,\n      type,\n      base64Encoded\n    }) => {\n      if (base64Only && !base64Encoded) {\n        return Optional.none();\n      } else {\n        const base64 = base64Encoded ? data : btoa(data);\n        return generateBlobInfo(base64, type);\n      }\n    });\n  };\n  const createBlobInfo$1 = (blobCache, blob, base64) => {\n    const blobInfo = blobCache.create(uniqueId$1(), blob, base64);\n    blobCache.add(blobInfo);\n    return blobInfo;\n  };\n  const dataUriToBlobInfo = (blobCache, dataUri, base64Only = false) => {\n    return processDataUri(dataUri, base64Only, (base64, type) => Optional.from(blobCache.getByData(base64, type)).orThunk(() => buildBlob(type, base64).map(blob => createBlobInfo$1(blobCache, blob, base64))));\n  };\n  const imageToBlobInfo = (blobCache, imageSrc) => {\n    const invalidDataUri = () => Promise.reject('Invalid data URI');\n    if (startsWith(imageSrc, 'blob:')) {\n      const blobInfo = blobCache.getByUri(imageSrc);\n      if (isNonNullable(blobInfo)) {\n        return Promise.resolve(blobInfo);\n      } else {\n        return uriToBlob(imageSrc).then(blob => {\n          return blobToDataUri(blob).then(dataUri => {\n            return processDataUri(dataUri, false, base64 => {\n              return Optional.some(createBlobInfo$1(blobCache, blob, base64));\n            }).getOrThunk(invalidDataUri);\n          });\n        });\n      }\n    } else if (startsWith(imageSrc, 'data:')) {\n      return dataUriToBlobInfo(blobCache, imageSrc).fold(invalidDataUri, blobInfo => Promise.resolve(blobInfo));\n    } else {\n      return Promise.reject('Unknown image data format');\n    }\n  };\n  const hostCaptureRegex = /^(?:(?:(?:[A-Za-z][A-Za-z\\d.+-]{0,14}:\\/\\/(?:[-.~*+=!&;:'%@?^${}(),\\w]+@)?|www\\.|[-;:&=+$,.\\w]+@)([A-Za-z\\d-]+(?:\\.[A-Za-z\\d-]+)*))(?::\\d+)?(?:\\/(?:[-.~*+=!;:'%@$(),\\/\\w]*[-~*+=%@$()\\/\\w])?)?(?:\\?(?:[-.~*+=!&;:'%@?^${}(),\\/\\w]+)?)?(?:#(?:[-.~*+=!&;:'%@?^${}(),\\/\\w]+)?)?)$/;\n  const extractHost = url => Optional.from(url.match(hostCaptureRegex)).bind(ms => get$b(ms, 1)).map(h => startsWith(h, 'www.') ? h.substring(4) : h);\n  const sandboxIframe = (iframeNode, exclusions) => {\n    if (Optional.from(iframeNode.attr('src')).bind(extractHost).forall(host => !contains$2(exclusions, host))) {\n      iframeNode.attr('sandbox', '');\n    }\n  };\n  const isMimeType = (mime, type) => startsWith(mime, `${type}/`);\n  const getEmbedType = type => {\n    if (isUndefined(type)) {\n      return 'iframe';\n    } else if (isMimeType(type, 'image')) {\n      return 'img';\n    } else if (isMimeType(type, 'video')) {\n      return 'video';\n    } else if (isMimeType(type, 'audio')) {\n      return 'audio';\n    } else {\n      return 'iframe';\n    }\n  };\n  const createSafeEmbed = ({\n    type,\n    src,\n    width,\n    height\n  } = {}, sandboxIframes, sandboxIframesExclusions) => {\n    const name = getEmbedType(type);\n    const embed = new AstNode(name, 1);\n    embed.attr(name === 'audio' ? {\n      src\n    } : {\n      src,\n      width,\n      height\n    });\n    if (name === 'audio' || name === 'video') {\n      embed.attr('controls', '');\n    }\n    if (name === 'iframe' && sandboxIframes) {\n      sandboxIframe(embed, sandboxIframesExclusions);\n    }\n    return embed;\n  };\n  const isBogusImage = img => isNonNullable(img.attr('data-mce-bogus'));\n  const isInternalImageSource = img => img.attr('src') === Env.transparentSrc || isNonNullable(img.attr('data-mce-placeholder'));\n  const registerBase64ImageFilter = (parser, settings) => {\n    const {\n      blob_cache: blobCache\n    } = settings;\n    if (blobCache) {\n      const processImage = img => {\n        const inputSrc = img.attr('src');\n        if (isInternalImageSource(img) || isBogusImage(img) || isNullable(inputSrc)) {\n          return;\n        }\n        dataUriToBlobInfo(blobCache, inputSrc, true).each(blobInfo => {\n          img.attr('src', blobInfo.blobUri());\n        });\n      };\n      parser.addAttributeFilter('src', nodes => each$e(nodes, processImage));\n    }\n  };\n  const register$4 = (parser, settings) => {\n    var _a, _b;\n    const schema = parser.schema;\n    parser.addAttributeFilter('href', nodes => {\n      let i = nodes.length;\n      const appendRel = rel => {\n        const parts = rel.split(' ').filter(p => p.length > 0);\n        return parts.concat(['noopener']).sort().join(' ');\n      };\n      const addNoOpener = rel => {\n        const newRel = rel ? Tools.trim(rel) : '';\n        if (!/\\b(noopener)\\b/g.test(newRel)) {\n          return appendRel(newRel);\n        } else {\n          return newRel;\n        }\n      };\n      if (!settings.allow_unsafe_link_target) {\n        while (i--) {\n          const node = nodes[i];\n          if (node.name === 'a' && node.attr('target') === '_blank') {\n            node.attr('rel', addNoOpener(node.attr('rel')));\n          }\n        }\n      }\n    });\n    if (!settings.allow_html_in_named_anchor) {\n      parser.addAttributeFilter('id,name', nodes => {\n        let i = nodes.length,\n          sibling,\n          prevSibling,\n          parent,\n          node;\n        while (i--) {\n          node = nodes[i];\n          if (node.name === 'a' && node.firstChild && !node.attr('href')) {\n            parent = node.parent;\n            sibling = node.lastChild;\n            while (sibling && parent) {\n              prevSibling = sibling.prev;\n              parent.insert(sibling, node);\n              sibling = prevSibling;\n            }\n          }\n        }\n      });\n    }\n    if (settings.fix_list_elements) {\n      parser.addNodeFilter('ul,ol', nodes => {\n        let i = nodes.length,\n          node,\n          parentNode;\n        while (i--) {\n          node = nodes[i];\n          parentNode = node.parent;\n          if (parentNode && (parentNode.name === 'ul' || parentNode.name === 'ol')) {\n            if (node.prev && node.prev.name === 'li') {\n              node.prev.append(node);\n            } else {\n              const li = new AstNode('li', 1);\n              li.attr('style', 'list-style-type: none');\n              node.wrap(li);\n            }\n          }\n        }\n      });\n    }\n    const validClasses = schema.getValidClasses();\n    if (settings.validate && validClasses) {\n      parser.addAttributeFilter('class', nodes => {\n        var _a;\n        let i = nodes.length;\n        while (i--) {\n          const node = nodes[i];\n          const clazz = (_a = node.attr('class')) !== null && _a !== void 0 ? _a : '';\n          const classList = Tools.explode(clazz, ' ');\n          let classValue = '';\n          for (let ci = 0; ci < classList.length; ci++) {\n            const className = classList[ci];\n            let valid = false;\n            let validClassesMap = validClasses['*'];\n            if (validClassesMap && validClassesMap[className]) {\n              valid = true;\n            }\n            validClassesMap = validClasses[node.name];\n            if (!valid && validClassesMap && validClassesMap[className]) {\n              valid = true;\n            }\n            if (valid) {\n              if (classValue) {\n                classValue += ' ';\n              }\n              classValue += className;\n            }\n          }\n          if (!classValue.length) {\n            classValue = null;\n          }\n          node.attr('class', classValue);\n        }\n      });\n    }\n    registerBase64ImageFilter(parser, settings);\n    const shouldSandboxIframes = (_a = settings.sandbox_iframes) !== null && _a !== void 0 ? _a : false;\n    const sandboxIframesExclusions = unique$1((_b = settings.sandbox_iframes_exclusions) !== null && _b !== void 0 ? _b : []);\n    if (settings.convert_unsafe_embeds) {\n      parser.addNodeFilter('object,embed', nodes => each$e(nodes, node => {\n        node.replace(createSafeEmbed({\n          type: node.attr('type'),\n          src: node.name === 'object' ? node.attr('data') : node.attr('src'),\n          width: node.attr('width'),\n          height: node.attr('height')\n        }, shouldSandboxIframes, sandboxIframesExclusions));\n      }));\n    }\n    if (shouldSandboxIframes) {\n      parser.addNodeFilter('iframe', nodes => each$e(nodes, node => sandboxIframe(node, sandboxIframesExclusions)));\n    }\n  };\n\n  /*! @license DOMPurify 3.1.7 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/3.1.7/LICENSE */\n\n  const {\n    entries,\n    setPrototypeOf,\n    isFrozen,\n    getPrototypeOf,\n    getOwnPropertyDescriptor\n  } = Object;\n  let {\n    freeze,\n    seal,\n    create: create$7\n  } = Object; // eslint-disable-line import/no-mutable-exports\n  let {\n    apply,\n    construct\n  } = typeof Reflect !== 'undefined' && Reflect;\n  if (!freeze) {\n    freeze = function freeze(x) {\n      return x;\n    };\n  }\n  if (!seal) {\n    seal = function seal(x) {\n      return x;\n    };\n  }\n  if (!apply) {\n    apply = function apply(fun, thisValue, args) {\n      return fun.apply(thisValue, args);\n    };\n  }\n  if (!construct) {\n    construct = function construct(Func, args) {\n      return new Func(...args);\n    };\n  }\n  const arrayForEach = unapply(Array.prototype.forEach);\n  const arrayPop = unapply(Array.prototype.pop);\n  const arrayPush = unapply(Array.prototype.push);\n  const stringToLowerCase = unapply(String.prototype.toLowerCase);\n  const stringToString = unapply(String.prototype.toString);\n  const stringMatch = unapply(String.prototype.match);\n  const stringReplace = unapply(String.prototype.replace);\n  const stringIndexOf = unapply(String.prototype.indexOf);\n  const stringTrim = unapply(String.prototype.trim);\n  const objectHasOwnProperty = unapply(Object.prototype.hasOwnProperty);\n  const regExpTest = unapply(RegExp.prototype.test);\n  const typeErrorCreate = unconstruct(TypeError);\n\n  /**\n   * Creates a new function that calls the given function with a specified thisArg and arguments.\n   *\n   * @param {Function} func - The function to be wrapped and called.\n   * @returns {Function} A new function that calls the given function with a specified thisArg and arguments.\n   */\n  function unapply(func) {\n    return function (thisArg) {\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n      return apply(func, thisArg, args);\n    };\n  }\n\n  /**\n   * Creates a new function that constructs an instance of the given constructor function with the provided arguments.\n   *\n   * @param {Function} func - The constructor function to be wrapped and called.\n   * @returns {Function} A new function that constructs an instance of the given constructor function with the provided arguments.\n   */\n  function unconstruct(func) {\n    return function () {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n      return construct(func, args);\n    };\n  }\n\n  /**\n   * Add properties to a lookup table\n   *\n   * @param {Object} set - The set to which elements will be added.\n   * @param {Array} array - The array containing elements to be added to the set.\n   * @param {Function} transformCaseFunc - An optional function to transform the case of each element before adding to the set.\n   * @returns {Object} The modified set with added elements.\n   */\n  function addToSet(set, array) {\n    let transformCaseFunc = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : stringToLowerCase;\n    if (setPrototypeOf) {\n      // Make 'in' and truthy checks like Boolean(set.constructor)\n      // independent of any properties defined on Object.prototype.\n      // Prevent prototype setters from intercepting set as a this value.\n      setPrototypeOf(set, null);\n    }\n    let l = array.length;\n    while (l--) {\n      let element = array[l];\n      if (typeof element === 'string') {\n        const lcElement = transformCaseFunc(element);\n        if (lcElement !== element) {\n          // Config presets (e.g. tags.js, attrs.js) are immutable.\n          if (!isFrozen(array)) {\n            array[l] = lcElement;\n          }\n          element = lcElement;\n        }\n      }\n      set[element] = true;\n    }\n    return set;\n  }\n\n  /**\n   * Clean up an array to harden against CSPP\n   *\n   * @param {Array} array - The array to be cleaned.\n   * @returns {Array} The cleaned version of the array\n   */\n  function cleanArray(array) {\n    for (let index = 0; index < array.length; index++) {\n      const isPropertyExist = objectHasOwnProperty(array, index);\n      if (!isPropertyExist) {\n        array[index] = null;\n      }\n    }\n    return array;\n  }\n\n  /**\n   * Shallow clone an object\n   *\n   * @param {Object} object - The object to be cloned.\n   * @returns {Object} A new object that copies the original.\n   */\n  function clone(object) {\n    const newObject = create$7(null);\n    for (const [property, value] of entries(object)) {\n      const isPropertyExist = objectHasOwnProperty(object, property);\n      if (isPropertyExist) {\n        if (Array.isArray(value)) {\n          newObject[property] = cleanArray(value);\n        } else if (value && typeof value === 'object' && value.constructor === Object) {\n          newObject[property] = clone(value);\n        } else {\n          newObject[property] = value;\n        }\n      }\n    }\n    return newObject;\n  }\n\n  /**\n   * This method automatically checks if the prop is function or getter and behaves accordingly.\n   *\n   * @param {Object} object - The object to look up the getter function in its prototype chain.\n   * @param {String} prop - The property name for which to find the getter function.\n   * @returns {Function} The getter function found in the prototype chain or a fallback function.\n   */\n  function lookupGetter(object, prop) {\n    while (object !== null) {\n      const desc = getOwnPropertyDescriptor(object, prop);\n      if (desc) {\n        if (desc.get) {\n          return unapply(desc.get);\n        }\n        if (typeof desc.value === 'function') {\n          return unapply(desc.value);\n        }\n      }\n      object = getPrototypeOf(object);\n    }\n    function fallbackValue() {\n      return null;\n    }\n    return fallbackValue;\n  }\n  const html$1 = freeze(['a', 'abbr', 'acronym', 'address', 'area', 'article', 'aside', 'audio', 'b', 'bdi', 'bdo', 'big', 'blink', 'blockquote', 'body', 'br', 'button', 'canvas', 'caption', 'center', 'cite', 'code', 'col', 'colgroup', 'content', 'data', 'datalist', 'dd', 'decorator', 'del', 'details', 'dfn', 'dialog', 'dir', 'div', 'dl', 'dt', 'element', 'em', 'fieldset', 'figcaption', 'figure', 'font', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'i', 'img', 'input', 'ins', 'kbd', 'label', 'legend', 'li', 'main', 'map', 'mark', 'marquee', 'menu', 'menuitem', 'meter', 'nav', 'nobr', 'ol', 'optgroup', 'option', 'output', 'p', 'picture', 'pre', 'progress', 'q', 'rp', 'rt', 'ruby', 's', 'samp', 'section', 'select', 'shadow', 'small', 'source', 'spacer', 'span', 'strike', 'strong', 'style', 'sub', 'summary', 'sup', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'time', 'tr', 'track', 'tt', 'u', 'ul', 'var', 'video', 'wbr']);\n\n  // SVG\n  const svg$1 = freeze(['svg', 'a', 'altglyph', 'altglyphdef', 'altglyphitem', 'animatecolor', 'animatemotion', 'animatetransform', 'circle', 'clippath', 'defs', 'desc', 'ellipse', 'filter', 'font', 'g', 'glyph', 'glyphref', 'hkern', 'image', 'line', 'lineargradient', 'marker', 'mask', 'metadata', 'mpath', 'path', 'pattern', 'polygon', 'polyline', 'radialgradient', 'rect', 'stop', 'style', 'switch', 'symbol', 'text', 'textpath', 'title', 'tref', 'tspan', 'view', 'vkern']);\n  const svgFilters = freeze(['feBlend', 'feColorMatrix', 'feComponentTransfer', 'feComposite', 'feConvolveMatrix', 'feDiffuseLighting', 'feDisplacementMap', 'feDistantLight', 'feDropShadow', 'feFlood', 'feFuncA', 'feFuncB', 'feFuncG', 'feFuncR', 'feGaussianBlur', 'feImage', 'feMerge', 'feMergeNode', 'feMorphology', 'feOffset', 'fePointLight', 'feSpecularLighting', 'feSpotLight', 'feTile', 'feTurbulence']);\n\n  // List of SVG elements that are disallowed by default.\n  // We still need to know them so that we can do namespace\n  // checks properly in case one wants to add them to\n  // allow-list.\n  const svgDisallowed = freeze(['animate', 'color-profile', 'cursor', 'discard', 'font-face', 'font-face-format', 'font-face-name', 'font-face-src', 'font-face-uri', 'foreignobject', 'hatch', 'hatchpath', 'mesh', 'meshgradient', 'meshpatch', 'meshrow', 'missing-glyph', 'script', 'set', 'solidcolor', 'unknown', 'use']);\n  const mathMl$1 = freeze(['math', 'menclose', 'merror', 'mfenced', 'mfrac', 'mglyph', 'mi', 'mlabeledtr', 'mmultiscripts', 'mn', 'mo', 'mover', 'mpadded', 'mphantom', 'mroot', 'mrow', 'ms', 'mspace', 'msqrt', 'mstyle', 'msub', 'msup', 'msubsup', 'mtable', 'mtd', 'mtext', 'mtr', 'munder', 'munderover', 'mprescripts']);\n\n  // Similarly to SVG, we want to know all MathML elements,\n  // even those that we disallow by default.\n  const mathMlDisallowed = freeze(['maction', 'maligngroup', 'malignmark', 'mlongdiv', 'mscarries', 'mscarry', 'msgroup', 'mstack', 'msline', 'msrow', 'semantics', 'annotation', 'annotation-xml', 'mprescripts', 'none']);\n  const text = freeze(['#text']);\n  const html = freeze(['accept', 'action', 'align', 'alt', 'autocapitalize', 'autocomplete', 'autopictureinpicture', 'autoplay', 'background', 'bgcolor', 'border', 'capture', 'cellpadding', 'cellspacing', 'checked', 'cite', 'class', 'clear', 'color', 'cols', 'colspan', 'controls', 'controlslist', 'coords', 'crossorigin', 'datetime', 'decoding', 'default', 'dir', 'disabled', 'disablepictureinpicture', 'disableremoteplayback', 'download', 'draggable', 'enctype', 'enterkeyhint', 'face', 'for', 'headers', 'height', 'hidden', 'high', 'href', 'hreflang', 'id', 'inputmode', 'integrity', 'ismap', 'kind', 'label', 'lang', 'list', 'loading', 'loop', 'low', 'max', 'maxlength', 'media', 'method', 'min', 'minlength', 'multiple', 'muted', 'name', 'nonce', 'noshade', 'novalidate', 'nowrap', 'open', 'optimum', 'pattern', 'placeholder', 'playsinline', 'popover', 'popovertarget', 'popovertargetaction', 'poster', 'preload', 'pubdate', 'radiogroup', 'readonly', 'rel', 'required', 'rev', 'reversed', 'role', 'rows', 'rowspan', 'spellcheck', 'scope', 'selected', 'shape', 'size', 'sizes', 'span', 'srclang', 'start', 'src', 'srcset', 'step', 'style', 'summary', 'tabindex', 'title', 'translate', 'type', 'usemap', 'valign', 'value', 'width', 'wrap', 'xmlns', 'slot']);\n  const svg = freeze(['accent-height', 'accumulate', 'additive', 'alignment-baseline', 'amplitude', 'ascent', 'attributename', 'attributetype', 'azimuth', 'basefrequency', 'baseline-shift', 'begin', 'bias', 'by', 'class', 'clip', 'clippathunits', 'clip-path', 'clip-rule', 'color', 'color-interpolation', 'color-interpolation-filters', 'color-profile', 'color-rendering', 'cx', 'cy', 'd', 'dx', 'dy', 'diffuseconstant', 'direction', 'display', 'divisor', 'dur', 'edgemode', 'elevation', 'end', 'exponent', 'fill', 'fill-opacity', 'fill-rule', 'filter', 'filterunits', 'flood-color', 'flood-opacity', 'font-family', 'font-size', 'font-size-adjust', 'font-stretch', 'font-style', 'font-variant', 'font-weight', 'fx', 'fy', 'g1', 'g2', 'glyph-name', 'glyphref', 'gradientunits', 'gradienttransform', 'height', 'href', 'id', 'image-rendering', 'in', 'in2', 'intercept', 'k', 'k1', 'k2', 'k3', 'k4', 'kerning', 'keypoints', 'keysplines', 'keytimes', 'lang', 'lengthadjust', 'letter-spacing', 'kernelmatrix', 'kernelunitlength', 'lighting-color', 'local', 'marker-end', 'marker-mid', 'marker-start', 'markerheight', 'markerunits', 'markerwidth', 'maskcontentunits', 'maskunits', 'max', 'mask', 'media', 'method', 'mode', 'min', 'name', 'numoctaves', 'offset', 'operator', 'opacity', 'order', 'orient', 'orientation', 'origin', 'overflow', 'paint-order', 'path', 'pathlength', 'patterncontentunits', 'patterntransform', 'patternunits', 'points', 'preservealpha', 'preserveaspectratio', 'primitiveunits', 'r', 'rx', 'ry', 'radius', 'refx', 'refy', 'repeatcount', 'repeatdur', 'restart', 'result', 'rotate', 'scale', 'seed', 'shape-rendering', 'slope', 'specularconstant', 'specularexponent', 'spreadmethod', 'startoffset', 'stddeviation', 'stitchtiles', 'stop-color', 'stop-opacity', 'stroke-dasharray', 'stroke-dashoffset', 'stroke-linecap', 'stroke-linejoin', 'stroke-miterlimit', 'stroke-opacity', 'stroke', 'stroke-width', 'style', 'surfacescale', 'systemlanguage', 'tabindex', 'tablevalues', 'targetx', 'targety', 'transform', 'transform-origin', 'text-anchor', 'text-decoration', 'text-rendering', 'textlength', 'type', 'u1', 'u2', 'unicode', 'values', 'viewbox', 'visibility', 'version', 'vert-adv-y', 'vert-origin-x', 'vert-origin-y', 'width', 'word-spacing', 'wrap', 'writing-mode', 'xchannelselector', 'ychannelselector', 'x', 'x1', 'x2', 'xmlns', 'y', 'y1', 'y2', 'z', 'zoomandpan']);\n  const mathMl = freeze(['accent', 'accentunder', 'align', 'bevelled', 'close', 'columnsalign', 'columnlines', 'columnspan', 'denomalign', 'depth', 'dir', 'display', 'displaystyle', 'encoding', 'fence', 'frame', 'height', 'href', 'id', 'largeop', 'length', 'linethickness', 'lspace', 'lquote', 'mathbackground', 'mathcolor', 'mathsize', 'mathvariant', 'maxsize', 'minsize', 'movablelimits', 'notation', 'numalign', 'open', 'rowalign', 'rowlines', 'rowspacing', 'rowspan', 'rspace', 'rquote', 'scriptlevel', 'scriptminsize', 'scriptsizemultiplier', 'selection', 'separator', 'separators', 'stretchy', 'subscriptshift', 'supscriptshift', 'symmetric', 'voffset', 'width', 'xmlns']);\n  const xml = freeze(['xlink:href', 'xml:id', 'xlink:title', 'xml:space', 'xmlns:xlink']);\n\n  // eslint-disable-next-line unicorn/better-regex\n  const MUSTACHE_EXPR = seal(/\\{\\{[\\w\\W]*|[\\w\\W]*\\}\\}/gm); // Specify template detection regex for SAFE_FOR_TEMPLATES mode\n  const ERB_EXPR = seal(/<%[\\w\\W]*|[\\w\\W]*%>/gm);\n  const TMPLIT_EXPR = seal(/\\${[\\w\\W]*}/gm);\n  const DATA_ATTR = seal(/^data-[\\-\\w.\\u00B7-\\uFFFF]/); // eslint-disable-line no-useless-escape\n  const ARIA_ATTR = seal(/^aria-[\\-\\w]+$/); // eslint-disable-line no-useless-escape\n  const IS_ALLOWED_URI = seal(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp):|[^a-z]|[a-z+.\\-]+(?:[^a-z+.\\-:]|$))/i // eslint-disable-line no-useless-escape\n  );\n  const IS_SCRIPT_OR_DATA = seal(/^(?:\\w+script|data):/i);\n  const ATTR_WHITESPACE = seal(/[\\u0000-\\u0020\\u00A0\\u1680\\u180E\\u2000-\\u2029\\u205F\\u3000]/g // eslint-disable-line no-control-regex\n  );\n  const DOCTYPE_NAME = seal(/^html$/i);\n  const CUSTOM_ELEMENT = seal(/^[a-z][.\\w]*(-[.\\w]+)+$/i);\n  var EXPRESSIONS = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    MUSTACHE_EXPR: MUSTACHE_EXPR,\n    ERB_EXPR: ERB_EXPR,\n    TMPLIT_EXPR: TMPLIT_EXPR,\n    DATA_ATTR: DATA_ATTR,\n    ARIA_ATTR: ARIA_ATTR,\n    IS_ALLOWED_URI: IS_ALLOWED_URI,\n    IS_SCRIPT_OR_DATA: IS_SCRIPT_OR_DATA,\n    ATTR_WHITESPACE: ATTR_WHITESPACE,\n    DOCTYPE_NAME: DOCTYPE_NAME,\n    CUSTOM_ELEMENT: CUSTOM_ELEMENT\n  });\n\n  // https://developer.mozilla.org/en-US/docs/Web/API/Node/nodeType\n  const NODE_TYPE = {\n    element: 1,\n    attribute: 2,\n    text: 3,\n    cdataSection: 4,\n    entityReference: 5,\n    // Deprecated\n    entityNode: 6,\n    // Deprecated\n    progressingInstruction: 7,\n    comment: 8,\n    document: 9,\n    documentType: 10,\n    documentFragment: 11,\n    notation: 12 // Deprecated\n  };\n  const getGlobal = function getGlobal() {\n    return typeof window === 'undefined' ? null : window;\n  };\n\n  /**\n   * Creates a no-op policy for internal use only.\n   * Don't export this function outside this module!\n   * @param {TrustedTypePolicyFactory} trustedTypes The policy factory.\n   * @param {HTMLScriptElement} purifyHostElement The Script element used to load DOMPurify (to determine policy name suffix).\n   * @return {TrustedTypePolicy} The policy created (or null, if Trusted Types\n   * are not supported or creating the policy failed).\n   */\n  const _createTrustedTypesPolicy = function _createTrustedTypesPolicy(trustedTypes, purifyHostElement) {\n    if (typeof trustedTypes !== 'object' || typeof trustedTypes.createPolicy !== 'function') {\n      return null;\n    }\n\n    // Allow the callers to control the unique policy name\n    // by adding a data-tt-policy-suffix to the script element with the DOMPurify.\n    // Policy creation with duplicate names throws in Trusted Types.\n    let suffix = null;\n    const ATTR_NAME = 'data-tt-policy-suffix';\n    if (purifyHostElement && purifyHostElement.hasAttribute(ATTR_NAME)) {\n      suffix = purifyHostElement.getAttribute(ATTR_NAME);\n    }\n    const policyName = 'dompurify' + (suffix ? '#' + suffix : '');\n    try {\n      return trustedTypes.createPolicy(policyName, {\n        createHTML(html) {\n          return html;\n        },\n        createScriptURL(scriptUrl) {\n          return scriptUrl;\n        }\n      });\n    } catch (_) {\n      // Policy creation failed (most likely another DOMPurify script has\n      // already run). Skip creating the policy, as this will only cause errors\n      // if TT are enforced.\n      console.warn('TrustedTypes policy ' + policyName + ' could not be created.');\n      return null;\n    }\n  };\n  function createDOMPurify() {\n    let window = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getGlobal();\n    const DOMPurify = root => createDOMPurify(root);\n\n    /**\n     * Version label, exposed for easier checks\n     * if DOMPurify is up to date or not\n     */\n    DOMPurify.version = '3.1.7';\n\n    /**\n     * Array of elements that DOMPurify removed during sanitation.\n     * Empty if nothing was removed.\n     */\n    DOMPurify.removed = [];\n    if (!window || !window.document || window.document.nodeType !== NODE_TYPE.document) {\n      // Not running in a browser, provide a factory function\n      // so that you can pass your own Window\n      DOMPurify.isSupported = false;\n      return DOMPurify;\n    }\n    let {\n      document\n    } = window;\n    const originalDocument = document;\n    const currentScript = originalDocument.currentScript;\n    const {\n      DocumentFragment,\n      HTMLTemplateElement,\n      Node,\n      Element,\n      NodeFilter,\n      NamedNodeMap = window.NamedNodeMap || window.MozNamedAttrMap,\n      HTMLFormElement,\n      DOMParser,\n      trustedTypes\n    } = window;\n    const ElementPrototype = Element.prototype;\n    const cloneNode = lookupGetter(ElementPrototype, 'cloneNode');\n    const remove = lookupGetter(ElementPrototype, 'remove');\n    const getNextSibling = lookupGetter(ElementPrototype, 'nextSibling');\n    const getChildNodes = lookupGetter(ElementPrototype, 'childNodes');\n    const getParentNode = lookupGetter(ElementPrototype, 'parentNode');\n\n    // As per issue #47, the web-components registry is inherited by a\n    // new document created via createHTMLDocument. As per the spec\n    // (http://w3c.github.io/webcomponents/spec/custom/#creating-and-passing-registries)\n    // a new empty registry is used when creating a template contents owner\n    // document, so we use that as our parent document to ensure nothing\n    // is inherited.\n    if (typeof HTMLTemplateElement === 'function') {\n      const template = document.createElement('template');\n      if (template.content && template.content.ownerDocument) {\n        document = template.content.ownerDocument;\n      }\n    }\n    let trustedTypesPolicy;\n    let emptyHTML = '';\n    const {\n      implementation,\n      createNodeIterator,\n      createDocumentFragment,\n      getElementsByTagName\n    } = document;\n    const {\n      importNode\n    } = originalDocument;\n    let hooks = {};\n\n    /**\n     * Expose whether this browser supports running the full DOMPurify.\n     */\n    DOMPurify.isSupported = typeof entries === 'function' && typeof getParentNode === 'function' && implementation && implementation.createHTMLDocument !== undefined;\n    const {\n      MUSTACHE_EXPR,\n      ERB_EXPR,\n      TMPLIT_EXPR,\n      DATA_ATTR,\n      ARIA_ATTR,\n      IS_SCRIPT_OR_DATA,\n      ATTR_WHITESPACE,\n      CUSTOM_ELEMENT\n    } = EXPRESSIONS;\n    let {\n      IS_ALLOWED_URI: IS_ALLOWED_URI$1\n    } = EXPRESSIONS;\n\n    /**\n     * We consider the elements and attributes below to be safe. Ideally\n     * don't add any new ones but feel free to remove unwanted ones.\n     */\n\n    /* allowed element names */\n    let ALLOWED_TAGS = null;\n    const DEFAULT_ALLOWED_TAGS = addToSet({}, [...html$1, ...svg$1, ...svgFilters, ...mathMl$1, ...text]);\n\n    /* Allowed attribute names */\n    let ALLOWED_ATTR = null;\n    const DEFAULT_ALLOWED_ATTR = addToSet({}, [...html, ...svg, ...mathMl, ...xml]);\n\n    /*\n     * Configure how DOMPUrify should handle custom elements and their attributes as well as customized built-in elements.\n     * @property {RegExp|Function|null} tagNameCheck one of [null, regexPattern, predicate]. Default: `null` (disallow any custom elements)\n     * @property {RegExp|Function|null} attributeNameCheck one of [null, regexPattern, predicate]. Default: `null` (disallow any attributes not on the allow list)\n     * @property {boolean} allowCustomizedBuiltInElements allow custom elements derived from built-ins if they pass CUSTOM_ELEMENT_HANDLING.tagNameCheck. Default: `false`.\n     */\n    let CUSTOM_ELEMENT_HANDLING = Object.seal(create$7(null, {\n      tagNameCheck: {\n        writable: true,\n        configurable: false,\n        enumerable: true,\n        value: null\n      },\n      attributeNameCheck: {\n        writable: true,\n        configurable: false,\n        enumerable: true,\n        value: null\n      },\n      allowCustomizedBuiltInElements: {\n        writable: true,\n        configurable: false,\n        enumerable: true,\n        value: false\n      }\n    }));\n\n    /* Explicitly forbidden tags (overrides ALLOWED_TAGS/ADD_TAGS) */\n    let FORBID_TAGS = null;\n\n    /* Explicitly forbidden attributes (overrides ALLOWED_ATTR/ADD_ATTR) */\n    let FORBID_ATTR = null;\n\n    /* Decide if ARIA attributes are okay */\n    let ALLOW_ARIA_ATTR = true;\n\n    /* Decide if custom data attributes are okay */\n    let ALLOW_DATA_ATTR = true;\n\n    /* Decide if unknown protocols are okay */\n    let ALLOW_UNKNOWN_PROTOCOLS = false;\n\n    /* Decide if self-closing tags in attributes are allowed.\n     * Usually removed due to a mXSS issue in jQuery 3.0 */\n    let ALLOW_SELF_CLOSE_IN_ATTR = true;\n\n    /* Output should be safe for common template engines.\n     * This means, DOMPurify removes data attributes, mustaches and ERB\n     */\n    let SAFE_FOR_TEMPLATES = false;\n\n    /* Output should be safe even for XML used within HTML and alike.\n     * This means, DOMPurify removes comments when containing risky content.\n     */\n    let SAFE_FOR_XML = true;\n\n    /* Decide if document with <html>... should be returned */\n    let WHOLE_DOCUMENT = false;\n\n    /* Track whether config is already set on this instance of DOMPurify. */\n    let SET_CONFIG = false;\n\n    /* Decide if all elements (e.g. style, script) must be children of\n     * document.body. By default, browsers might move them to document.head */\n    let FORCE_BODY = false;\n\n    /* Decide if a DOM `HTMLBodyElement` should be returned, instead of a html\n     * string (or a TrustedHTML object if Trusted Types are supported).\n     * If `WHOLE_DOCUMENT` is enabled a `HTMLHtmlElement` will be returned instead\n     */\n    let RETURN_DOM = false;\n\n    /* Decide if a DOM `DocumentFragment` should be returned, instead of a html\n     * string  (or a TrustedHTML object if Trusted Types are supported) */\n    let RETURN_DOM_FRAGMENT = false;\n\n    /* Try to return a Trusted Type object instead of a string, return a string in\n     * case Trusted Types are not supported  */\n    let RETURN_TRUSTED_TYPE = false;\n\n    /* Output should be free from DOM clobbering attacks?\n     * This sanitizes markups named with colliding, clobberable built-in DOM APIs.\n     */\n    let SANITIZE_DOM = true;\n\n    /* Achieve full DOM Clobbering protection by isolating the namespace of named\n     * properties and JS variables, mitigating attacks that abuse the HTML/DOM spec rules.\n     *\n     * HTML/DOM spec rules that enable DOM Clobbering:\n     *   - Named Access on Window (§7.3.3)\n     *   - DOM Tree Accessors (§3.1.5)\n     *   - Form Element Parent-Child Relations (§4.10.3)\n     *   - Iframe srcdoc / Nested WindowProxies (§4.8.5)\n     *   - HTMLCollection (§4.2.10.2)\n     *\n     * Namespace isolation is implemented by prefixing `id` and `name` attributes\n     * with a constant string, i.e., `user-content-`\n     */\n    let SANITIZE_NAMED_PROPS = false;\n    const SANITIZE_NAMED_PROPS_PREFIX = 'user-content-';\n\n    /* Keep element content when removing element? */\n    let KEEP_CONTENT = true;\n\n    /* If a `Node` is passed to sanitize(), then performs sanitization in-place instead\n     * of importing it into a new Document and returning a sanitized copy */\n    let IN_PLACE = false;\n\n    /* Allow usage of profiles like html, svg and mathMl */\n    let USE_PROFILES = {};\n\n    /* Tags to ignore content of when KEEP_CONTENT is true */\n    let FORBID_CONTENTS = null;\n    const DEFAULT_FORBID_CONTENTS = addToSet({}, ['annotation-xml', 'audio', 'colgroup', 'desc', 'foreignobject', 'head', 'iframe', 'math', 'mi', 'mn', 'mo', 'ms', 'mtext', 'noembed', 'noframes', 'noscript', 'plaintext', 'script', 'style', 'svg', 'template', 'thead', 'title', 'video', 'xmp']);\n\n    /* Tags that are safe for data: URIs */\n    let DATA_URI_TAGS = null;\n    const DEFAULT_DATA_URI_TAGS = addToSet({}, ['audio', 'video', 'img', 'source', 'image', 'track']);\n\n    /* Attributes safe for values like \"javascript:\" */\n    let URI_SAFE_ATTRIBUTES = null;\n    const DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, ['alt', 'class', 'for', 'id', 'label', 'name', 'pattern', 'placeholder', 'role', 'summary', 'title', 'value', 'style', 'xmlns']);\n    const MATHML_NAMESPACE = 'http://www.w3.org/1998/Math/MathML';\n    const SVG_NAMESPACE = 'http://www.w3.org/2000/svg';\n    const HTML_NAMESPACE = 'http://www.w3.org/1999/xhtml';\n    /* Document namespace */\n    let NAMESPACE = HTML_NAMESPACE;\n    let IS_EMPTY_INPUT = false;\n\n    /* Allowed XHTML+XML namespaces */\n    let ALLOWED_NAMESPACES = null;\n    const DEFAULT_ALLOWED_NAMESPACES = addToSet({}, [MATHML_NAMESPACE, SVG_NAMESPACE, HTML_NAMESPACE], stringToString);\n\n    /* Parsing of strict XHTML documents */\n    let PARSER_MEDIA_TYPE = null;\n    const SUPPORTED_PARSER_MEDIA_TYPES = ['application/xhtml+xml', 'text/html'];\n    const DEFAULT_PARSER_MEDIA_TYPE = 'text/html';\n    let transformCaseFunc = null;\n\n    /* Keep a reference to config to pass to hooks */\n    let CONFIG = null;\n\n    /* Ideally, do not touch anything below this line */\n    /* ______________________________________________ */\n\n    const formElement = document.createElement('form');\n    const isRegexOrFunction = function isRegexOrFunction(testValue) {\n      return testValue instanceof RegExp || testValue instanceof Function;\n    };\n\n    /**\n     * _parseConfig\n     *\n     * @param  {Object} cfg optional config literal\n     */\n    // eslint-disable-next-line complexity\n    const _parseConfig = function _parseConfig() {\n      let cfg = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      if (CONFIG && CONFIG === cfg) {\n        return;\n      }\n\n      /* Shield configuration object from tampering */\n      if (!cfg || typeof cfg !== 'object') {\n        cfg = {};\n      }\n\n      /* Shield configuration object from prototype pollution */\n      cfg = clone(cfg);\n      PARSER_MEDIA_TYPE =\n      // eslint-disable-next-line unicorn/prefer-includes\n      SUPPORTED_PARSER_MEDIA_TYPES.indexOf(cfg.PARSER_MEDIA_TYPE) === -1 ? DEFAULT_PARSER_MEDIA_TYPE : cfg.PARSER_MEDIA_TYPE;\n\n      // HTML tags and attributes are not case-sensitive, converting to lowercase. Keeping XHTML as is.\n      transformCaseFunc = PARSER_MEDIA_TYPE === 'application/xhtml+xml' ? stringToString : stringToLowerCase;\n\n      /* Set configuration parameters */\n      ALLOWED_TAGS = objectHasOwnProperty(cfg, 'ALLOWED_TAGS') ? addToSet({}, cfg.ALLOWED_TAGS, transformCaseFunc) : DEFAULT_ALLOWED_TAGS;\n      ALLOWED_ATTR = objectHasOwnProperty(cfg, 'ALLOWED_ATTR') ? addToSet({}, cfg.ALLOWED_ATTR, transformCaseFunc) : DEFAULT_ALLOWED_ATTR;\n      ALLOWED_NAMESPACES = objectHasOwnProperty(cfg, 'ALLOWED_NAMESPACES') ? addToSet({}, cfg.ALLOWED_NAMESPACES, stringToString) : DEFAULT_ALLOWED_NAMESPACES;\n      URI_SAFE_ATTRIBUTES = objectHasOwnProperty(cfg, 'ADD_URI_SAFE_ATTR') ? addToSet(clone(DEFAULT_URI_SAFE_ATTRIBUTES),\n      // eslint-disable-line indent\n      cfg.ADD_URI_SAFE_ATTR,\n      // eslint-disable-line indent\n      transformCaseFunc // eslint-disable-line indent\n      ) // eslint-disable-line indent\n      : DEFAULT_URI_SAFE_ATTRIBUTES;\n      DATA_URI_TAGS = objectHasOwnProperty(cfg, 'ADD_DATA_URI_TAGS') ? addToSet(clone(DEFAULT_DATA_URI_TAGS),\n      // eslint-disable-line indent\n      cfg.ADD_DATA_URI_TAGS,\n      // eslint-disable-line indent\n      transformCaseFunc // eslint-disable-line indent\n      ) // eslint-disable-line indent\n      : DEFAULT_DATA_URI_TAGS;\n      FORBID_CONTENTS = objectHasOwnProperty(cfg, 'FORBID_CONTENTS') ? addToSet({}, cfg.FORBID_CONTENTS, transformCaseFunc) : DEFAULT_FORBID_CONTENTS;\n      FORBID_TAGS = objectHasOwnProperty(cfg, 'FORBID_TAGS') ? addToSet({}, cfg.FORBID_TAGS, transformCaseFunc) : {};\n      FORBID_ATTR = objectHasOwnProperty(cfg, 'FORBID_ATTR') ? addToSet({}, cfg.FORBID_ATTR, transformCaseFunc) : {};\n      USE_PROFILES = objectHasOwnProperty(cfg, 'USE_PROFILES') ? cfg.USE_PROFILES : false;\n      ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false; // Default true\n      ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false; // Default true\n      ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false; // Default false\n      ALLOW_SELF_CLOSE_IN_ATTR = cfg.ALLOW_SELF_CLOSE_IN_ATTR !== false; // Default true\n      SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false; // Default false\n      SAFE_FOR_XML = cfg.SAFE_FOR_XML !== false; // Default true\n      WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false; // Default false\n      RETURN_DOM = cfg.RETURN_DOM || false; // Default false\n      RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false; // Default false\n      RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false; // Default false\n      FORCE_BODY = cfg.FORCE_BODY || false; // Default false\n      SANITIZE_DOM = cfg.SANITIZE_DOM !== false; // Default true\n      SANITIZE_NAMED_PROPS = cfg.SANITIZE_NAMED_PROPS || false; // Default false\n      KEEP_CONTENT = cfg.KEEP_CONTENT !== false; // Default true\n      IN_PLACE = cfg.IN_PLACE || false; // Default false\n      IS_ALLOWED_URI$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI;\n      NAMESPACE = cfg.NAMESPACE || HTML_NAMESPACE;\n      CUSTOM_ELEMENT_HANDLING = cfg.CUSTOM_ELEMENT_HANDLING || {};\n      if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck)) {\n        CUSTOM_ELEMENT_HANDLING.tagNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck;\n      }\n      if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck)) {\n        CUSTOM_ELEMENT_HANDLING.attributeNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck;\n      }\n      if (cfg.CUSTOM_ELEMENT_HANDLING && typeof cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements === 'boolean') {\n        CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements = cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements;\n      }\n      if (SAFE_FOR_TEMPLATES) {\n        ALLOW_DATA_ATTR = false;\n      }\n      if (RETURN_DOM_FRAGMENT) {\n        RETURN_DOM = true;\n      }\n\n      /* Parse profile info */\n      if (USE_PROFILES) {\n        ALLOWED_TAGS = addToSet({}, text);\n        ALLOWED_ATTR = [];\n        if (USE_PROFILES.html === true) {\n          addToSet(ALLOWED_TAGS, html$1);\n          addToSet(ALLOWED_ATTR, html);\n        }\n        if (USE_PROFILES.svg === true) {\n          addToSet(ALLOWED_TAGS, svg$1);\n          addToSet(ALLOWED_ATTR, svg);\n          addToSet(ALLOWED_ATTR, xml);\n        }\n        if (USE_PROFILES.svgFilters === true) {\n          addToSet(ALLOWED_TAGS, svgFilters);\n          addToSet(ALLOWED_ATTR, svg);\n          addToSet(ALLOWED_ATTR, xml);\n        }\n        if (USE_PROFILES.mathMl === true) {\n          addToSet(ALLOWED_TAGS, mathMl$1);\n          addToSet(ALLOWED_ATTR, mathMl);\n          addToSet(ALLOWED_ATTR, xml);\n        }\n      }\n\n      /* Merge configuration parameters */\n      if (cfg.ADD_TAGS) {\n        if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {\n          ALLOWED_TAGS = clone(ALLOWED_TAGS);\n        }\n        addToSet(ALLOWED_TAGS, cfg.ADD_TAGS, transformCaseFunc);\n      }\n      if (cfg.ADD_ATTR) {\n        if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {\n          ALLOWED_ATTR = clone(ALLOWED_ATTR);\n        }\n        addToSet(ALLOWED_ATTR, cfg.ADD_ATTR, transformCaseFunc);\n      }\n      if (cfg.ADD_URI_SAFE_ATTR) {\n        addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR, transformCaseFunc);\n      }\n      if (cfg.FORBID_CONTENTS) {\n        if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) {\n          FORBID_CONTENTS = clone(FORBID_CONTENTS);\n        }\n        addToSet(FORBID_CONTENTS, cfg.FORBID_CONTENTS, transformCaseFunc);\n      }\n\n      /* Add #text in case KEEP_CONTENT is set to true */\n      if (KEEP_CONTENT) {\n        ALLOWED_TAGS['#text'] = true;\n      }\n\n      /* Add html, head and body to ALLOWED_TAGS in case WHOLE_DOCUMENT is true */\n      if (WHOLE_DOCUMENT) {\n        addToSet(ALLOWED_TAGS, ['html', 'head', 'body']);\n      }\n\n      /* Add tbody to ALLOWED_TAGS in case tables are permitted, see #286, #365 */\n      if (ALLOWED_TAGS.table) {\n        addToSet(ALLOWED_TAGS, ['tbody']);\n        delete FORBID_TAGS.tbody;\n      }\n      if (cfg.TRUSTED_TYPES_POLICY) {\n        if (typeof cfg.TRUSTED_TYPES_POLICY.createHTML !== 'function') {\n          throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a \"createHTML\" hook.');\n        }\n        if (typeof cfg.TRUSTED_TYPES_POLICY.createScriptURL !== 'function') {\n          throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a \"createScriptURL\" hook.');\n        }\n\n        // Overwrite existing TrustedTypes policy.\n        trustedTypesPolicy = cfg.TRUSTED_TYPES_POLICY;\n\n        // Sign local variables required by `sanitize`.\n        emptyHTML = trustedTypesPolicy.createHTML('');\n      } else {\n        // Uninitialized policy, attempt to initialize the internal dompurify policy.\n        if (trustedTypesPolicy === undefined) {\n          trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes, currentScript);\n        }\n\n        // If creating the internal policy succeeded sign internal variables.\n        if (trustedTypesPolicy !== null && typeof emptyHTML === 'string') {\n          emptyHTML = trustedTypesPolicy.createHTML('');\n        }\n      }\n\n      // Prevent further manipulation of configuration.\n      // Not available in IE8, Safari 5, etc.\n      if (freeze) {\n        freeze(cfg);\n      }\n      CONFIG = cfg;\n    };\n    const MATHML_TEXT_INTEGRATION_POINTS = addToSet({}, ['mi', 'mo', 'mn', 'ms', 'mtext']);\n    const HTML_INTEGRATION_POINTS = addToSet({}, ['annotation-xml']);\n\n    // Certain elements are allowed in both SVG and HTML\n    // namespace. We need to specify them explicitly\n    // so that they don't get erroneously deleted from\n    // HTML namespace.\n    const COMMON_SVG_AND_HTML_ELEMENTS = addToSet({}, ['title', 'style', 'font', 'a', 'script']);\n\n    /* Keep track of all possible SVG and MathML tags\n     * so that we can perform the namespace checks\n     * correctly. */\n    const ALL_SVG_TAGS = addToSet({}, [...svg$1, ...svgFilters, ...svgDisallowed]);\n    const ALL_MATHML_TAGS = addToSet({}, [...mathMl$1, ...mathMlDisallowed]);\n\n    /**\n     * @param  {Element} element a DOM element whose namespace is being checked\n     * @returns {boolean} Return false if the element has a\n     *  namespace that a spec-compliant parser would never\n     *  return. Return true otherwise.\n     */\n    const _checkValidNamespace = function _checkValidNamespace(element) {\n      let parent = getParentNode(element);\n\n      // In JSDOM, if we're inside shadow DOM, then parentNode\n      // can be null. We just simulate parent in this case.\n      if (!parent || !parent.tagName) {\n        parent = {\n          namespaceURI: NAMESPACE,\n          tagName: 'template'\n        };\n      }\n      const tagName = stringToLowerCase(element.tagName);\n      const parentTagName = stringToLowerCase(parent.tagName);\n      if (!ALLOWED_NAMESPACES[element.namespaceURI]) {\n        return false;\n      }\n      if (element.namespaceURI === SVG_NAMESPACE) {\n        // The only way to switch from HTML namespace to SVG\n        // is via <svg>. If it happens via any other tag, then\n        // it should be killed.\n        if (parent.namespaceURI === HTML_NAMESPACE) {\n          return tagName === 'svg';\n        }\n\n        // The only way to switch from MathML to SVG is via`\n        // svg if parent is either <annotation-xml> or MathML\n        // text integration points.\n        if (parent.namespaceURI === MATHML_NAMESPACE) {\n          return tagName === 'svg' && (parentTagName === 'annotation-xml' || MATHML_TEXT_INTEGRATION_POINTS[parentTagName]);\n        }\n\n        // We only allow elements that are defined in SVG\n        // spec. All others are disallowed in SVG namespace.\n        return Boolean(ALL_SVG_TAGS[tagName]);\n      }\n      if (element.namespaceURI === MATHML_NAMESPACE) {\n        // The only way to switch from HTML namespace to MathML\n        // is via <math>. If it happens via any other tag, then\n        // it should be killed.\n        if (parent.namespaceURI === HTML_NAMESPACE) {\n          return tagName === 'math';\n        }\n\n        // The only way to switch from SVG to MathML is via\n        // <math> and HTML integration points\n        if (parent.namespaceURI === SVG_NAMESPACE) {\n          return tagName === 'math' && HTML_INTEGRATION_POINTS[parentTagName];\n        }\n\n        // We only allow elements that are defined in MathML\n        // spec. All others are disallowed in MathML namespace.\n        return Boolean(ALL_MATHML_TAGS[tagName]);\n      }\n      if (element.namespaceURI === HTML_NAMESPACE) {\n        // The only way to switch from SVG to HTML is via\n        // HTML integration points, and from MathML to HTML\n        // is via MathML text integration points\n        if (parent.namespaceURI === SVG_NAMESPACE && !HTML_INTEGRATION_POINTS[parentTagName]) {\n          return false;\n        }\n        if (parent.namespaceURI === MATHML_NAMESPACE && !MATHML_TEXT_INTEGRATION_POINTS[parentTagName]) {\n          return false;\n        }\n\n        // We disallow tags that are specific for MathML\n        // or SVG and should never appear in HTML namespace\n        return !ALL_MATHML_TAGS[tagName] && (COMMON_SVG_AND_HTML_ELEMENTS[tagName] || !ALL_SVG_TAGS[tagName]);\n      }\n\n      // For XHTML and XML documents that support custom namespaces\n      if (PARSER_MEDIA_TYPE === 'application/xhtml+xml' && ALLOWED_NAMESPACES[element.namespaceURI]) {\n        return true;\n      }\n\n      // The code should never reach this place (this means\n      // that the element somehow got namespace that is not\n      // HTML, SVG, MathML or allowed via ALLOWED_NAMESPACES).\n      // Return false just in case.\n      return false;\n    };\n\n    /**\n     * _forceRemove\n     *\n     * @param  {Node} node a DOM node\n     */\n    const _forceRemove = function _forceRemove(node) {\n      arrayPush(DOMPurify.removed, {\n        element: node\n      });\n      try {\n        // eslint-disable-next-line unicorn/prefer-dom-node-remove\n        getParentNode(node).removeChild(node);\n      } catch (_) {\n        remove(node);\n      }\n    };\n\n    /**\n     * _removeAttribute\n     *\n     * @param  {String} name an Attribute name\n     * @param  {Node} node a DOM node\n     */\n    const _removeAttribute = function _removeAttribute(name, node) {\n      try {\n        arrayPush(DOMPurify.removed, {\n          attribute: node.getAttributeNode(name),\n          from: node\n        });\n      } catch (_) {\n        arrayPush(DOMPurify.removed, {\n          attribute: null,\n          from: node\n        });\n      }\n      node.removeAttribute(name);\n\n      // We void attribute values for unremovable \"is\"\" attributes\n      if (name === 'is' && !ALLOWED_ATTR[name]) {\n        if (RETURN_DOM || RETURN_DOM_FRAGMENT) {\n          try {\n            _forceRemove(node);\n          } catch (_) {}\n        } else {\n          try {\n            node.setAttribute(name, '');\n          } catch (_) {}\n        }\n      }\n    };\n\n    /**\n     * _initDocument\n     *\n     * @param  {String} dirty a string of dirty markup\n     * @return {Document} a DOM, filled with the dirty markup\n     */\n    const _initDocument = function _initDocument(dirty) {\n      /* Create a HTML document */\n      let doc = null;\n      let leadingWhitespace = null;\n      if (FORCE_BODY) {\n        dirty = '<remove></remove>' + dirty;\n      } else {\n        /* If FORCE_BODY isn't used, leading whitespace needs to be preserved manually */\n        const matches = stringMatch(dirty, /^[\\r\\n\\t ]+/);\n        leadingWhitespace = matches && matches[0];\n      }\n      if (PARSER_MEDIA_TYPE === 'application/xhtml+xml' && NAMESPACE === HTML_NAMESPACE) {\n        // Root of XHTML doc must contain xmlns declaration (see https://www.w3.org/TR/xhtml1/normative.html#strict)\n        dirty = '<html xmlns=\"http://www.w3.org/1999/xhtml\"><head></head><body>' + dirty + '</body></html>';\n      }\n      const dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;\n      /*\n       * Use the DOMParser API by default, fallback later if needs be\n       * DOMParser not work for svg when has multiple root element.\n       */\n      if (NAMESPACE === HTML_NAMESPACE) {\n        try {\n          doc = new DOMParser().parseFromString(dirtyPayload, PARSER_MEDIA_TYPE);\n        } catch (_) {}\n      }\n\n      /* Use createHTMLDocument in case DOMParser is not available */\n      if (!doc || !doc.documentElement) {\n        doc = implementation.createDocument(NAMESPACE, 'template', null);\n        try {\n          doc.documentElement.innerHTML = IS_EMPTY_INPUT ? emptyHTML : dirtyPayload;\n        } catch (_) {\n          // Syntax error if dirtyPayload is invalid xml\n        }\n      }\n      const body = doc.body || doc.documentElement;\n      if (dirty && leadingWhitespace) {\n        body.insertBefore(document.createTextNode(leadingWhitespace), body.childNodes[0] || null);\n      }\n\n      /* Work on whole document or just its body */\n      if (NAMESPACE === HTML_NAMESPACE) {\n        return getElementsByTagName.call(doc, WHOLE_DOCUMENT ? 'html' : 'body')[0];\n      }\n      return WHOLE_DOCUMENT ? doc.documentElement : body;\n    };\n\n    /**\n     * Creates a NodeIterator object that you can use to traverse filtered lists of nodes or elements in a document.\n     *\n     * @param  {Node} root The root element or node to start traversing on.\n     * @return {NodeIterator} The created NodeIterator\n     */\n    const _createNodeIterator = function _createNodeIterator(root) {\n      return createNodeIterator.call(root.ownerDocument || root, root,\n      // eslint-disable-next-line no-bitwise\n      NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT | NodeFilter.SHOW_PROCESSING_INSTRUCTION | NodeFilter.SHOW_CDATA_SECTION, null);\n    };\n\n    /**\n     * _isClobbered\n     *\n     * @param  {Node} elm element to check for clobbering attacks\n     * @return {Boolean} true if clobbered, false if safe\n     */\n    const _isClobbered = function _isClobbered(elm) {\n      return elm instanceof HTMLFormElement && (typeof elm.nodeName !== 'string' || typeof elm.textContent !== 'string' || typeof elm.removeChild !== 'function' || !(elm.attributes instanceof NamedNodeMap) || typeof elm.removeAttribute !== 'function' || typeof elm.setAttribute !== 'function' || typeof elm.namespaceURI !== 'string' || typeof elm.insertBefore !== 'function' || typeof elm.hasChildNodes !== 'function');\n    };\n\n    /**\n     * Checks whether the given object is a DOM node.\n     *\n     * @param  {Node} object object to check whether it's a DOM node\n     * @return {Boolean} true is object is a DOM node\n     */\n    const _isNode = function _isNode(object) {\n      return typeof Node === 'function' && object instanceof Node;\n    };\n\n    /**\n     * _executeHook\n     * Execute user configurable hooks\n     *\n     * @param  {String} entryPoint  Name of the hook's entry point\n     * @param  {Node} currentNode node to work on with the hook\n     * @param  {Object} data additional hook parameters\n     */\n    const _executeHook = function _executeHook(entryPoint, currentNode, data) {\n      if (!hooks[entryPoint]) {\n        return;\n      }\n      arrayForEach(hooks[entryPoint], hook => {\n        hook.call(DOMPurify, currentNode, data, CONFIG);\n      });\n    };\n\n    /**\n     * _sanitizeElements\n     *\n     * @protect nodeName\n     * @protect textContent\n     * @protect removeChild\n     *\n     * @param   {Node} currentNode to check for permission to exist\n     * @return  {Boolean} true if node was killed, false if left alive\n     */\n    const _sanitizeElements = function _sanitizeElements(currentNode) {\n      let content = null;\n\n      /* Execute a hook if present */\n      _executeHook('beforeSanitizeElements', currentNode, null);\n\n      /* Check if element is clobbered or can clobber */\n      if (_isClobbered(currentNode)) {\n        _forceRemove(currentNode);\n        return true;\n      }\n\n      /* Now let's check the element's type and name */\n      const tagName = transformCaseFunc(currentNode.nodeName);\n\n      /* Execute a hook if present */\n      _executeHook('uponSanitizeElement', currentNode, {\n        tagName,\n        allowedTags: ALLOWED_TAGS\n      });\n\n      /* Detect mXSS attempts abusing namespace confusion */\n      if (currentNode.hasChildNodes() && !_isNode(currentNode.firstElementChild) && regExpTest(/<[/\\w]/g, currentNode.innerHTML) && regExpTest(/<[/\\w]/g, currentNode.textContent)) {\n        _forceRemove(currentNode);\n        return true;\n      }\n\n      /* Remove any occurrence of processing instructions */\n      if (currentNode.nodeType === NODE_TYPE.progressingInstruction) {\n        _forceRemove(currentNode);\n        return true;\n      }\n\n      /* Remove any kind of possibly harmful comments */\n      if (SAFE_FOR_XML && currentNode.nodeType === NODE_TYPE.comment && regExpTest(/<[/\\w]/g, currentNode.data)) {\n        _forceRemove(currentNode);\n        return true;\n      }\n\n      /* Remove element if anything forbids its presence */\n      if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {\n        /* Check if we have a custom element to handle */\n        if (!FORBID_TAGS[tagName] && _isBasicCustomElement(tagName)) {\n          if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, tagName)) {\n            return false;\n          }\n          if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(tagName)) {\n            return false;\n          }\n        }\n\n        /* Keep content except for bad-listed elements */\n        if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]) {\n          const parentNode = getParentNode(currentNode) || currentNode.parentNode;\n          const childNodes = getChildNodes(currentNode) || currentNode.childNodes;\n          if (childNodes && parentNode) {\n            const childCount = childNodes.length;\n            for (let i = childCount - 1; i >= 0; --i) {\n              const childClone = cloneNode(childNodes[i], true);\n              childClone.__removalCount = (currentNode.__removalCount || 0) + 1;\n              parentNode.insertBefore(childClone, getNextSibling(currentNode));\n            }\n          }\n        }\n        _forceRemove(currentNode);\n        return true;\n      }\n\n      /* Check whether element has a valid namespace */\n      if (currentNode instanceof Element && !_checkValidNamespace(currentNode)) {\n        _forceRemove(currentNode);\n        return true;\n      }\n\n      /* Make sure that older browsers don't get fallback-tag mXSS */\n      if ((tagName === 'noscript' || tagName === 'noembed' || tagName === 'noframes') && regExpTest(/<\\/no(script|embed|frames)/i, currentNode.innerHTML)) {\n        _forceRemove(currentNode);\n        return true;\n      }\n\n      /* Sanitize element content to be template-safe */\n      if (SAFE_FOR_TEMPLATES && currentNode.nodeType === NODE_TYPE.text) {\n        /* Get the element's text content */\n        content = currentNode.textContent;\n        arrayForEach([MUSTACHE_EXPR, ERB_EXPR, TMPLIT_EXPR], expr => {\n          content = stringReplace(content, expr, ' ');\n        });\n        if (currentNode.textContent !== content) {\n          arrayPush(DOMPurify.removed, {\n            element: currentNode.cloneNode()\n          });\n          currentNode.textContent = content;\n        }\n      }\n\n      /* Execute a hook if present */\n      _executeHook('afterSanitizeElements', currentNode, null);\n      return false;\n    };\n\n    /**\n     * _isValidAttribute\n     *\n     * @param  {string} lcTag Lowercase tag name of containing element.\n     * @param  {string} lcName Lowercase attribute name.\n     * @param  {string} value Attribute value.\n     * @return {Boolean} Returns true if `value` is valid, otherwise false.\n     */\n    // eslint-disable-next-line complexity\n    const _isValidAttribute = function _isValidAttribute(lcTag, lcName, value) {\n      /* Make sure attribute cannot clobber */\n      if (SANITIZE_DOM && (lcName === 'id' || lcName === 'name') && (value in document || value in formElement)) {\n        return false;\n      }\n\n      /* Allow valid data-* attributes: At least one character after \"-\"\n          (https://html.spec.whatwg.org/multipage/dom.html#embedding-custom-non-visible-data-with-the-data-*-attributes)\n          XML-compatible (https://html.spec.whatwg.org/multipage/infrastructure.html#xml-compatible and http://www.w3.org/TR/xml/#d0e804)\n          We don't need to check the value; it's always URI safe. */\n      if (ALLOW_DATA_ATTR && !FORBID_ATTR[lcName] && regExpTest(DATA_ATTR, lcName)) ;else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR, lcName)) ;else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {\n        if (\n        // First condition does a very basic check if a) it's basically a valid custom element tagname AND\n        // b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck\n        // and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck\n        _isBasicCustomElement(lcTag) && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, lcTag) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(lcTag)) && (CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.attributeNameCheck, lcName) || CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.attributeNameCheck(lcName)) ||\n        // Alternative, second condition checks if it's an `is`-attribute, AND\n        // the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck\n        lcName === 'is' && CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, value) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(value))) ;else {\n          return false;\n        }\n        /* Check value is safe. First, is attr inert? If so, is safe */\n      } else if (URI_SAFE_ATTRIBUTES[lcName]) ;else if (regExpTest(IS_ALLOWED_URI$1, stringReplace(value, ATTR_WHITESPACE, ''))) ;else if ((lcName === 'src' || lcName === 'xlink:href' || lcName === 'href') && lcTag !== 'script' && stringIndexOf(value, 'data:') === 0 && DATA_URI_TAGS[lcTag]) ;else if (ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA, stringReplace(value, ATTR_WHITESPACE, ''))) ;else if (value) {\n        return false;\n      } else ;\n      return true;\n    };\n\n    /**\n     * _isBasicCustomElement\n     * checks if at least one dash is included in tagName, and it's not the first char\n     * for more sophisticated checking see https://github.com/sindresorhus/validate-element-name\n     *\n     * @param {string} tagName name of the tag of the node to sanitize\n     * @returns {boolean} Returns true if the tag name meets the basic criteria for a custom element, otherwise false.\n     */\n    const _isBasicCustomElement = function _isBasicCustomElement(tagName) {\n      return tagName !== 'annotation-xml' && stringMatch(tagName, CUSTOM_ELEMENT);\n    };\n\n    /**\n     * _sanitizeAttributes\n     *\n     * @protect attributes\n     * @protect nodeName\n     * @protect removeAttribute\n     * @protect setAttribute\n     *\n     * @param  {Node} currentNode to sanitize\n     */\n    const _sanitizeAttributes = function _sanitizeAttributes(currentNode) {\n      /* Execute a hook if present */\n      _executeHook('beforeSanitizeAttributes', currentNode, null);\n      const {\n        attributes\n      } = currentNode;\n\n      /* Check if we have attributes; if not we might have a text node */\n      if (!attributes) {\n        return;\n      }\n      const hookEvent = {\n        attrName: '',\n        attrValue: '',\n        keepAttr: true,\n        allowedAttributes: ALLOWED_ATTR\n      };\n      let l = attributes.length;\n\n      /* Go backwards over all attributes; safely remove bad ones */\n      while (l--) {\n        const attr = attributes[l];\n        const {\n          name,\n          namespaceURI,\n          value: attrValue\n        } = attr;\n        const lcName = transformCaseFunc(name);\n        let value = name === 'value' ? attrValue : stringTrim(attrValue);\n        const initValue = value;\n\n        /* Execute a hook if present */\n        hookEvent.attrName = lcName;\n        hookEvent.attrValue = value;\n        hookEvent.keepAttr = true;\n        hookEvent.forceKeepAttr = undefined; // Allows developers to see this is a property they can set\n        _executeHook('uponSanitizeAttribute', currentNode, hookEvent);\n        value = hookEvent.attrValue;\n\n        /* Did the hooks approve of the attribute? */\n        if (hookEvent.forceKeepAttr) {\n          continue;\n        }\n\n        /* Remove attribute */\n\n        /* Did the hooks approve of the attribute? */\n        if (!hookEvent.keepAttr) {\n          _removeAttribute(name, currentNode);\n          continue;\n        }\n\n        /* Work around a security issue in jQuery 3.0 */\n        if (!ALLOW_SELF_CLOSE_IN_ATTR && regExpTest(/\\/>/i, value)) {\n          _removeAttribute(name, currentNode);\n          continue;\n        }\n\n        /* Sanitize attribute content to be template-safe */\n        if (SAFE_FOR_TEMPLATES) {\n          arrayForEach([MUSTACHE_EXPR, ERB_EXPR, TMPLIT_EXPR], expr => {\n            value = stringReplace(value, expr, ' ');\n          });\n        }\n\n        /* Is `value` valid for this attribute? */\n        const lcTag = transformCaseFunc(currentNode.nodeName);\n        if (!_isValidAttribute(lcTag, lcName, value)) {\n          _removeAttribute(name, currentNode);\n          continue;\n        }\n\n        /* Full DOM Clobbering protection via namespace isolation,\n         * Prefix id and name attributes with `user-content-`\n         */\n        if (SANITIZE_NAMED_PROPS && (lcName === 'id' || lcName === 'name')) {\n          // Remove the attribute with this value\n          _removeAttribute(name, currentNode);\n\n          // Prefix the value and later re-create the attribute with the sanitized value\n          value = SANITIZE_NAMED_PROPS_PREFIX + value;\n        }\n\n        /* Work around a security issue with comments inside attributes */\n        if (SAFE_FOR_XML && regExpTest(/((--!?|])>)|<\\/(style|title)/i, value)) {\n          _removeAttribute(name, currentNode);\n          continue;\n        }\n\n        /* Handle attributes that require Trusted Types */\n        if (trustedTypesPolicy && typeof trustedTypes === 'object' && typeof trustedTypes.getAttributeType === 'function') {\n          if (namespaceURI) ;else {\n            switch (trustedTypes.getAttributeType(lcTag, lcName)) {\n              case 'TrustedHTML':\n                {\n                  value = trustedTypesPolicy.createHTML(value);\n                  break;\n                }\n              case 'TrustedScriptURL':\n                {\n                  value = trustedTypesPolicy.createScriptURL(value);\n                  break;\n                }\n            }\n          }\n        }\n\n        /* Handle invalid data-* attribute set by try-catching it */\n        if (value !== initValue) {\n          try {\n            if (namespaceURI) {\n              currentNode.setAttributeNS(namespaceURI, name, value);\n            } else {\n              /* Fallback to setAttribute() for browser-unrecognized namespaces e.g. \"x-schema\". */\n              currentNode.setAttribute(name, value);\n            }\n            if (_isClobbered(currentNode)) {\n              _forceRemove(currentNode);\n            } else {\n              arrayPop(DOMPurify.removed);\n            }\n          } catch (_) {}\n        }\n      }\n\n      /* Execute a hook if present */\n      _executeHook('afterSanitizeAttributes', currentNode, null);\n    };\n\n    /**\n     * _sanitizeShadowDOM\n     *\n     * @param  {DocumentFragment} fragment to iterate over recursively\n     */\n    const _sanitizeShadowDOM = function _sanitizeShadowDOM(fragment) {\n      let shadowNode = null;\n      const shadowIterator = _createNodeIterator(fragment);\n\n      /* Execute a hook if present */\n      _executeHook('beforeSanitizeShadowDOM', fragment, null);\n      while (shadowNode = shadowIterator.nextNode()) {\n        /* Execute a hook if present */\n        _executeHook('uponSanitizeShadowNode', shadowNode, null);\n\n        /* Sanitize tags and elements */\n        if (_sanitizeElements(shadowNode)) {\n          continue;\n        }\n\n        /* Deep shadow DOM detected */\n        if (shadowNode.content instanceof DocumentFragment) {\n          _sanitizeShadowDOM(shadowNode.content);\n        }\n\n        /* Check attributes, sanitize if necessary */\n        _sanitizeAttributes(shadowNode);\n      }\n\n      /* Execute a hook if present */\n      _executeHook('afterSanitizeShadowDOM', fragment, null);\n    };\n\n    /**\n     * Sanitize\n     * Public method providing core sanitation functionality\n     *\n     * @param {String|Node} dirty string or DOM node\n     * @param {Object} cfg object\n     */\n    // eslint-disable-next-line complexity\n    DOMPurify.sanitize = function (dirty) {\n      let cfg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      let body = null;\n      let importedNode = null;\n      let currentNode = null;\n      let returnNode = null;\n      /* Make sure we have a string to sanitize.\n        DO NOT return early, as this will return the wrong type if\n        the user has requested a DOM object rather than a string */\n      IS_EMPTY_INPUT = !dirty;\n      if (IS_EMPTY_INPUT) {\n        dirty = '<!-->';\n      }\n\n      /* Stringify, in case dirty is an object */\n      if (typeof dirty !== 'string' && !_isNode(dirty)) {\n        if (typeof dirty.toString === 'function') {\n          dirty = dirty.toString();\n          if (typeof dirty !== 'string') {\n            throw typeErrorCreate('dirty is not a string, aborting');\n          }\n        } else {\n          throw typeErrorCreate('toString is not a function');\n        }\n      }\n\n      /* Return dirty HTML if DOMPurify cannot run */\n      if (!DOMPurify.isSupported) {\n        return dirty;\n      }\n\n      /* Assign config vars */\n      if (!SET_CONFIG) {\n        _parseConfig(cfg);\n      }\n\n      /* Clean up removed elements */\n      DOMPurify.removed = [];\n\n      /* Check if dirty is correctly typed for IN_PLACE */\n      if (typeof dirty === 'string') {\n        IN_PLACE = false;\n      }\n      if (IN_PLACE) {\n        /* Do some early pre-sanitization to avoid unsafe root nodes */\n        if (dirty.nodeName) {\n          const tagName = transformCaseFunc(dirty.nodeName);\n          if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {\n            throw typeErrorCreate('root node is forbidden and cannot be sanitized in-place');\n          }\n        }\n      } else if (dirty instanceof Node) {\n        /* If dirty is a DOM element, append to an empty document to avoid\n           elements being stripped by the parser */\n        body = _initDocument('<!---->');\n        importedNode = body.ownerDocument.importNode(dirty, true);\n        if (importedNode.nodeType === NODE_TYPE.element && importedNode.nodeName === 'BODY') {\n          /* Node is already a body, use as is */\n          body = importedNode;\n        } else if (importedNode.nodeName === 'HTML') {\n          body = importedNode;\n        } else {\n          // eslint-disable-next-line unicorn/prefer-dom-node-append\n          body.appendChild(importedNode);\n        }\n      } else {\n        /* Exit directly if we have nothing to do */\n        if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT &&\n        // eslint-disable-next-line unicorn/prefer-includes\n        dirty.indexOf('<') === -1) {\n          return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;\n        }\n\n        /* Initialize the document to work on */\n        body = _initDocument(dirty);\n\n        /* Check we have a DOM node from the data */\n        if (!body) {\n          return RETURN_DOM ? null : RETURN_TRUSTED_TYPE ? emptyHTML : '';\n        }\n      }\n\n      /* Remove first element node (ours) if FORCE_BODY is set */\n      if (body && FORCE_BODY) {\n        _forceRemove(body.firstChild);\n      }\n\n      /* Get node iterator */\n      const nodeIterator = _createNodeIterator(IN_PLACE ? dirty : body);\n\n      /* Now start iterating over the created document */\n      while (currentNode = nodeIterator.nextNode()) {\n        /* Sanitize tags and elements */\n        if (_sanitizeElements(currentNode)) {\n          continue;\n        }\n\n        /* Shadow DOM detected, sanitize it */\n        if (currentNode.content instanceof DocumentFragment) {\n          _sanitizeShadowDOM(currentNode.content);\n        }\n\n        /* Check attributes, sanitize if necessary */\n        _sanitizeAttributes(currentNode);\n      }\n\n      /* If we sanitized `dirty` in-place, return it. */\n      if (IN_PLACE) {\n        return dirty;\n      }\n\n      /* Return sanitized string or DOM */\n      if (RETURN_DOM) {\n        if (RETURN_DOM_FRAGMENT) {\n          returnNode = createDocumentFragment.call(body.ownerDocument);\n          while (body.firstChild) {\n            // eslint-disable-next-line unicorn/prefer-dom-node-append\n            returnNode.appendChild(body.firstChild);\n          }\n        } else {\n          returnNode = body;\n        }\n        if (ALLOWED_ATTR.shadowroot || ALLOWED_ATTR.shadowrootmode) {\n          /*\n            AdoptNode() is not used because internal state is not reset\n            (e.g. the past names map of a HTMLFormElement), this is safe\n            in theory but we would rather not risk another attack vector.\n            The state that is cloned by importNode() is explicitly defined\n            by the specs.\n          */\n          returnNode = importNode.call(originalDocument, returnNode, true);\n        }\n        return returnNode;\n      }\n      let serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;\n\n      /* Serialize doctype if allowed */\n      if (WHOLE_DOCUMENT && ALLOWED_TAGS['!doctype'] && body.ownerDocument && body.ownerDocument.doctype && body.ownerDocument.doctype.name && regExpTest(DOCTYPE_NAME, body.ownerDocument.doctype.name)) {\n        serializedHTML = '<!DOCTYPE ' + body.ownerDocument.doctype.name + '>\\n' + serializedHTML;\n      }\n\n      /* Sanitize final string template-safe */\n      if (SAFE_FOR_TEMPLATES) {\n        arrayForEach([MUSTACHE_EXPR, ERB_EXPR, TMPLIT_EXPR], expr => {\n          serializedHTML = stringReplace(serializedHTML, expr, ' ');\n        });\n      }\n      return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;\n    };\n\n    /**\n     * Public method to set the configuration once\n     * setConfig\n     *\n     * @param {Object} cfg configuration object\n     */\n    DOMPurify.setConfig = function () {\n      let cfg = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      _parseConfig(cfg);\n      SET_CONFIG = true;\n    };\n\n    /**\n     * Public method to remove the configuration\n     * clearConfig\n     *\n     */\n    DOMPurify.clearConfig = function () {\n      CONFIG = null;\n      SET_CONFIG = false;\n    };\n\n    /**\n     * Public method to check if an attribute value is valid.\n     * Uses last set config, if any. Otherwise, uses config defaults.\n     * isValidAttribute\n     *\n     * @param  {String} tag Tag name of containing element.\n     * @param  {String} attr Attribute name.\n     * @param  {String} value Attribute value.\n     * @return {Boolean} Returns true if `value` is valid. Otherwise, returns false.\n     */\n    DOMPurify.isValidAttribute = function (tag, attr, value) {\n      /* Initialize shared config vars if necessary. */\n      if (!CONFIG) {\n        _parseConfig({});\n      }\n      const lcTag = transformCaseFunc(tag);\n      const lcName = transformCaseFunc(attr);\n      return _isValidAttribute(lcTag, lcName, value);\n    };\n\n    /**\n     * AddHook\n     * Public method to add DOMPurify hooks\n     *\n     * @param {String} entryPoint entry point for the hook to add\n     * @param {Function} hookFunction function to execute\n     */\n    DOMPurify.addHook = function (entryPoint, hookFunction) {\n      if (typeof hookFunction !== 'function') {\n        return;\n      }\n      hooks[entryPoint] = hooks[entryPoint] || [];\n      arrayPush(hooks[entryPoint], hookFunction);\n    };\n\n    /**\n     * RemoveHook\n     * Public method to remove a DOMPurify hook at a given entryPoint\n     * (pops it from the stack of hooks if more are present)\n     *\n     * @param {String} entryPoint entry point for the hook to remove\n     * @return {Function} removed(popped) hook\n     */\n    DOMPurify.removeHook = function (entryPoint) {\n      if (hooks[entryPoint]) {\n        return arrayPop(hooks[entryPoint]);\n      }\n    };\n\n    /**\n     * RemoveHooks\n     * Public method to remove all DOMPurify hooks at a given entryPoint\n     *\n     * @param  {String} entryPoint entry point for the hooks to remove\n     */\n    DOMPurify.removeHooks = function (entryPoint) {\n      if (hooks[entryPoint]) {\n        hooks[entryPoint] = [];\n      }\n    };\n\n    /**\n     * RemoveAllHooks\n     * Public method to remove all DOMPurify hooks\n     */\n    DOMPurify.removeAllHooks = function () {\n      hooks = {};\n    };\n    return DOMPurify;\n  }\n  var purify = createDOMPurify();\n  const each$4 = Tools.each,\n    trim = Tools.trim;\n  const queryParts = ['source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'];\n  const DEFAULT_PORTS = {\n    ftp: 21,\n    http: 80,\n    https: 443,\n    mailto: 25\n  };\n  const safeSvgDataUrlElements = ['img', 'video'];\n  const blockSvgDataUris = (allowSvgDataUrls, tagName) => {\n    if (isNonNullable(allowSvgDataUrls)) {\n      return !allowSvgDataUrls;\n    } else {\n      return isNonNullable(tagName) ? !contains$2(safeSvgDataUrlElements, tagName) : true;\n    }\n  };\n  const decodeUri = encodedUri => {\n    try {\n      return decodeURIComponent(encodedUri);\n    } catch (ex) {\n      return unescape(encodedUri);\n    }\n  };\n  const isInvalidUri = (settings, uri, tagName) => {\n    const decodedUri = decodeUri(uri).replace(/\\s/g, '');\n    if (settings.allow_script_urls) {\n      return false;\n    } else if (/((java|vb)script|mhtml):/i.test(decodedUri)) {\n      return true;\n    } else if (settings.allow_html_data_urls) {\n      return false;\n    } else if (/^data:image\\//i.test(decodedUri)) {\n      return blockSvgDataUris(settings.allow_svg_data_urls, tagName) && /^data:image\\/svg\\+xml/i.test(decodedUri);\n    } else {\n      return /^data:/i.test(decodedUri);\n    }\n  };\n  class URI {\n    static parseDataUri(uri) {\n      let type;\n      const uriComponents = decodeURIComponent(uri).split(',');\n      const matches = /data:([^;]+)/.exec(uriComponents[0]);\n      if (matches) {\n        type = matches[1];\n      }\n      return {\n        type,\n        data: uriComponents[1]\n      };\n    }\n    static isDomSafe(uri, context, options = {}) {\n      if (options.allow_script_urls) {\n        return true;\n      } else {\n        const decodedUri = Entities.decode(uri).replace(/[\\s\\u0000-\\u001F]+/g, '');\n        return !isInvalidUri(options, decodedUri, context);\n      }\n    }\n    static getDocumentBaseUrl(loc) {\n      var _a;\n      let baseUrl;\n      if (loc.protocol.indexOf('http') !== 0 && loc.protocol !== 'file:') {\n        baseUrl = (_a = loc.href) !== null && _a !== void 0 ? _a : '';\n      } else {\n        baseUrl = loc.protocol + '//' + loc.host + loc.pathname;\n      }\n      if (/^[^:]+:\\/\\/\\/?[^\\/]+\\//.test(baseUrl)) {\n        baseUrl = baseUrl.replace(/[\\?#].*$/, '').replace(/[\\/\\\\][^\\/]+$/, '');\n        if (!/[\\/\\\\]$/.test(baseUrl)) {\n          baseUrl += '/';\n        }\n      }\n      return baseUrl;\n    }\n    constructor(url, settings = {}) {\n      this.path = '';\n      this.directory = '';\n      url = trim(url);\n      this.settings = settings;\n      const baseUri = settings.base_uri;\n      const self = this;\n      if (/^([\\w\\-]+):([^\\/]{2})/i.test(url) || /^\\s*#/.test(url)) {\n        self.source = url;\n        return;\n      }\n      const isProtocolRelative = url.indexOf('//') === 0;\n      if (url.indexOf('/') === 0 && !isProtocolRelative) {\n        url = (baseUri ? baseUri.protocol || 'http' : 'http') + '://mce_host' + url;\n      }\n      if (!/^[\\w\\-]*:?\\/\\//.test(url)) {\n        const baseUrl = baseUri ? baseUri.path : new URI(document.location.href).directory;\n        if ((baseUri === null || baseUri === void 0 ? void 0 : baseUri.protocol) === '') {\n          url = '//mce_host' + self.toAbsPath(baseUrl, url);\n        } else {\n          const match = /([^#?]*)([#?]?.*)/.exec(url);\n          if (match) {\n            url = (baseUri && baseUri.protocol || 'http') + '://mce_host' + self.toAbsPath(baseUrl, match[1]) + match[2];\n          }\n        }\n      }\n      url = url.replace(/@@/g, '(mce_at)');\n      const urlMatch = /^(?:(?![^:@]+:[^:@\\/]*@)([^:\\/?#.]+):)?(?:\\/\\/)?((?:(([^:@\\/]*):?([^:@\\/]*))?@)?(\\[[a-zA-Z0-9:.%]+\\]|[^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/.exec(url);\n      if (urlMatch) {\n        each$4(queryParts, (v, i) => {\n          let part = urlMatch[i];\n          if (part) {\n            part = part.replace(/\\(mce_at\\)/g, '@@');\n          }\n          self[v] = part;\n        });\n      }\n      if (baseUri) {\n        if (!self.protocol) {\n          self.protocol = baseUri.protocol;\n        }\n        if (!self.userInfo) {\n          self.userInfo = baseUri.userInfo;\n        }\n        if (!self.port && self.host === 'mce_host') {\n          self.port = baseUri.port;\n        }\n        if (!self.host || self.host === 'mce_host') {\n          self.host = baseUri.host;\n        }\n        self.source = '';\n      }\n      if (isProtocolRelative) {\n        self.protocol = '';\n      }\n    }\n    setPath(path) {\n      const pathMatch = /^(.*?)\\/?(\\w+)?$/.exec(path);\n      if (pathMatch) {\n        this.path = pathMatch[0];\n        this.directory = pathMatch[1];\n        this.file = pathMatch[2];\n      }\n      this.source = '';\n      this.getURI();\n    }\n    toRelative(uri) {\n      if (uri === './') {\n        return uri;\n      }\n      const relativeUri = new URI(uri, {\n        base_uri: this\n      });\n      if (relativeUri.host !== 'mce_host' && this.host !== relativeUri.host && relativeUri.host || this.port !== relativeUri.port || this.protocol !== relativeUri.protocol && relativeUri.protocol !== '') {\n        return relativeUri.getURI();\n      }\n      const tu = this.getURI(),\n        uu = relativeUri.getURI();\n      if (tu === uu || tu.charAt(tu.length - 1) === '/' && tu.substr(0, tu.length - 1) === uu) {\n        return tu;\n      }\n      let output = this.toRelPath(this.path, relativeUri.path);\n      if (relativeUri.query) {\n        output += '?' + relativeUri.query;\n      }\n      if (relativeUri.anchor) {\n        output += '#' + relativeUri.anchor;\n      }\n      return output;\n    }\n    toAbsolute(uri, noHost) {\n      const absoluteUri = new URI(uri, {\n        base_uri: this\n      });\n      return absoluteUri.getURI(noHost && this.isSameOrigin(absoluteUri));\n    }\n    isSameOrigin(uri) {\n      if (this.host == uri.host && this.protocol == uri.protocol) {\n        if (this.port == uri.port) {\n          return true;\n        }\n        const defaultPort = this.protocol ? DEFAULT_PORTS[this.protocol] : null;\n        if (defaultPort && (this.port || defaultPort) == (uri.port || defaultPort)) {\n          return true;\n        }\n      }\n      return false;\n    }\n    toRelPath(base, path) {\n      let breakPoint = 0,\n        out = '',\n        i,\n        l;\n      const normalizedBase = base.substring(0, base.lastIndexOf('/')).split('/');\n      const items = path.split('/');\n      if (normalizedBase.length >= items.length) {\n        for (i = 0, l = normalizedBase.length; i < l; i++) {\n          if (i >= items.length || normalizedBase[i] !== items[i]) {\n            breakPoint = i + 1;\n            break;\n          }\n        }\n      }\n      if (normalizedBase.length < items.length) {\n        for (i = 0, l = items.length; i < l; i++) {\n          if (i >= normalizedBase.length || normalizedBase[i] !== items[i]) {\n            breakPoint = i + 1;\n            break;\n          }\n        }\n      }\n      if (breakPoint === 1) {\n        return path;\n      }\n      for (i = 0, l = normalizedBase.length - (breakPoint - 1); i < l; i++) {\n        out += '../';\n      }\n      for (i = breakPoint - 1, l = items.length; i < l; i++) {\n        if (i !== breakPoint - 1) {\n          out += '/' + items[i];\n        } else {\n          out += items[i];\n        }\n      }\n      return out;\n    }\n    toAbsPath(base, path) {\n      let nb = 0;\n      const tr = /\\/$/.test(path) ? '/' : '';\n      const normalizedBase = base.split('/');\n      const normalizedPath = path.split('/');\n      const baseParts = [];\n      each$4(normalizedBase, k => {\n        if (k) {\n          baseParts.push(k);\n        }\n      });\n      const pathParts = [];\n      for (let i = normalizedPath.length - 1; i >= 0; i--) {\n        if (normalizedPath[i].length === 0 || normalizedPath[i] === '.') {\n          continue;\n        }\n        if (normalizedPath[i] === '..') {\n          nb++;\n          continue;\n        }\n        if (nb > 0) {\n          nb--;\n          continue;\n        }\n        pathParts.push(normalizedPath[i]);\n      }\n      const i = baseParts.length - nb;\n      let outPath;\n      if (i <= 0) {\n        outPath = reverse(pathParts).join('/');\n      } else {\n        outPath = baseParts.slice(0, i).join('/') + '/' + reverse(pathParts).join('/');\n      }\n      if (outPath.indexOf('/') !== 0) {\n        outPath = '/' + outPath;\n      }\n      if (tr && outPath.lastIndexOf('/') !== outPath.length - 1) {\n        outPath += tr;\n      }\n      return outPath;\n    }\n    getURI(noProtoHost = false) {\n      let s;\n      if (!this.source || noProtoHost) {\n        s = '';\n        if (!noProtoHost) {\n          if (this.protocol) {\n            s += this.protocol + '://';\n          } else {\n            s += '//';\n          }\n          if (this.userInfo) {\n            s += this.userInfo + '@';\n          }\n          if (this.host) {\n            s += this.host;\n          }\n          if (this.port) {\n            s += ':' + this.port;\n          }\n        }\n        if (this.path) {\n          s += this.path;\n        }\n        if (this.query) {\n          s += '?' + this.query;\n        }\n        if (this.anchor) {\n          s += '#' + this.anchor;\n        }\n        this.source = s;\n      }\n      return this.source;\n    }\n  }\n  const filteredUrlAttrs = Tools.makeMap('src,href,data,background,action,formaction,poster,xlink:href');\n  const internalElementAttr = 'data-mce-type';\n  let uid = 0;\n  const processNode = (node, settings, schema, scope, evt) => {\n    var _a, _b, _c, _d;\n    const validate = settings.validate;\n    const specialElements = schema.getSpecialElements();\n    if (node.nodeType === COMMENT && !settings.allow_conditional_comments && /^\\[if/i.test((_a = node.nodeValue) !== null && _a !== void 0 ? _a : '')) {\n      node.nodeValue = ' ' + node.nodeValue;\n    }\n    const lcTagName = (_b = evt === null || evt === void 0 ? void 0 : evt.tagName) !== null && _b !== void 0 ? _b : node.nodeName.toLowerCase();\n    if (scope !== 'html' && schema.isValid(scope)) {\n      if (isNonNullable(evt)) {\n        evt.allowedTags[lcTagName] = true;\n      }\n      return;\n    }\n    if (node.nodeType !== ELEMENT || lcTagName === 'body') {\n      return;\n    }\n    const element = SugarElement.fromDom(node);\n    const isInternalElement = has$1(element, internalElementAttr);\n    const bogus = get$9(element, 'data-mce-bogus');\n    if (!isInternalElement && isString(bogus)) {\n      if (bogus === 'all') {\n        remove$4(element);\n      } else {\n        unwrap(element);\n      }\n      return;\n    }\n    const rule = schema.getElementRule(lcTagName);\n    if (validate && !rule) {\n      if (has$2(specialElements, lcTagName)) {\n        remove$4(element);\n      } else {\n        unwrap(element);\n      }\n      return;\n    } else {\n      if (isNonNullable(evt)) {\n        evt.allowedTags[lcTagName] = true;\n      }\n    }\n    if (validate && rule && !isInternalElement) {\n      each$e((_c = rule.attributesForced) !== null && _c !== void 0 ? _c : [], attr => {\n        set$3(element, attr.name, attr.value === '{$uid}' ? `mce_${uid++}` : attr.value);\n      });\n      each$e((_d = rule.attributesDefault) !== null && _d !== void 0 ? _d : [], attr => {\n        if (!has$1(element, attr.name)) {\n          set$3(element, attr.name, attr.value === '{$uid}' ? `mce_${uid++}` : attr.value);\n        }\n      });\n      if (rule.attributesRequired && !exists(rule.attributesRequired, attr => has$1(element, attr))) {\n        unwrap(element);\n        return;\n      }\n      if (rule.removeEmptyAttrs && hasNone(element)) {\n        unwrap(element);\n        return;\n      }\n      if (rule.outputName && rule.outputName !== lcTagName) {\n        mutate(element, rule.outputName);\n      }\n    }\n  };\n  const processAttr = (ele, settings, schema, scope, evt) => {\n    const tagName = ele.tagName.toLowerCase();\n    const {\n      attrName,\n      attrValue\n    } = evt;\n    evt.keepAttr = shouldKeepAttribute(settings, schema, scope, tagName, attrName, attrValue);\n    if (evt.keepAttr) {\n      evt.allowedAttributes[attrName] = true;\n      if (isBooleanAttribute(attrName, schema)) {\n        evt.attrValue = attrName;\n      }\n      if (settings.allow_svg_data_urls && startsWith(attrValue, 'data:image/svg+xml')) {\n        evt.forceKeepAttr = true;\n      }\n    } else if (isRequiredAttributeOfInternalElement(ele, attrName)) {\n      evt.forceKeepAttr = true;\n    }\n  };\n  const shouldKeepAttribute = (settings, schema, scope, tagName, attrName, attrValue) => {\n    if (scope !== 'html' && !isNonHtmlElementRootName(tagName)) {\n      return true;\n    }\n    return !(attrName in filteredUrlAttrs && isInvalidUri(settings, attrValue, tagName)) && (!settings.validate || schema.isValid(tagName, attrName) || startsWith(attrName, 'data-') || startsWith(attrName, 'aria-'));\n  };\n  const isRequiredAttributeOfInternalElement = (ele, attrName) => ele.hasAttribute(internalElementAttr) && (attrName === 'id' || attrName === 'class' || attrName === 'style');\n  const isBooleanAttribute = (attrName, schema) => attrName in schema.getBoolAttrs();\n  const filterAttributes = (ele, settings, schema, scope) => {\n    const {\n      attributes\n    } = ele;\n    for (let i = attributes.length - 1; i >= 0; i--) {\n      const attr = attributes[i];\n      const attrName = attr.name;\n      const attrValue = attr.value;\n      if (!shouldKeepAttribute(settings, schema, scope, ele.tagName.toLowerCase(), attrName, attrValue) && !isRequiredAttributeOfInternalElement(ele, attrName)) {\n        ele.removeAttribute(attrName);\n      } else if (isBooleanAttribute(attrName, schema)) {\n        ele.setAttribute(attrName, attrName);\n      }\n    }\n  };\n  const setupPurify = (settings, schema, namespaceTracker) => {\n    const purify$1 = purify();\n    purify$1.addHook('uponSanitizeElement', (ele, evt) => {\n      processNode(ele, settings, schema, namespaceTracker.track(ele), evt);\n    });\n    purify$1.addHook('uponSanitizeAttribute', (ele, evt) => {\n      processAttr(ele, settings, schema, namespaceTracker.current(), evt);\n    });\n    return purify$1;\n  };\n  const getPurifyConfig = (settings, mimeType) => {\n    const basePurifyConfig = {\n      IN_PLACE: true,\n      ALLOW_UNKNOWN_PROTOCOLS: true,\n      ALLOWED_TAGS: ['#comment', '#cdata-section', 'body'],\n      ALLOWED_ATTR: [],\n      SAFE_FOR_XML: false\n    };\n    const config = {\n      ...basePurifyConfig\n    };\n    config.PARSER_MEDIA_TYPE = mimeType;\n    if (settings.allow_script_urls) {\n      config.ALLOWED_URI_REGEXP = /.*/;\n    } else if (settings.allow_html_data_urls) {\n      config.ALLOWED_URI_REGEXP = /^(?!(\\w+script|mhtml):)/i;\n    }\n    return config;\n  };\n  const sanitizeSvgElement = ele => {\n    const xlinkAttrs = ['type', 'href', 'role', 'arcrole', 'title', 'show', 'actuate', 'label', 'from', 'to'].map(name => `xlink:${name}`);\n    const config = {\n      IN_PLACE: true,\n      USE_PROFILES: {\n        html: true,\n        svg: true,\n        svgFilters: true\n      },\n      ALLOWED_ATTR: xlinkAttrs\n    };\n    purify().sanitize(ele, config);\n  };\n  const sanitizeMathmlElement = (node, settings) => {\n    const config = {\n      IN_PLACE: true,\n      USE_PROFILES: {\n        mathMl: true\n      }\n    };\n    const purify$1 = purify();\n    purify$1.addHook('uponSanitizeElement', (node, evt) => {\n      var _a;\n      const lcTagName = (_a = evt.tagName) !== null && _a !== void 0 ? _a : node.nodeName.toLowerCase();\n      const allowedEncodings = settings.allow_mathml_annotation_encodings;\n      if (lcTagName === 'annotation' && isArray$1(allowedEncodings) && allowedEncodings.length > 0) {\n        const encoding = node.getAttribute('encoding');\n        if (isString(encoding) && contains$2(allowedEncodings, encoding)) {\n          evt.allowedTags[lcTagName] = true;\n        }\n      }\n    });\n    purify$1.sanitize(node, config);\n  };\n  const mkSanitizeNamespaceElement = settings => ele => {\n    const namespaceType = toScopeType(ele);\n    if (namespaceType === 'svg') {\n      sanitizeSvgElement(ele);\n    } else if (namespaceType === 'math') {\n      sanitizeMathmlElement(ele, settings);\n    } else {\n      throw new Error('Not a namespace element');\n    }\n  };\n  const getSanitizer = (settings, schema) => {\n    const namespaceTracker = createNamespaceTracker();\n    if (settings.sanitize) {\n      const purify = setupPurify(settings, schema, namespaceTracker);\n      const sanitizeHtmlElement = (body, mimeType) => {\n        purify.sanitize(body, getPurifyConfig(settings, mimeType));\n        purify.removed = [];\n        namespaceTracker.reset();\n      };\n      return {\n        sanitizeHtmlElement,\n        sanitizeNamespaceElement: mkSanitizeNamespaceElement(settings)\n      };\n    } else {\n      const sanitizeHtmlElement = (body, _mimeType) => {\n        const nodeIterator = document.createNodeIterator(body, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT);\n        let node;\n        while (node = nodeIterator.nextNode()) {\n          const currentScope = namespaceTracker.track(node);\n          processNode(node, settings, schema, currentScope);\n          if (isElement$6(node)) {\n            filterAttributes(node, settings, schema, currentScope);\n          }\n        }\n        namespaceTracker.reset();\n      };\n      const sanitizeNamespaceElement = noop;\n      return {\n        sanitizeHtmlElement,\n        sanitizeNamespaceElement\n      };\n    }\n  };\n  const makeMap = Tools.makeMap,\n    extend$1 = Tools.extend;\n  const transferChildren = (parent, nativeParent, specialElements, nsSanitizer) => {\n    const parentName = parent.name;\n    const isSpecial = parentName in specialElements && parentName !== 'title' && parentName !== 'textarea' && parentName !== 'noscript';\n    const childNodes = nativeParent.childNodes;\n    for (let ni = 0, nl = childNodes.length; ni < nl; ni++) {\n      const nativeChild = childNodes[ni];\n      const child = new AstNode(nativeChild.nodeName.toLowerCase(), nativeChild.nodeType);\n      if (isElement$6(nativeChild)) {\n        const attributes = nativeChild.attributes;\n        for (let ai = 0, al = attributes.length; ai < al; ai++) {\n          const attr = attributes[ai];\n          child.attr(attr.name, attr.value);\n        }\n        if (isNonHtmlElementRootName(child.name)) {\n          nsSanitizer(nativeChild);\n          child.value = nativeChild.innerHTML;\n        }\n      } else if (isText$b(nativeChild)) {\n        child.value = nativeChild.data;\n        if (isSpecial) {\n          child.raw = true;\n        }\n      } else if (isComment(nativeChild) || isCData(nativeChild) || isPi(nativeChild)) {\n        child.value = nativeChild.data;\n      }\n      if (!isNonHtmlElementRootName(child.name)) {\n        transferChildren(child, nativeChild, specialElements, nsSanitizer);\n      }\n      parent.append(child);\n    }\n  };\n  const walkTree = (root, preprocessors, postprocessors) => {\n    const traverseOrder = [];\n    for (let node = root, lastNode = node; node; lastNode = node, node = node.walk()) {\n      const tempNode = node;\n      each$e(preprocessors, preprocess => preprocess(tempNode));\n      if (isNullable(tempNode.parent) && tempNode !== root) {\n        node = lastNode;\n      } else {\n        traverseOrder.push(tempNode);\n      }\n    }\n    for (let i = traverseOrder.length - 1; i >= 0; i--) {\n      const node = traverseOrder[i];\n      each$e(postprocessors, postprocess => postprocess(node));\n    }\n  };\n  const whitespaceCleaner = (root, schema, settings, args) => {\n    const validate = settings.validate;\n    const nonEmptyElements = schema.getNonEmptyElements();\n    const whitespaceElements = schema.getWhitespaceElements();\n    const blockElements = extend$1(makeMap('script,style,head,html,body,title,meta,param'), schema.getBlockElements());\n    const textRootBlockElements = getTextRootBlockElements(schema);\n    const allWhiteSpaceRegExp = /[ \\t\\r\\n]+/g;\n    const startWhiteSpaceRegExp = /^[ \\t\\r\\n]+/;\n    const endWhiteSpaceRegExp = /[ \\t\\r\\n]+$/;\n    const hasWhitespaceParent = node => {\n      let tempNode = node.parent;\n      while (isNonNullable(tempNode)) {\n        if (tempNode.name in whitespaceElements) {\n          return true;\n        } else {\n          tempNode = tempNode.parent;\n        }\n      }\n      return false;\n    };\n    const isTextRootBlockEmpty = node => {\n      let tempNode = node;\n      while (isNonNullable(tempNode)) {\n        if (tempNode.name in textRootBlockElements) {\n          return isEmpty(schema, nonEmptyElements, whitespaceElements, tempNode);\n        } else {\n          tempNode = tempNode.parent;\n        }\n      }\n      return false;\n    };\n    const isBlock = node => node.name in blockElements || isTransparentAstBlock(schema, node) || isNonHtmlElementRootName(node.name) && node.parent === root;\n    const isAtEdgeOfBlock = (node, start) => {\n      const neighbour = start ? node.prev : node.next;\n      if (isNonNullable(neighbour) || isNullable(node.parent)) {\n        return false;\n      }\n      return isBlock(node.parent) && (node.parent !== root || args.isRootContent === true);\n    };\n    const preprocess = node => {\n      var _a;\n      if (node.type === 3) {\n        if (!hasWhitespaceParent(node)) {\n          let text = (_a = node.value) !== null && _a !== void 0 ? _a : '';\n          text = text.replace(allWhiteSpaceRegExp, ' ');\n          if (isLineBreakNode(node.prev, isBlock) || isAtEdgeOfBlock(node, true)) {\n            text = text.replace(startWhiteSpaceRegExp, '');\n          }\n          if (text.length === 0) {\n            node.remove();\n          } else if (text === ' ' && node.prev && node.prev.type === COMMENT && node.next && node.next.type === COMMENT) {\n            node.remove();\n          } else {\n            node.value = text;\n          }\n        }\n      }\n    };\n    const postprocess = node => {\n      var _a;\n      if (node.type === 1) {\n        const elementRule = schema.getElementRule(node.name);\n        if (validate && elementRule) {\n          const isNodeEmpty = isEmpty(schema, nonEmptyElements, whitespaceElements, node);\n          if (elementRule.paddInEmptyBlock && isNodeEmpty && isTextRootBlockEmpty(node)) {\n            paddEmptyNode(settings, args, isBlock, node);\n          } else if (elementRule.removeEmpty && isNodeEmpty) {\n            if (isBlock(node)) {\n              node.remove();\n            } else {\n              node.unwrap();\n            }\n          } else if (elementRule.paddEmpty && (isNodeEmpty || isPaddedWithNbsp(node))) {\n            paddEmptyNode(settings, args, isBlock, node);\n          }\n        }\n      } else if (node.type === 3) {\n        if (!hasWhitespaceParent(node)) {\n          let text = (_a = node.value) !== null && _a !== void 0 ? _a : '';\n          if (node.next && isBlock(node.next) || isAtEdgeOfBlock(node, false)) {\n            text = text.replace(endWhiteSpaceRegExp, '');\n          }\n          if (text.length === 0) {\n            node.remove();\n          } else {\n            node.value = text;\n          }\n        }\n      }\n    };\n    return [preprocess, postprocess];\n  };\n  const getRootBlockName = (settings, args) => {\n    var _a;\n    const name = (_a = args.forced_root_block) !== null && _a !== void 0 ? _a : settings.forced_root_block;\n    if (name === false) {\n      return '';\n    } else if (name === true) {\n      return 'p';\n    } else {\n      return name;\n    }\n  };\n  const DomParser = (settings = {}, schema = Schema()) => {\n    const nodeFilterRegistry = create$8();\n    const attributeFilterRegistry = create$8();\n    const defaultedSettings = {\n      validate: true,\n      root_name: 'body',\n      sanitize: true,\n      ...settings\n    };\n    const parser = new DOMParser();\n    const sanitizer = getSanitizer(defaultedSettings, schema);\n    const parseAndSanitizeWithContext = (html, rootName, format = 'html') => {\n      const mimeType = format === 'xhtml' ? 'application/xhtml+xml' : 'text/html';\n      const isSpecialRoot = has$2(schema.getSpecialElements(), rootName.toLowerCase());\n      const content = isSpecialRoot ? `<${rootName}>${html}</${rootName}>` : html;\n      const makeWrap = () => {\n        if (format === 'xhtml') {\n          return `<html xmlns=\"http://www.w3.org/1999/xhtml\"><head></head><body>${content}</body></html>`;\n        } else if (/^[\\s]*<head/i.test(html) || /^[\\s]*<html/i.test(html) || /^[\\s]*<!DOCTYPE/i.test(html)) {\n          return `<html>${content}</html>`;\n        } else {\n          return `<body>${content}</body>`;\n        }\n      };\n      const body = parser.parseFromString(makeWrap(), mimeType).body;\n      sanitizer.sanitizeHtmlElement(body, mimeType);\n      return isSpecialRoot ? body.firstChild : body;\n    };\n    const addNodeFilter = nodeFilterRegistry.addFilter;\n    const getNodeFilters = nodeFilterRegistry.getFilters;\n    const removeNodeFilter = nodeFilterRegistry.removeFilter;\n    const addAttributeFilter = attributeFilterRegistry.addFilter;\n    const getAttributeFilters = attributeFilterRegistry.getFilters;\n    const removeAttributeFilter = attributeFilterRegistry.removeFilter;\n    const findInvalidChildren = (node, invalidChildren) => {\n      if (isInvalid(schema, node)) {\n        invalidChildren.push(node);\n      }\n    };\n    const isWrappableNode = (blockElements, node) => {\n      const isInternalElement = isString(node.attr(internalElementAttr));\n      const isInlineElement = node.type === 1 && !has$2(blockElements, node.name) && !isTransparentAstBlock(schema, node) && !isNonHtmlElementRootName(node.name);\n      return node.type === 3 || isInlineElement && !isInternalElement;\n    };\n    const addRootBlocks = (rootNode, rootBlockName) => {\n      const blockElements = extend$1(makeMap('script,style,head,html,body,title,meta,param'), schema.getBlockElements());\n      const startWhiteSpaceRegExp = /^[ \\t\\r\\n]+/;\n      const endWhiteSpaceRegExp = /[ \\t\\r\\n]+$/;\n      let node = rootNode.firstChild,\n        rootBlockNode = null;\n      const trim = rootBlock => {\n        var _a, _b;\n        if (rootBlock) {\n          node = rootBlock.firstChild;\n          if (node && node.type === 3) {\n            node.value = (_a = node.value) === null || _a === void 0 ? void 0 : _a.replace(startWhiteSpaceRegExp, '');\n          }\n          node = rootBlock.lastChild;\n          if (node && node.type === 3) {\n            node.value = (_b = node.value) === null || _b === void 0 ? void 0 : _b.replace(endWhiteSpaceRegExp, '');\n          }\n        }\n      };\n      if (!schema.isValidChild(rootNode.name, rootBlockName.toLowerCase())) {\n        return;\n      }\n      while (node) {\n        const next = node.next;\n        if (isWrappableNode(blockElements, node)) {\n          if (!rootBlockNode) {\n            rootBlockNode = new AstNode(rootBlockName, 1);\n            rootBlockNode.attr(defaultedSettings.forced_root_block_attrs);\n            rootNode.insert(rootBlockNode, node);\n            rootBlockNode.append(node);\n          } else {\n            rootBlockNode.append(node);\n          }\n        } else {\n          trim(rootBlockNode);\n          rootBlockNode = null;\n        }\n        node = next;\n      }\n      trim(rootBlockNode);\n    };\n    const parse = (html, args = {}) => {\n      var _a;\n      const validate = defaultedSettings.validate;\n      const rootName = (_a = args.context) !== null && _a !== void 0 ? _a : defaultedSettings.root_name;\n      const element = parseAndSanitizeWithContext(html, rootName, args.format);\n      updateChildren(schema, element);\n      const rootNode = new AstNode(rootName, 11);\n      transferChildren(rootNode, element, schema.getSpecialElements(), sanitizer.sanitizeNamespaceElement);\n      element.innerHTML = '';\n      const [whitespacePre, whitespacePost] = whitespaceCleaner(rootNode, schema, defaultedSettings, args);\n      const invalidChildren = [];\n      const invalidFinder = validate ? node => findInvalidChildren(node, invalidChildren) : noop;\n      const matches = {\n        nodes: {},\n        attributes: {}\n      };\n      const matchFinder = node => matchNode$1(getNodeFilters(), getAttributeFilters(), node, matches);\n      walkTree(rootNode, [whitespacePre, matchFinder], [whitespacePost, invalidFinder]);\n      invalidChildren.reverse();\n      if (validate && invalidChildren.length > 0) {\n        if (args.context) {\n          const {\n            pass: topLevelChildren,\n            fail: otherChildren\n          } = partition$2(invalidChildren, child => child.parent === rootNode);\n          cleanInvalidNodes(otherChildren, schema, rootNode, matchFinder);\n          args.invalid = topLevelChildren.length > 0;\n        } else {\n          cleanInvalidNodes(invalidChildren, schema, rootNode, matchFinder);\n        }\n      }\n      const rootBlockName = getRootBlockName(defaultedSettings, args);\n      if (rootBlockName && (rootNode.name === 'body' || args.isRootContent)) {\n        addRootBlocks(rootNode, rootBlockName);\n      }\n      if (!args.invalid) {\n        runFilters(matches, args);\n      }\n      return rootNode;\n    };\n    const exports = {\n      schema,\n      addAttributeFilter,\n      getAttributeFilters,\n      removeAttributeFilter,\n      addNodeFilter,\n      getNodeFilters,\n      removeNodeFilter,\n      parse\n    };\n    register$4(exports, defaultedSettings);\n    register$5(exports, defaultedSettings, schema);\n    return exports;\n  };\n  const serializeContent = content => isTreeNode(content) ? HtmlSerializer({\n    validate: false\n  }).serialize(content) : content;\n  const withSerializedContent = (content, fireEvent, parserSettings) => {\n    const serializedContent = serializeContent(content);\n    const eventArgs = fireEvent(serializedContent);\n    if (eventArgs.isDefaultPrevented()) {\n      return eventArgs;\n    } else if (isTreeNode(content)) {\n      if (eventArgs.content !== serializedContent) {\n        const rootNode = DomParser({\n          validate: false,\n          forced_root_block: false,\n          ...parserSettings\n        }).parse(eventArgs.content, {\n          context: content.name\n        });\n        return {\n          ...eventArgs,\n          content: rootNode\n        };\n      } else {\n        return {\n          ...eventArgs,\n          content\n        };\n      }\n    } else {\n      return eventArgs;\n    }\n  };\n  const makeParserSettings = editor => ({\n    sanitize: shouldSanitizeXss(editor),\n    sandbox_iframes: shouldSandboxIframes(editor),\n    sandbox_iframes_exclusions: getSandboxIframesExclusions(editor)\n  });\n  const preProcessGetContent = (editor, args) => {\n    if (args.no_events) {\n      return Result.value(args);\n    } else {\n      const eventArgs = fireBeforeGetContent(editor, args);\n      if (eventArgs.isDefaultPrevented()) {\n        return Result.error(fireGetContent(editor, {\n          content: '',\n          ...eventArgs\n        }).content);\n      } else {\n        return Result.value(eventArgs);\n      }\n    }\n  };\n  const postProcessGetContent = (editor, content, args) => {\n    if (args.no_events) {\n      return content;\n    } else {\n      const processedEventArgs = withSerializedContent(content, content => fireGetContent(editor, {\n        ...args,\n        content\n      }), makeParserSettings(editor));\n      return processedEventArgs.content;\n    }\n  };\n  const preProcessSetContent = (editor, args) => {\n    if (args.no_events) {\n      return Result.value(args);\n    } else {\n      const processedEventArgs = withSerializedContent(args.content, content => fireBeforeSetContent(editor, {\n        ...args,\n        content\n      }), makeParserSettings(editor));\n      if (processedEventArgs.isDefaultPrevented()) {\n        fireSetContent(editor, processedEventArgs);\n        return Result.error(undefined);\n      } else {\n        return Result.value(processedEventArgs);\n      }\n    }\n  };\n  const postProcessSetContent = (editor, content, args) => {\n    if (!args.no_events) {\n      fireSetContent(editor, {\n        ...args,\n        content\n      });\n    }\n  };\n  const tableModel = (element, width, rows) => ({\n    element,\n    width,\n    rows\n  });\n  const tableRow = (element, cells) => ({\n    element,\n    cells\n  });\n  const cellPosition = (x, y) => ({\n    x,\n    y\n  });\n  const getSpan = (td, key) => {\n    return getOpt(td, key).bind(toInt).getOr(1);\n  };\n  const fillout = (table, x, y, tr, td) => {\n    const rowspan = getSpan(td, 'rowspan');\n    const colspan = getSpan(td, 'colspan');\n    const rows = table.rows;\n    for (let y2 = y; y2 < y + rowspan; y2++) {\n      if (!rows[y2]) {\n        rows[y2] = tableRow(deep$1(tr), []);\n      }\n      for (let x2 = x; x2 < x + colspan; x2++) {\n        const cells = rows[y2].cells;\n        cells[x2] = y2 === y && x2 === x ? td : shallow$1(td);\n      }\n    }\n  };\n  const cellExists = (table, x, y) => {\n    const rows = table.rows;\n    const cells = rows[y] ? rows[y].cells : [];\n    return !!cells[x];\n  };\n  const skipCellsX = (table, x, y) => {\n    while (cellExists(table, x, y)) {\n      x++;\n    }\n    return x;\n  };\n  const getWidth = rows => {\n    return foldl(rows, (acc, row) => {\n      return row.cells.length > acc ? row.cells.length : acc;\n    }, 0);\n  };\n  const findElementPos = (table, element) => {\n    const rows = table.rows;\n    for (let y = 0; y < rows.length; y++) {\n      const cells = rows[y].cells;\n      for (let x = 0; x < cells.length; x++) {\n        if (eq(cells[x], element)) {\n          return Optional.some(cellPosition(x, y));\n        }\n      }\n    }\n    return Optional.none();\n  };\n  const extractRows = (table, sx, sy, ex, ey) => {\n    const newRows = [];\n    const rows = table.rows;\n    for (let y = sy; y <= ey; y++) {\n      const cells = rows[y].cells;\n      const slice = sx < ex ? cells.slice(sx, ex + 1) : cells.slice(ex, sx + 1);\n      newRows.push(tableRow(rows[y].element, slice));\n    }\n    return newRows;\n  };\n  const subTable = (table, startPos, endPos) => {\n    const sx = startPos.x,\n      sy = startPos.y;\n    const ex = endPos.x,\n      ey = endPos.y;\n    const newRows = sy < ey ? extractRows(table, sx, sy, ex, ey) : extractRows(table, sx, ey, ex, sy);\n    return tableModel(table.element, getWidth(newRows), newRows);\n  };\n  const createDomTable = (table, rows) => {\n    const tableElement = shallow$1(table.element);\n    const tableBody = SugarElement.fromTag('tbody');\n    append(tableBody, rows);\n    append$1(tableElement, tableBody);\n    return tableElement;\n  };\n  const modelRowsToDomRows = table => {\n    return map$3(table.rows, row => {\n      const cells = map$3(row.cells, cell => {\n        const td = deep$1(cell);\n        remove$9(td, 'colspan');\n        remove$9(td, 'rowspan');\n        return td;\n      });\n      const tr = shallow$1(row.element);\n      append(tr, cells);\n      return tr;\n    });\n  };\n  const fromDom = tableElm => {\n    const table = tableModel(shallow$1(tableElm), 0, []);\n    each$e(descendants(tableElm, 'tr'), (tr, y) => {\n      each$e(descendants(tr, 'td,th'), (td, x) => {\n        fillout(table, skipCellsX(table, x, y), y, tr, td);\n      });\n    });\n    return tableModel(table.element, getWidth(table.rows), table.rows);\n  };\n  const toDom = table => {\n    return createDomTable(table, modelRowsToDomRows(table));\n  };\n  const subsection = (table, startElement, endElement) => {\n    return findElementPos(table, startElement).bind(startPos => {\n      return findElementPos(table, endElement).map(endPos => {\n        return subTable(table, startPos, endPos);\n      });\n    });\n  };\n  const findParentListContainer = parents => find$2(parents, elm => name(elm) === 'ul' || name(elm) === 'ol');\n  const getFullySelectedListWrappers = (parents, rng) => find$2(parents, elm => name(elm) === 'li' && hasAllContentsSelected(elm, rng)).fold(constant([]), _li => findParentListContainer(parents).map(listCont => {\n    const listElm = SugarElement.fromTag(name(listCont));\n    const listStyles = filter$4(getAllRaw(listCont), (_style, name) => startsWith(name, 'list-style'));\n    setAll(listElm, listStyles);\n    return [SugarElement.fromTag('li'), listElm];\n  }).getOr([]));\n  const wrap = (innerElm, elms) => {\n    const wrapped = foldl(elms, (acc, elm) => {\n      append$1(elm, acc);\n      return elm;\n    }, innerElm);\n    return elms.length > 0 ? fromElements([wrapped]) : wrapped;\n  };\n  const directListWrappers = commonAnchorContainer => {\n    if (isListItem$1(commonAnchorContainer)) {\n      return parent(commonAnchorContainer).filter(isList).fold(constant([]), listElm => [commonAnchorContainer, listElm]);\n    } else {\n      return isList(commonAnchorContainer) ? [commonAnchorContainer] : [];\n    }\n  };\n  const getWrapElements = (rootNode, rng, schema) => {\n    const commonAnchorContainer = SugarElement.fromDom(rng.commonAncestorContainer);\n    const parents = parentsAndSelf(commonAnchorContainer, rootNode);\n    const wrapElements = filter$5(parents, el => schema.isWrapper(name(el)));\n    const listWrappers = getFullySelectedListWrappers(parents, rng);\n    const allWrappers = wrapElements.concat(listWrappers.length ? listWrappers : directListWrappers(commonAnchorContainer));\n    return map$3(allWrappers, shallow$1);\n  };\n  const emptyFragment = () => fromElements([]);\n  const getFragmentFromRange = (rootNode, rng, schema) => wrap(SugarElement.fromDom(rng.cloneContents()), getWrapElements(rootNode, rng, schema));\n  const getParentTable = (rootElm, cell) => ancestor$3(cell, 'table', curry(eq, rootElm));\n  const getTableFragment = (rootNode, selectedTableCells) => getParentTable(rootNode, selectedTableCells[0]).bind(tableElm => {\n    const firstCell = selectedTableCells[0];\n    const lastCell = selectedTableCells[selectedTableCells.length - 1];\n    const fullTableModel = fromDom(tableElm);\n    return subsection(fullTableModel, firstCell, lastCell).map(sectionedTableModel => fromElements([toDom(sectionedTableModel)]));\n  }).getOrThunk(emptyFragment);\n  const getSelectionFragment = (rootNode, ranges, schema) => ranges.length > 0 && ranges[0].collapsed ? emptyFragment() : getFragmentFromRange(rootNode, ranges[0], schema);\n  const read$3 = (rootNode, ranges, schema) => {\n    const selectedCells = getCellsFromElementOrRanges(ranges, rootNode);\n    return selectedCells.length > 0 ? getTableFragment(rootNode, selectedCells) : getSelectionFragment(rootNode, ranges, schema);\n  };\n  const isCollapsibleWhitespace = (text, index) => index >= 0 && index < text.length && isWhiteSpace(text.charAt(index));\n  const getInnerText = bin => {\n    return trim$2(bin.innerText);\n  };\n  const getContextNodeName = parentBlockOpt => parentBlockOpt.map(block => block.nodeName).getOr('div').toLowerCase();\n  const getTextContent = editor => Optional.from(editor.selection.getRng()).map(rng => {\n    var _a;\n    const parentBlockOpt = Optional.from(editor.dom.getParent(rng.commonAncestorContainer, editor.dom.isBlock));\n    const body = editor.getBody();\n    const contextNodeName = getContextNodeName(parentBlockOpt);\n    const rangeContentClone = SugarElement.fromDom(rng.cloneContents());\n    cleanupBogusElements(rangeContentClone);\n    cleanupInputNames(rangeContentClone);\n    const bin = editor.dom.add(body, contextNodeName, {\n      'data-mce-bogus': 'all',\n      'style': 'overflow: hidden; opacity: 0;'\n    }, rangeContentClone.dom);\n    const text = getInnerText(bin);\n    const nonRenderedText = trim$2((_a = bin.textContent) !== null && _a !== void 0 ? _a : '');\n    editor.dom.remove(bin);\n    if (isCollapsibleWhitespace(nonRenderedText, 0) || isCollapsibleWhitespace(nonRenderedText, nonRenderedText.length - 1)) {\n      const parentBlock = parentBlockOpt.getOr(body);\n      const parentBlockText = getInnerText(parentBlock);\n      const textIndex = parentBlockText.indexOf(text);\n      if (textIndex === -1) {\n        return text;\n      } else {\n        const hasProceedingSpace = isCollapsibleWhitespace(parentBlockText, textIndex - 1);\n        const hasTrailingSpace = isCollapsibleWhitespace(parentBlockText, textIndex + text.length);\n        return (hasProceedingSpace ? ' ' : '') + text + (hasTrailingSpace ? ' ' : '');\n      }\n    } else {\n      return text;\n    }\n  }).getOr('');\n  const getSerializedContent = (editor, args) => {\n    const rng = editor.selection.getRng(),\n      tmpElm = editor.dom.create('body');\n    const sel = editor.selection.getSel();\n    const ranges = processRanges(editor, getRanges$1(sel));\n    const fragment = args.contextual ? read$3(SugarElement.fromDom(editor.getBody()), ranges, editor.schema).dom : rng.cloneContents();\n    if (fragment) {\n      tmpElm.appendChild(fragment);\n    }\n    return editor.selection.serializer.serialize(tmpElm, args);\n  };\n  const extractSelectedContent = (editor, args) => {\n    if (args.format === 'text') {\n      return getTextContent(editor);\n    } else {\n      const content = getSerializedContent(editor, args);\n      if (args.format === 'tree') {\n        return content;\n      } else {\n        return editor.selection.isCollapsed() ? '' : content;\n      }\n    }\n  };\n  const setupArgs$3 = (args, format) => ({\n    ...args,\n    format,\n    get: true,\n    selection: true,\n    getInner: true\n  });\n  const getSelectedContentInternal = (editor, format, args = {}) => {\n    const defaultedArgs = setupArgs$3(args, format);\n    return preProcessGetContent(editor, defaultedArgs).fold(identity, updatedArgs => {\n      const content = extractSelectedContent(editor, updatedArgs);\n      return postProcessGetContent(editor, content, updatedArgs);\n    });\n  };\n  const KEEP = 0,\n    INSERT = 1,\n    DELETE = 2;\n  const diff = (left, right) => {\n    const size = left.length + right.length + 2;\n    const vDown = new Array(size);\n    const vUp = new Array(size);\n    const snake = (start, end, diag) => {\n      return {\n        start,\n        end,\n        diag\n      };\n    };\n    const buildScript = (start1, end1, start2, end2, script) => {\n      const middle = getMiddleSnake(start1, end1, start2, end2);\n      if (middle === null || middle.start === end1 && middle.diag === end1 - end2 || middle.end === start1 && middle.diag === start1 - start2) {\n        let i = start1;\n        let j = start2;\n        while (i < end1 || j < end2) {\n          if (i < end1 && j < end2 && left[i] === right[j]) {\n            script.push([KEEP, left[i]]);\n            ++i;\n            ++j;\n          } else {\n            if (end1 - start1 > end2 - start2) {\n              script.push([DELETE, left[i]]);\n              ++i;\n            } else {\n              script.push([INSERT, right[j]]);\n              ++j;\n            }\n          }\n        }\n      } else {\n        buildScript(start1, middle.start, start2, middle.start - middle.diag, script);\n        for (let i2 = middle.start; i2 < middle.end; ++i2) {\n          script.push([KEEP, left[i2]]);\n        }\n        buildScript(middle.end, end1, middle.end - middle.diag, end2, script);\n      }\n    };\n    const buildSnake = (start, diag, end1, end2) => {\n      let end = start;\n      while (end - diag < end2 && end < end1 && left[end] === right[end - diag]) {\n        ++end;\n      }\n      return snake(start, end, diag);\n    };\n    const getMiddleSnake = (start1, end1, start2, end2) => {\n      const m = end1 - start1;\n      const n = end2 - start2;\n      if (m === 0 || n === 0) {\n        return null;\n      }\n      const delta = m - n;\n      const sum = n + m;\n      const offset = (sum % 2 === 0 ? sum : sum + 1) / 2;\n      vDown[1 + offset] = start1;\n      vUp[1 + offset] = end1 + 1;\n      let d, k, i, x, y;\n      for (d = 0; d <= offset; ++d) {\n        for (k = -d; k <= d; k += 2) {\n          i = k + offset;\n          if (k === -d || k !== d && vDown[i - 1] < vDown[i + 1]) {\n            vDown[i] = vDown[i + 1];\n          } else {\n            vDown[i] = vDown[i - 1] + 1;\n          }\n          x = vDown[i];\n          y = x - start1 + start2 - k;\n          while (x < end1 && y < end2 && left[x] === right[y]) {\n            vDown[i] = ++x;\n            ++y;\n          }\n          if (delta % 2 !== 0 && delta - d <= k && k <= delta + d) {\n            if (vUp[i - delta] <= vDown[i]) {\n              return buildSnake(vUp[i - delta], k + start1 - start2, end1, end2);\n            }\n          }\n        }\n        for (k = delta - d; k <= delta + d; k += 2) {\n          i = k + offset - delta;\n          if (k === delta - d || k !== delta + d && vUp[i + 1] <= vUp[i - 1]) {\n            vUp[i] = vUp[i + 1] - 1;\n          } else {\n            vUp[i] = vUp[i - 1];\n          }\n          x = vUp[i] - 1;\n          y = x - start1 + start2 - k;\n          while (x >= start1 && y >= start2 && left[x] === right[y]) {\n            vUp[i] = x--;\n            y--;\n          }\n          if (delta % 2 === 0 && -d <= k && k <= d) {\n            if (vUp[i] <= vDown[i + delta]) {\n              return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n            }\n          }\n        }\n      }\n      return null;\n    };\n    const script = [];\n    buildScript(0, left.length, 0, right.length, script);\n    return script;\n  };\n  const getOuterHtml = elm => {\n    if (isElement$6(elm)) {\n      return elm.outerHTML;\n    } else if (isText$b(elm)) {\n      return Entities.encodeRaw(elm.data, false);\n    } else if (isComment(elm)) {\n      return '<!--' + elm.data + '-->';\n    }\n    return '';\n  };\n  const createFragment = html => {\n    let node;\n    const container = document.createElement('div');\n    const frag = document.createDocumentFragment();\n    if (html) {\n      container.innerHTML = html;\n    }\n    while (node = container.firstChild) {\n      frag.appendChild(node);\n    }\n    return frag;\n  };\n  const insertAt = (elm, html, index) => {\n    const fragment = createFragment(html);\n    if (elm.hasChildNodes() && index < elm.childNodes.length) {\n      const target = elm.childNodes[index];\n      elm.insertBefore(fragment, target);\n    } else {\n      elm.appendChild(fragment);\n    }\n  };\n  const removeAt = (elm, index) => {\n    if (elm.hasChildNodes() && index < elm.childNodes.length) {\n      const target = elm.childNodes[index];\n      elm.removeChild(target);\n    }\n  };\n  const applyDiff = (diff, elm) => {\n    let index = 0;\n    each$e(diff, action => {\n      if (action[0] === KEEP) {\n        index++;\n      } else if (action[0] === INSERT) {\n        insertAt(elm, action[1], index);\n        index++;\n      } else if (action[0] === DELETE) {\n        removeAt(elm, index);\n      }\n    });\n  };\n  const read$2 = (elm, trimZwsp) => filter$5(map$3(from(elm.childNodes), trimZwsp ? compose(trim$2, getOuterHtml) : getOuterHtml), item => {\n    return item.length > 0;\n  });\n  const write = (fragments, elm) => {\n    const currentFragments = map$3(from(elm.childNodes), getOuterHtml);\n    applyDiff(diff(currentFragments, fragments), elm);\n    return elm;\n  };\n  const lazyTempDocument = cached(() => document.implementation.createHTMLDocument('undo'));\n  const hasIframes = body => body.querySelector('iframe') !== null;\n  const createFragmentedLevel = fragments => {\n    return {\n      type: 'fragmented',\n      fragments,\n      content: '',\n      bookmark: null,\n      beforeBookmark: null\n    };\n  };\n  const createCompleteLevel = content => {\n    return {\n      type: 'complete',\n      fragments: null,\n      content,\n      bookmark: null,\n      beforeBookmark: null\n    };\n  };\n  const createFromEditor = editor => {\n    const tempAttrs = editor.serializer.getTempAttrs();\n    const body = trim$1(editor.getBody(), tempAttrs);\n    return hasIframes(body) ? createFragmentedLevel(read$2(body, true)) : createCompleteLevel(trim$2(body.innerHTML));\n  };\n  const applyToEditor = (editor, level, before) => {\n    const bookmark = before ? level.beforeBookmark : level.bookmark;\n    if (level.type === 'fragmented') {\n      write(level.fragments, editor.getBody());\n    } else {\n      editor.setContent(level.content, {\n        format: 'raw',\n        no_selection: isNonNullable(bookmark) && isPathBookmark(bookmark) ? !bookmark.isFakeCaret : true\n      });\n    }\n    if (bookmark) {\n      editor.selection.moveToBookmark(bookmark);\n      editor.selection.scrollIntoView();\n    }\n  };\n  const getLevelContent = level => {\n    return level.type === 'fragmented' ? level.fragments.join('') : level.content;\n  };\n  const getCleanLevelContent = level => {\n    const elm = SugarElement.fromTag('body', lazyTempDocument());\n    set$1(elm, getLevelContent(level));\n    each$e(descendants(elm, '*[data-mce-bogus]'), unwrap);\n    return get$6(elm);\n  };\n  const hasEqualContent = (level1, level2) => getLevelContent(level1) === getLevelContent(level2);\n  const hasEqualCleanedContent = (level1, level2) => getCleanLevelContent(level1) === getCleanLevelContent(level2);\n  const isEq$1 = (level1, level2) => {\n    if (!level1 || !level2) {\n      return false;\n    } else if (hasEqualContent(level1, level2)) {\n      return true;\n    } else {\n      return hasEqualCleanedContent(level1, level2);\n    }\n  };\n  const isUnlocked = locks => locks.get() === 0;\n  const setTyping = (undoManager, typing, locks) => {\n    if (isUnlocked(locks)) {\n      undoManager.typing = typing;\n    }\n  };\n  const endTyping = (undoManager, locks) => {\n    if (undoManager.typing) {\n      setTyping(undoManager, false, locks);\n      undoManager.add();\n    }\n  };\n  const endTypingLevelIgnoreLocks = undoManager => {\n    if (undoManager.typing) {\n      undoManager.typing = false;\n      undoManager.add();\n    }\n  };\n  const beforeChange$1 = (editor, locks, beforeBookmark) => {\n    if (isUnlocked(locks)) {\n      beforeBookmark.set(getUndoBookmark(editor.selection));\n    }\n  };\n  const addUndoLevel$1 = (editor, undoManager, index, locks, beforeBookmark, level, event) => {\n    const currentLevel = createFromEditor(editor);\n    const newLevel = Tools.extend(level || {}, currentLevel);\n    if (!isUnlocked(locks) || editor.removed) {\n      return null;\n    }\n    const lastLevel = undoManager.data[index.get()];\n    if (editor.dispatch('BeforeAddUndo', {\n      level: newLevel,\n      lastLevel,\n      originalEvent: event\n    }).isDefaultPrevented()) {\n      return null;\n    }\n    if (lastLevel && isEq$1(lastLevel, newLevel)) {\n      return null;\n    }\n    if (undoManager.data[index.get()]) {\n      beforeBookmark.get().each(bm => {\n        undoManager.data[index.get()].beforeBookmark = bm;\n      });\n    }\n    const customUndoRedoLevels = getCustomUndoRedoLevels(editor);\n    if (customUndoRedoLevels) {\n      if (undoManager.data.length > customUndoRedoLevels) {\n        for (let i = 0; i < undoManager.data.length - 1; i++) {\n          undoManager.data[i] = undoManager.data[i + 1];\n        }\n        undoManager.data.length--;\n        index.set(undoManager.data.length);\n      }\n    }\n    newLevel.bookmark = getUndoBookmark(editor.selection);\n    if (index.get() < undoManager.data.length - 1) {\n      undoManager.data.length = index.get() + 1;\n    }\n    undoManager.data.push(newLevel);\n    index.set(undoManager.data.length - 1);\n    const args = {\n      level: newLevel,\n      lastLevel,\n      originalEvent: event\n    };\n    if (index.get() > 0) {\n      editor.setDirty(true);\n      editor.dispatch('AddUndo', args);\n      editor.dispatch('change', args);\n    } else {\n      editor.dispatch('AddUndo', args);\n    }\n    return newLevel;\n  };\n  const clear$1 = (editor, undoManager, index) => {\n    undoManager.data = [];\n    index.set(0);\n    undoManager.typing = false;\n    editor.dispatch('ClearUndos');\n  };\n  const extra$1 = (editor, undoManager, index, callback1, callback2) => {\n    if (undoManager.transact(callback1)) {\n      const bookmark = undoManager.data[index.get()].bookmark;\n      const lastLevel = undoManager.data[index.get() - 1];\n      applyToEditor(editor, lastLevel, true);\n      if (undoManager.transact(callback2)) {\n        undoManager.data[index.get() - 1].beforeBookmark = bookmark;\n      }\n    }\n  };\n  const redo$1 = (editor, index, data) => {\n    let level;\n    if (index.get() < data.length - 1) {\n      index.set(index.get() + 1);\n      level = data[index.get()];\n      applyToEditor(editor, level, false);\n      editor.setDirty(true);\n      editor.dispatch('Redo', {\n        level\n      });\n    }\n    return level;\n  };\n  const undo$1 = (editor, undoManager, locks, index) => {\n    let level;\n    if (undoManager.typing) {\n      undoManager.add();\n      undoManager.typing = false;\n      setTyping(undoManager, false, locks);\n    }\n    if (index.get() > 0) {\n      index.set(index.get() - 1);\n      level = undoManager.data[index.get()];\n      applyToEditor(editor, level, true);\n      editor.setDirty(true);\n      editor.dispatch('Undo', {\n        level\n      });\n    }\n    return level;\n  };\n  const reset$1 = undoManager => {\n    undoManager.clear();\n    undoManager.add();\n  };\n  const hasUndo$1 = (editor, undoManager, index) => index.get() > 0 || undoManager.typing && undoManager.data[0] && !isEq$1(createFromEditor(editor), undoManager.data[0]);\n  const hasRedo$1 = (undoManager, index) => index.get() < undoManager.data.length - 1 && !undoManager.typing;\n  const transact$1 = (undoManager, locks, callback) => {\n    endTyping(undoManager, locks);\n    undoManager.beforeChange();\n    undoManager.ignore(callback);\n    return undoManager.add();\n  };\n  const ignore$1 = (locks, callback) => {\n    try {\n      locks.set(locks.get() + 1);\n      callback();\n    } finally {\n      locks.set(locks.get() - 1);\n    }\n  };\n  const addVisualInternal = (editor, elm) => {\n    const dom = editor.dom;\n    const scope = isNonNullable(elm) ? elm : editor.getBody();\n    each$e(dom.select('table,a', scope), matchedElm => {\n      switch (matchedElm.nodeName) {\n        case 'TABLE':\n          const cls = getVisualAidsTableClass(editor);\n          const value = dom.getAttrib(matchedElm, 'border');\n          if ((!value || value === '0') && editor.hasVisual) {\n            dom.addClass(matchedElm, cls);\n          } else {\n            dom.removeClass(matchedElm, cls);\n          }\n          break;\n        case 'A':\n          if (!dom.getAttrib(matchedElm, 'href')) {\n            const value = dom.getAttrib(matchedElm, 'name') || matchedElm.id;\n            const cls = getVisualAidsAnchorClass(editor);\n            if (value && editor.hasVisual) {\n              dom.addClass(matchedElm, cls);\n            } else {\n              dom.removeClass(matchedElm, cls);\n            }\n          }\n          break;\n      }\n    });\n    editor.dispatch('VisualAid', {\n      element: elm,\n      hasVisual: editor.hasVisual\n    });\n  };\n  const makePlainAdaptor = editor => ({\n    init: {\n      bindEvents: noop\n    },\n    undoManager: {\n      beforeChange: (locks, beforeBookmark) => beforeChange$1(editor, locks, beforeBookmark),\n      add: (undoManager, index, locks, beforeBookmark, level, event) => addUndoLevel$1(editor, undoManager, index, locks, beforeBookmark, level, event),\n      undo: (undoManager, locks, index) => undo$1(editor, undoManager, locks, index),\n      redo: (index, data) => redo$1(editor, index, data),\n      clear: (undoManager, index) => clear$1(editor, undoManager, index),\n      reset: undoManager => reset$1(undoManager),\n      hasUndo: (undoManager, index) => hasUndo$1(editor, undoManager, index),\n      hasRedo: (undoManager, index) => hasRedo$1(undoManager, index),\n      transact: (undoManager, locks, callback) => transact$1(undoManager, locks, callback),\n      ignore: (locks, callback) => ignore$1(locks, callback),\n      extra: (undoManager, index, callback1, callback2) => extra$1(editor, undoManager, index, callback1, callback2)\n    },\n    formatter: {\n      match: (name, vars, node, similar) => match$2(editor, name, vars, node, similar),\n      matchAll: (names, vars) => matchAll(editor, names, vars),\n      matchNode: (node, name, vars, similar) => matchNode(editor, node, name, vars, similar),\n      canApply: name => canApply(editor, name),\n      closest: names => closest(editor, names),\n      apply: (name, vars, node) => applyFormat$1(editor, name, vars, node),\n      remove: (name, vars, node, similar) => removeFormat$1(editor, name, vars, node, similar),\n      toggle: (name, vars, node) => toggle(editor, name, vars, node),\n      formatChanged: (registeredFormatListeners, formats, callback, similar, vars) => formatChangedInternal(editor, registeredFormatListeners, formats, callback, similar, vars)\n    },\n    editor: {\n      getContent: args => getContentInternal(editor, args),\n      setContent: (content, args) => setContentInternal(editor, content, args),\n      insertContent: (value, details) => insertHtmlAtCaret(editor, value, details),\n      addVisual: elm => addVisualInternal(editor, elm)\n    },\n    selection: {\n      getContent: (format, args) => getSelectedContentInternal(editor, format, args)\n    },\n    autocompleter: {\n      addDecoration: noop,\n      removeDecoration: noop\n    },\n    raw: {\n      getModel: () => Optional.none()\n    }\n  });\n  const makeRtcAdaptor = rtcEditor => {\n    const defaultVars = vars => isObject(vars) ? vars : {};\n    const {\n      init,\n      undoManager,\n      formatter,\n      editor,\n      selection,\n      autocompleter,\n      raw\n    } = rtcEditor;\n    return {\n      init: {\n        bindEvents: init.bindEvents\n      },\n      undoManager: {\n        beforeChange: undoManager.beforeChange,\n        add: undoManager.add,\n        undo: undoManager.undo,\n        redo: undoManager.redo,\n        clear: undoManager.clear,\n        reset: undoManager.reset,\n        hasUndo: undoManager.hasUndo,\n        hasRedo: undoManager.hasRedo,\n        transact: (_undoManager, _locks, fn) => undoManager.transact(fn),\n        ignore: (_locks, callback) => undoManager.ignore(callback),\n        extra: (_undoManager, _index, callback1, callback2) => undoManager.extra(callback1, callback2)\n      },\n      formatter: {\n        match: (name, vars, _node, similar) => formatter.match(name, defaultVars(vars), similar),\n        matchAll: formatter.matchAll,\n        matchNode: formatter.matchNode,\n        canApply: name => formatter.canApply(name),\n        closest: names => formatter.closest(names),\n        apply: (name, vars, _node) => formatter.apply(name, defaultVars(vars)),\n        remove: (name, vars, _node, _similar) => formatter.remove(name, defaultVars(vars)),\n        toggle: (name, vars, _node) => formatter.toggle(name, defaultVars(vars)),\n        formatChanged: (_rfl, formats, callback, similar, vars) => formatter.formatChanged(formats, callback, similar, vars)\n      },\n      editor: {\n        getContent: args => editor.getContent(args),\n        setContent: (content, args) => {\n          return {\n            content: editor.setContent(content, args),\n            html: ''\n          };\n        },\n        insertContent: (content, _details) => {\n          editor.insertContent(content);\n          return '';\n        },\n        addVisual: editor.addVisual\n      },\n      selection: {\n        getContent: (_format, args) => selection.getContent(args)\n      },\n      autocompleter: {\n        addDecoration: autocompleter.addDecoration,\n        removeDecoration: autocompleter.removeDecoration\n      },\n      raw: {\n        getModel: () => Optional.some(raw.getRawModel())\n      }\n    };\n  };\n  const makeNoopAdaptor = () => {\n    const nul = constant(null);\n    const empty = constant('');\n    return {\n      init: {\n        bindEvents: noop\n      },\n      undoManager: {\n        beforeChange: noop,\n        add: nul,\n        undo: nul,\n        redo: nul,\n        clear: noop,\n        reset: noop,\n        hasUndo: never,\n        hasRedo: never,\n        transact: nul,\n        ignore: noop,\n        extra: noop\n      },\n      formatter: {\n        match: never,\n        matchAll: constant([]),\n        matchNode: constant(undefined),\n        canApply: never,\n        closest: empty,\n        apply: noop,\n        remove: noop,\n        toggle: noop,\n        formatChanged: constant({\n          unbind: noop\n        })\n      },\n      editor: {\n        getContent: empty,\n        setContent: constant({\n          content: '',\n          html: ''\n        }),\n        insertContent: constant(''),\n        addVisual: noop\n      },\n      selection: {\n        getContent: empty\n      },\n      autocompleter: {\n        addDecoration: noop,\n        removeDecoration: noop\n      },\n      raw: {\n        getModel: constant(Optional.none())\n      }\n    };\n  };\n  const isRtc = editor => has$2(editor.plugins, 'rtc');\n  const getRtcSetup = editor => get$a(editor.plugins, 'rtc').bind(rtcPlugin => Optional.from(rtcPlugin.setup));\n  const setup$t = editor => {\n    const editorCast = editor;\n    return getRtcSetup(editor).fold(() => {\n      editorCast.rtcInstance = makePlainAdaptor(editor);\n      return Optional.none();\n    }, setup => {\n      editorCast.rtcInstance = makeNoopAdaptor();\n      return Optional.some(() => setup().then(rtcEditor => {\n        editorCast.rtcInstance = makeRtcAdaptor(rtcEditor);\n        return rtcEditor.rtc.isRemote;\n      }));\n    });\n  };\n  const getRtcInstanceWithFallback = editor => editor.rtcInstance ? editor.rtcInstance : makePlainAdaptor(editor);\n  const getRtcInstanceWithError = editor => {\n    const rtcInstance = editor.rtcInstance;\n    if (!rtcInstance) {\n      throw new Error('Failed to get RTC instance not yet initialized.');\n    } else {\n      return rtcInstance;\n    }\n  };\n  const beforeChange = (editor, locks, beforeBookmark) => {\n    getRtcInstanceWithError(editor).undoManager.beforeChange(locks, beforeBookmark);\n  };\n  const addUndoLevel = (editor, undoManager, index, locks, beforeBookmark, level, event) => getRtcInstanceWithError(editor).undoManager.add(undoManager, index, locks, beforeBookmark, level, event);\n  const undo = (editor, undoManager, locks, index) => getRtcInstanceWithError(editor).undoManager.undo(undoManager, locks, index);\n  const redo = (editor, index, data) => getRtcInstanceWithError(editor).undoManager.redo(index, data);\n  const clear = (editor, undoManager, index) => {\n    getRtcInstanceWithError(editor).undoManager.clear(undoManager, index);\n  };\n  const reset = (editor, undoManager) => {\n    getRtcInstanceWithError(editor).undoManager.reset(undoManager);\n  };\n  const hasUndo = (editor, undoManager, index) => getRtcInstanceWithError(editor).undoManager.hasUndo(undoManager, index);\n  const hasRedo = (editor, undoManager, index) => getRtcInstanceWithError(editor).undoManager.hasRedo(undoManager, index);\n  const transact = (editor, undoManager, locks, callback) => getRtcInstanceWithError(editor).undoManager.transact(undoManager, locks, callback);\n  const ignore = (editor, locks, callback) => {\n    getRtcInstanceWithError(editor).undoManager.ignore(locks, callback);\n  };\n  const extra = (editor, undoManager, index, callback1, callback2) => {\n    getRtcInstanceWithError(editor).undoManager.extra(undoManager, index, callback1, callback2);\n  };\n  const matchFormat = (editor, name, vars, node, similar) => getRtcInstanceWithError(editor).formatter.match(name, vars, node, similar);\n  const matchAllFormats = (editor, names, vars) => getRtcInstanceWithError(editor).formatter.matchAll(names, vars);\n  const matchNodeFormat = (editor, node, name, vars, similar) => getRtcInstanceWithError(editor).formatter.matchNode(node, name, vars, similar);\n  const canApplyFormat = (editor, name) => getRtcInstanceWithError(editor).formatter.canApply(name);\n  const closestFormat = (editor, names) => getRtcInstanceWithError(editor).formatter.closest(names);\n  const applyFormat = (editor, name, vars, node) => {\n    getRtcInstanceWithError(editor).formatter.apply(name, vars, node);\n  };\n  const removeFormat = (editor, name, vars, node, similar) => {\n    getRtcInstanceWithError(editor).formatter.remove(name, vars, node, similar);\n  };\n  const toggleFormat = (editor, name, vars, node) => {\n    getRtcInstanceWithError(editor).formatter.toggle(name, vars, node);\n  };\n  const formatChanged = (editor, registeredFormatListeners, formats, callback, similar, vars) => getRtcInstanceWithError(editor).formatter.formatChanged(registeredFormatListeners, formats, callback, similar, vars);\n  const getContent$2 = (editor, args) => getRtcInstanceWithFallback(editor).editor.getContent(args);\n  const setContent$2 = (editor, content, args) => getRtcInstanceWithFallback(editor).editor.setContent(content, args);\n  const insertContent$1 = (editor, value, details) => getRtcInstanceWithFallback(editor).editor.insertContent(value, details);\n  const getSelectedContent = (editor, format, args) => getRtcInstanceWithError(editor).selection.getContent(format, args);\n  const addVisual$1 = (editor, elm) => getRtcInstanceWithError(editor).editor.addVisual(elm);\n  const bindEvents = editor => getRtcInstanceWithError(editor).init.bindEvents();\n  const getContent$1 = (editor, args = {}) => {\n    const format = args.format ? args.format : 'html';\n    return getSelectedContent(editor, format, args);\n  };\n  const removeEmpty = text => {\n    if (text.dom.length === 0) {\n      remove$4(text);\n      return Optional.none();\n    } else {\n      return Optional.some(text);\n    }\n  };\n  const walkPastBookmark = (node, start) => node.filter(elm => BookmarkManager.isBookmarkNode(elm.dom)).bind(start ? nextSibling : prevSibling);\n  const merge$1 = (outer, inner, rng, start, schema) => {\n    const outerElm = outer.dom;\n    const innerElm = inner.dom;\n    const oldLength = start ? outerElm.length : innerElm.length;\n    if (start) {\n      mergeTextNodes(outerElm, innerElm, schema, false, !start);\n      rng.setStart(innerElm, oldLength);\n    } else {\n      mergeTextNodes(innerElm, outerElm, schema, false, !start);\n      rng.setEnd(innerElm, oldLength);\n    }\n  };\n  const normalizeTextIfRequired = (inner, start, schema) => {\n    parent(inner).each(root => {\n      const text = inner.dom;\n      if (start && needsToBeNbspLeft(root, CaretPosition(text, 0), schema)) {\n        normalizeWhitespaceAfter(text, 0, schema);\n      } else if (!start && needsToBeNbspRight(root, CaretPosition(text, text.length), schema)) {\n        normalizeWhitespaceBefore(text, text.length, schema);\n      }\n    });\n  };\n  const mergeAndNormalizeText = (outerNode, innerNode, rng, start, schema) => {\n    outerNode.bind(outer => {\n      const normalizer = start ? normalizeWhitespaceBefore : normalizeWhitespaceAfter;\n      normalizer(outer.dom, start ? outer.dom.length : 0, schema);\n      return innerNode.filter(isText$c).map(inner => merge$1(outer, inner, rng, start, schema));\n    }).orThunk(() => {\n      const innerTextNode = walkPastBookmark(innerNode, start).or(innerNode).filter(isText$c);\n      return innerTextNode.map(inner => normalizeTextIfRequired(inner, start, schema));\n    });\n  };\n  const rngSetContent = (rng, fragment, schema) => {\n    const firstChild = Optional.from(fragment.firstChild).map(SugarElement.fromDom);\n    const lastChild = Optional.from(fragment.lastChild).map(SugarElement.fromDom);\n    rng.deleteContents();\n    rng.insertNode(fragment);\n    const prevText = firstChild.bind(prevSibling).filter(isText$c).bind(removeEmpty);\n    const nextText = lastChild.bind(nextSibling).filter(isText$c).bind(removeEmpty);\n    mergeAndNormalizeText(prevText, firstChild, rng, true, schema);\n    mergeAndNormalizeText(nextText, lastChild, rng, false, schema);\n    rng.collapse(false);\n  };\n  const setupArgs$2 = (args, content) => ({\n    format: 'html',\n    ...args,\n    set: true,\n    selection: true,\n    content\n  });\n  const cleanContent = (editor, args) => {\n    if (args.format !== 'raw') {\n      const rng = editor.selection.getRng();\n      const contextBlock = editor.dom.getParent(rng.commonAncestorContainer, editor.dom.isBlock);\n      const contextArgs = contextBlock ? {\n        context: contextBlock.nodeName.toLowerCase()\n      } : {};\n      const node = editor.parser.parse(args.content, {\n        forced_root_block: false,\n        ...contextArgs,\n        ...args\n      });\n      return HtmlSerializer({\n        validate: false\n      }, editor.schema).serialize(node);\n    } else {\n      return args.content;\n    }\n  };\n  const setContent$1 = (editor, content, args = {}) => {\n    const defaultedArgs = setupArgs$2(args, content);\n    preProcessSetContent(editor, defaultedArgs).each(updatedArgs => {\n      const cleanedContent = cleanContent(editor, updatedArgs);\n      const rng = editor.selection.getRng();\n      rngSetContent(rng, rng.createContextualFragment(cleanedContent), editor.schema);\n      editor.selection.setRng(rng);\n      scrollRangeIntoView(editor, rng);\n      postProcessSetContent(editor, cleanedContent, updatedArgs);\n    });\n  };\n  const deleteFromCallbackMap = (callbackMap, selector, callback) => {\n    if (has$2(callbackMap, selector)) {\n      const newCallbacks = filter$5(callbackMap[selector], cb => cb !== callback);\n      if (newCallbacks.length === 0) {\n        delete callbackMap[selector];\n      } else {\n        callbackMap[selector] = newCallbacks;\n      }\n    }\n  };\n  var SelectorChanged = (dom, editor) => {\n    let selectorChangedData;\n    let currentSelectors;\n    const findMatchingNode = (selector, nodes) => find$2(nodes, node => dom.is(node, selector));\n    const getParents = elem => dom.getParents(elem, undefined, dom.getRoot());\n    const setup = () => {\n      selectorChangedData = {};\n      currentSelectors = {};\n      editor.on('NodeChange', e => {\n        const node = e.element;\n        const parents = getParents(node);\n        const matchedSelectors = {};\n        each$d(selectorChangedData, (callbacks, selector) => {\n          findMatchingNode(selector, parents).each(node => {\n            if (!currentSelectors[selector]) {\n              each$e(callbacks, callback => {\n                callback(true, {\n                  node,\n                  selector,\n                  parents\n                });\n              });\n              currentSelectors[selector] = callbacks;\n            }\n            matchedSelectors[selector] = callbacks;\n          });\n        });\n        each$d(currentSelectors, (callbacks, selector) => {\n          if (!matchedSelectors[selector]) {\n            delete currentSelectors[selector];\n            each$e(callbacks, callback => {\n              callback(false, {\n                node,\n                selector,\n                parents\n              });\n            });\n          }\n        });\n      });\n    };\n    return {\n      selectorChangedWithUnbind: (selector, callback) => {\n        if (!selectorChangedData) {\n          setup();\n        }\n        if (!selectorChangedData[selector]) {\n          selectorChangedData[selector] = [];\n        }\n        selectorChangedData[selector].push(callback);\n        findMatchingNode(selector, getParents(editor.selection.getStart())).each(() => {\n          currentSelectors[selector] = selectorChangedData[selector];\n        });\n        return {\n          unbind: () => {\n            deleteFromCallbackMap(selectorChangedData, selector, callback);\n            deleteFromCallbackMap(currentSelectors, selector, callback);\n          }\n        };\n      }\n    };\n  };\n  const isAttachedToDom = node => {\n    return !!(node && node.ownerDocument) && contains(SugarElement.fromDom(node.ownerDocument), SugarElement.fromDom(node));\n  };\n  const isValidRange = rng => {\n    if (!rng) {\n      return false;\n    } else {\n      return isAttachedToDom(rng.startContainer) && isAttachedToDom(rng.endContainer);\n    }\n  };\n  const EditorSelection = (dom, win, serializer, editor) => {\n    let selectedRange;\n    let explicitRange;\n    const {\n      selectorChangedWithUnbind\n    } = SelectorChanged(dom, editor);\n    const setCursorLocation = (node, offset) => {\n      const rng = dom.createRng();\n      if (isNonNullable(node) && isNonNullable(offset)) {\n        rng.setStart(node, offset);\n        rng.setEnd(node, offset);\n        setRng(rng);\n        collapse(false);\n      } else {\n        moveEndPoint(dom, rng, editor.getBody(), true);\n        setRng(rng);\n      }\n    };\n    const getContent = args => getContent$1(editor, args);\n    const setContent = (content, args) => setContent$1(editor, content, args);\n    const getStart$1 = real => getStart(editor.getBody(), getRng$1(), real);\n    const getEnd$1 = real => getEnd(editor.getBody(), getRng$1(), real);\n    const getBookmark = (type, normalized) => bookmarkManager.getBookmark(type, normalized);\n    const moveToBookmark = bookmark => bookmarkManager.moveToBookmark(bookmark);\n    const select$1 = (node, content) => {\n      select(dom, node, content).each(setRng);\n      return node;\n    };\n    const isCollapsed = () => {\n      const rng = getRng$1(),\n        sel = getSel();\n      if (!rng || rng.item) {\n        return false;\n      }\n      if (rng.compareEndPoints) {\n        return rng.compareEndPoints('StartToEnd', rng) === 0;\n      }\n      return !sel || rng.collapsed;\n    };\n    const isEditable = () => {\n      if (editor.mode.isReadOnly()) {\n        return false;\n      }\n      const rng = getRng$1();\n      const fakeSelectedElements = editor.getBody().querySelectorAll('[data-mce-selected=\"1\"]');\n      if (fakeSelectedElements.length > 0) {\n        return forall(fakeSelectedElements, el => dom.isEditable(el.parentElement));\n      } else {\n        return isEditableRange(dom, rng);\n      }\n    };\n    const collapse = toStart => {\n      const rng = getRng$1();\n      rng.collapse(!!toStart);\n      setRng(rng);\n    };\n    const getSel = () => win.getSelection ? win.getSelection() : win.document.selection;\n    const getRng$1 = () => {\n      let rng;\n      const tryCompareBoundaryPoints = (how, sourceRange, destinationRange) => {\n        try {\n          return sourceRange.compareBoundaryPoints(how, destinationRange);\n        } catch (ex) {\n          return -1;\n        }\n      };\n      const doc = win.document;\n      if (isNonNullable(editor.bookmark) && !hasFocus(editor)) {\n        const bookmark = getRng(editor);\n        if (bookmark.isSome()) {\n          return bookmark.map(r => processRanges(editor, [r])[0]).getOr(doc.createRange());\n        }\n      }\n      try {\n        const selection = getSel();\n        if (selection && !isRestrictedNode(selection.anchorNode)) {\n          if (selection.rangeCount > 0) {\n            rng = selection.getRangeAt(0);\n          } else {\n            rng = doc.createRange();\n          }\n          rng = processRanges(editor, [rng])[0];\n        }\n      } catch (ex) {}\n      if (!rng) {\n        rng = doc.createRange();\n      }\n      if (isDocument$1(rng.startContainer) && rng.collapsed) {\n        const elm = dom.getRoot();\n        rng.setStart(elm, 0);\n        rng.setEnd(elm, 0);\n      }\n      if (selectedRange && explicitRange) {\n        if (tryCompareBoundaryPoints(rng.START_TO_START, rng, selectedRange) === 0 && tryCompareBoundaryPoints(rng.END_TO_END, rng, selectedRange) === 0) {\n          rng = explicitRange;\n        } else {\n          selectedRange = null;\n          explicitRange = null;\n        }\n      }\n      return rng;\n    };\n    const setRng = (rng, forward) => {\n      if (!isValidRange(rng)) {\n        return;\n      }\n      const sel = getSel();\n      const evt = editor.dispatch('SetSelectionRange', {\n        range: rng,\n        forward\n      });\n      rng = evt.range;\n      if (sel) {\n        explicitRange = rng;\n        try {\n          sel.removeAllRanges();\n          sel.addRange(rng);\n        } catch (ex) {}\n        if (forward === false && sel.extend) {\n          sel.collapse(rng.endContainer, rng.endOffset);\n          sel.extend(rng.startContainer, rng.startOffset);\n        }\n        selectedRange = sel.rangeCount > 0 ? sel.getRangeAt(0) : null;\n      }\n      if (!rng.collapsed && rng.startContainer === rng.endContainer && (sel === null || sel === void 0 ? void 0 : sel.setBaseAndExtent)) {\n        if (rng.endOffset - rng.startOffset < 2) {\n          if (rng.startContainer.hasChildNodes()) {\n            const node = rng.startContainer.childNodes[rng.startOffset];\n            if (node && node.nodeName === 'IMG') {\n              sel.setBaseAndExtent(rng.startContainer, rng.startOffset, rng.endContainer, rng.endOffset);\n              if (sel.anchorNode !== rng.startContainer || sel.focusNode !== rng.endContainer) {\n                sel.setBaseAndExtent(node, 0, node, 1);\n              }\n            }\n          }\n        }\n      }\n      editor.dispatch('AfterSetSelectionRange', {\n        range: rng,\n        forward\n      });\n    };\n    const setNode = elm => {\n      setContent(dom.getOuterHTML(elm));\n      return elm;\n    };\n    const getNode$1 = () => getNode(editor.getBody(), getRng$1());\n    const getSelectedBlocks$1 = (startElm, endElm) => getSelectedBlocks(dom, getRng$1(), startElm, endElm);\n    const isForward = () => {\n      const sel = getSel();\n      const anchorNode = sel === null || sel === void 0 ? void 0 : sel.anchorNode;\n      const focusNode = sel === null || sel === void 0 ? void 0 : sel.focusNode;\n      if (!sel || !anchorNode || !focusNode || isRestrictedNode(anchorNode) || isRestrictedNode(focusNode)) {\n        return true;\n      }\n      const anchorRange = dom.createRng();\n      const focusRange = dom.createRng();\n      try {\n        anchorRange.setStart(anchorNode, sel.anchorOffset);\n        anchorRange.collapse(true);\n        focusRange.setStart(focusNode, sel.focusOffset);\n        focusRange.collapse(true);\n      } catch (e) {\n        return true;\n      }\n      return anchorRange.compareBoundaryPoints(anchorRange.START_TO_START, focusRange) <= 0;\n    };\n    const normalize = () => {\n      const rng = getRng$1();\n      const sel = getSel();\n      if (!hasMultipleRanges(sel) && hasAnyRanges(editor)) {\n        const normRng = normalize$2(dom, rng);\n        normRng.each(normRng => {\n          setRng(normRng, isForward());\n        });\n        return normRng.getOr(rng);\n      }\n      return rng;\n    };\n    const selectorChanged = (selector, callback) => {\n      selectorChangedWithUnbind(selector, callback);\n      return exports;\n    };\n    const getScrollContainer = () => {\n      let scrollContainer;\n      let node = dom.getRoot();\n      while (node && node.nodeName !== 'BODY') {\n        if (node.scrollHeight > node.clientHeight) {\n          scrollContainer = node;\n          break;\n        }\n        node = node.parentNode;\n      }\n      return scrollContainer;\n    };\n    const scrollIntoView = (elm, alignToTop) => {\n      if (isNonNullable(elm)) {\n        scrollElementIntoView(editor, elm, alignToTop);\n      } else {\n        scrollRangeIntoView(editor, getRng$1(), alignToTop);\n      }\n    };\n    const placeCaretAt = (clientX, clientY) => setRng(fromPoint(clientX, clientY, editor.getDoc()));\n    const getBoundingClientRect = () => {\n      const rng = getRng$1();\n      return rng.collapsed ? CaretPosition.fromRangeStart(rng).getClientRects()[0] : rng.getBoundingClientRect();\n    };\n    const destroy = () => {\n      win = selectedRange = explicitRange = null;\n      controlSelection.destroy();\n    };\n    const expand = (options = {\n      type: 'word'\n    }) => setRng(RangeUtils(dom).expand(getRng$1(), options));\n    const exports = {\n      dom,\n      win,\n      serializer,\n      editor,\n      expand,\n      collapse,\n      setCursorLocation,\n      getContent,\n      setContent,\n      getBookmark,\n      moveToBookmark,\n      select: select$1,\n      isCollapsed,\n      isEditable,\n      isForward,\n      setNode,\n      getNode: getNode$1,\n      getSel,\n      setRng,\n      getRng: getRng$1,\n      getStart: getStart$1,\n      getEnd: getEnd$1,\n      getSelectedBlocks: getSelectedBlocks$1,\n      normalize,\n      selectorChanged,\n      selectorChangedWithUnbind,\n      getScrollContainer,\n      scrollIntoView,\n      placeCaretAt,\n      getBoundingClientRect,\n      destroy\n    };\n    const bookmarkManager = BookmarkManager(exports);\n    const controlSelection = ControlSelection(exports, editor);\n    exports.bookmarkManager = bookmarkManager;\n    exports.controlSelection = controlSelection;\n    return exports;\n  };\n  const addNodeFilter = (settings, htmlParser, schema) => {\n    htmlParser.addNodeFilter('br', (nodes, _, args) => {\n      const blockElements = Tools.extend({}, schema.getBlockElements());\n      const nonEmptyElements = schema.getNonEmptyElements();\n      const whitespaceElements = schema.getWhitespaceElements();\n      blockElements.body = 1;\n      const isBlock = node => node.name in blockElements || isTransparentAstBlock(schema, node);\n      for (let i = 0, l = nodes.length; i < l; i++) {\n        let node = nodes[i];\n        let parent = node.parent;\n        if (parent && isBlock(parent) && node === parent.lastChild) {\n          let prev = node.prev;\n          while (prev) {\n            const prevName = prev.name;\n            if (prevName !== 'span' || prev.attr('data-mce-type') !== 'bookmark') {\n              if (prevName === 'br') {\n                node = null;\n              }\n              break;\n            }\n            prev = prev.prev;\n          }\n          if (node) {\n            node.remove();\n            if (isEmpty(schema, nonEmptyElements, whitespaceElements, parent)) {\n              const elementRule = schema.getElementRule(parent.name);\n              if (elementRule) {\n                if (elementRule.removeEmpty) {\n                  parent.remove();\n                } else if (elementRule.paddEmpty) {\n                  paddEmptyNode(settings, args, isBlock, parent);\n                }\n              }\n            }\n          }\n        } else {\n          let lastParent = node;\n          while (parent && parent.firstChild === lastParent && parent.lastChild === lastParent) {\n            lastParent = parent;\n            if (blockElements[parent.name]) {\n              break;\n            }\n            parent = parent.parent;\n          }\n          if (lastParent === parent) {\n            const textNode = new AstNode('#text', 3);\n            textNode.value = nbsp;\n            node.replace(textNode);\n          }\n        }\n      }\n    });\n  };\n  const register$3 = (htmlParser, settings, dom) => {\n    htmlParser.addAttributeFilter('data-mce-tabindex', (nodes, name) => {\n      let i = nodes.length;\n      while (i--) {\n        const node = nodes[i];\n        node.attr('tabindex', node.attr('data-mce-tabindex'));\n        node.attr(name, null);\n      }\n    });\n    htmlParser.addAttributeFilter('src,href,style', (nodes, name) => {\n      const internalName = 'data-mce-' + name;\n      const urlConverter = settings.url_converter;\n      const urlConverterScope = settings.url_converter_scope;\n      let i = nodes.length;\n      while (i--) {\n        const node = nodes[i];\n        let value = node.attr(internalName);\n        if (value !== undefined) {\n          node.attr(name, value.length > 0 ? value : null);\n          node.attr(internalName, null);\n        } else {\n          value = node.attr(name);\n          if (name === 'style') {\n            value = dom.serializeStyle(dom.parseStyle(value), node.name);\n          } else if (urlConverter) {\n            value = urlConverter.call(urlConverterScope, value, name, node.name);\n          }\n          node.attr(name, value.length > 0 ? value : null);\n        }\n      }\n    });\n    htmlParser.addAttributeFilter('class', nodes => {\n      let i = nodes.length;\n      while (i--) {\n        const node = nodes[i];\n        let value = node.attr('class');\n        if (value) {\n          value = value.replace(/(?:^|\\s)mce-item-\\w+(?!\\S)/g, '');\n          node.attr('class', value.length > 0 ? value : null);\n        }\n      }\n    });\n    htmlParser.addAttributeFilter('data-mce-type', (nodes, name, args) => {\n      let i = nodes.length;\n      while (i--) {\n        const node = nodes[i];\n        if (node.attr('data-mce-type') === 'bookmark' && !args.cleanup) {\n          const hasChildren = Optional.from(node.firstChild).exists(firstChild => {\n            var _a;\n            return !isZwsp((_a = firstChild.value) !== null && _a !== void 0 ? _a : '');\n          });\n          if (hasChildren) {\n            node.unwrap();\n          } else {\n            node.remove();\n          }\n        }\n      }\n    });\n    htmlParser.addNodeFilter('script,style', (nodes, name) => {\n      var _a;\n      const trim = value => {\n        return value.replace(/(<!--\\[CDATA\\[|\\]\\]-->)/g, '\\n').replace(/^[\\r\\n]*|[\\r\\n]*$/g, '').replace(/^\\s*((<!--)?(\\s*\\/\\/)?\\s*<!\\[CDATA\\[|(<!--\\s*)?\\/\\*\\s*<!\\[CDATA\\[\\s*\\*\\/|(\\/\\/)?\\s*<!--|\\/\\*\\s*<!--\\s*\\*\\/)\\s*[\\r\\n]*/gi, '').replace(/\\s*(\\/\\*\\s*\\]\\]>\\s*\\*\\/(-->)?|\\s*\\/\\/\\s*\\]\\]>(-->)?|\\/\\/\\s*(-->)?|\\]\\]>|\\/\\*\\s*-->\\s*\\*\\/|\\s*-->\\s*)\\s*$/g, '');\n      };\n      let i = nodes.length;\n      while (i--) {\n        const node = nodes[i];\n        const firstChild = node.firstChild;\n        const value = (_a = firstChild === null || firstChild === void 0 ? void 0 : firstChild.value) !== null && _a !== void 0 ? _a : '';\n        if (name === 'script') {\n          const type = node.attr('type');\n          if (type) {\n            node.attr('type', type === 'mce-no/type' ? null : type.replace(/^mce\\-/, ''));\n          }\n          if (settings.element_format === 'xhtml' && firstChild && value.length > 0) {\n            firstChild.value = '// <![CDATA[\\n' + trim(value) + '\\n// ]]>';\n          }\n        } else {\n          if (settings.element_format === 'xhtml' && firstChild && value.length > 0) {\n            firstChild.value = '<!--\\n' + trim(value) + '\\n-->';\n          }\n        }\n      }\n    });\n    htmlParser.addNodeFilter('#comment', nodes => {\n      let i = nodes.length;\n      while (i--) {\n        const node = nodes[i];\n        const value = node.value;\n        if (settings.preserve_cdata && (value === null || value === void 0 ? void 0 : value.indexOf('[CDATA[')) === 0) {\n          node.name = '#cdata';\n          node.type = 4;\n          node.value = dom.decode(value.replace(/^\\[CDATA\\[|\\]\\]$/g, ''));\n        } else if ((value === null || value === void 0 ? void 0 : value.indexOf('mce:protected ')) === 0) {\n          node.name = '#text';\n          node.type = 3;\n          node.raw = true;\n          node.value = unescape(value).substr(14);\n        }\n      }\n    });\n    htmlParser.addNodeFilter('xml:namespace,input', (nodes, name) => {\n      let i = nodes.length;\n      while (i--) {\n        const node = nodes[i];\n        if (node.type === 7) {\n          node.remove();\n        } else if (node.type === 1) {\n          if (name === 'input' && !node.attr('type')) {\n            node.attr('type', 'text');\n          }\n        }\n      }\n    });\n    htmlParser.addAttributeFilter('data-mce-type', nodes => {\n      each$e(nodes, node => {\n        if (node.attr('data-mce-type') === 'format-caret') {\n          if (node.isEmpty(htmlParser.schema.getNonEmptyElements())) {\n            node.remove();\n          } else {\n            node.unwrap();\n          }\n        }\n      });\n    });\n    htmlParser.addAttributeFilter('data-mce-src,data-mce-href,data-mce-style,' + 'data-mce-selected,data-mce-expando,data-mce-block,' + 'data-mce-type,data-mce-resize,data-mce-placeholder', (nodes, name) => {\n      let i = nodes.length;\n      while (i--) {\n        nodes[i].attr(name, null);\n      }\n    });\n    if (settings.remove_trailing_brs) {\n      addNodeFilter(settings, htmlParser, htmlParser.schema);\n    }\n  };\n  const trimTrailingBr = rootNode => {\n    const isBr = node => {\n      return (node === null || node === void 0 ? void 0 : node.name) === 'br';\n    };\n    const brNode1 = rootNode.lastChild;\n    if (isBr(brNode1)) {\n      const brNode2 = brNode1.prev;\n      if (isBr(brNode2)) {\n        brNode1.remove();\n        brNode2.remove();\n      }\n    }\n  };\n  const preProcess$1 = (editor, node, args) => {\n    let oldDoc;\n    const dom = editor.dom;\n    let clonedNode = node.cloneNode(true);\n    const impl = document.implementation;\n    if (impl.createHTMLDocument) {\n      const doc = impl.createHTMLDocument('');\n      Tools.each(clonedNode.nodeName === 'BODY' ? clonedNode.childNodes : [clonedNode], node => {\n        doc.body.appendChild(doc.importNode(node, true));\n      });\n      if (clonedNode.nodeName !== 'BODY') {\n        clonedNode = doc.body.firstChild;\n      } else {\n        clonedNode = doc.body;\n      }\n      oldDoc = dom.doc;\n      dom.doc = doc;\n    }\n    firePreProcess(editor, {\n      ...args,\n      node: clonedNode\n    });\n    if (oldDoc) {\n      dom.doc = oldDoc;\n    }\n    return clonedNode;\n  };\n  const shouldFireEvent = (editor, args) => {\n    return isNonNullable(editor) && editor.hasEventListeners('PreProcess') && !args.no_events;\n  };\n  const process$1 = (editor, node, args) => {\n    return shouldFireEvent(editor, args) ? preProcess$1(editor, node, args) : node;\n  };\n  const addTempAttr = (htmlParser, tempAttrs, name) => {\n    if (Tools.inArray(tempAttrs, name) === -1) {\n      htmlParser.addAttributeFilter(name, (nodes, name) => {\n        let i = nodes.length;\n        while (i--) {\n          nodes[i].attr(name, null);\n        }\n      });\n      tempAttrs.push(name);\n    }\n  };\n  const postProcess = (editor, args, content) => {\n    if (!args.no_events && editor) {\n      const outArgs = firePostProcess(editor, {\n        ...args,\n        content\n      });\n      return outArgs.content;\n    } else {\n      return content;\n    }\n  };\n  const getHtmlFromNode = (dom, node, args) => {\n    const html = trim$2(args.getInner ? node.innerHTML : dom.getOuterHTML(node));\n    return args.selection || isWsPreserveElement(SugarElement.fromDom(node)) ? html : Tools.trim(html);\n  };\n  const parseHtml = (htmlParser, html, args) => {\n    const parserArgs = args.selection ? {\n      forced_root_block: false,\n      ...args\n    } : args;\n    const rootNode = htmlParser.parse(html, parserArgs);\n    trimTrailingBr(rootNode);\n    return rootNode;\n  };\n  const serializeNode = (settings, schema, node) => {\n    const htmlSerializer = HtmlSerializer(settings, schema);\n    return htmlSerializer.serialize(node);\n  };\n  const toHtml = (editor, settings, schema, rootNode, args) => {\n    const content = serializeNode(settings, schema, rootNode);\n    return postProcess(editor, args, content);\n  };\n  const DomSerializerImpl = (settings, editor) => {\n    const tempAttrs = ['data-mce-selected'];\n    const defaultedSettings = {\n      entity_encoding: 'named',\n      remove_trailing_brs: true,\n      pad_empty_with_br: false,\n      ...settings\n    };\n    const dom = editor && editor.dom ? editor.dom : DOMUtils.DOM;\n    const schema = editor && editor.schema ? editor.schema : Schema(defaultedSettings);\n    const htmlParser = DomParser(defaultedSettings, schema);\n    register$3(htmlParser, defaultedSettings, dom);\n    const serialize = (node, parserArgs = {}) => {\n      const args = {\n        format: 'html',\n        ...parserArgs\n      };\n      const targetNode = process$1(editor, node, args);\n      const html = getHtmlFromNode(dom, targetNode, args);\n      const rootNode = parseHtml(htmlParser, html, args);\n      return args.format === 'tree' ? rootNode : toHtml(editor, defaultedSettings, schema, rootNode, args);\n    };\n    return {\n      schema,\n      addNodeFilter: htmlParser.addNodeFilter,\n      addAttributeFilter: htmlParser.addAttributeFilter,\n      serialize: serialize,\n      addRules: schema.addValidElements,\n      setRules: schema.setValidElements,\n      addTempAttr: curry(addTempAttr, htmlParser, tempAttrs),\n      getTempAttrs: constant(tempAttrs),\n      getNodeFilters: htmlParser.getNodeFilters,\n      getAttributeFilters: htmlParser.getAttributeFilters,\n      removeNodeFilter: htmlParser.removeNodeFilter,\n      removeAttributeFilter: htmlParser.removeAttributeFilter\n    };\n  };\n  const DomSerializer = (settings, editor) => {\n    const domSerializer = DomSerializerImpl(settings, editor);\n    return {\n      schema: domSerializer.schema,\n      addNodeFilter: domSerializer.addNodeFilter,\n      addAttributeFilter: domSerializer.addAttributeFilter,\n      serialize: domSerializer.serialize,\n      addRules: domSerializer.addRules,\n      setRules: domSerializer.setRules,\n      addTempAttr: domSerializer.addTempAttr,\n      getTempAttrs: domSerializer.getTempAttrs,\n      getNodeFilters: domSerializer.getNodeFilters,\n      getAttributeFilters: domSerializer.getAttributeFilters,\n      removeNodeFilter: domSerializer.removeNodeFilter,\n      removeAttributeFilter: domSerializer.removeAttributeFilter\n    };\n  };\n  const defaultFormat$1 = 'html';\n  const setupArgs$1 = (args, format) => ({\n    ...args,\n    format,\n    get: true,\n    getInner: true\n  });\n  const getContent = (editor, args = {}) => {\n    const format = args.format ? args.format : defaultFormat$1;\n    const defaultedArgs = setupArgs$1(args, format);\n    return preProcessGetContent(editor, defaultedArgs).fold(identity, updatedArgs => {\n      const content = getContent$2(editor, updatedArgs);\n      return postProcessGetContent(editor, content, updatedArgs);\n    });\n  };\n  const defaultFormat = 'html';\n  const setupArgs = (args, content) => ({\n    format: defaultFormat,\n    ...args,\n    set: true,\n    content\n  });\n  const setContent = (editor, content, args = {}) => {\n    const defaultedArgs = setupArgs(args, content);\n    return preProcessSetContent(editor, defaultedArgs).map(updatedArgs => {\n      const result = setContent$2(editor, updatedArgs.content, updatedArgs);\n      postProcessSetContent(editor, result.html, updatedArgs);\n      return result.content;\n    }).getOr(content);\n  };\n  const removedOptions = ('autoresize_on_init,content_editable_state,padd_empty_with_br,block_elements,' + 'boolean_attributes,editor_deselector,editor_selector,elements,file_browser_callback_types,filepicker_validator_handler,' + 'force_hex_style_colors,force_p_newlines,gecko_spellcheck,images_dataimg_filter,media_scripts,mode,move_caret_before_on_enter_elements,' + 'non_empty_elements,self_closing_elements,short_ended_elements,special,spellchecker_select_languages,spellchecker_whitelist,' + 'tab_focus,tabfocus_elements,table_responsive_width,text_block_elements,text_inline_elements,toolbar_drawer,types,validate,whitespace_elements,' + 'paste_enable_default_filters,paste_filter_drop,paste_word_valid_elements,paste_retain_style_properties,paste_convert_word_fake_lists,' + 'template_cdate_classes,template_mdate_classes,template_selected_content_classes,template_preview_replace_values,template_replace_values,templates,template_cdate_format,template_mdate_format').split(',');\n  const deprecatedOptions = [];\n  const removedPlugins = 'bbcode,colorpicker,contextmenu,fullpage,legacyoutput,spellchecker,template,textcolor,rtc'.split(',');\n  const deprecatedPlugins = [];\n  const getMatchingOptions = (options, searchingFor) => {\n    const settingNames = filter$5(searchingFor, setting => has$2(options, setting));\n    return sort(settingNames);\n  };\n  const getRemovedOptions = options => {\n    const settingNames = getMatchingOptions(options, removedOptions);\n    const forcedRootBlock = options.forced_root_block;\n    if (forcedRootBlock === false || forcedRootBlock === '') {\n      settingNames.push('forced_root_block (false only)');\n    }\n    return sort(settingNames);\n  };\n  const getDeprecatedOptions = options => getMatchingOptions(options, deprecatedOptions);\n  const getMatchingPlugins = (options, searchingFor) => {\n    const plugins = Tools.makeMap(options.plugins, ' ');\n    const hasPlugin = plugin => has$2(plugins, plugin);\n    const pluginNames = filter$5(searchingFor, hasPlugin);\n    return sort(pluginNames);\n  };\n  const getRemovedPlugins = options => getMatchingPlugins(options, removedPlugins);\n  const getDeprecatedPlugins = options => getMatchingPlugins(options, deprecatedPlugins.map(entry => entry.name));\n  const logRemovedWarnings = (rawOptions, normalizedOptions) => {\n    const removedOptions = getRemovedOptions(rawOptions);\n    const removedPlugins = getRemovedPlugins(normalizedOptions);\n    const hasRemovedPlugins = removedPlugins.length > 0;\n    const hasRemovedOptions = removedOptions.length > 0;\n    const isLegacyMobileTheme = normalizedOptions.theme === 'mobile';\n    if (hasRemovedPlugins || hasRemovedOptions || isLegacyMobileTheme) {\n      const listJoiner = '\\n- ';\n      const themesMessage = isLegacyMobileTheme ? `\\n\\nThemes:${listJoiner}mobile` : '';\n      const pluginsMessage = hasRemovedPlugins ? `\\n\\nPlugins:${listJoiner}${removedPlugins.join(listJoiner)}` : '';\n      const optionsMessage = hasRemovedOptions ? `\\n\\nOptions:${listJoiner}${removedOptions.join(listJoiner)}` : '';\n      console.warn('The following deprecated features are currently enabled and have been removed in TinyMCE 7.0. These features will no longer work and should be removed from the TinyMCE configuration. ' + 'See https://www.tiny.cloud/docs/tinymce/7/migration-from-6x/ for more information.' + themesMessage + pluginsMessage + optionsMessage);\n    }\n  };\n  const getPluginDescription = name => find$2(deprecatedPlugins, entry => entry.name === name).fold(() => name, entry => {\n    if (entry.replacedWith) {\n      return `${name}, replaced by ${entry.replacedWith}`;\n    } else {\n      return name;\n    }\n  });\n  const logDeprecatedWarnings = (rawOptions, normalizedOptions) => {\n    const deprecatedOptions = getDeprecatedOptions(rawOptions);\n    const deprecatedPlugins = getDeprecatedPlugins(normalizedOptions);\n    const hasDeprecatedPlugins = deprecatedPlugins.length > 0;\n    const hasDeprecatedOptions = deprecatedOptions.length > 0;\n    if (hasDeprecatedPlugins || hasDeprecatedOptions) {\n      const listJoiner = '\\n- ';\n      const pluginsMessage = hasDeprecatedPlugins ? `\\n\\nPlugins:${listJoiner}${deprecatedPlugins.map(getPluginDescription).join(listJoiner)}` : '';\n      const optionsMessage = hasDeprecatedOptions ? `\\n\\nOptions:${listJoiner}${deprecatedOptions.join(listJoiner)}` : '';\n      console.warn('The following deprecated features are currently enabled but will be removed soon.' + pluginsMessage + optionsMessage);\n    }\n  };\n  const logWarnings = (rawOptions, normalizedOptions) => {\n    logRemovedWarnings(rawOptions, normalizedOptions);\n    logDeprecatedWarnings(rawOptions, normalizedOptions);\n  };\n  const DOM$8 = DOMUtils.DOM;\n  const restoreOriginalStyles = editor => {\n    DOM$8.setStyle(editor.id, 'display', editor.orgDisplay);\n  };\n  const safeDestroy = x => Optional.from(x).each(x => x.destroy());\n  const clearDomReferences = editor => {\n    const ed = editor;\n    ed.contentAreaContainer = ed.formElement = ed.container = ed.editorContainer = null;\n    ed.bodyElement = ed.contentDocument = ed.contentWindow = null;\n    ed.iframeElement = ed.targetElm = null;\n    const selection = editor.selection;\n    if (selection) {\n      const dom = selection.dom;\n      ed.selection = selection.win = selection.dom = dom.doc = null;\n    }\n  };\n  const restoreForm = editor => {\n    const form = editor.formElement;\n    if (form) {\n      if (form._mceOldSubmit) {\n        form.submit = form._mceOldSubmit;\n        delete form._mceOldSubmit;\n      }\n      DOM$8.unbind(form, 'submit reset', editor.formEventDelegate);\n    }\n  };\n  const remove$1 = editor => {\n    if (!editor.removed) {\n      const {\n        _selectionOverrides,\n        editorUpload\n      } = editor;\n      const body = editor.getBody();\n      const element = editor.getElement();\n      if (body) {\n        editor.save({\n          is_removing: true\n        });\n      }\n      editor.removed = true;\n      editor.unbindAllNativeEvents();\n      if (editor.hasHiddenInput && isNonNullable(element === null || element === void 0 ? void 0 : element.nextSibling)) {\n        DOM$8.remove(element.nextSibling);\n      }\n      fireRemove(editor);\n      editor.editorManager.remove(editor);\n      if (!editor.inline && body) {\n        restoreOriginalStyles(editor);\n      }\n      fireDetach(editor);\n      DOM$8.remove(editor.getContainer());\n      safeDestroy(_selectionOverrides);\n      safeDestroy(editorUpload);\n      editor.destroy();\n    }\n  };\n  const destroy = (editor, automatic) => {\n    const {\n      selection,\n      dom\n    } = editor;\n    if (editor.destroyed) {\n      return;\n    }\n    if (!automatic && !editor.removed) {\n      editor.remove();\n      return;\n    }\n    if (!automatic) {\n      editor.editorManager.off('beforeunload', editor._beforeUnload);\n      if (editor.theme && editor.theme.destroy) {\n        editor.theme.destroy();\n      }\n      safeDestroy(selection);\n      safeDestroy(dom);\n    }\n    restoreForm(editor);\n    clearDomReferences(editor);\n    editor.destroyed = true;\n  };\n  const CreateIconManager = () => {\n    const lookup = {};\n    const add = (id, iconPack) => {\n      lookup[id] = iconPack;\n    };\n    const get = id => {\n      if (lookup[id]) {\n        return lookup[id];\n      } else {\n        return {\n          icons: {}\n        };\n      }\n    };\n    const has = id => has$2(lookup, id);\n    return {\n      add,\n      get,\n      has\n    };\n  };\n  const IconManager = CreateIconManager();\n  const ModelManager = AddOnManager.ModelManager;\n  const getProp = (propName, elm) => {\n    const rawElm = elm.dom;\n    return rawElm[propName];\n  };\n  const getComputedSizeProp = (propName, elm) => parseInt(get$7(elm, propName), 10);\n  const getClientWidth = curry(getProp, 'clientWidth');\n  const getClientHeight = curry(getProp, 'clientHeight');\n  const getMarginTop = curry(getComputedSizeProp, 'margin-top');\n  const getMarginLeft = curry(getComputedSizeProp, 'margin-left');\n  const getBoundingClientRect = elm => elm.dom.getBoundingClientRect();\n  const isInsideElementContentArea = (bodyElm, clientX, clientY) => {\n    const clientWidth = getClientWidth(bodyElm);\n    const clientHeight = getClientHeight(bodyElm);\n    return clientX >= 0 && clientY >= 0 && clientX <= clientWidth && clientY <= clientHeight;\n  };\n  const transpose = (inline, elm, clientX, clientY) => {\n    const clientRect = getBoundingClientRect(elm);\n    const deltaX = inline ? clientRect.left + elm.dom.clientLeft + getMarginLeft(elm) : 0;\n    const deltaY = inline ? clientRect.top + elm.dom.clientTop + getMarginTop(elm) : 0;\n    const x = clientX - deltaX;\n    const y = clientY - deltaY;\n    return {\n      x,\n      y\n    };\n  };\n  const isXYInContentArea = (editor, clientX, clientY) => {\n    const bodyElm = SugarElement.fromDom(editor.getBody());\n    const targetElm = editor.inline ? bodyElm : documentElement(bodyElm);\n    const transposedPoint = transpose(editor.inline, targetElm, clientX, clientY);\n    return isInsideElementContentArea(targetElm, transposedPoint.x, transposedPoint.y);\n  };\n  const fromDomSafe = node => Optional.from(node).map(SugarElement.fromDom);\n  const isEditorAttachedToDom = editor => {\n    const rawContainer = editor.inline ? editor.getBody() : editor.getContentAreaContainer();\n    return fromDomSafe(rawContainer).map(inBody).getOr(false);\n  };\n  var NotificationManagerImpl = () => {\n    const unimplemented = () => {\n      throw new Error('Theme did not provide a NotificationManager implementation.');\n    };\n    return {\n      open: unimplemented,\n      close: unimplemented,\n      getArgs: unimplemented\n    };\n  };\n  const NotificationManager = editor => {\n    const notifications = [];\n    const getImplementation = () => {\n      const theme = editor.theme;\n      return theme && theme.getNotificationManagerImpl ? theme.getNotificationManagerImpl() : NotificationManagerImpl();\n    };\n    const getTopNotification = () => {\n      return Optional.from(notifications[0]);\n    };\n    const isEqual = (a, b) => {\n      return a.type === b.type && a.text === b.text && !a.progressBar && !a.timeout && !b.progressBar && !b.timeout;\n    };\n    const reposition = () => {\n      getTopNotification().each(notification => {\n        notification.reposition();\n      });\n    };\n    const addNotification = notification => {\n      notifications.push(notification);\n    };\n    const closeNotification = notification => {\n      findIndex$2(notifications, otherNotification => {\n        return otherNotification === notification;\n      }).each(index => {\n        notifications.splice(index, 1);\n      });\n    };\n    const open = (spec, fireEvent = true) => {\n      if (editor.removed || !isEditorAttachedToDom(editor)) {\n        return {};\n      }\n      if (fireEvent) {\n        editor.dispatch('BeforeOpenNotification', {\n          notification: spec\n        });\n      }\n      return find$2(notifications, notification => {\n        return isEqual(getImplementation().getArgs(notification), spec);\n      }).getOrThunk(() => {\n        editor.editorManager.setActive(editor);\n        const notification = getImplementation().open(spec, () => {\n          closeNotification(notification);\n        }, () => hasEditorOrUiFocus(editor));\n        addNotification(notification);\n        reposition();\n        editor.dispatch('OpenNotification', {\n          notification: {\n            ...notification\n          }\n        });\n        return notification;\n      });\n    };\n    const close = () => {\n      getTopNotification().each(notification => {\n        getImplementation().close(notification);\n        closeNotification(notification);\n        reposition();\n      });\n    };\n    const getNotifications = constant(notifications);\n    const registerEvents = editor => {\n      editor.on('SkinLoaded', () => {\n        const serviceMessage = getServiceMessage(editor);\n        if (serviceMessage) {\n          open({\n            text: serviceMessage,\n            type: 'warning',\n            timeout: 0\n          }, false);\n        }\n        reposition();\n      });\n      editor.on('show ResizeEditor ResizeWindow NodeChange ToggleView FullscreenStateChanged', () => {\n        requestAnimationFrame(reposition);\n      });\n      editor.on('remove', () => {\n        each$e(notifications.slice(), notification => {\n          getImplementation().close(notification);\n        });\n      });\n      editor.on('keydown', e => {\n        var _a;\n        const isF12 = ((_a = e.key) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === 'f12' || e.keyCode === 123;\n        if (e.altKey && isF12) {\n          e.preventDefault();\n          getTopNotification().map(notificationApi => SugarElement.fromDom(notificationApi.getEl())).each(elm => focus$1(elm));\n        }\n      });\n    };\n    registerEvents(editor);\n    return {\n      open,\n      close,\n      getNotifications\n    };\n  };\n  const PluginManager = AddOnManager.PluginManager;\n  const ThemeManager = AddOnManager.ThemeManager;\n  var WindowManagerImpl = () => {\n    const unimplemented = () => {\n      throw new Error('Theme did not provide a WindowManager implementation.');\n    };\n    return {\n      open: unimplemented,\n      openUrl: unimplemented,\n      alert: unimplemented,\n      confirm: unimplemented,\n      close: unimplemented\n    };\n  };\n  const WindowManager = editor => {\n    let dialogs = [];\n    const getImplementation = () => {\n      const theme = editor.theme;\n      return theme && theme.getWindowManagerImpl ? theme.getWindowManagerImpl() : WindowManagerImpl();\n    };\n    const funcBind = (scope, f) => {\n      return (...args) => {\n        return f ? f.apply(scope, args) : undefined;\n      };\n    };\n    const fireOpenEvent = dialog => {\n      editor.dispatch('OpenWindow', {\n        dialog\n      });\n    };\n    const fireCloseEvent = dialog => {\n      editor.dispatch('CloseWindow', {\n        dialog\n      });\n    };\n    const addDialog = dialog => {\n      dialogs.push(dialog);\n      fireOpenEvent(dialog);\n    };\n    const closeDialog = dialog => {\n      fireCloseEvent(dialog);\n      dialogs = filter$5(dialogs, otherDialog => {\n        return otherDialog !== dialog;\n      });\n      if (dialogs.length === 0) {\n        editor.focus();\n      }\n    };\n    const getTopDialog = () => {\n      return Optional.from(dialogs[dialogs.length - 1]);\n    };\n    const storeSelectionAndOpenDialog = openDialog => {\n      editor.editorManager.setActive(editor);\n      store(editor);\n      editor.ui.show();\n      const dialog = openDialog();\n      addDialog(dialog);\n      return dialog;\n    };\n    const open = (args, params) => {\n      return storeSelectionAndOpenDialog(() => getImplementation().open(args, params, closeDialog));\n    };\n    const openUrl = args => {\n      return storeSelectionAndOpenDialog(() => getImplementation().openUrl(args, closeDialog));\n    };\n    const alert = (message, callback, scope) => {\n      const windowManagerImpl = getImplementation();\n      windowManagerImpl.alert(message, funcBind(scope ? scope : windowManagerImpl, callback));\n    };\n    const confirm = (message, callback, scope) => {\n      const windowManagerImpl = getImplementation();\n      windowManagerImpl.confirm(message, funcBind(scope ? scope : windowManagerImpl, callback));\n    };\n    const close = () => {\n      getTopDialog().each(dialog => {\n        getImplementation().close(dialog);\n        closeDialog(dialog);\n      });\n    };\n    editor.on('remove', () => {\n      each$e(dialogs, dialog => {\n        getImplementation().close(dialog);\n      });\n    });\n    return {\n      open,\n      openUrl,\n      alert,\n      confirm,\n      close\n    };\n  };\n  const displayNotification = (editor, message) => {\n    editor.notificationManager.open({\n      type: 'error',\n      text: message\n    });\n  };\n  const displayError = (editor, message) => {\n    if (editor._skinLoaded) {\n      displayNotification(editor, message);\n    } else {\n      editor.on('SkinLoaded', () => {\n        displayNotification(editor, message);\n      });\n    }\n  };\n  const uploadError = (editor, message) => {\n    displayError(editor, I18n.translate(['Failed to upload image: {0}', message]));\n  };\n  const logError = (editor, errorType, msg) => {\n    fireError(editor, errorType, {\n      message: msg\n    });\n    console.error(msg);\n  };\n  const createLoadError = (type, url, name) => name ? `Failed to load ${type}: ${name} from url ${url}` : `Failed to load ${type} url: ${url}`;\n  const pluginLoadError = (editor, url, name) => {\n    logError(editor, 'PluginLoadError', createLoadError('plugin', url, name));\n  };\n  const iconsLoadError = (editor, url, name) => {\n    logError(editor, 'IconsLoadError', createLoadError('icons', url, name));\n  };\n  const languageLoadError = (editor, url, name) => {\n    logError(editor, 'LanguageLoadError', createLoadError('language', url, name));\n  };\n  const themeLoadError = (editor, url, name) => {\n    logError(editor, 'ThemeLoadError', createLoadError('theme', url, name));\n  };\n  const modelLoadError = (editor, url, name) => {\n    logError(editor, 'ModelLoadError', createLoadError('model', url, name));\n  };\n  const pluginInitError = (editor, name, err) => {\n    const message = I18n.translate(['Failed to initialize plugin: {0}', name]);\n    fireError(editor, 'PluginLoadError', {\n      message\n    });\n    initError(message, err);\n    displayError(editor, message);\n  };\n  const initError = (message, ...x) => {\n    const console = window.console;\n    if (console) {\n      if (console.error) {\n        console.error(message, ...x);\n      } else {\n        console.log(message, ...x);\n      }\n    }\n  };\n  const isContentCssSkinName = url => /^[a-z0-9\\-]+$/i.test(url);\n  const toContentSkinResourceName = url => 'content/' + url + '/content.css';\n  const isBundledCssSkinName = url => tinymce.Resource.has(toContentSkinResourceName(url));\n  const getContentCssUrls = editor => {\n    return transformToUrls(editor, getContentCss(editor));\n  };\n  const getFontCssUrls = editor => {\n    return transformToUrls(editor, getFontCss(editor));\n  };\n  const transformToUrls = (editor, cssLinks) => {\n    const skinUrl = editor.editorManager.baseURL + '/skins/content';\n    const suffix = editor.editorManager.suffix;\n    const contentCssFile = `content${suffix}.css`;\n    return map$3(cssLinks, url => {\n      if (isBundledCssSkinName(url)) {\n        return url;\n      } else if (isContentCssSkinName(url) && !editor.inline) {\n        return `${skinUrl}/${url}/${contentCssFile}`;\n      } else {\n        return editor.documentBaseURI.toAbsolute(url);\n      }\n    });\n  };\n  const appendContentCssFromSettings = editor => {\n    editor.contentCSS = editor.contentCSS.concat(getContentCssUrls(editor), getFontCssUrls(editor));\n  };\n  const getAllImages = elm => {\n    return elm ? from(elm.getElementsByTagName('img')) : [];\n  };\n  const ImageScanner = (uploadStatus, blobCache) => {\n    const cachedPromises = {};\n    const findAll = (elm, predicate = always) => {\n      const images = filter$5(getAllImages(elm), img => {\n        const src = img.src;\n        if (img.hasAttribute('data-mce-bogus')) {\n          return false;\n        }\n        if (img.hasAttribute('data-mce-placeholder')) {\n          return false;\n        }\n        if (!src || src === Env.transparentSrc) {\n          return false;\n        }\n        if (startsWith(src, 'blob:')) {\n          return !uploadStatus.isUploaded(src) && predicate(img);\n        }\n        if (startsWith(src, 'data:')) {\n          return predicate(img);\n        }\n        return false;\n      });\n      const promises = map$3(images, img => {\n        const imageSrc = img.src;\n        if (has$2(cachedPromises, imageSrc)) {\n          return cachedPromises[imageSrc].then(imageInfo => {\n            if (isString(imageInfo)) {\n              return imageInfo;\n            } else {\n              return {\n                image: img,\n                blobInfo: imageInfo.blobInfo\n              };\n            }\n          });\n        } else {\n          const newPromise = imageToBlobInfo(blobCache, imageSrc).then(blobInfo => {\n            delete cachedPromises[imageSrc];\n            return {\n              image: img,\n              blobInfo\n            };\n          }).catch(error => {\n            delete cachedPromises[imageSrc];\n            return error;\n          });\n          cachedPromises[imageSrc] = newPromise;\n          return newPromise;\n        }\n      });\n      return Promise.all(promises);\n    };\n    return {\n      findAll\n    };\n  };\n  const UploadStatus = () => {\n    const PENDING = 1,\n      UPLOADED = 2;\n    let blobUriStatuses = {};\n    const createStatus = (status, resultUri) => {\n      return {\n        status,\n        resultUri\n      };\n    };\n    const hasBlobUri = blobUri => {\n      return blobUri in blobUriStatuses;\n    };\n    const getResultUri = blobUri => {\n      const result = blobUriStatuses[blobUri];\n      return result ? result.resultUri : null;\n    };\n    const isPending = blobUri => {\n      return hasBlobUri(blobUri) ? blobUriStatuses[blobUri].status === PENDING : false;\n    };\n    const isUploaded = blobUri => {\n      return hasBlobUri(blobUri) ? blobUriStatuses[blobUri].status === UPLOADED : false;\n    };\n    const markPending = blobUri => {\n      blobUriStatuses[blobUri] = createStatus(PENDING, null);\n    };\n    const markUploaded = (blobUri, resultUri) => {\n      blobUriStatuses[blobUri] = createStatus(UPLOADED, resultUri);\n    };\n    const removeFailed = blobUri => {\n      delete blobUriStatuses[blobUri];\n    };\n    const destroy = () => {\n      blobUriStatuses = {};\n    };\n    return {\n      hasBlobUri,\n      getResultUri,\n      isPending,\n      isUploaded,\n      markPending,\n      markUploaded,\n      removeFailed,\n      destroy\n    };\n  };\n  let count = 0;\n  const seed = () => {\n    const rnd = () => {\n      return Math.round(random() * 4294967295).toString(36);\n    };\n    const now = new Date().getTime();\n    return 's' + now.toString(36) + rnd() + rnd() + rnd();\n  };\n  const uuid = prefix => {\n    return prefix + count++ + seed();\n  };\n  const BlobCache = () => {\n    let cache = [];\n    const mimeToExt = mime => {\n      const mimes = {\n        'image/jpeg': 'jpg',\n        'image/jpg': 'jpg',\n        'image/gif': 'gif',\n        'image/png': 'png',\n        'image/apng': 'apng',\n        'image/avif': 'avif',\n        'image/svg+xml': 'svg',\n        'image/webp': 'webp',\n        'image/bmp': 'bmp',\n        'image/tiff': 'tiff'\n      };\n      return mimes[mime.toLowerCase()] || 'dat';\n    };\n    const create = (o, blob, base64, name, filename) => {\n      if (isString(o)) {\n        const id = o;\n        return toBlobInfo({\n          id,\n          name,\n          filename,\n          blob: blob,\n          base64: base64\n        });\n      } else if (isObject(o)) {\n        return toBlobInfo(o);\n      } else {\n        throw new Error('Unknown input type');\n      }\n    };\n    const toBlobInfo = o => {\n      if (!o.blob || !o.base64) {\n        throw new Error('blob and base64 representations of the image are required for BlobInfo to be created');\n      }\n      const id = o.id || uuid('blobid');\n      const name = o.name || id;\n      const blob = o.blob;\n      return {\n        id: constant(id),\n        name: constant(name),\n        filename: constant(o.filename || name + '.' + mimeToExt(blob.type)),\n        blob: constant(blob),\n        base64: constant(o.base64),\n        blobUri: constant(o.blobUri || URL.createObjectURL(blob)),\n        uri: constant(o.uri)\n      };\n    };\n    const add = blobInfo => {\n      if (!get(blobInfo.id())) {\n        cache.push(blobInfo);\n      }\n    };\n    const findFirst = predicate => find$2(cache, predicate).getOrUndefined();\n    const get = id => findFirst(cachedBlobInfo => cachedBlobInfo.id() === id);\n    const getByUri = blobUri => findFirst(blobInfo => blobInfo.blobUri() === blobUri);\n    const getByData = (base64, type) => findFirst(blobInfo => blobInfo.base64() === base64 && blobInfo.blob().type === type);\n    const removeByUri = blobUri => {\n      cache = filter$5(cache, blobInfo => {\n        if (blobInfo.blobUri() === blobUri) {\n          URL.revokeObjectURL(blobInfo.blobUri());\n          return false;\n        }\n        return true;\n      });\n    };\n    const destroy = () => {\n      each$e(cache, cachedBlobInfo => {\n        URL.revokeObjectURL(cachedBlobInfo.blobUri());\n      });\n      cache = [];\n    };\n    return {\n      create,\n      add,\n      get,\n      getByUri,\n      getByData,\n      findFirst,\n      removeByUri,\n      destroy\n    };\n  };\n  const Uploader = (uploadStatus, settings) => {\n    const pendingPromises = {};\n    const pathJoin = (path1, path2) => {\n      if (path1) {\n        return path1.replace(/\\/$/, '') + '/' + path2.replace(/^\\//, '');\n      }\n      return path2;\n    };\n    const defaultHandler = (blobInfo, progress) => new Promise((success, failure) => {\n      const xhr = new XMLHttpRequest();\n      xhr.open('POST', settings.url);\n      xhr.withCredentials = settings.credentials;\n      xhr.upload.onprogress = e => {\n        progress(e.loaded / e.total * 100);\n      };\n      xhr.onerror = () => {\n        failure('Image upload failed due to a XHR Transport error. Code: ' + xhr.status);\n      };\n      xhr.onload = () => {\n        if (xhr.status < 200 || xhr.status >= 300) {\n          failure('HTTP Error: ' + xhr.status);\n          return;\n        }\n        const json = JSON.parse(xhr.responseText);\n        if (!json || !isString(json.location)) {\n          failure('Invalid JSON: ' + xhr.responseText);\n          return;\n        }\n        success(pathJoin(settings.basePath, json.location));\n      };\n      const formData = new FormData();\n      formData.append('file', blobInfo.blob(), blobInfo.filename());\n      xhr.send(formData);\n    });\n    const uploadHandler = isFunction(settings.handler) ? settings.handler : defaultHandler;\n    const noUpload = () => new Promise(resolve => {\n      resolve([]);\n    });\n    const handlerSuccess = (blobInfo, url) => ({\n      url,\n      blobInfo,\n      status: true\n    });\n    const handlerFailure = (blobInfo, error) => ({\n      url: '',\n      blobInfo,\n      status: false,\n      error\n    });\n    const resolvePending = (blobUri, result) => {\n      Tools.each(pendingPromises[blobUri], resolve => {\n        resolve(result);\n      });\n      delete pendingPromises[blobUri];\n    };\n    const uploadBlobInfo = (blobInfo, handler, openNotification) => {\n      uploadStatus.markPending(blobInfo.blobUri());\n      return new Promise(resolve => {\n        let notification;\n        let progress;\n        try {\n          const closeNotification = () => {\n            if (notification) {\n              notification.close();\n              progress = noop;\n            }\n          };\n          const success = url => {\n            closeNotification();\n            uploadStatus.markUploaded(blobInfo.blobUri(), url);\n            resolvePending(blobInfo.blobUri(), handlerSuccess(blobInfo, url));\n            resolve(handlerSuccess(blobInfo, url));\n          };\n          const failure = error => {\n            closeNotification();\n            uploadStatus.removeFailed(blobInfo.blobUri());\n            resolvePending(blobInfo.blobUri(), handlerFailure(blobInfo, error));\n            resolve(handlerFailure(blobInfo, error));\n          };\n          progress = percent => {\n            if (percent < 0 || percent > 100) {\n              return;\n            }\n            Optional.from(notification).orThunk(() => Optional.from(openNotification).map(apply$1)).each(n => {\n              notification = n;\n              n.progressBar.value(percent);\n            });\n          };\n          handler(blobInfo, progress).then(success, err => {\n            failure(isString(err) ? {\n              message: err\n            } : err);\n          });\n        } catch (ex) {\n          resolve(handlerFailure(blobInfo, ex));\n        }\n      });\n    };\n    const isDefaultHandler = handler => handler === defaultHandler;\n    const pendingUploadBlobInfo = blobInfo => {\n      const blobUri = blobInfo.blobUri();\n      return new Promise(resolve => {\n        pendingPromises[blobUri] = pendingPromises[blobUri] || [];\n        pendingPromises[blobUri].push(resolve);\n      });\n    };\n    const uploadBlobs = (blobInfos, openNotification) => {\n      blobInfos = Tools.grep(blobInfos, blobInfo => !uploadStatus.isUploaded(blobInfo.blobUri()));\n      return Promise.all(Tools.map(blobInfos, blobInfo => uploadStatus.isPending(blobInfo.blobUri()) ? pendingUploadBlobInfo(blobInfo) : uploadBlobInfo(blobInfo, uploadHandler, openNotification)));\n    };\n    const upload = (blobInfos, openNotification) => !settings.url && isDefaultHandler(uploadHandler) ? noUpload() : uploadBlobs(blobInfos, openNotification);\n    return {\n      upload\n    };\n  };\n  const openNotification = editor => () => editor.notificationManager.open({\n    text: editor.translate('Image uploading...'),\n    type: 'info',\n    timeout: -1,\n    progressBar: true\n  });\n  const createUploader = (editor, uploadStatus) => Uploader(uploadStatus, {\n    url: getImageUploadUrl(editor),\n    basePath: getImageUploadBasePath(editor),\n    credentials: getImagesUploadCredentials(editor),\n    handler: getImagesUploadHandler(editor)\n  });\n  const ImageUploader = editor => {\n    const uploadStatus = UploadStatus();\n    const uploader = createUploader(editor, uploadStatus);\n    return {\n      upload: (blobInfos, showNotification = true) => uploader.upload(blobInfos, showNotification ? openNotification(editor) : undefined)\n    };\n  };\n  const isEmptyForPadding = (editor, element) => editor.dom.isEmpty(element.dom) && isNonNullable(editor.schema.getTextBlockElements()[name(element)]);\n  const addPaddingToEmpty = editor => element => {\n    if (isEmptyForPadding(editor, element)) {\n      append$1(element, SugarElement.fromHtml('<br data-mce-bogus=\"1\" />'));\n    }\n  };\n  const EditorUpload = editor => {\n    const blobCache = BlobCache();\n    let uploader, imageScanner;\n    const uploadStatus = UploadStatus();\n    const urlFilters = [];\n    const aliveGuard = callback => {\n      return result => {\n        if (editor.selection) {\n          return callback(result);\n        }\n        return [];\n      };\n    };\n    const cacheInvalidator = url => url + (url.indexOf('?') === -1 ? '?' : '&') + new Date().getTime();\n    const replaceString = (content, search, replace) => {\n      let index = 0;\n      do {\n        index = content.indexOf(search, index);\n        if (index !== -1) {\n          content = content.substring(0, index) + replace + content.substr(index + search.length);\n          index += replace.length - search.length + 1;\n        }\n      } while (index !== -1);\n      return content;\n    };\n    const replaceImageUrl = (content, targetUrl, replacementUrl) => {\n      const replacementString = `src=\"${replacementUrl}\"${replacementUrl === Env.transparentSrc ? ' data-mce-placeholder=\"1\"' : ''}`;\n      content = replaceString(content, `src=\"${targetUrl}\"`, replacementString);\n      content = replaceString(content, 'data-mce-src=\"' + targetUrl + '\"', 'data-mce-src=\"' + replacementUrl + '\"');\n      return content;\n    };\n    const replaceUrlInUndoStack = (targetUrl, replacementUrl) => {\n      each$e(editor.undoManager.data, level => {\n        if (level.type === 'fragmented') {\n          level.fragments = map$3(level.fragments, fragment => replaceImageUrl(fragment, targetUrl, replacementUrl));\n        } else {\n          level.content = replaceImageUrl(level.content, targetUrl, replacementUrl);\n        }\n      });\n    };\n    const replaceImageUriInView = (image, resultUri) => {\n      const src = editor.convertURL(resultUri, 'src');\n      replaceUrlInUndoStack(image.src, resultUri);\n      setAll$1(SugarElement.fromDom(image), {\n        'src': shouldReuseFileName(editor) ? cacheInvalidator(resultUri) : resultUri,\n        'data-mce-src': src\n      });\n    };\n    const uploadImages = () => {\n      if (!uploader) {\n        uploader = createUploader(editor, uploadStatus);\n      }\n      return scanForImages().then(aliveGuard(imageInfos => {\n        const blobInfos = map$3(imageInfos, imageInfo => imageInfo.blobInfo);\n        return uploader.upload(blobInfos, openNotification(editor)).then(aliveGuard(result => {\n          const imagesToRemove = [];\n          let shouldDispatchChange = false;\n          const filteredResult = map$3(result, (uploadInfo, index) => {\n            const {\n              blobInfo,\n              image\n            } = imageInfos[index];\n            let removed = false;\n            if (uploadInfo.status && shouldReplaceBlobUris(editor)) {\n              if (uploadInfo.url && !contains$1(image.src, uploadInfo.url)) {\n                shouldDispatchChange = true;\n              }\n              blobCache.removeByUri(image.src);\n              if (isRtc(editor)) ;else {\n                replaceImageUriInView(image, uploadInfo.url);\n              }\n            } else if (uploadInfo.error) {\n              if (uploadInfo.error.remove) {\n                replaceUrlInUndoStack(image.src, Env.transparentSrc);\n                imagesToRemove.push(image);\n                removed = true;\n              }\n              uploadError(editor, uploadInfo.error.message);\n            }\n            return {\n              element: image,\n              status: uploadInfo.status,\n              uploadUri: uploadInfo.url,\n              blobInfo,\n              removed\n            };\n          });\n          if (imagesToRemove.length > 0 && !isRtc(editor)) {\n            editor.undoManager.transact(() => {\n              each$e(fromDom$1(imagesToRemove), sugarElement => {\n                const parentOpt = parent(sugarElement);\n                remove$4(sugarElement);\n                parentOpt.each(addPaddingToEmpty(editor));\n                blobCache.removeByUri(sugarElement.dom.src);\n              });\n            });\n          } else if (shouldDispatchChange) {\n            editor.undoManager.dispatchChange();\n          }\n          return filteredResult;\n        }));\n      }));\n    };\n    const uploadImagesAuto = () => isAutomaticUploadsEnabled(editor) ? uploadImages() : Promise.resolve([]);\n    const isValidDataUriImage = imgElm => forall(urlFilters, filter => filter(imgElm));\n    const addFilter = filter => {\n      urlFilters.push(filter);\n    };\n    const scanForImages = () => {\n      if (!imageScanner) {\n        imageScanner = ImageScanner(uploadStatus, blobCache);\n      }\n      return imageScanner.findAll(editor.getBody(), isValidDataUriImage).then(aliveGuard(result => {\n        const filteredResult = filter$5(result, resultItem => {\n          if (isString(resultItem)) {\n            displayError(editor, resultItem);\n            return false;\n          } else if (resultItem.uriType === 'blob') {\n            return false;\n          } else {\n            return true;\n          }\n        });\n        if (isRtc(editor)) ;else {\n          each$e(filteredResult, resultItem => {\n            replaceUrlInUndoStack(resultItem.image.src, resultItem.blobInfo.blobUri());\n            resultItem.image.src = resultItem.blobInfo.blobUri();\n            resultItem.image.removeAttribute('data-mce-src');\n          });\n        }\n        return filteredResult;\n      }));\n    };\n    const destroy = () => {\n      blobCache.destroy();\n      uploadStatus.destroy();\n      imageScanner = uploader = null;\n    };\n    const replaceBlobUris = content => {\n      return content.replace(/src=\"(blob:[^\"]+)\"/g, (match, blobUri) => {\n        const resultUri = uploadStatus.getResultUri(blobUri);\n        if (resultUri) {\n          return 'src=\"' + resultUri + '\"';\n        }\n        let blobInfo = blobCache.getByUri(blobUri);\n        if (!blobInfo) {\n          blobInfo = foldl(editor.editorManager.get(), (result, editor) => {\n            return result || editor.editorUpload && editor.editorUpload.blobCache.getByUri(blobUri);\n          }, undefined);\n        }\n        if (blobInfo) {\n          const blob = blobInfo.blob();\n          return 'src=\"data:' + blob.type + ';base64,' + blobInfo.base64() + '\"';\n        }\n        return match;\n      });\n    };\n    editor.on('SetContent', () => {\n      if (isAutomaticUploadsEnabled(editor)) {\n        uploadImagesAuto();\n      } else {\n        scanForImages();\n      }\n    });\n    editor.on('RawSaveContent', e => {\n      e.content = replaceBlobUris(e.content);\n    });\n    editor.on('GetContent', e => {\n      if (e.source_view || e.format === 'raw' || e.format === 'tree') {\n        return;\n      }\n      e.content = replaceBlobUris(e.content);\n    });\n    editor.on('PostRender', () => {\n      editor.parser.addNodeFilter('img', images => {\n        each$e(images, img => {\n          const src = img.attr('src');\n          if (!src || blobCache.getByUri(src)) {\n            return;\n          }\n          const resultUri = uploadStatus.getResultUri(src);\n          if (resultUri) {\n            img.attr('src', resultUri);\n          }\n        });\n      });\n    });\n    return {\n      blobCache,\n      addFilter,\n      uploadImages,\n      uploadImagesAuto,\n      scanForImages,\n      destroy\n    };\n  };\n  const get$1 = editor => {\n    const dom = editor.dom;\n    const schemaType = editor.schema.type;\n    const formats = {\n      valigntop: [{\n        selector: 'td,th',\n        styles: {\n          verticalAlign: 'top'\n        }\n      }],\n      valignmiddle: [{\n        selector: 'td,th',\n        styles: {\n          verticalAlign: 'middle'\n        }\n      }],\n      valignbottom: [{\n        selector: 'td,th',\n        styles: {\n          verticalAlign: 'bottom'\n        }\n      }],\n      alignleft: [{\n        selector: 'figure.image',\n        collapsed: false,\n        classes: 'align-left',\n        ceFalseOverride: true,\n        preview: 'font-family font-size'\n      }, {\n        selector: 'figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li,pre',\n        styles: {\n          textAlign: 'left'\n        },\n        inherit: false,\n        preview: false\n      }, {\n        selector: 'img,audio,video',\n        collapsed: false,\n        styles: {\n          float: 'left'\n        },\n        preview: 'font-family font-size'\n      }, {\n        selector: 'table',\n        collapsed: false,\n        styles: {\n          marginLeft: '0px',\n          marginRight: 'auto'\n        },\n        onformat: table => {\n          dom.setStyle(table, 'float', null);\n        },\n        preview: 'font-family font-size'\n      }, {\n        selector: '.mce-preview-object,[data-ephox-embed-iri]',\n        ceFalseOverride: true,\n        styles: {\n          float: 'left'\n        }\n      }],\n      aligncenter: [{\n        selector: 'figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li,pre',\n        styles: {\n          textAlign: 'center'\n        },\n        inherit: false,\n        preview: 'font-family font-size'\n      }, {\n        selector: 'figure.image',\n        collapsed: false,\n        classes: 'align-center',\n        ceFalseOverride: true,\n        preview: 'font-family font-size'\n      }, {\n        selector: 'img,audio,video',\n        collapsed: false,\n        styles: {\n          display: 'block',\n          marginLeft: 'auto',\n          marginRight: 'auto'\n        },\n        preview: false\n      }, {\n        selector: 'table',\n        collapsed: false,\n        styles: {\n          marginLeft: 'auto',\n          marginRight: 'auto'\n        },\n        preview: 'font-family font-size'\n      }, {\n        selector: '.mce-preview-object',\n        ceFalseOverride: true,\n        styles: {\n          display: 'table',\n          marginLeft: 'auto',\n          marginRight: 'auto'\n        },\n        preview: false\n      }, {\n        selector: '[data-ephox-embed-iri]',\n        ceFalseOverride: true,\n        styles: {\n          marginLeft: 'auto',\n          marginRight: 'auto'\n        },\n        preview: false\n      }],\n      alignright: [{\n        selector: 'figure.image',\n        collapsed: false,\n        classes: 'align-right',\n        ceFalseOverride: true,\n        preview: 'font-family font-size'\n      }, {\n        selector: 'figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li,pre',\n        styles: {\n          textAlign: 'right'\n        },\n        inherit: false,\n        preview: 'font-family font-size'\n      }, {\n        selector: 'img,audio,video',\n        collapsed: false,\n        styles: {\n          float: 'right'\n        },\n        preview: 'font-family font-size'\n      }, {\n        selector: 'table',\n        collapsed: false,\n        styles: {\n          marginRight: '0px',\n          marginLeft: 'auto'\n        },\n        onformat: table => {\n          dom.setStyle(table, 'float', null);\n        },\n        preview: 'font-family font-size'\n      }, {\n        selector: '.mce-preview-object,[data-ephox-embed-iri]',\n        ceFalseOverride: true,\n        styles: {\n          float: 'right'\n        },\n        preview: false\n      }],\n      alignjustify: [{\n        selector: 'figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li,pre',\n        styles: {\n          textAlign: 'justify'\n        },\n        inherit: false,\n        preview: 'font-family font-size'\n      }],\n      bold: [{\n        inline: 'strong',\n        remove: 'all',\n        preserve_attributes: ['class', 'style']\n      }, {\n        inline: 'span',\n        styles: {\n          fontWeight: 'bold'\n        }\n      }, {\n        inline: 'b',\n        remove: 'all',\n        preserve_attributes: ['class', 'style']\n      }],\n      italic: [{\n        inline: 'em',\n        remove: 'all',\n        preserve_attributes: ['class', 'style']\n      }, {\n        inline: 'span',\n        styles: {\n          fontStyle: 'italic'\n        }\n      }, {\n        inline: 'i',\n        remove: 'all',\n        preserve_attributes: ['class', 'style']\n      }],\n      underline: [{\n        inline: 'span',\n        styles: {\n          textDecoration: 'underline'\n        },\n        exact: true\n      }, {\n        inline: 'u',\n        remove: 'all',\n        preserve_attributes: ['class', 'style']\n      }],\n      strikethrough: (() => {\n        const span = {\n          inline: 'span',\n          styles: {\n            textDecoration: 'line-through'\n          },\n          exact: true\n        };\n        const strike = {\n          inline: 'strike',\n          remove: 'all',\n          preserve_attributes: ['class', 'style']\n        };\n        const s = {\n          inline: 's',\n          remove: 'all',\n          preserve_attributes: ['class', 'style']\n        };\n        return schemaType !== 'html4' ? [s, span, strike] : [span, s, strike];\n      })(),\n      forecolor: {\n        inline: 'span',\n        styles: {\n          color: '%value'\n        },\n        links: true,\n        remove_similar: true,\n        clear_child_styles: true\n      },\n      hilitecolor: {\n        inline: 'span',\n        styles: {\n          backgroundColor: '%value'\n        },\n        links: true,\n        remove_similar: true,\n        clear_child_styles: true\n      },\n      fontname: {\n        inline: 'span',\n        toggle: false,\n        styles: {\n          fontFamily: '%value'\n        },\n        clear_child_styles: true\n      },\n      fontsize: {\n        inline: 'span',\n        toggle: false,\n        styles: {\n          fontSize: '%value'\n        },\n        clear_child_styles: true\n      },\n      lineheight: {\n        selector: 'h1,h2,h3,h4,h5,h6,p,li,td,th,div',\n        styles: {\n          lineHeight: '%value'\n        }\n      },\n      fontsize_class: {\n        inline: 'span',\n        attributes: {\n          class: '%value'\n        }\n      },\n      blockquote: {\n        block: 'blockquote',\n        wrapper: true,\n        remove: 'all'\n      },\n      subscript: {\n        inline: 'sub'\n      },\n      superscript: {\n        inline: 'sup'\n      },\n      code: {\n        inline: 'code'\n      },\n      link: {\n        inline: 'a',\n        selector: 'a',\n        remove: 'all',\n        split: true,\n        deep: true,\n        onmatch: (node, _fmt, _itemName) => {\n          return isElement$6(node) && node.hasAttribute('href');\n        },\n        onformat: (elm, _fmt, vars) => {\n          Tools.each(vars, (value, key) => {\n            dom.setAttrib(elm, key, value);\n          });\n        }\n      },\n      lang: {\n        inline: 'span',\n        clear_child_styles: true,\n        remove_similar: true,\n        attributes: {\n          'lang': '%value',\n          'data-mce-lang': vars => {\n            var _a;\n            return (_a = vars === null || vars === void 0 ? void 0 : vars.customValue) !== null && _a !== void 0 ? _a : null;\n          }\n        }\n      },\n      removeformat: [{\n        selector: 'b,strong,em,i,font,u,strike,s,sub,sup,dfn,code,samp,kbd,var,cite,mark,q,del,ins,small',\n        remove: 'all',\n        split: true,\n        expand: false,\n        block_expand: true,\n        deep: true\n      }, {\n        selector: 'span',\n        attributes: ['style', 'class'],\n        remove: 'empty',\n        split: true,\n        expand: false,\n        deep: true\n      }, {\n        selector: '*',\n        attributes: ['style', 'class'],\n        split: false,\n        expand: false,\n        deep: true\n      }]\n    };\n    Tools.each('p h1 h2 h3 h4 h5 h6 div address pre dt dd samp'.split(/\\s/), name => {\n      formats[name] = {\n        block: name,\n        remove: 'all'\n      };\n    });\n    return formats;\n  };\n  const genericBase = {\n    remove_similar: true,\n    inherit: false\n  };\n  const cellBase = {\n    selector: 'td,th',\n    ...genericBase\n  };\n  const cellFormats = {\n    tablecellbackgroundcolor: {\n      styles: {\n        backgroundColor: '%value'\n      },\n      ...cellBase\n    },\n    tablecellverticalalign: {\n      styles: {\n        'vertical-align': '%value'\n      },\n      ...cellBase\n    },\n    tablecellbordercolor: {\n      styles: {\n        borderColor: '%value'\n      },\n      ...cellBase\n    },\n    tablecellclass: {\n      classes: ['%value'],\n      ...cellBase\n    },\n    tableclass: {\n      selector: 'table',\n      classes: ['%value'],\n      ...genericBase\n    },\n    tablecellborderstyle: {\n      styles: {\n        borderStyle: '%value'\n      },\n      ...cellBase\n    },\n    tablecellborderwidth: {\n      styles: {\n        borderWidth: '%value'\n      },\n      ...cellBase\n    }\n  };\n  const get = constant(cellFormats);\n  const FormatRegistry = editor => {\n    const formats = {};\n    const get$2 = name => isNonNullable(name) ? formats[name] : formats;\n    const has = name => has$2(formats, name);\n    const register = (name, format) => {\n      if (name) {\n        if (!isString(name)) {\n          each$d(name, (format, name) => {\n            register(name, format);\n          });\n        } else {\n          if (!isArray$1(format)) {\n            format = [format];\n          }\n          each$e(format, format => {\n            if (isUndefined(format.deep)) {\n              format.deep = !isSelectorFormat(format);\n            }\n            if (isUndefined(format.split)) {\n              format.split = !isSelectorFormat(format) || isInlineFormat(format);\n            }\n            if (isUndefined(format.remove) && isSelectorFormat(format) && !isInlineFormat(format)) {\n              format.remove = 'none';\n            }\n            if (isSelectorFormat(format) && isInlineFormat(format)) {\n              format.mixed = true;\n              format.block_expand = true;\n            }\n            if (isString(format.classes)) {\n              format.classes = format.classes.split(/\\s+/);\n            }\n          });\n          formats[name] = format;\n        }\n      }\n    };\n    const unregister = name => {\n      if (name && formats[name]) {\n        delete formats[name];\n      }\n      return formats;\n    };\n    register(get$1(editor));\n    register(get());\n    register(getFormats(editor));\n    return {\n      get: get$2,\n      has,\n      register,\n      unregister\n    };\n  };\n  const each$3 = Tools.each;\n  const dom = DOMUtils.DOM;\n  const isPreviewItem = item => isNonNullable(item) && isObject(item);\n  const parsedSelectorToHtml = (ancestry, editor) => {\n    const schema = editor && editor.schema || Schema({});\n    const decorate = (elm, item) => {\n      if (item.classes.length > 0) {\n        dom.addClass(elm, item.classes.join(' '));\n      }\n      dom.setAttribs(elm, item.attrs);\n    };\n    const createElement = sItem => {\n      const item = isString(sItem) ? {\n        name: sItem,\n        classes: [],\n        attrs: {}\n      } : sItem;\n      const elm = dom.create(item.name);\n      decorate(elm, item);\n      return elm;\n    };\n    const getRequiredParent = (elm, candidate) => {\n      const elmRule = schema.getElementRule(elm.nodeName.toLowerCase());\n      const parentsRequired = elmRule === null || elmRule === void 0 ? void 0 : elmRule.parentsRequired;\n      if (parentsRequired && parentsRequired.length) {\n        return candidate && contains$2(parentsRequired, candidate) ? candidate : parentsRequired[0];\n      } else {\n        return false;\n      }\n    };\n    const wrapInHtml = (elm, ancestors, siblings) => {\n      let parentCandidate;\n      const ancestor = ancestors[0];\n      const ancestorName = isPreviewItem(ancestor) ? ancestor.name : undefined;\n      const parentRequired = getRequiredParent(elm, ancestorName);\n      if (parentRequired) {\n        if (ancestorName === parentRequired) {\n          parentCandidate = ancestor;\n          ancestors = ancestors.slice(1);\n        } else {\n          parentCandidate = parentRequired;\n        }\n      } else if (ancestor) {\n        parentCandidate = ancestor;\n        ancestors = ancestors.slice(1);\n      } else if (!siblings) {\n        return elm;\n      }\n      const parent = parentCandidate ? createElement(parentCandidate) : dom.create('div');\n      parent.appendChild(elm);\n      if (siblings) {\n        Tools.each(siblings, sibling => {\n          const siblingElm = createElement(sibling);\n          parent.insertBefore(siblingElm, elm);\n        });\n      }\n      const parentSiblings = isPreviewItem(parentCandidate) ? parentCandidate.siblings : undefined;\n      return wrapInHtml(parent, ancestors, parentSiblings);\n    };\n    const fragment = dom.create('div');\n    if (ancestry.length > 0) {\n      const item = ancestry[0];\n      const elm = createElement(item);\n      const siblings = isPreviewItem(item) ? item.siblings : undefined;\n      fragment.appendChild(wrapInHtml(elm, ancestry.slice(1), siblings));\n    }\n    return fragment;\n  };\n  const parseSelectorItem = item => {\n    item = Tools.trim(item);\n    let tagName = 'div';\n    const obj = {\n      name: tagName,\n      classes: [],\n      attrs: {},\n      selector: item\n    };\n    if (item !== '*') {\n      tagName = item.replace(/(?:([#\\.]|::?)([\\w\\-]+)|(\\[)([^\\]]+)\\]?)/g, ($0, $1, $2, $3, $4) => {\n        switch ($1) {\n          case '#':\n            obj.attrs.id = $2;\n            break;\n          case '.':\n            obj.classes.push($2);\n            break;\n          case ':':\n            if (Tools.inArray('checked disabled enabled read-only required'.split(' '), $2) !== -1) {\n              obj.attrs[$2] = $2;\n            }\n            break;\n        }\n        if ($3 === '[') {\n          const m = $4.match(/([\\w\\-]+)(?:\\=\\\"([^\\\"]+))?/);\n          if (m) {\n            obj.attrs[m[1]] = m[2];\n          }\n        }\n        return '';\n      });\n    }\n    obj.name = tagName || 'div';\n    return obj;\n  };\n  const parseSelector = selector => {\n    if (!isString(selector)) {\n      return [];\n    }\n    selector = selector.split(/\\s*,\\s*/)[0];\n    selector = selector.replace(/\\s*(~\\+|~|\\+|>)\\s*/g, '$1');\n    return Tools.map(selector.split(/(?:>|\\s+(?![^\\[\\]]+\\]))/), item => {\n      const siblings = Tools.map(item.split(/(?:~\\+|~|\\+)/), parseSelectorItem);\n      const obj = siblings.pop();\n      if (siblings.length) {\n        obj.siblings = siblings;\n      }\n      return obj;\n    }).reverse();\n  };\n  const getCssText = (editor, format) => {\n    let previewCss = '';\n    let previewStyles = getPreviewStyles(editor);\n    if (previewStyles === '') {\n      return '';\n    }\n    const removeVars = val => {\n      return isString(val) ? val.replace(/%(\\w+)/g, '') : '';\n    };\n    const getComputedStyle = (name, elm) => {\n      return dom.getStyle(elm !== null && elm !== void 0 ? elm : editor.getBody(), name, true);\n    };\n    if (isString(format)) {\n      const formats = editor.formatter.get(format);\n      if (!formats) {\n        return '';\n      }\n      format = formats[0];\n    }\n    if ('preview' in format) {\n      const preview = format.preview;\n      if (preview === false) {\n        return '';\n      } else {\n        previewStyles = preview || previewStyles;\n      }\n    }\n    let name = format.block || format.inline || 'span';\n    let previewFrag;\n    const items = parseSelector(format.selector);\n    if (items.length > 0) {\n      if (!items[0].name) {\n        items[0].name = name;\n      }\n      name = format.selector;\n      previewFrag = parsedSelectorToHtml(items, editor);\n    } else {\n      previewFrag = parsedSelectorToHtml([name], editor);\n    }\n    const previewElm = dom.select(name, previewFrag)[0] || previewFrag.firstChild;\n    each$3(format.styles, (value, name) => {\n      const newValue = removeVars(value);\n      if (newValue) {\n        dom.setStyle(previewElm, name, newValue);\n      }\n    });\n    each$3(format.attributes, (value, name) => {\n      const newValue = removeVars(value);\n      if (newValue) {\n        dom.setAttrib(previewElm, name, newValue);\n      }\n    });\n    each$3(format.classes, value => {\n      const newValue = removeVars(value);\n      if (!dom.hasClass(previewElm, newValue)) {\n        dom.addClass(previewElm, newValue);\n      }\n    });\n    editor.dispatch('PreviewFormats');\n    dom.setStyles(previewFrag, {\n      position: 'absolute',\n      left: -65535\n    });\n    editor.getBody().appendChild(previewFrag);\n    const rawParentFontSize = getComputedStyle('fontSize');\n    const parentFontSize = /px$/.test(rawParentFontSize) ? parseInt(rawParentFontSize, 10) : 0;\n    each$3(previewStyles.split(' '), name => {\n      let value = getComputedStyle(name, previewElm);\n      if (name === 'background-color' && /transparent|rgba\\s*\\([^)]+,\\s*0\\)/.test(value)) {\n        value = getComputedStyle(name);\n        if (rgbaToHexString(value).toLowerCase() === '#ffffff') {\n          return;\n        }\n      }\n      if (name === 'color') {\n        if (rgbaToHexString(value).toLowerCase() === '#000000') {\n          return;\n        }\n      }\n      if (name === 'font-size') {\n        if (/em|%$/.test(value)) {\n          if (parentFontSize === 0) {\n            return;\n          }\n          const numValue = parseFloat(value) / (/%$/.test(value) ? 100 : 1);\n          value = numValue * parentFontSize + 'px';\n        }\n      }\n      if (name === 'border' && value) {\n        previewCss += 'padding:0 2px;';\n      }\n      previewCss += name + ':' + value + ';';\n    });\n    editor.dispatch('AfterPreviewFormats');\n    dom.remove(previewFrag);\n    return previewCss;\n  };\n  const setup$s = editor => {\n    editor.addShortcut('meta+b', '', 'Bold');\n    editor.addShortcut('meta+i', '', 'Italic');\n    editor.addShortcut('meta+u', '', 'Underline');\n    for (let i = 1; i <= 6; i++) {\n      editor.addShortcut('access+' + i, '', ['FormatBlock', false, 'h' + i]);\n    }\n    editor.addShortcut('access+7', '', ['FormatBlock', false, 'p']);\n    editor.addShortcut('access+8', '', ['FormatBlock', false, 'div']);\n    editor.addShortcut('access+9', '', ['FormatBlock', false, 'address']);\n  };\n  const Formatter = editor => {\n    const formats = FormatRegistry(editor);\n    const formatChangeState = Cell({});\n    setup$s(editor);\n    setup$v(editor);\n    if (!isRtc(editor)) {\n      setup$u(formatChangeState, editor);\n    }\n    return {\n      get: formats.get,\n      has: formats.has,\n      register: formats.register,\n      unregister: formats.unregister,\n      apply: (name, vars, node) => {\n        applyFormat(editor, name, vars, node);\n      },\n      remove: (name, vars, node, similar) => {\n        removeFormat(editor, name, vars, node, similar);\n      },\n      toggle: (name, vars, node) => {\n        toggleFormat(editor, name, vars, node);\n      },\n      match: (name, vars, node, similar) => matchFormat(editor, name, vars, node, similar),\n      closest: names => closestFormat(editor, names),\n      matchAll: (names, vars) => matchAllFormats(editor, names, vars),\n      matchNode: (node, name, vars, similar) => matchNodeFormat(editor, node, name, vars, similar),\n      canApply: name => canApplyFormat(editor, name),\n      formatChanged: (formats, callback, similar, vars) => formatChanged(editor, formatChangeState, formats, callback, similar, vars),\n      getCssText: curry(getCssText, editor)\n    };\n  };\n  const shouldIgnoreCommand = cmd => {\n    switch (cmd.toLowerCase()) {\n      case 'undo':\n      case 'redo':\n      case 'mcefocus':\n        return true;\n      default:\n        return false;\n    }\n  };\n  const registerEvents = (editor, undoManager, locks) => {\n    const isFirstTypedCharacter = Cell(false);\n    const addNonTypingUndoLevel = e => {\n      setTyping(undoManager, false, locks);\n      undoManager.add({}, e);\n    };\n    editor.on('init', () => {\n      undoManager.add();\n    });\n    editor.on('BeforeExecCommand', e => {\n      const cmd = e.command;\n      if (!shouldIgnoreCommand(cmd)) {\n        endTyping(undoManager, locks);\n        undoManager.beforeChange();\n      }\n    });\n    editor.on('ExecCommand', e => {\n      const cmd = e.command;\n      if (!shouldIgnoreCommand(cmd)) {\n        addNonTypingUndoLevel(e);\n      }\n    });\n    editor.on('ObjectResizeStart cut', () => {\n      undoManager.beforeChange();\n    });\n    editor.on('SaveContent ObjectResized blur', addNonTypingUndoLevel);\n    editor.on('dragend', addNonTypingUndoLevel);\n    editor.on('keyup', e => {\n      const keyCode = e.keyCode;\n      if (e.isDefaultPrevented()) {\n        return;\n      }\n      const isMeta = Env.os.isMacOS() && e.key === 'Meta';\n      if (keyCode >= 33 && keyCode <= 36 || keyCode >= 37 && keyCode <= 40 || keyCode === 45 || e.ctrlKey || isMeta) {\n        addNonTypingUndoLevel();\n        editor.nodeChanged();\n      }\n      if (keyCode === 46 || keyCode === 8) {\n        editor.nodeChanged();\n      }\n      if (isFirstTypedCharacter.get() && undoManager.typing && !isEq$1(createFromEditor(editor), undoManager.data[0])) {\n        if (!editor.isDirty()) {\n          editor.setDirty(true);\n        }\n        editor.dispatch('TypingUndo');\n        isFirstTypedCharacter.set(false);\n        editor.nodeChanged();\n      }\n    });\n    editor.on('keydown', e => {\n      const keyCode = e.keyCode;\n      if (e.isDefaultPrevented()) {\n        return;\n      }\n      if (keyCode >= 33 && keyCode <= 36 || keyCode >= 37 && keyCode <= 40 || keyCode === 45) {\n        if (undoManager.typing) {\n          addNonTypingUndoLevel(e);\n        }\n        return;\n      }\n      const modKey = e.ctrlKey && !e.altKey || e.metaKey;\n      if ((keyCode < 16 || keyCode > 20) && keyCode !== 224 && keyCode !== 91 && !undoManager.typing && !modKey) {\n        undoManager.beforeChange();\n        setTyping(undoManager, true, locks);\n        undoManager.add({}, e);\n        isFirstTypedCharacter.set(true);\n        return;\n      }\n      const hasOnlyMetaOrCtrlModifier = Env.os.isMacOS() ? e.metaKey : e.ctrlKey && !e.altKey;\n      if (hasOnlyMetaOrCtrlModifier) {\n        undoManager.beforeChange();\n      }\n    });\n    editor.on('mousedown', e => {\n      if (undoManager.typing) {\n        addNonTypingUndoLevel(e);\n      }\n    });\n    const isInsertReplacementText = event => event.inputType === 'insertReplacementText';\n    const isInsertTextDataNull = event => event.inputType === 'insertText' && event.data === null;\n    const isInsertFromPasteOrDrop = event => event.inputType === 'insertFromPaste' || event.inputType === 'insertFromDrop';\n    editor.on('input', e => {\n      if (e.inputType && (isInsertReplacementText(e) || isInsertTextDataNull(e) || isInsertFromPasteOrDrop(e))) {\n        addNonTypingUndoLevel(e);\n      }\n    });\n    editor.on('AddUndo Undo Redo ClearUndos', e => {\n      if (!e.isDefaultPrevented()) {\n        editor.nodeChanged();\n      }\n    });\n  };\n  const addKeyboardShortcuts = editor => {\n    editor.addShortcut('meta+z', '', 'Undo');\n    editor.addShortcut('meta+y,meta+shift+z', '', 'Redo');\n  };\n  const UndoManager = editor => {\n    const beforeBookmark = value$2();\n    const locks = Cell(0);\n    const index = Cell(0);\n    const undoManager = {\n      data: [],\n      typing: false,\n      beforeChange: () => {\n        beforeChange(editor, locks, beforeBookmark);\n      },\n      add: (level, event) => {\n        return addUndoLevel(editor, undoManager, index, locks, beforeBookmark, level, event);\n      },\n      dispatchChange: () => {\n        editor.setDirty(true);\n        const level = createFromEditor(editor);\n        level.bookmark = getUndoBookmark(editor.selection);\n        editor.dispatch('change', {\n          level,\n          lastLevel: get$b(undoManager.data, index.get()).getOrUndefined()\n        });\n      },\n      undo: () => {\n        return undo(editor, undoManager, locks, index);\n      },\n      redo: () => {\n        return redo(editor, index, undoManager.data);\n      },\n      clear: () => {\n        clear(editor, undoManager, index);\n      },\n      reset: () => {\n        reset(editor, undoManager);\n      },\n      hasUndo: () => {\n        return hasUndo(editor, undoManager, index);\n      },\n      hasRedo: () => {\n        return hasRedo(editor, undoManager, index);\n      },\n      transact: callback => {\n        return transact(editor, undoManager, locks, callback);\n      },\n      ignore: callback => {\n        ignore(editor, locks, callback);\n      },\n      extra: (callback1, callback2) => {\n        extra(editor, undoManager, index, callback1, callback2);\n      }\n    };\n    if (!isRtc(editor)) {\n      registerEvents(editor, undoManager, locks);\n    }\n    addKeyboardShortcuts(editor);\n    return undoManager;\n  };\n  const nonTypingKeycodes = [9, 27, VK.HOME, VK.END, 19, 20, 44, 144, 145, 33, 34, 45, 16, 17, 18, 91, 92, 93, VK.DOWN, VK.UP, VK.LEFT, VK.RIGHT].concat(Env.browser.isFirefox() ? [224] : []);\n  const placeholderAttr = 'data-mce-placeholder';\n  const isKeyboardEvent = e => e.type === 'keydown' || e.type === 'keyup';\n  const isDeleteEvent = e => {\n    const keyCode = e.keyCode;\n    return keyCode === VK.BACKSPACE || keyCode === VK.DELETE;\n  };\n  const isNonTypingKeyboardEvent = e => {\n    if (isKeyboardEvent(e)) {\n      const keyCode = e.keyCode;\n      return !isDeleteEvent(e) && (VK.metaKeyPressed(e) || e.altKey || keyCode >= 112 && keyCode <= 123 || contains$2(nonTypingKeycodes, keyCode));\n    } else {\n      return false;\n    }\n  };\n  const isTypingKeyboardEvent = e => isKeyboardEvent(e) && !(isDeleteEvent(e) || e.type === 'keyup' && e.keyCode === 229);\n  const isVisuallyEmpty = (dom, rootElm, forcedRootBlock) => {\n    if (dom.isEmpty(rootElm, undefined, {\n      skipBogus: false,\n      includeZwsp: true\n    })) {\n      const firstElement = rootElm.firstElementChild;\n      if (!firstElement) {\n        return true;\n      } else if (dom.getStyle(rootElm.firstElementChild, 'padding-left') || dom.getStyle(rootElm.firstElementChild, 'padding-right')) {\n        return false;\n      } else {\n        return forcedRootBlock === firstElement.nodeName.toLowerCase();\n      }\n    } else {\n      return false;\n    }\n  };\n  const setup$r = editor => {\n    var _a;\n    const dom = editor.dom;\n    const rootBlock = getForcedRootBlock(editor);\n    const placeholder = (_a = getPlaceholder(editor)) !== null && _a !== void 0 ? _a : '';\n    const updatePlaceholder = (e, initial) => {\n      if (isNonTypingKeyboardEvent(e)) {\n        return;\n      }\n      const body = editor.getBody();\n      const showPlaceholder = isTypingKeyboardEvent(e) ? false : isVisuallyEmpty(dom, body, rootBlock);\n      const isPlaceholderShown = dom.getAttrib(body, placeholderAttr) !== '';\n      if (isPlaceholderShown !== showPlaceholder || initial) {\n        dom.setAttrib(body, placeholderAttr, showPlaceholder ? placeholder : null);\n        firePlaceholderToggle(editor, showPlaceholder);\n        editor.on(showPlaceholder ? 'keydown' : 'keyup', updatePlaceholder);\n        editor.off(showPlaceholder ? 'keyup' : 'keydown', updatePlaceholder);\n      }\n    };\n    if (isNotEmpty(placeholder)) {\n      editor.on('init', e => {\n        updatePlaceholder(e, true);\n        editor.on('change SetContent ExecCommand', updatePlaceholder);\n        editor.on('paste', e => Delay.setEditorTimeout(editor, () => updatePlaceholder(e)));\n      });\n    }\n  };\n  const blockPosition = (block, position) => ({\n    block,\n    position\n  });\n  const blockBoundary = (from, to) => ({\n    from,\n    to\n  });\n  const getBlockPosition = (rootNode, pos) => {\n    const rootElm = SugarElement.fromDom(rootNode);\n    const containerElm = SugarElement.fromDom(pos.container());\n    return getParentBlock$2(rootElm, containerElm).map(block => blockPosition(block, pos));\n  };\n  const isNotAncestorial = blockBoundary => !(contains(blockBoundary.to.block, blockBoundary.from.block) || contains(blockBoundary.from.block, blockBoundary.to.block));\n  const isDifferentBlocks = blockBoundary => !eq(blockBoundary.from.block, blockBoundary.to.block);\n  const getClosestHost = (root, scope) => {\n    const isRoot = node => eq(node, root);\n    const isHost = node => isTableCell$2(node) || isContentEditableTrue$3(node.dom);\n    return closest$4(scope, isHost, isRoot).filter(isElement$7).getOr(root);\n  };\n  const hasSameHost = (rootNode, blockBoundary) => {\n    const root = SugarElement.fromDom(rootNode);\n    return eq(getClosestHost(root, blockBoundary.from.block), getClosestHost(root, blockBoundary.to.block));\n  };\n  const isEditable$1 = blockBoundary => isContentEditableFalse$b(blockBoundary.from.block.dom) === false && isContentEditableFalse$b(blockBoundary.to.block.dom) === false;\n  const hasValidBlocks = blockBoundary => {\n    const isValidBlock = block => isTextBlock$2(block) || hasBlockAttr(block.dom) || isListItem$1(block);\n    return isValidBlock(blockBoundary.from.block) && isValidBlock(blockBoundary.to.block);\n  };\n  const skipLastBr = (schema, rootNode, forward, blockPosition) => {\n    if (isBr$6(blockPosition.position.getNode()) && !isEmpty$2(schema, blockPosition.block)) {\n      return positionIn(false, blockPosition.block.dom).bind(lastPositionInBlock => {\n        if (lastPositionInBlock.isEqual(blockPosition.position)) {\n          return fromPosition(forward, rootNode, lastPositionInBlock).bind(to => getBlockPosition(rootNode, to));\n        } else {\n          return Optional.some(blockPosition);\n        }\n      }).getOr(blockPosition);\n    } else {\n      return blockPosition;\n    }\n  };\n  const readFromRange = (schema, rootNode, forward, rng) => {\n    const fromBlockPos = getBlockPosition(rootNode, CaretPosition.fromRangeStart(rng));\n    const toBlockPos = fromBlockPos.bind(blockPos => fromPosition(forward, rootNode, blockPos.position).bind(to => getBlockPosition(rootNode, to).map(blockPos => skipLastBr(schema, rootNode, forward, blockPos))));\n    return lift2(fromBlockPos, toBlockPos, blockBoundary).filter(blockBoundary => isDifferentBlocks(blockBoundary) && hasSameHost(rootNode, blockBoundary) && isEditable$1(blockBoundary) && hasValidBlocks(blockBoundary) && isNotAncestorial(blockBoundary));\n  };\n  const read$1 = (schema, rootNode, forward, rng) => rng.collapsed ? readFromRange(schema, rootNode, forward, rng) : Optional.none();\n  const getChildrenUntilBlockBoundary = (block, schema) => {\n    const children = children$1(block);\n    return findIndex$2(children, el => schema.isBlock(name(el))).fold(constant(children), index => children.slice(0, index));\n  };\n  const extractChildren = (block, schema) => {\n    const children = getChildrenUntilBlockBoundary(block, schema);\n    each$e(children, remove$4);\n    return children;\n  };\n  const removeEmptyRoot = (schema, rootNode, block) => {\n    const parents = parentsAndSelf(block, rootNode);\n    return find$2(parents.reverse(), element => isEmpty$2(schema, element)).each(remove$4);\n  };\n  const isEmptyBefore = (schema, el) => filter$5(prevSiblings(el), el => !isEmpty$2(schema, el)).length === 0;\n  const nestedBlockMerge = (rootNode, fromBlock, toBlock, schema, insertionPoint) => {\n    if (isEmpty$2(schema, toBlock)) {\n      fillWithPaddingBr(toBlock);\n      return firstPositionIn(toBlock.dom);\n    }\n    if (isEmptyBefore(schema, insertionPoint) && isEmpty$2(schema, fromBlock)) {\n      before$3(insertionPoint, SugarElement.fromTag('br'));\n    }\n    const position = prevPosition(toBlock.dom, CaretPosition.before(insertionPoint.dom));\n    each$e(extractChildren(fromBlock, schema), child => {\n      before$3(insertionPoint, child);\n    });\n    removeEmptyRoot(schema, rootNode, fromBlock);\n    return position;\n  };\n  const isInline = (schema, node) => schema.isInline(name(node));\n  const sidelongBlockMerge = (rootNode, fromBlock, toBlock, schema) => {\n    if (isEmpty$2(schema, toBlock)) {\n      if (isEmpty$2(schema, fromBlock)) {\n        const getInlineToBlockDescendants = el => {\n          const helper = (node, elements) => firstChild(node).fold(() => elements, child => isInline(schema, child) ? helper(child, elements.concat(shallow$1(child))) : elements);\n          return helper(el, []);\n        };\n        const newFromBlockDescendants = foldr(getInlineToBlockDescendants(toBlock), (element, descendant) => {\n          wrap$2(element, descendant);\n          return descendant;\n        }, createPaddingBr());\n        empty(fromBlock);\n        append$1(fromBlock, newFromBlockDescendants);\n      }\n      remove$4(toBlock);\n      return firstPositionIn(fromBlock.dom);\n    }\n    const position = lastPositionIn(toBlock.dom);\n    each$e(extractChildren(fromBlock, schema), child => {\n      append$1(toBlock, child);\n    });\n    removeEmptyRoot(schema, rootNode, fromBlock);\n    return position;\n  };\n  const findInsertionPoint = (toBlock, block) => {\n    const parentsAndSelf$1 = parentsAndSelf(block, toBlock);\n    return Optional.from(parentsAndSelf$1[parentsAndSelf$1.length - 1]);\n  };\n  const getInsertionPoint = (fromBlock, toBlock) => contains(toBlock, fromBlock) ? findInsertionPoint(toBlock, fromBlock) : Optional.none();\n  const trimBr = (first, block) => {\n    positionIn(first, block.dom).bind(position => Optional.from(position.getNode())).map(SugarElement.fromDom).filter(isBr$5).each(remove$4);\n  };\n  const mergeBlockInto = (rootNode, fromBlock, toBlock, schema) => {\n    trimBr(true, fromBlock);\n    trimBr(false, toBlock);\n    return getInsertionPoint(fromBlock, toBlock).fold(curry(sidelongBlockMerge, rootNode, fromBlock, toBlock, schema), curry(nestedBlockMerge, rootNode, fromBlock, toBlock, schema));\n  };\n  const mergeBlocks = (rootNode, forward, block1, block2, schema) => forward ? mergeBlockInto(rootNode, block2, block1, schema) : mergeBlockInto(rootNode, block1, block2, schema);\n  const backspaceDelete$a = (editor, forward) => {\n    const rootNode = SugarElement.fromDom(editor.getBody());\n    const position = read$1(editor.schema, rootNode.dom, forward, editor.selection.getRng()).map(blockBoundary => () => {\n      mergeBlocks(rootNode, forward, blockBoundary.from.block, blockBoundary.to.block, editor.schema).each(pos => {\n        editor.selection.setRng(pos.toRange());\n      });\n    });\n    return position;\n  };\n  const deleteRangeMergeBlocks = (rootNode, selection, schema) => {\n    const rng = selection.getRng();\n    return lift2(getParentBlock$2(rootNode, SugarElement.fromDom(rng.startContainer)), getParentBlock$2(rootNode, SugarElement.fromDom(rng.endContainer)), (block1, block2) => {\n      if (!eq(block1, block2)) {\n        return Optional.some(() => {\n          rng.deleteContents();\n          mergeBlocks(rootNode, true, block1, block2, schema).each(pos => {\n            selection.setRng(pos.toRange());\n          });\n        });\n      } else {\n        return Optional.none();\n      }\n    }).getOr(Optional.none());\n  };\n  const isRawNodeInTable = (root, rawNode) => {\n    const node = SugarElement.fromDom(rawNode);\n    const isRoot = curry(eq, root);\n    return ancestor$4(node, isTableCell$2, isRoot).isSome();\n  };\n  const isSelectionInTable = (root, rng) => isRawNodeInTable(root, rng.startContainer) || isRawNodeInTable(root, rng.endContainer);\n  const isEverythingSelected = (root, rng) => {\n    const noPrevious = prevPosition(root.dom, CaretPosition.fromRangeStart(rng)).isNone();\n    const noNext = nextPosition(root.dom, CaretPosition.fromRangeEnd(rng)).isNone();\n    return !isSelectionInTable(root, rng) && noPrevious && noNext;\n  };\n  const emptyEditor = editor => {\n    return Optional.some(() => {\n      editor.setContent('');\n      editor.selection.setCursorLocation();\n    });\n  };\n  const deleteRange$2 = editor => {\n    const rootNode = SugarElement.fromDom(editor.getBody());\n    const rng = editor.selection.getRng();\n    return isEverythingSelected(rootNode, rng) ? emptyEditor(editor) : deleteRangeMergeBlocks(rootNode, editor.selection, editor.schema);\n  };\n  const backspaceDelete$9 = (editor, _forward) => editor.selection.isCollapsed() ? Optional.none() : deleteRange$2(editor);\n  const showCaret = (direction, editor, node, before, scrollIntoView) => Optional.from(editor._selectionOverrides.showCaret(direction, node, before, scrollIntoView));\n  const getNodeRange = node => {\n    const rng = node.ownerDocument.createRange();\n    rng.selectNode(node);\n    return rng;\n  };\n  const selectNode = (editor, node) => {\n    const e = editor.dispatch('BeforeObjectSelected', {\n      target: node\n    });\n    if (e.isDefaultPrevented()) {\n      return Optional.none();\n    }\n    return Optional.some(getNodeRange(node));\n  };\n  const renderCaretAtRange = (editor, range, scrollIntoView) => {\n    const normalizedRange = normalizeRange(1, editor.getBody(), range);\n    const caretPosition = CaretPosition.fromRangeStart(normalizedRange);\n    const caretPositionNode = caretPosition.getNode();\n    if (isInlineFakeCaretTarget(caretPositionNode)) {\n      return showCaret(1, editor, caretPositionNode, !caretPosition.isAtEnd(), false);\n    }\n    const caretPositionBeforeNode = caretPosition.getNode(true);\n    if (isInlineFakeCaretTarget(caretPositionBeforeNode)) {\n      return showCaret(1, editor, caretPositionBeforeNode, false, false);\n    }\n    const ceRoot = getContentEditableRoot$1(editor.dom.getRoot(), caretPosition.getNode());\n    if (isInlineFakeCaretTarget(ceRoot)) {\n      return showCaret(1, editor, ceRoot, false, scrollIntoView);\n    }\n    return Optional.none();\n  };\n  const renderRangeCaret = (editor, range, scrollIntoView) => range.collapsed ? renderCaretAtRange(editor, range, scrollIntoView).getOr(range) : range;\n  const isBeforeBoundary = pos => isBeforeContentEditableFalse(pos) || isBeforeMedia(pos);\n  const isAfterBoundary = pos => isAfterContentEditableFalse(pos) || isAfterMedia(pos);\n  const trimEmptyTextNode = (dom, node) => {\n    if (isText$b(node) && node.data.length === 0) {\n      dom.remove(node);\n    }\n  };\n  const deleteContentAndShowCaret = (editor, range, node, direction, forward, peekCaretPosition) => {\n    showCaret(direction, editor, peekCaretPosition.getNode(!forward), forward, true).each(caretRange => {\n      if (range.collapsed) {\n        const deleteRange = range.cloneRange();\n        if (forward) {\n          deleteRange.setEnd(caretRange.startContainer, caretRange.startOffset);\n        } else {\n          deleteRange.setStart(caretRange.endContainer, caretRange.endOffset);\n        }\n        deleteRange.deleteContents();\n      } else {\n        range.deleteContents();\n      }\n      editor.selection.setRng(caretRange);\n    });\n    trimEmptyTextNode(editor.dom, node);\n  };\n  const deleteBoundaryText = (editor, forward) => {\n    const range = editor.selection.getRng();\n    if (!isText$b(range.commonAncestorContainer)) {\n      return Optional.none();\n    }\n    const direction = forward ? HDirection.Forwards : HDirection.Backwards;\n    const caretWalker = CaretWalker(editor.getBody());\n    const getNextPosFn = curry(getVisualCaretPosition, forward ? caretWalker.next : caretWalker.prev);\n    const isBeforeFn = forward ? isBeforeBoundary : isAfterBoundary;\n    const caretPosition = getNormalizedRangeEndPoint(direction, editor.getBody(), range);\n    const nextCaretPosition = getNextPosFn(caretPosition);\n    const normalizedNextCaretPosition = nextCaretPosition ? normalizePosition(forward, nextCaretPosition) : nextCaretPosition;\n    if (!normalizedNextCaretPosition || !isMoveInsideSameBlock(caretPosition, normalizedNextCaretPosition)) {\n      return Optional.none();\n    } else if (isBeforeFn(normalizedNextCaretPosition)) {\n      return Optional.some(() => deleteContentAndShowCaret(editor, range, caretPosition.getNode(), direction, forward, normalizedNextCaretPosition));\n    }\n    const peekCaretPosition = getNextPosFn(normalizedNextCaretPosition);\n    if (peekCaretPosition && isBeforeFn(peekCaretPosition)) {\n      if (isMoveInsideSameBlock(normalizedNextCaretPosition, peekCaretPosition)) {\n        return Optional.some(() => deleteContentAndShowCaret(editor, range, caretPosition.getNode(), direction, forward, peekCaretPosition));\n      }\n    }\n    return Optional.none();\n  };\n  const backspaceDelete$8 = (editor, forward) => deleteBoundaryText(editor, forward);\n  const getEdgeCefPosition = (editor, atStart) => {\n    const root = editor.getBody();\n    return atStart ? firstPositionIn(root).filter(isBeforeContentEditableFalse) : lastPositionIn(root).filter(isAfterContentEditableFalse);\n  };\n  const isCefAtEdgeSelected = editor => {\n    const rng = editor.selection.getRng();\n    return !rng.collapsed && (getEdgeCefPosition(editor, true).exists(pos => pos.isEqual(CaretPosition.fromRangeStart(rng))) || getEdgeCefPosition(editor, false).exists(pos => pos.isEqual(CaretPosition.fromRangeEnd(rng))));\n  };\n  const isCompoundElement = node => isNonNullable(node) && (isTableCell$2(SugarElement.fromDom(node)) || isListItem$1(SugarElement.fromDom(node)));\n  const DeleteAction = Adt.generate([{\n    remove: ['element']\n  }, {\n    moveToElement: ['element']\n  }, {\n    moveToPosition: ['position']\n  }]);\n  const isAtContentEditableBlockCaret = (forward, from) => {\n    const elm = from.getNode(!forward);\n    const caretLocation = forward ? 'after' : 'before';\n    return isElement$6(elm) && elm.getAttribute('data-mce-caret') === caretLocation;\n  };\n  const isDeleteFromCefDifferentBlocks = (root, forward, from, to, schema) => {\n    const inSameBlock = elm => schema.isInline(elm.nodeName.toLowerCase()) && !isInSameBlock(from, to, root);\n    return getRelativeCefElm(!forward, from).fold(() => getRelativeCefElm(forward, to).fold(never, inSameBlock), inSameBlock);\n  };\n  const deleteEmptyBlockOrMoveToCef = (schema, root, forward, from, to) => {\n    const toCefElm = to.getNode(!forward);\n    return getParentBlock$2(SugarElement.fromDom(root), SugarElement.fromDom(from.getNode())).map(blockElm => isEmpty$2(schema, blockElm) ? DeleteAction.remove(blockElm.dom) : DeleteAction.moveToElement(toCefElm)).orThunk(() => Optional.some(DeleteAction.moveToElement(toCefElm)));\n  };\n  const findCefPosition = (root, forward, from, schema) => fromPosition(forward, root, from).bind(to => {\n    if (isCompoundElement(to.getNode())) {\n      return Optional.none();\n    } else if (isDeleteFromCefDifferentBlocks(root, forward, from, to, schema)) {\n      return Optional.none();\n    } else if (forward && isContentEditableFalse$b(to.getNode())) {\n      return deleteEmptyBlockOrMoveToCef(schema, root, forward, from, to);\n    } else if (!forward && isContentEditableFalse$b(to.getNode(true))) {\n      return deleteEmptyBlockOrMoveToCef(schema, root, forward, from, to);\n    } else if (forward && isAfterContentEditableFalse(from)) {\n      return Optional.some(DeleteAction.moveToPosition(to));\n    } else if (!forward && isBeforeContentEditableFalse(from)) {\n      return Optional.some(DeleteAction.moveToPosition(to));\n    } else {\n      return Optional.none();\n    }\n  });\n  const getContentEditableBlockAction = (forward, elm) => {\n    if (isNullable(elm)) {\n      return Optional.none();\n    } else if (forward && isContentEditableFalse$b(elm.nextSibling)) {\n      return Optional.some(DeleteAction.moveToElement(elm.nextSibling));\n    } else if (!forward && isContentEditableFalse$b(elm.previousSibling)) {\n      return Optional.some(DeleteAction.moveToElement(elm.previousSibling));\n    } else {\n      return Optional.none();\n    }\n  };\n  const skipMoveToActionFromInlineCefToContent = (root, from, deleteAction) => deleteAction.fold(elm => Optional.some(DeleteAction.remove(elm)), elm => Optional.some(DeleteAction.moveToElement(elm)), to => {\n    if (isInSameBlock(from, to, root)) {\n      return Optional.none();\n    } else {\n      return Optional.some(DeleteAction.moveToPosition(to));\n    }\n  });\n  const getContentEditableAction = (root, forward, from, schema) => {\n    if (isAtContentEditableBlockCaret(forward, from)) {\n      return getContentEditableBlockAction(forward, from.getNode(!forward)).orThunk(() => findCefPosition(root, forward, from, schema));\n    } else {\n      return findCefPosition(root, forward, from, schema).bind(deleteAction => skipMoveToActionFromInlineCefToContent(root, from, deleteAction));\n    }\n  };\n  const read = (root, forward, rng, schema) => {\n    const normalizedRange = normalizeRange(forward ? 1 : -1, root, rng);\n    const from = CaretPosition.fromRangeStart(normalizedRange);\n    const rootElement = SugarElement.fromDom(root);\n    if (!forward && isAfterContentEditableFalse(from)) {\n      return Optional.some(DeleteAction.remove(from.getNode(true)));\n    } else if (forward && isBeforeContentEditableFalse(from)) {\n      return Optional.some(DeleteAction.remove(from.getNode()));\n    } else if (!forward && isBeforeContentEditableFalse(from) && isAfterBr(rootElement, from, schema)) {\n      return findPreviousBr(rootElement, from, schema).map(br => DeleteAction.remove(br.getNode()));\n    } else if (forward && isAfterContentEditableFalse(from) && isBeforeBr$1(rootElement, from, schema)) {\n      return findNextBr(rootElement, from, schema).map(br => DeleteAction.remove(br.getNode()));\n    } else {\n      return getContentEditableAction(root, forward, from, schema);\n    }\n  };\n  const deleteElement$1 = (editor, forward) => element => {\n    editor._selectionOverrides.hideFakeCaret();\n    deleteElement$2(editor, forward, SugarElement.fromDom(element));\n    return true;\n  };\n  const moveToElement = (editor, forward) => element => {\n    const pos = forward ? CaretPosition.before(element) : CaretPosition.after(element);\n    editor.selection.setRng(pos.toRange());\n    return true;\n  };\n  const moveToPosition = editor => pos => {\n    editor.selection.setRng(pos.toRange());\n    return true;\n  };\n  const getAncestorCe = (editor, node) => Optional.from(getContentEditableRoot$1(editor.getBody(), node));\n  const backspaceDeleteCaret = (editor, forward) => {\n    const selectedNode = editor.selection.getNode();\n    return getAncestorCe(editor, selectedNode).filter(isContentEditableFalse$b).fold(() => read(editor.getBody(), forward, editor.selection.getRng(), editor.schema).map(deleteAction => () => deleteAction.fold(deleteElement$1(editor, forward), moveToElement(editor, forward), moveToPosition(editor))), () => Optional.some(noop));\n  };\n  const deleteOffscreenSelection = rootElement => {\n    each$e(descendants(rootElement, '.mce-offscreen-selection'), remove$4);\n  };\n  const backspaceDeleteRange = (editor, forward) => {\n    const selectedNode = editor.selection.getNode();\n    if (isContentEditableFalse$b(selectedNode) && !isTableCell$3(selectedNode)) {\n      const hasCefAncestor = getAncestorCe(editor, selectedNode.parentNode).filter(isContentEditableFalse$b);\n      return hasCefAncestor.fold(() => Optional.some(() => {\n        deleteOffscreenSelection(SugarElement.fromDom(editor.getBody()));\n        deleteElement$2(editor, forward, SugarElement.fromDom(editor.selection.getNode()));\n        paddEmptyBody(editor);\n      }), () => Optional.some(noop));\n    }\n    if (isCefAtEdgeSelected(editor)) {\n      return Optional.some(() => {\n        deleteRangeContents(editor, editor.selection.getRng(), SugarElement.fromDom(editor.getBody()));\n      });\n    }\n    return Optional.none();\n  };\n  const paddEmptyElement = editor => {\n    const dom = editor.dom,\n      selection = editor.selection;\n    const ceRoot = getContentEditableRoot$1(editor.getBody(), selection.getNode());\n    if (isContentEditableTrue$3(ceRoot) && dom.isBlock(ceRoot) && dom.isEmpty(ceRoot)) {\n      const br = dom.create('br', {\n        'data-mce-bogus': '1'\n      });\n      dom.setHTML(ceRoot, '');\n      ceRoot.appendChild(br);\n      selection.setRng(CaretPosition.before(br).toRange());\n    }\n    return true;\n  };\n  const backspaceDelete$7 = (editor, forward) => {\n    if (editor.selection.isCollapsed()) {\n      return backspaceDeleteCaret(editor, forward);\n    } else {\n      return backspaceDeleteRange(editor, forward);\n    }\n  };\n  const isTextEndpoint = endpoint => endpoint.hasOwnProperty('text');\n  const isElementEndpoint = endpoint => endpoint.hasOwnProperty('marker');\n  const getBookmark = (range, createMarker) => {\n    const getEndpoint = (container, offset) => {\n      if (isText$b(container)) {\n        return {\n          text: container,\n          offset\n        };\n      } else {\n        const marker = createMarker();\n        const children = container.childNodes;\n        if (offset < children.length) {\n          container.insertBefore(marker, children[offset]);\n          return {\n            marker,\n            before: true\n          };\n        } else {\n          container.appendChild(marker);\n          return {\n            marker,\n            before: false\n          };\n        }\n      }\n    };\n    const end = getEndpoint(range.endContainer, range.endOffset);\n    const start = getEndpoint(range.startContainer, range.startOffset);\n    return {\n      start,\n      end\n    };\n  };\n  const resolveBookmark = bm => {\n    var _a, _b;\n    const {\n      start,\n      end\n    } = bm;\n    const rng = new window.Range();\n    if (isTextEndpoint(start)) {\n      rng.setStart(start.text, start.offset);\n    } else {\n      if (isElementEndpoint(start)) {\n        if (start.before) {\n          rng.setStartBefore(start.marker);\n        } else {\n          rng.setStartAfter(start.marker);\n        }\n        (_a = start.marker.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(start.marker);\n      }\n    }\n    if (isTextEndpoint(end)) {\n      rng.setEnd(end.text, end.offset);\n    } else {\n      if (isElementEndpoint(end)) {\n        if (end.before) {\n          rng.setEndBefore(end.marker);\n        } else {\n          rng.setEndAfter(end.marker);\n        }\n        (_b = end.marker.parentNode) === null || _b === void 0 ? void 0 : _b.removeChild(end.marker);\n      }\n    }\n    return rng;\n  };\n  const backspaceDelete$6 = (editor, forward) => {\n    var _a;\n    const dom = editor.dom;\n    const startBlock = dom.getParent(editor.selection.getStart(), dom.isBlock);\n    const endBlock = dom.getParent(editor.selection.getEnd(), dom.isBlock);\n    const body = editor.getBody();\n    const startBlockName = (_a = startBlock === null || startBlock === void 0 ? void 0 : startBlock.nodeName) === null || _a === void 0 ? void 0 : _a.toLowerCase();\n    if (startBlockName === 'div' && startBlock && endBlock && startBlock === body.firstChild && endBlock === body.lastChild && !dom.isEmpty(body)) {\n      const wrapper = startBlock.cloneNode(false);\n      const deleteAction = () => {\n        if (forward) {\n          execNativeForwardDeleteCommand(editor);\n        } else {\n          execNativeDeleteCommand(editor);\n        }\n        if (body.firstChild !== startBlock) {\n          const bookmark = getBookmark(editor.selection.getRng(), () => document.createElement('span'));\n          Array.from(body.childNodes).forEach(node => wrapper.appendChild(node));\n          body.appendChild(wrapper);\n          editor.selection.setRng(resolveBookmark(bookmark));\n        }\n      };\n      return Optional.some(deleteAction);\n    }\n    return Optional.none();\n  };\n  const deleteCaret$2 = (editor, forward) => {\n    const fromPos = CaretPosition.fromRangeStart(editor.selection.getRng());\n    return fromPosition(forward, editor.getBody(), fromPos).filter(pos => forward ? isBeforeImageBlock(pos) : isAfterImageBlock(pos)).bind(pos => getChildNodeAtRelativeOffset(forward ? 0 : -1, pos)).map(elm => () => editor.selection.select(elm));\n  };\n  const backspaceDelete$5 = (editor, forward) => editor.selection.isCollapsed() ? deleteCaret$2(editor, forward) : Optional.none();\n  const isText$2 = isText$b;\n  const startsWithCaretContainer = node => isText$2(node) && node.data[0] === ZWSP$1;\n  const endsWithCaretContainer = node => isText$2(node) && node.data[node.data.length - 1] === ZWSP$1;\n  const createZwsp = node => {\n    var _a;\n    const doc = (_a = node.ownerDocument) !== null && _a !== void 0 ? _a : document;\n    return doc.createTextNode(ZWSP$1);\n  };\n  const insertBefore$1 = node => {\n    var _a;\n    if (isText$2(node.previousSibling)) {\n      if (endsWithCaretContainer(node.previousSibling)) {\n        return node.previousSibling;\n      } else {\n        node.previousSibling.appendData(ZWSP$1);\n        return node.previousSibling;\n      }\n    } else if (isText$2(node)) {\n      if (startsWithCaretContainer(node)) {\n        return node;\n      } else {\n        node.insertData(0, ZWSP$1);\n        return node;\n      }\n    } else {\n      const newNode = createZwsp(node);\n      (_a = node.parentNode) === null || _a === void 0 ? void 0 : _a.insertBefore(newNode, node);\n      return newNode;\n    }\n  };\n  const insertAfter$1 = node => {\n    var _a, _b;\n    if (isText$2(node.nextSibling)) {\n      if (startsWithCaretContainer(node.nextSibling)) {\n        return node.nextSibling;\n      } else {\n        node.nextSibling.insertData(0, ZWSP$1);\n        return node.nextSibling;\n      }\n    } else if (isText$2(node)) {\n      if (endsWithCaretContainer(node)) {\n        return node;\n      } else {\n        node.appendData(ZWSP$1);\n        return node;\n      }\n    } else {\n      const newNode = createZwsp(node);\n      if (node.nextSibling) {\n        (_a = node.parentNode) === null || _a === void 0 ? void 0 : _a.insertBefore(newNode, node.nextSibling);\n      } else {\n        (_b = node.parentNode) === null || _b === void 0 ? void 0 : _b.appendChild(newNode);\n      }\n      return newNode;\n    }\n  };\n  const insertInline = (before, node) => before ? insertBefore$1(node) : insertAfter$1(node);\n  const insertInlineBefore = curry(insertInline, true);\n  const insertInlineAfter = curry(insertInline, false);\n  const insertInlinePos = (pos, before) => {\n    if (isText$b(pos.container())) {\n      return insertInline(before, pos.container());\n    } else {\n      return insertInline(before, pos.getNode());\n    }\n  };\n  const isPosCaretContainer = (pos, caret) => {\n    const caretNode = caret.get();\n    return caretNode && pos.container() === caretNode && isCaretContainerInline(caretNode);\n  };\n  const renderCaret = (caret, location) => location.fold(element => {\n    remove$2(caret.get());\n    const text = insertInlineBefore(element);\n    caret.set(text);\n    return Optional.some(CaretPosition(text, text.length - 1));\n  }, element => firstPositionIn(element).map(pos => {\n    if (!isPosCaretContainer(pos, caret)) {\n      remove$2(caret.get());\n      const text = insertInlinePos(pos, true);\n      caret.set(text);\n      return CaretPosition(text, 1);\n    } else {\n      const node = caret.get();\n      return CaretPosition(node, 1);\n    }\n  }), element => lastPositionIn(element).map(pos => {\n    if (!isPosCaretContainer(pos, caret)) {\n      remove$2(caret.get());\n      const text = insertInlinePos(pos, false);\n      caret.set(text);\n      return CaretPosition(text, text.length - 1);\n    } else {\n      const node = caret.get();\n      return CaretPosition(node, node.length - 1);\n    }\n  }), element => {\n    remove$2(caret.get());\n    const text = insertInlineAfter(element);\n    caret.set(text);\n    return Optional.some(CaretPosition(text, 1));\n  });\n  const evaluateUntil = (fns, args) => {\n    for (let i = 0; i < fns.length; i++) {\n      const result = fns[i].apply(null, args);\n      if (result.isSome()) {\n        return result;\n      }\n    }\n    return Optional.none();\n  };\n  const Location = Adt.generate([{\n    before: ['element']\n  }, {\n    start: ['element']\n  }, {\n    end: ['element']\n  }, {\n    after: ['element']\n  }]);\n  const rescope$1 = (rootNode, node) => {\n    const parentBlock = getParentBlock$3(node, rootNode);\n    return parentBlock ? parentBlock : rootNode;\n  };\n  const before = (isInlineTarget, rootNode, pos) => {\n    const nPos = normalizeForwards(pos);\n    const scope = rescope$1(rootNode, nPos.container());\n    return findRootInline(isInlineTarget, scope, nPos).fold(() => nextPosition(scope, nPos).bind(curry(findRootInline, isInlineTarget, scope)).map(inline => Location.before(inline)), Optional.none);\n  };\n  const isNotInsideFormatCaretContainer = (rootNode, elm) => getParentCaretContainer(rootNode, elm) === null;\n  const findInsideRootInline = (isInlineTarget, rootNode, pos) => findRootInline(isInlineTarget, rootNode, pos).filter(curry(isNotInsideFormatCaretContainer, rootNode));\n  const start$1 = (isInlineTarget, rootNode, pos) => {\n    const nPos = normalizeBackwards(pos);\n    return findInsideRootInline(isInlineTarget, rootNode, nPos).bind(inline => {\n      const prevPos = prevPosition(inline, nPos);\n      return prevPos.isNone() ? Optional.some(Location.start(inline)) : Optional.none();\n    });\n  };\n  const end = (isInlineTarget, rootNode, pos) => {\n    const nPos = normalizeForwards(pos);\n    return findInsideRootInline(isInlineTarget, rootNode, nPos).bind(inline => {\n      const nextPos = nextPosition(inline, nPos);\n      return nextPos.isNone() ? Optional.some(Location.end(inline)) : Optional.none();\n    });\n  };\n  const after = (isInlineTarget, rootNode, pos) => {\n    const nPos = normalizeBackwards(pos);\n    const scope = rescope$1(rootNode, nPos.container());\n    return findRootInline(isInlineTarget, scope, nPos).fold(() => prevPosition(scope, nPos).bind(curry(findRootInline, isInlineTarget, scope)).map(inline => Location.after(inline)), Optional.none);\n  };\n  const isValidLocation = location => !isRtl(getElement(location));\n  const readLocation = (isInlineTarget, rootNode, pos) => {\n    const location = evaluateUntil([before, start$1, end, after], [isInlineTarget, rootNode, pos]);\n    return location.filter(isValidLocation);\n  };\n  const getElement = location => location.fold(identity, identity, identity, identity);\n  const getName = location => location.fold(constant('before'), constant('start'), constant('end'), constant('after'));\n  const outside = location => location.fold(Location.before, Location.before, Location.after, Location.after);\n  const inside = location => location.fold(Location.start, Location.start, Location.end, Location.end);\n  const isEq = (location1, location2) => getName(location1) === getName(location2) && getElement(location1) === getElement(location2);\n  const betweenInlines = (forward, isInlineTarget, rootNode, from, to, location) => lift2(findRootInline(isInlineTarget, rootNode, from), findRootInline(isInlineTarget, rootNode, to), (fromInline, toInline) => {\n    if (fromInline !== toInline && hasSameParentBlock(rootNode, fromInline, toInline)) {\n      return Location.after(forward ? fromInline : toInline);\n    } else {\n      return location;\n    }\n  }).getOr(location);\n  const skipNoMovement = (fromLocation, toLocation) => fromLocation.fold(always, fromLocation => !isEq(fromLocation, toLocation));\n  const findLocationTraverse = (forward, isInlineTarget, rootNode, fromLocation, pos) => {\n    const from = normalizePosition(forward, pos);\n    const to = fromPosition(forward, rootNode, from).map(curry(normalizePosition, forward));\n    const location = to.fold(() => fromLocation.map(outside), to => readLocation(isInlineTarget, rootNode, to).map(curry(betweenInlines, forward, isInlineTarget, rootNode, from, to)).filter(curry(skipNoMovement, fromLocation)));\n    return location.filter(isValidLocation);\n  };\n  const findLocationSimple = (forward, location) => {\n    if (forward) {\n      return location.fold(compose(Optional.some, Location.start), Optional.none, compose(Optional.some, Location.after), Optional.none);\n    } else {\n      return location.fold(Optional.none, compose(Optional.some, Location.before), Optional.none, compose(Optional.some, Location.end));\n    }\n  };\n  const findLocation$1 = (forward, isInlineTarget, rootNode, pos) => {\n    const from = normalizePosition(forward, pos);\n    const fromLocation = readLocation(isInlineTarget, rootNode, from);\n    return readLocation(isInlineTarget, rootNode, from).bind(curry(findLocationSimple, forward)).orThunk(() => findLocationTraverse(forward, isInlineTarget, rootNode, fromLocation, pos));\n  };\n  const hasSelectionModifyApi = editor => {\n    return isFunction(editor.selection.getSel().modify);\n  };\n  const moveRel = (forward, selection, pos) => {\n    const delta = forward ? 1 : -1;\n    selection.setRng(CaretPosition(pos.container(), pos.offset() + delta).toRange());\n    selection.getSel().modify('move', forward ? 'forward' : 'backward', 'word');\n    return true;\n  };\n  const moveByWord = (forward, editor) => {\n    const rng = editor.selection.getRng();\n    const pos = forward ? CaretPosition.fromRangeEnd(rng) : CaretPosition.fromRangeStart(rng);\n    if (!hasSelectionModifyApi(editor)) {\n      return false;\n    } else if (forward && isBeforeInline(pos)) {\n      return moveRel(true, editor.selection, pos);\n    } else if (!forward && isAfterInline(pos)) {\n      return moveRel(false, editor.selection, pos);\n    } else {\n      return false;\n    }\n  };\n  var BreakType;\n  (function (BreakType) {\n    BreakType[BreakType['Br'] = 0] = 'Br';\n    BreakType[BreakType['Block'] = 1] = 'Block';\n    BreakType[BreakType['Wrap'] = 2] = 'Wrap';\n    BreakType[BreakType['Eol'] = 3] = 'Eol';\n  })(BreakType || (BreakType = {}));\n  const flip = (direction, positions) => direction === HDirection.Backwards ? reverse(positions) : positions;\n  const walk$1 = (direction, caretWalker, pos) => direction === HDirection.Forwards ? caretWalker.next(pos) : caretWalker.prev(pos);\n  const getBreakType = (scope, direction, currentPos, nextPos) => {\n    if (isBr$6(nextPos.getNode(direction === HDirection.Forwards))) {\n      return BreakType.Br;\n    } else if (isInSameBlock(currentPos, nextPos) === false) {\n      return BreakType.Block;\n    } else {\n      return BreakType.Wrap;\n    }\n  };\n  const getPositionsUntil = (predicate, direction, scope, start) => {\n    const caretWalker = CaretWalker(scope);\n    let currentPos = start;\n    const positions = [];\n    while (currentPos) {\n      const nextPos = walk$1(direction, caretWalker, currentPos);\n      if (!nextPos) {\n        break;\n      }\n      if (isBr$6(nextPos.getNode(false))) {\n        if (direction === HDirection.Forwards) {\n          return {\n            positions: flip(direction, positions).concat([nextPos]),\n            breakType: BreakType.Br,\n            breakAt: Optional.some(nextPos)\n          };\n        } else {\n          return {\n            positions: flip(direction, positions),\n            breakType: BreakType.Br,\n            breakAt: Optional.some(nextPos)\n          };\n        }\n      }\n      if (!nextPos.isVisible()) {\n        currentPos = nextPos;\n        continue;\n      }\n      if (predicate(currentPos, nextPos)) {\n        const breakType = getBreakType(scope, direction, currentPos, nextPos);\n        return {\n          positions: flip(direction, positions),\n          breakType,\n          breakAt: Optional.some(nextPos)\n        };\n      }\n      positions.push(nextPos);\n      currentPos = nextPos;\n    }\n    return {\n      positions: flip(direction, positions),\n      breakType: BreakType.Eol,\n      breakAt: Optional.none()\n    };\n  };\n  const getAdjacentLinePositions = (direction, getPositionsUntilBreak, scope, start) => getPositionsUntilBreak(scope, start).breakAt.map(pos => {\n    const positions = getPositionsUntilBreak(scope, pos).positions;\n    return direction === HDirection.Backwards ? positions.concat(pos) : [pos].concat(positions);\n  }).getOr([]);\n  const findClosestHorizontalPositionFromPoint = (positions, x) => foldl(positions, (acc, newPos) => acc.fold(() => Optional.some(newPos), lastPos => lift2(head(lastPos.getClientRects()), head(newPos.getClientRects()), (lastRect, newRect) => {\n    const lastDist = Math.abs(x - lastRect.left);\n    const newDist = Math.abs(x - newRect.left);\n    return newDist <= lastDist ? newPos : lastPos;\n  }).or(acc)), Optional.none());\n  const findClosestHorizontalPosition = (positions, pos) => head(pos.getClientRects()).bind(targetRect => findClosestHorizontalPositionFromPoint(positions, targetRect.left));\n  const getPositionsUntilPreviousLine = curry(getPositionsUntil, CaretPosition.isAbove, -1);\n  const getPositionsUntilNextLine = curry(getPositionsUntil, CaretPosition.isBelow, 1);\n  const getPositionsAbove = curry(getAdjacentLinePositions, -1, getPositionsUntilPreviousLine);\n  const getPositionsBelow = curry(getAdjacentLinePositions, 1, getPositionsUntilNextLine);\n  const isAtFirstLine = (scope, pos) => getPositionsUntilPreviousLine(scope, pos).breakAt.isNone();\n  const isAtLastLine = (scope, pos) => getPositionsUntilNextLine(scope, pos).breakAt.isNone();\n  const getFirstLinePositions = scope => firstPositionIn(scope).map(pos => [pos].concat(getPositionsUntilNextLine(scope, pos).positions)).getOr([]);\n  const getLastLinePositions = scope => lastPositionIn(scope).map(pos => getPositionsUntilPreviousLine(scope, pos).positions.concat(pos)).getOr([]);\n  const getClosestPositionAbove = (scope, pos) => findClosestHorizontalPosition(getPositionsAbove(scope, pos), pos);\n  const getClosestPositionBelow = (scope, pos) => findClosestHorizontalPosition(getPositionsBelow(scope, pos), pos);\n  const isContentEditableFalse$5 = isContentEditableFalse$b;\n  const distanceToRectLeft$1 = (clientRect, clientX) => Math.abs(clientRect.left - clientX);\n  const distanceToRectRight$1 = (clientRect, clientX) => Math.abs(clientRect.right - clientX);\n  const isNodeClientRect = rect => hasNonNullableKey(rect, 'node');\n  const findClosestClientRect = (clientRects, clientX) => reduce(clientRects, (oldClientRect, clientRect) => {\n    const oldDistance = Math.min(distanceToRectLeft$1(oldClientRect, clientX), distanceToRectRight$1(oldClientRect, clientX));\n    const newDistance = Math.min(distanceToRectLeft$1(clientRect, clientX), distanceToRectRight$1(clientRect, clientX));\n    if (newDistance === oldDistance && isNodeClientRect(clientRect) && isContentEditableFalse$5(clientRect.node)) {\n      return clientRect;\n    }\n    if (newDistance < oldDistance) {\n      return clientRect;\n    }\n    return oldClientRect;\n  });\n  const getNodeClientRects = node => {\n    const toArrayWithNode = clientRects => {\n      return map$3(clientRects, rect => {\n        const clientRect = clone$1(rect);\n        clientRect.node = node;\n        return clientRect;\n      });\n    };\n    if (isElement$6(node)) {\n      return toArrayWithNode(node.getClientRects());\n    } else if (isText$b(node)) {\n      const rng = node.ownerDocument.createRange();\n      rng.setStart(node, 0);\n      rng.setEnd(node, node.data.length);\n      return toArrayWithNode(rng.getClientRects());\n    } else {\n      return [];\n    }\n  };\n  const getClientRects = nodes => bind$3(nodes, getNodeClientRects);\n  var VDirection;\n  (function (VDirection) {\n    VDirection[VDirection['Up'] = -1] = 'Up';\n    VDirection[VDirection['Down'] = 1] = 'Down';\n  })(VDirection || (VDirection = {}));\n  const findUntil = (direction, root, predicateFn, node) => {\n    let currentNode = node;\n    while (currentNode = findNode(currentNode, direction, isEditableCaretCandidate$1, root)) {\n      if (predicateFn(currentNode)) {\n        return;\n      }\n    }\n  };\n  const walkUntil = (direction, isAboveFn, isBeflowFn, root, predicateFn, caretPosition) => {\n    let line = 0;\n    const result = [];\n    const add = node => {\n      let clientRects = getClientRects([node]);\n      if (direction === -1) {\n        clientRects = clientRects.reverse();\n      }\n      for (let i = 0; i < clientRects.length; i++) {\n        const clientRect = clientRects[i];\n        if (isBeflowFn(clientRect, targetClientRect)) {\n          continue;\n        }\n        if (result.length > 0 && isAboveFn(clientRect, last$1(result))) {\n          line++;\n        }\n        clientRect.line = line;\n        if (predicateFn(clientRect)) {\n          return true;\n        }\n        result.push(clientRect);\n      }\n      return false;\n    };\n    const targetClientRect = last$1(caretPosition.getClientRects());\n    if (!targetClientRect) {\n      return result;\n    }\n    const node = caretPosition.getNode();\n    if (node) {\n      add(node);\n      findUntil(direction, root, add, node);\n    }\n    return result;\n  };\n  const aboveLineNumber = (lineNumber, clientRect) => clientRect.line > lineNumber;\n  const isLineNumber = (lineNumber, clientRect) => clientRect.line === lineNumber;\n  const upUntil = curry(walkUntil, VDirection.Up, isAbove$1, isBelow$1);\n  const downUntil = curry(walkUntil, VDirection.Down, isBelow$1, isAbove$1);\n  const getLastClientRect = caretPosition => {\n    return last$1(caretPosition.getClientRects());\n  };\n  const positionsUntil = (direction, root, predicateFn, node) => {\n    const caretWalker = CaretWalker(root);\n    let walkFn;\n    let isBelowFn;\n    let isAboveFn;\n    let caretPosition;\n    const result = [];\n    let line = 0;\n    if (direction === 1) {\n      walkFn = caretWalker.next;\n      isBelowFn = isBelow$1;\n      isAboveFn = isAbove$1;\n      caretPosition = CaretPosition.after(node);\n    } else {\n      walkFn = caretWalker.prev;\n      isBelowFn = isAbove$1;\n      isAboveFn = isBelow$1;\n      caretPosition = CaretPosition.before(node);\n    }\n    const targetClientRect = getLastClientRect(caretPosition);\n    do {\n      if (!caretPosition.isVisible()) {\n        continue;\n      }\n      const rect = getLastClientRect(caretPosition);\n      if (isAboveFn(rect, targetClientRect)) {\n        continue;\n      }\n      if (result.length > 0 && isBelowFn(rect, last$1(result))) {\n        line++;\n      }\n      const clientRect = clone$1(rect);\n      clientRect.position = caretPosition;\n      clientRect.line = line;\n      if (predicateFn(clientRect)) {\n        return result;\n      }\n      result.push(clientRect);\n    } while (caretPosition = walkFn(caretPosition));\n    return result;\n  };\n  const isAboveLine = lineNumber => clientRect => aboveLineNumber(lineNumber, clientRect);\n  const isLine = lineNumber => clientRect => isLineNumber(lineNumber, clientRect);\n  const moveToRange = (editor, rng) => {\n    editor.selection.setRng(rng);\n    scrollRangeIntoView(editor, editor.selection.getRng());\n  };\n  const renderRangeCaretOpt = (editor, range, scrollIntoView) => Optional.some(renderRangeCaret(editor, range, scrollIntoView));\n  const moveHorizontally = (editor, direction, range, isBefore, isAfter, isElement) => {\n    const forwards = direction === HDirection.Forwards;\n    const caretWalker = CaretWalker(editor.getBody());\n    const getNextPosFn = curry(getVisualCaretPosition, forwards ? caretWalker.next : caretWalker.prev);\n    const isBeforeFn = forwards ? isBefore : isAfter;\n    if (!range.collapsed) {\n      const node = getSelectedNode(range);\n      if (isElement(node)) {\n        return showCaret(direction, editor, node, direction === HDirection.Backwards, false);\n      } else if (isCefAtEdgeSelected(editor)) {\n        const newRange = range.cloneRange();\n        newRange.collapse(direction === HDirection.Backwards);\n        return Optional.from(newRange);\n      }\n    }\n    const caretPosition = getNormalizedRangeEndPoint(direction, editor.getBody(), range);\n    if (isBeforeFn(caretPosition)) {\n      return selectNode(editor, caretPosition.getNode(!forwards));\n    }\n    let nextCaretPosition = getNextPosFn(caretPosition);\n    const rangeIsInContainerBlock = isRangeInCaretContainerBlock(range);\n    if (!nextCaretPosition) {\n      return rangeIsInContainerBlock ? Optional.some(range) : Optional.none();\n    } else {\n      nextCaretPosition = normalizePosition(forwards, nextCaretPosition);\n    }\n    if (isBeforeFn(nextCaretPosition)) {\n      return showCaret(direction, editor, nextCaretPosition.getNode(!forwards), forwards, false);\n    }\n    const peekCaretPosition = getNextPosFn(nextCaretPosition);\n    if (peekCaretPosition && isBeforeFn(peekCaretPosition)) {\n      if (isMoveInsideSameBlock(nextCaretPosition, peekCaretPosition)) {\n        return showCaret(direction, editor, peekCaretPosition.getNode(!forwards), forwards, false);\n      }\n    }\n    if (rangeIsInContainerBlock) {\n      return renderRangeCaretOpt(editor, nextCaretPosition.toRange(), false);\n    }\n    return Optional.none();\n  };\n  const moveVertically = (editor, direction, range, isBefore, isAfter, isElement) => {\n    const caretPosition = getNormalizedRangeEndPoint(direction, editor.getBody(), range);\n    const caretClientRect = last$1(caretPosition.getClientRects());\n    const forwards = direction === VDirection.Down;\n    const root = editor.getBody();\n    if (!caretClientRect) {\n      return Optional.none();\n    }\n    if (isCefAtEdgeSelected(editor)) {\n      const caretPosition = forwards ? CaretPosition.fromRangeEnd(range) : CaretPosition.fromRangeStart(range);\n      const getClosestFn = !forwards ? getClosestPositionAbove : getClosestPositionBelow;\n      return getClosestFn(root, caretPosition).orThunk(() => Optional.from(caretPosition)).map(pos => pos.toRange());\n    }\n    const walkerFn = forwards ? downUntil : upUntil;\n    const linePositions = walkerFn(root, isAboveLine(1), caretPosition);\n    const nextLinePositions = filter$5(linePositions, isLine(1));\n    const clientX = caretClientRect.left;\n    const nextLineRect = findClosestClientRect(nextLinePositions, clientX);\n    if (nextLineRect && isElement(nextLineRect.node)) {\n      const dist1 = Math.abs(clientX - nextLineRect.left);\n      const dist2 = Math.abs(clientX - nextLineRect.right);\n      return showCaret(direction, editor, nextLineRect.node, dist1 < dist2, false);\n    }\n    let currentNode;\n    if (isBefore(caretPosition)) {\n      currentNode = caretPosition.getNode();\n    } else if (isAfter(caretPosition)) {\n      currentNode = caretPosition.getNode(true);\n    } else {\n      currentNode = getSelectedNode(range);\n    }\n    if (currentNode) {\n      const caretPositions = positionsUntil(direction, root, isAboveLine(1), currentNode);\n      let closestNextLineRect = findClosestClientRect(filter$5(caretPositions, isLine(1)), clientX);\n      if (closestNextLineRect) {\n        return renderRangeCaretOpt(editor, closestNextLineRect.position.toRange(), false);\n      }\n      closestNextLineRect = last$1(filter$5(caretPositions, isLine(0)));\n      if (closestNextLineRect) {\n        return renderRangeCaretOpt(editor, closestNextLineRect.position.toRange(), false);\n      }\n    }\n    if (nextLinePositions.length === 0) {\n      return getLineEndPoint(editor, forwards).filter(forwards ? isAfter : isBefore).map(pos => renderRangeCaret(editor, pos.toRange(), false));\n    }\n    return Optional.none();\n  };\n  const getLineEndPoint = (editor, forward) => {\n    const rng = editor.selection.getRng();\n    const from = forward ? CaretPosition.fromRangeEnd(rng) : CaretPosition.fromRangeStart(rng);\n    const host = getEditingHost(from.container(), editor.getBody());\n    if (forward) {\n      const lineInfo = getPositionsUntilNextLine(host, from);\n      return last$2(lineInfo.positions);\n    } else {\n      const lineInfo = getPositionsUntilPreviousLine(host, from);\n      return head(lineInfo.positions);\n    }\n  };\n  const moveToLineEndPoint$3 = (editor, forward, isElementPosition) => getLineEndPoint(editor, forward).filter(isElementPosition).exists(pos => {\n    editor.selection.setRng(pos.toRange());\n    return true;\n  });\n  const setCaretPosition = (editor, pos) => {\n    const rng = editor.dom.createRng();\n    rng.setStart(pos.container(), pos.offset());\n    rng.setEnd(pos.container(), pos.offset());\n    editor.selection.setRng(rng);\n  };\n  const setSelected = (state, elm) => {\n    if (state) {\n      elm.setAttribute('data-mce-selected', 'inline-boundary');\n    } else {\n      elm.removeAttribute('data-mce-selected');\n    }\n  };\n  const renderCaretLocation = (editor, caret, location) => renderCaret(caret, location).map(pos => {\n    setCaretPosition(editor, pos);\n    return location;\n  });\n  const getPositionFromRange = (range, root, forward) => {\n    const start = CaretPosition.fromRangeStart(range);\n    if (range.collapsed) {\n      return start;\n    } else {\n      const end = CaretPosition.fromRangeEnd(range);\n      return forward ? prevPosition(root, end).getOr(end) : nextPosition(root, start).getOr(start);\n    }\n  };\n  const findLocation = (editor, caret, forward) => {\n    const rootNode = editor.getBody();\n    const from = getPositionFromRange(editor.selection.getRng(), rootNode, forward);\n    const isInlineTarget$1 = curry(isInlineTarget, editor);\n    const location = findLocation$1(forward, isInlineTarget$1, rootNode, from);\n    return location.bind(location => renderCaretLocation(editor, caret, location));\n  };\n  const toggleInlines = (isInlineTarget, dom, elms) => {\n    const inlineBoundaries = map$3(descendants(SugarElement.fromDom(dom.getRoot()), '*[data-mce-selected=\"inline-boundary\"]'), e => e.dom);\n    const selectedInlines = filter$5(inlineBoundaries, isInlineTarget);\n    const targetInlines = filter$5(elms, isInlineTarget);\n    each$e(difference(selectedInlines, targetInlines), curry(setSelected, false));\n    each$e(difference(targetInlines, selectedInlines), curry(setSelected, true));\n  };\n  const safeRemoveCaretContainer = (editor, caret) => {\n    const caretValue = caret.get();\n    if (editor.selection.isCollapsed() && !editor.composing && caretValue) {\n      const pos = CaretPosition.fromRangeStart(editor.selection.getRng());\n      if (CaretPosition.isTextPosition(pos) && !isAtZwsp(pos)) {\n        setCaretPosition(editor, removeAndReposition(caretValue, pos));\n        caret.set(null);\n      }\n    }\n  };\n  const renderInsideInlineCaret = (isInlineTarget, editor, caret, elms) => {\n    if (editor.selection.isCollapsed()) {\n      const inlines = filter$5(elms, isInlineTarget);\n      each$e(inlines, _inline => {\n        const pos = CaretPosition.fromRangeStart(editor.selection.getRng());\n        readLocation(isInlineTarget, editor.getBody(), pos).bind(location => renderCaretLocation(editor, caret, location));\n      });\n    }\n  };\n  const move$3 = (editor, caret, forward) => isInlineBoundariesEnabled(editor) ? findLocation(editor, caret, forward).isSome() : false;\n  const moveWord = (forward, editor, _caret) => isInlineBoundariesEnabled(editor) ? moveByWord(forward, editor) : false;\n  const setupSelectedState = editor => {\n    const caret = Cell(null);\n    const isInlineTarget$1 = curry(isInlineTarget, editor);\n    editor.on('NodeChange', e => {\n      if (isInlineBoundariesEnabled(editor)) {\n        toggleInlines(isInlineTarget$1, editor.dom, e.parents);\n        safeRemoveCaretContainer(editor, caret);\n        renderInsideInlineCaret(isInlineTarget$1, editor, caret, e.parents);\n      }\n    });\n    return caret;\n  };\n  const moveNextWord = curry(moveWord, true);\n  const movePrevWord = curry(moveWord, false);\n  const moveToLineEndPoint$2 = (editor, forward, caret) => {\n    if (isInlineBoundariesEnabled(editor)) {\n      const linePoint = getLineEndPoint(editor, forward).getOrThunk(() => {\n        const rng = editor.selection.getRng();\n        return forward ? CaretPosition.fromRangeEnd(rng) : CaretPosition.fromRangeStart(rng);\n      });\n      return readLocation(curry(isInlineTarget, editor), editor.getBody(), linePoint).exists(loc => {\n        const outsideLoc = outside(loc);\n        return renderCaret(caret, outsideLoc).exists(pos => {\n          setCaretPosition(editor, pos);\n          return true;\n        });\n      });\n    } else {\n      return false;\n    }\n  };\n  const rangeFromPositions = (from, to) => {\n    const range = document.createRange();\n    range.setStart(from.container(), from.offset());\n    range.setEnd(to.container(), to.offset());\n    return range;\n  };\n  const hasOnlyTwoOrLessPositionsLeft = elm => lift2(firstPositionIn(elm), lastPositionIn(elm), (firstPos, lastPos) => {\n    const normalizedFirstPos = normalizePosition(true, firstPos);\n    const normalizedLastPos = normalizePosition(false, lastPos);\n    return nextPosition(elm, normalizedFirstPos).forall(pos => pos.isEqual(normalizedLastPos));\n  }).getOr(true);\n  const setCaretLocation = (editor, caret) => location => renderCaret(caret, location).map(pos => () => setCaretPosition(editor, pos));\n  const deleteFromTo = (editor, caret, from, to) => {\n    const rootNode = editor.getBody();\n    const isInlineTarget$1 = curry(isInlineTarget, editor);\n    editor.undoManager.ignore(() => {\n      editor.selection.setRng(rangeFromPositions(from, to));\n      execNativeDeleteCommand(editor);\n      readLocation(isInlineTarget$1, rootNode, CaretPosition.fromRangeStart(editor.selection.getRng())).map(inside).bind(setCaretLocation(editor, caret)).each(call);\n    });\n    editor.nodeChanged();\n  };\n  const rescope = (rootNode, node) => {\n    const parentBlock = getParentBlock$3(node, rootNode);\n    return parentBlock ? parentBlock : rootNode;\n  };\n  const backspaceDeleteCollapsed = (editor, caret, forward, from) => {\n    const rootNode = rescope(editor.getBody(), from.container());\n    const isInlineTarget$1 = curry(isInlineTarget, editor);\n    const fromLocation = readLocation(isInlineTarget$1, rootNode, from);\n    const location = fromLocation.bind(location => {\n      if (forward) {\n        return location.fold(constant(Optional.some(inside(location))), Optional.none, constant(Optional.some(outside(location))), Optional.none);\n      } else {\n        return location.fold(Optional.none, constant(Optional.some(outside(location))), Optional.none, constant(Optional.some(inside(location))));\n      }\n    });\n    return location.map(setCaretLocation(editor, caret)).getOrThunk(() => {\n      const toPosition = navigate(forward, rootNode, from);\n      const toLocation = toPosition.bind(pos => readLocation(isInlineTarget$1, rootNode, pos));\n      return lift2(fromLocation, toLocation, () => findRootInline(isInlineTarget$1, rootNode, from).bind(elm => {\n        if (hasOnlyTwoOrLessPositionsLeft(elm)) {\n          return Optional.some(() => {\n            deleteElement$2(editor, forward, SugarElement.fromDom(elm));\n          });\n        } else {\n          return Optional.none();\n        }\n      })).getOrThunk(() => toLocation.bind(() => toPosition.map(to => {\n        return () => {\n          if (forward) {\n            deleteFromTo(editor, caret, from, to);\n          } else {\n            deleteFromTo(editor, caret, to, from);\n          }\n        };\n      })));\n    });\n  };\n  const backspaceDelete$4 = (editor, caret, forward) => {\n    if (editor.selection.isCollapsed() && isInlineBoundariesEnabled(editor)) {\n      const from = CaretPosition.fromRangeStart(editor.selection.getRng());\n      return backspaceDeleteCollapsed(editor, caret, forward, from);\n    }\n    return Optional.none();\n  };\n  const hasMultipleChildren = elm => childNodesCount(elm) > 1;\n  const getParentsUntil = (editor, pred) => {\n    const rootElm = SugarElement.fromDom(editor.getBody());\n    const startElm = SugarElement.fromDom(editor.selection.getStart());\n    const parents = parentsAndSelf(startElm, rootElm);\n    return findIndex$2(parents, pred).fold(constant(parents), index => parents.slice(0, index));\n  };\n  const hasOnlyOneChild = elm => childNodesCount(elm) === 1;\n  const getParentInlinesUntilMultichildInline = editor => getParentsUntil(editor, elm => editor.schema.isBlock(name(elm)) || hasMultipleChildren(elm));\n  const getParentInlines = editor => getParentsUntil(editor, el => editor.schema.isBlock(name(el)));\n  const getFormatNodes = (editor, parentInlines) => {\n    const isFormatElement$1 = curry(isFormatElement, editor);\n    return bind$3(parentInlines, elm => isFormatElement$1(elm) ? [elm.dom] : []);\n  };\n  const getFormatNodesAtStart = editor => {\n    const parentInlines = getParentInlines(editor);\n    return getFormatNodes(editor, parentInlines);\n  };\n  const deleteLastPosition = (forward, editor, target, parentInlines) => {\n    const formatNodes = getFormatNodes(editor, parentInlines);\n    if (formatNodes.length === 0) {\n      deleteElement$2(editor, forward, target);\n    } else {\n      const pos = replaceWithCaretFormat(target.dom, formatNodes);\n      editor.selection.setRng(pos.toRange());\n    }\n  };\n  const deleteCaret$1 = (editor, forward) => {\n    const parentInlines = filter$5(getParentInlinesUntilMultichildInline(editor), hasOnlyOneChild);\n    return last$2(parentInlines).bind(target => {\n      const fromPos = CaretPosition.fromRangeStart(editor.selection.getRng());\n      if (willDeleteLastPositionInElement(forward, fromPos, target.dom) && !isEmptyCaretFormatElement(target)) {\n        return Optional.some(() => deleteLastPosition(forward, editor, target, parentInlines));\n      } else {\n        return Optional.none();\n      }\n    });\n  };\n  const isBrInEmptyElement = (editor, elm) => {\n    const parentElm = elm.parentElement;\n    return isBr$6(elm) && !isNull(parentElm) && editor.dom.isEmpty(parentElm);\n  };\n  const isEmptyCaret = elm => isEmptyCaretFormatElement(SugarElement.fromDom(elm));\n  const createCaretFormatAtStart = (editor, formatNodes) => {\n    const startElm = editor.selection.getStart();\n    const pos = isBrInEmptyElement(editor, startElm) || isEmptyCaret(startElm) ? replaceWithCaretFormat(startElm, formatNodes) : createCaretFormatAtStart$1(editor.selection.getRng(), formatNodes);\n    editor.selection.setRng(pos.toRange());\n  };\n  const updateCaretFormat = (editor, updateFormats) => {\n    const missingFormats = difference(updateFormats, getFormatNodesAtStart(editor));\n    if (missingFormats.length > 0) {\n      createCaretFormatAtStart(editor, missingFormats);\n    }\n  };\n  const rangeStartsAtTextContainer = rng => isText$b(rng.startContainer);\n  const rangeStartsAtStartOfTextContainer = rng => rng.startOffset === 0 && rangeStartsAtTextContainer(rng);\n  const rangeStartParentIsFormatElement = (editor, rng) => {\n    const startParent = rng.startContainer.parentElement;\n    return !isNull(startParent) && isFormatElement(editor, SugarElement.fromDom(startParent));\n  };\n  const rangeStartAndEndHaveSameParent = rng => {\n    const startParent = rng.startContainer.parentNode;\n    const endParent = rng.endContainer.parentNode;\n    return !isNull(startParent) && !isNull(endParent) && startParent.isEqualNode(endParent);\n  };\n  const rangeEndsAtEndOfEndContainer = rng => {\n    const endContainer = rng.endContainer;\n    return rng.endOffset === (isText$b(endContainer) ? endContainer.length : endContainer.childNodes.length);\n  };\n  const rangeEndsAtEndOfStartContainer = rng => rangeStartAndEndHaveSameParent(rng) && rangeEndsAtEndOfEndContainer(rng);\n  const rangeEndsAfterEndOfStartContainer = rng => !rng.endContainer.isEqualNode(rng.commonAncestorContainer);\n  const rangeEndsAtOrAfterEndOfStartContainer = rng => rangeEndsAtEndOfStartContainer(rng) || rangeEndsAfterEndOfStartContainer(rng);\n  const requiresDeleteRangeOverride = editor => {\n    const rng = editor.selection.getRng();\n    return rangeStartsAtStartOfTextContainer(rng) && rangeStartParentIsFormatElement(editor, rng) && rangeEndsAtOrAfterEndOfStartContainer(rng);\n  };\n  const deleteRange$1 = editor => {\n    if (requiresDeleteRangeOverride(editor)) {\n      const formatNodes = getFormatNodesAtStart(editor);\n      return Optional.some(() => {\n        execNativeDeleteCommand(editor);\n        updateCaretFormat(editor, formatNodes);\n      });\n    } else {\n      return Optional.none();\n    }\n  };\n  const backspaceDelete$3 = (editor, forward) => editor.selection.isCollapsed() ? deleteCaret$1(editor, forward) : deleteRange$1(editor);\n  const hasAncestorInlineCaret = (elm, schema) => ancestor$2(elm, node => isCaretNode(node.dom), el => schema.isBlock(name(el)));\n  const hasAncestorInlineCaretAtStart = editor => hasAncestorInlineCaret(SugarElement.fromDom(editor.selection.getStart()), editor.schema);\n  const requiresRefreshCaretOverride = editor => {\n    const rng = editor.selection.getRng();\n    return rng.collapsed && (rangeStartsAtTextContainer(rng) || editor.dom.isEmpty(rng.startContainer)) && !hasAncestorInlineCaretAtStart(editor);\n  };\n  const refreshCaret = editor => {\n    if (requiresRefreshCaretOverride(editor)) {\n      createCaretFormatAtStart(editor, []);\n    }\n    return true;\n  };\n  const deleteElement = (editor, forward, element) => {\n    if (isNonNullable(element)) {\n      return Optional.some(() => {\n        editor._selectionOverrides.hideFakeCaret();\n        deleteElement$2(editor, forward, SugarElement.fromDom(element));\n      });\n    } else {\n      return Optional.none();\n    }\n  };\n  const deleteCaret = (editor, forward) => {\n    const isNearMedia = forward ? isBeforeMedia : isAfterMedia;\n    const direction = forward ? HDirection.Forwards : HDirection.Backwards;\n    const fromPos = getNormalizedRangeEndPoint(direction, editor.getBody(), editor.selection.getRng());\n    if (isNearMedia(fromPos)) {\n      return deleteElement(editor, forward, fromPos.getNode(!forward));\n    } else {\n      return Optional.from(normalizePosition(forward, fromPos)).filter(pos => isNearMedia(pos) && isMoveInsideSameBlock(fromPos, pos)).bind(pos => deleteElement(editor, forward, pos.getNode(!forward)));\n    }\n  };\n  const deleteRange = (editor, forward) => {\n    const selectedNode = editor.selection.getNode();\n    return isMedia$2(selectedNode) ? deleteElement(editor, forward, selectedNode) : Optional.none();\n  };\n  const backspaceDelete$2 = (editor, forward) => editor.selection.isCollapsed() ? deleteCaret(editor, forward) : deleteRange(editor, forward);\n  const isEditable = target => closest$4(target, elm => isContentEditableTrue$3(elm.dom) || isContentEditableFalse$b(elm.dom)).exists(elm => isContentEditableTrue$3(elm.dom));\n  const parseIndentValue = value => toInt(value !== null && value !== void 0 ? value : '').getOr(0);\n  const getIndentStyleName = (useMargin, element) => {\n    const indentStyleName = useMargin || isTable$1(element) ? 'margin' : 'padding';\n    const suffix = get$7(element, 'direction') === 'rtl' ? '-right' : '-left';\n    return indentStyleName + suffix;\n  };\n  const indentElement = (dom, command, useMargin, value, unit, element) => {\n    const indentStyleName = getIndentStyleName(useMargin, SugarElement.fromDom(element));\n    const parsedValue = parseIndentValue(dom.getStyle(element, indentStyleName));\n    if (command === 'outdent') {\n      const styleValue = Math.max(0, parsedValue - value);\n      dom.setStyle(element, indentStyleName, styleValue ? styleValue + unit : '');\n    } else {\n      const styleValue = parsedValue + value + unit;\n      dom.setStyle(element, indentStyleName, styleValue);\n    }\n  };\n  const validateBlocks = (editor, blocks) => forall(blocks, block => {\n    const indentStyleName = getIndentStyleName(shouldIndentUseMargin(editor), block);\n    const intentValue = getRaw(block, indentStyleName).map(parseIndentValue).getOr(0);\n    const contentEditable = editor.dom.getContentEditable(block.dom);\n    return contentEditable !== 'false' && intentValue > 0;\n  });\n  const canOutdent = editor => {\n    const blocks = getBlocksToIndent(editor);\n    return !editor.mode.isReadOnly() && (blocks.length > 1 || validateBlocks(editor, blocks));\n  };\n  const isListComponent = el => isList(el) || isListItem$1(el);\n  const parentIsListComponent = el => parent(el).exists(isListComponent);\n  const getBlocksToIndent = editor => filter$5(fromDom$1(editor.selection.getSelectedBlocks()), el => !isListComponent(el) && !parentIsListComponent(el) && isEditable(el));\n  const handle = (editor, command) => {\n    var _a, _b;\n    if (editor.mode.isReadOnly()) {\n      return;\n    }\n    const {\n      dom\n    } = editor;\n    const indentation = getIndentation(editor);\n    const indentUnit = (_b = (_a = /[a-z%]+$/i.exec(indentation)) === null || _a === void 0 ? void 0 : _a[0]) !== null && _b !== void 0 ? _b : 'px';\n    const indentValue = parseIndentValue(indentation);\n    const useMargin = shouldIndentUseMargin(editor);\n    each$e(getBlocksToIndent(editor), block => {\n      indentElement(dom, command, useMargin, indentValue, indentUnit, block.dom);\n    });\n  };\n  const indent = editor => handle(editor, 'indent');\n  const outdent = editor => handle(editor, 'outdent');\n  const backspaceDelete$1 = editor => {\n    if (editor.selection.isCollapsed() && canOutdent(editor)) {\n      const dom = editor.dom;\n      const rng = editor.selection.getRng();\n      const pos = CaretPosition.fromRangeStart(rng);\n      const block = dom.getParent(rng.startContainer, dom.isBlock);\n      if (block !== null && isAtStartOfBlock(SugarElement.fromDom(block), pos, editor.schema)) {\n        return Optional.some(() => outdent(editor));\n      }\n    }\n    return Optional.none();\n  };\n  const findAction = (editor, caret, forward) => findMap([backspaceDelete$1, backspaceDelete$7, backspaceDelete$8, (editor, forward) => backspaceDelete$4(editor, caret, forward), backspaceDelete$a, backspaceDelete$b, backspaceDelete$5, backspaceDelete$2, backspaceDelete$9, backspaceDelete$3, backspaceDelete$6], item => item(editor, forward)).filter(_ => editor.selection.isEditable());\n  const deleteCommand = (editor, caret) => {\n    const result = findAction(editor, caret, false);\n    result.fold(() => {\n      if (editor.selection.isEditable()) {\n        execNativeDeleteCommand(editor);\n        paddEmptyBody(editor);\n      }\n    }, call);\n  };\n  const forwardDeleteCommand = (editor, caret) => {\n    const result = findAction(editor, caret, true);\n    result.fold(() => {\n      if (editor.selection.isEditable()) {\n        execNativeForwardDeleteCommand(editor);\n      }\n    }, call);\n  };\n  const setup$q = (editor, caret) => {\n    editor.addCommand('delete', () => {\n      deleteCommand(editor, caret);\n    });\n    editor.addCommand('forwardDelete', () => {\n      forwardDeleteCommand(editor, caret);\n    });\n  };\n  const SIGNIFICANT_MOVE = 5;\n  const LONGPRESS_DELAY = 400;\n  const getTouch = event => {\n    if (event.touches === undefined || event.touches.length !== 1) {\n      return Optional.none();\n    }\n    return Optional.some(event.touches[0]);\n  };\n  const isFarEnough = (touch, data) => {\n    const distX = Math.abs(touch.clientX - data.x);\n    const distY = Math.abs(touch.clientY - data.y);\n    return distX > SIGNIFICANT_MOVE || distY > SIGNIFICANT_MOVE;\n  };\n  const setup$p = editor => {\n    const startData = value$2();\n    const longpressFired = Cell(false);\n    const debounceLongpress = last(e => {\n      editor.dispatch('longpress', {\n        ...e,\n        type: 'longpress'\n      });\n      longpressFired.set(true);\n    }, LONGPRESS_DELAY);\n    editor.on('touchstart', e => {\n      getTouch(e).each(touch => {\n        debounceLongpress.cancel();\n        const data = {\n          x: touch.clientX,\n          y: touch.clientY,\n          target: e.target\n        };\n        debounceLongpress.throttle(e);\n        longpressFired.set(false);\n        startData.set(data);\n      });\n    }, true);\n    editor.on('touchmove', e => {\n      debounceLongpress.cancel();\n      getTouch(e).each(touch => {\n        startData.on(data => {\n          if (isFarEnough(touch, data)) {\n            startData.clear();\n            longpressFired.set(false);\n            editor.dispatch('longpresscancel');\n          }\n        });\n      });\n    }, true);\n    editor.on('touchend touchcancel', e => {\n      debounceLongpress.cancel();\n      if (e.type === 'touchcancel') {\n        return;\n      }\n      startData.get().filter(data => data.target.isEqualNode(e.target)).each(() => {\n        if (longpressFired.get()) {\n          e.preventDefault();\n        } else {\n          editor.dispatch('tap', {\n            ...e,\n            type: 'tap'\n          });\n        }\n      });\n    }, true);\n  };\n  const isBlockElement = (blockElements, node) => has$2(blockElements, node.nodeName);\n  const isValidTarget = (schema, node) => {\n    if (isText$b(node)) {\n      return true;\n    } else if (isElement$6(node)) {\n      return !isBlockElement(schema.getBlockElements(), node) && !isBookmarkNode$1(node) && !isTransparentBlock(schema, node) && !isNonHtmlElementRoot(node);\n    } else {\n      return false;\n    }\n  };\n  const hasBlockParent = (blockElements, root, node) => {\n    return exists(parents(SugarElement.fromDom(node), SugarElement.fromDom(root)), elm => {\n      return isBlockElement(blockElements, elm.dom);\n    });\n  };\n  const shouldRemoveTextNode = (blockElements, node) => {\n    if (isText$b(node)) {\n      if (node.data.length === 0) {\n        return true;\n      } else if (/^\\s+$/.test(node.data)) {\n        return !node.nextSibling || isBlockElement(blockElements, node.nextSibling) || isNonHtmlElementRoot(node.nextSibling);\n      }\n    }\n    return false;\n  };\n  const createRootBlock = editor => editor.dom.create(getForcedRootBlock(editor), getForcedRootBlockAttrs(editor));\n  const addRootBlocks = editor => {\n    const dom = editor.dom,\n      selection = editor.selection;\n    const schema = editor.schema;\n    const blockElements = schema.getBlockElements();\n    const startNode = selection.getStart();\n    const rootNode = editor.getBody();\n    let rootBlockNode;\n    let tempNode;\n    let bm = null;\n    const forcedRootBlock = getForcedRootBlock(editor);\n    if (!startNode || !isElement$6(startNode)) {\n      return;\n    }\n    const rootNodeName = rootNode.nodeName.toLowerCase();\n    if (!schema.isValidChild(rootNodeName, forcedRootBlock.toLowerCase()) || hasBlockParent(blockElements, rootNode, startNode)) {\n      return;\n    }\n    if (rootNode.firstChild === rootNode.lastChild && isBr$6(rootNode.firstChild)) {\n      rootBlockNode = createRootBlock(editor);\n      rootBlockNode.appendChild(createPaddingBr().dom);\n      rootNode.replaceChild(rootBlockNode, rootNode.firstChild);\n      editor.selection.setCursorLocation(rootBlockNode, 0);\n      editor.nodeChanged();\n      return;\n    }\n    let node = rootNode.firstChild;\n    while (node) {\n      if (isElement$6(node)) {\n        updateElement(schema, node);\n      }\n      if (isValidTarget(schema, node)) {\n        if (shouldRemoveTextNode(blockElements, node)) {\n          tempNode = node;\n          node = node.nextSibling;\n          dom.remove(tempNode);\n          continue;\n        }\n        if (!rootBlockNode) {\n          if (!bm && editor.hasFocus()) {\n            bm = getBookmark(editor.selection.getRng(), () => document.createElement('span'));\n          }\n          if (!node.parentNode) {\n            node = null;\n            break;\n          }\n          rootBlockNode = createRootBlock(editor);\n          rootNode.insertBefore(rootBlockNode, node);\n        }\n        tempNode = node;\n        node = node.nextSibling;\n        rootBlockNode.appendChild(tempNode);\n      } else {\n        rootBlockNode = null;\n        node = node.nextSibling;\n      }\n    }\n    if (bm) {\n      editor.selection.setRng(resolveBookmark(bm));\n      editor.nodeChanged();\n    }\n  };\n  const insertEmptyLine = (editor, root, insertBlock) => {\n    const block = SugarElement.fromDom(createRootBlock(editor));\n    const br = createPaddingBr();\n    append$1(block, br);\n    insertBlock(root, block);\n    const rng = document.createRange();\n    rng.setStartBefore(br.dom);\n    rng.setEndBefore(br.dom);\n    return rng;\n  };\n  const setup$o = editor => {\n    editor.on('NodeChange', () => addRootBlocks(editor));\n  };\n  const hasClass = checkClassName => node => (' ' + node.attr('class') + ' ').indexOf(checkClassName) !== -1;\n  const replaceMatchWithSpan = (editor, content, cls) => {\n    return function (match) {\n      const args = arguments,\n        index = args[args.length - 2];\n      const prevChar = index > 0 ? content.charAt(index - 1) : '';\n      if (prevChar === '\"') {\n        return match;\n      }\n      if (prevChar === '>') {\n        const findStartTagIndex = content.lastIndexOf('<', index);\n        if (findStartTagIndex !== -1) {\n          const tagHtml = content.substring(findStartTagIndex, index);\n          if (tagHtml.indexOf('contenteditable=\"false\"') !== -1) {\n            return match;\n          }\n        }\n      }\n      return '<span class=\"' + cls + '\" data-mce-content=\"' + editor.dom.encode(args[0]) + '\">' + editor.dom.encode(typeof args[1] === 'string' ? args[1] : args[0]) + '</span>';\n    };\n  };\n  const convertRegExpsToNonEditable = (editor, nonEditableRegExps, e) => {\n    let i = nonEditableRegExps.length,\n      content = e.content;\n    if (e.format === 'raw') {\n      return;\n    }\n    while (i--) {\n      content = content.replace(nonEditableRegExps[i], replaceMatchWithSpan(editor, content, getNonEditableClass(editor)));\n    }\n    e.content = content;\n  };\n  const isValidContent = (nonEditableRegExps, content) => {\n    return forall(nonEditableRegExps, re => {\n      const matches = content.match(re);\n      return matches !== null && matches[0].length === content.length;\n    });\n  };\n  const setup$n = editor => {\n    const contentEditableAttrName = 'contenteditable';\n    const editClass = ' ' + Tools.trim(getEditableClass(editor)) + ' ';\n    const nonEditClass = ' ' + Tools.trim(getNonEditableClass(editor)) + ' ';\n    const hasEditClass = hasClass(editClass);\n    const hasNonEditClass = hasClass(nonEditClass);\n    const nonEditableRegExps = getNonEditableRegExps(editor);\n    if (nonEditableRegExps.length > 0) {\n      editor.on('BeforeSetContent', e => {\n        convertRegExpsToNonEditable(editor, nonEditableRegExps, e);\n      });\n    }\n    editor.parser.addAttributeFilter('class', nodes => {\n      let i = nodes.length;\n      while (i--) {\n        const node = nodes[i];\n        if (hasEditClass(node)) {\n          node.attr(contentEditableAttrName, 'true');\n        } else if (hasNonEditClass(node)) {\n          node.attr(contentEditableAttrName, 'false');\n        }\n      }\n    });\n    editor.serializer.addAttributeFilter(contentEditableAttrName, nodes => {\n      let i = nodes.length;\n      while (i--) {\n        const node = nodes[i];\n        if (!hasEditClass(node) && !hasNonEditClass(node)) {\n          continue;\n        }\n        const content = node.attr('data-mce-content');\n        if (nonEditableRegExps.length > 0 && content) {\n          if (isValidContent(nonEditableRegExps, content)) {\n            node.name = '#text';\n            node.type = 3;\n            node.raw = true;\n            node.value = content;\n          } else {\n            node.remove();\n          }\n        } else {\n          node.attr(contentEditableAttrName, null);\n        }\n      }\n    });\n  };\n  const findBlockCaretContainer = editor => descendant$1(SugarElement.fromDom(editor.getBody()), '*[data-mce-caret]').map(elm => elm.dom).getOrNull();\n  const showBlockCaretContainer = (editor, blockCaretContainer) => {\n    if (blockCaretContainer.hasAttribute('data-mce-caret')) {\n      showCaretContainerBlock(blockCaretContainer);\n      editor.selection.setRng(editor.selection.getRng());\n      editor.selection.scrollIntoView(blockCaretContainer);\n    }\n  };\n  const handleBlockContainer = (editor, e) => {\n    const blockCaretContainer = findBlockCaretContainer(editor);\n    if (!blockCaretContainer) {\n      return;\n    }\n    if (e.type === 'compositionstart') {\n      e.preventDefault();\n      e.stopPropagation();\n      showBlockCaretContainer(editor, blockCaretContainer);\n      return;\n    }\n    if (hasContent(blockCaretContainer)) {\n      showBlockCaretContainer(editor, blockCaretContainer);\n      editor.undoManager.add();\n    }\n  };\n  const setup$m = editor => {\n    editor.on('keyup compositionstart', curry(handleBlockContainer, editor));\n  };\n  const isContentEditableFalse$4 = isContentEditableFalse$b;\n  const moveToCeFalseHorizontally = (direction, editor, range) => moveHorizontally(editor, direction, range, isBeforeContentEditableFalse, isAfterContentEditableFalse, isContentEditableFalse$4);\n  const moveToCeFalseVertically = (direction, editor, range) => {\n    const isBefore = caretPosition => isBeforeContentEditableFalse(caretPosition) || isBeforeTable(caretPosition);\n    const isAfter = caretPosition => isAfterContentEditableFalse(caretPosition) || isAfterTable(caretPosition);\n    return moveVertically(editor, direction, range, isBefore, isAfter, isContentEditableFalse$4);\n  };\n  const createTextBlock = editor => {\n    const textBlock = editor.dom.create(getForcedRootBlock(editor));\n    textBlock.innerHTML = '<br data-mce-bogus=\"1\">';\n    return textBlock;\n  };\n  const exitPreBlock = (editor, direction, range) => {\n    const caretWalker = CaretWalker(editor.getBody());\n    const getVisualCaretPosition$1 = curry(getVisualCaretPosition, direction === 1 ? caretWalker.next : caretWalker.prev);\n    if (range.collapsed) {\n      const pre = editor.dom.getParent(range.startContainer, 'PRE');\n      if (!pre) {\n        return;\n      }\n      const caretPos = getVisualCaretPosition$1(CaretPosition.fromRangeStart(range));\n      if (!caretPos) {\n        const newBlock = SugarElement.fromDom(createTextBlock(editor));\n        if (direction === 1) {\n          after$4(SugarElement.fromDom(pre), newBlock);\n        } else {\n          before$3(SugarElement.fromDom(pre), newBlock);\n        }\n        editor.selection.select(newBlock.dom, true);\n        editor.selection.collapse();\n      }\n    }\n  };\n  const getHorizontalRange = (editor, forward) => {\n    const direction = forward ? HDirection.Forwards : HDirection.Backwards;\n    const range = editor.selection.getRng();\n    return moveToCeFalseHorizontally(direction, editor, range).orThunk(() => {\n      exitPreBlock(editor, direction, range);\n      return Optional.none();\n    });\n  };\n  const getVerticalRange = (editor, down) => {\n    const direction = down ? 1 : -1;\n    const range = editor.selection.getRng();\n    return moveToCeFalseVertically(direction, editor, range).orThunk(() => {\n      exitPreBlock(editor, direction, range);\n      return Optional.none();\n    });\n  };\n  const flipDirection = (selection, forward) => {\n    const elm = forward ? selection.getEnd(true) : selection.getStart(true);\n    return isRtl(elm) ? !forward : forward;\n  };\n  const moveH$2 = (editor, forward) => getHorizontalRange(editor, flipDirection(editor.selection, forward)).exists(newRange => {\n    moveToRange(editor, newRange);\n    return true;\n  });\n  const moveV$4 = (editor, down) => getVerticalRange(editor, down).exists(newRange => {\n    moveToRange(editor, newRange);\n    return true;\n  });\n  const moveToLineEndPoint$1 = (editor, forward) => {\n    const isCefPosition = forward ? isAfterContentEditableFalse : isBeforeContentEditableFalse;\n    return moveToLineEndPoint$3(editor, forward, isCefPosition);\n  };\n  const selectToEndPoint = (editor, forward) => getEdgeCefPosition(editor, !forward).map(pos => {\n    const rng = pos.toRange();\n    const curRng = editor.selection.getRng();\n    if (forward) {\n      rng.setStart(curRng.startContainer, curRng.startOffset);\n    } else {\n      rng.setEnd(curRng.endContainer, curRng.endOffset);\n    }\n    return rng;\n  }).exists(rng => {\n    moveToRange(editor, rng);\n    return true;\n  });\n  const isTarget = node => contains$2(['figcaption'], name(node));\n  const getClosestTargetBlock = (pos, root, schema) => {\n    const isRoot = curry(eq, root);\n    return closest$4(SugarElement.fromDom(pos.container()), el => schema.isBlock(name(el)), isRoot).filter(isTarget);\n  };\n  const isAtFirstOrLastLine = (root, forward, pos) => forward ? isAtLastLine(root.dom, pos) : isAtFirstLine(root.dom, pos);\n  const moveCaretToNewEmptyLine = (editor, forward) => {\n    const root = SugarElement.fromDom(editor.getBody());\n    const pos = CaretPosition.fromRangeStart(editor.selection.getRng());\n    return getClosestTargetBlock(pos, root, editor.schema).exists(() => {\n      if (isAtFirstOrLastLine(root, forward, pos)) {\n        const insertFn = forward ? append$1 : prepend;\n        const rng = insertEmptyLine(editor, root, insertFn);\n        editor.selection.setRng(rng);\n        return true;\n      } else {\n        return false;\n      }\n    });\n  };\n  const moveV$3 = (editor, forward) => {\n    if (editor.selection.isCollapsed()) {\n      return moveCaretToNewEmptyLine(editor, forward);\n    } else {\n      return false;\n    }\n  };\n  const moveUp = (editor, details, summary) => {\n    const rng = editor.selection.getRng();\n    const pos = CaretPosition.fromRangeStart(rng);\n    const root = editor.getBody();\n    if (root.firstChild === details && isAtFirstLine(summary, pos)) {\n      editor.execCommand('InsertNewBlockBefore');\n      return true;\n    } else {\n      return false;\n    }\n  };\n  const moveDown = (editor, details) => {\n    const rng = editor.selection.getRng();\n    const pos = CaretPosition.fromRangeStart(rng);\n    const root = editor.getBody();\n    if (root.lastChild === details && isAtLastLine(details, pos)) {\n      editor.execCommand('InsertNewBlockAfter');\n      return true;\n    } else {\n      return false;\n    }\n  };\n  const move$2 = (editor, forward) => {\n    if (forward) {\n      return Optional.from(editor.dom.getParent(editor.selection.getNode(), 'details')).map(details => moveDown(editor, details)).getOr(false);\n    } else {\n      return Optional.from(editor.dom.getParent(editor.selection.getNode(), 'summary')).bind(summary => Optional.from(editor.dom.getParent(summary, 'details')).map(details => moveUp(editor, details, summary))).getOr(false);\n    }\n  };\n  const moveV$2 = (editor, forward) => move$2(editor, forward);\n  const baseKeyPattern = {\n    shiftKey: false,\n    altKey: false,\n    ctrlKey: false,\n    metaKey: false,\n    keyCode: 0\n  };\n  const defaultPatterns = patterns => map$3(patterns, pattern => ({\n    ...baseKeyPattern,\n    ...pattern\n  }));\n  const defaultDelayedPatterns = patterns => map$3(patterns, pattern => ({\n    ...baseKeyPattern,\n    ...pattern\n  }));\n  const matchesEvent = (pattern, evt) => evt.keyCode === pattern.keyCode && evt.shiftKey === pattern.shiftKey && evt.altKey === pattern.altKey && evt.ctrlKey === pattern.ctrlKey && evt.metaKey === pattern.metaKey;\n  const match$1 = (patterns, evt) => bind$3(defaultPatterns(patterns), pattern => matchesEvent(pattern, evt) ? [pattern] : []);\n  const matchDelayed = (patterns, evt) => bind$3(defaultDelayedPatterns(patterns), pattern => matchesEvent(pattern, evt) ? [pattern] : []);\n  const action = (f, ...x) => () => f.apply(null, x);\n  const execute = (patterns, evt) => find$2(match$1(patterns, evt), pattern => pattern.action());\n  const executeWithDelayedAction = (patterns, evt) => findMap(matchDelayed(patterns, evt), pattern => pattern.action());\n  const moveH$1 = (editor, forward) => {\n    const direction = forward ? HDirection.Forwards : HDirection.Backwards;\n    const range = editor.selection.getRng();\n    return moveHorizontally(editor, direction, range, isBeforeMedia, isAfterMedia, isMedia$2).exists(newRange => {\n      moveToRange(editor, newRange);\n      return true;\n    });\n  };\n  const moveV$1 = (editor, down) => {\n    const direction = down ? 1 : -1;\n    const range = editor.selection.getRng();\n    return moveVertically(editor, direction, range, isBeforeMedia, isAfterMedia, isMedia$2).exists(newRange => {\n      moveToRange(editor, newRange);\n      return true;\n    });\n  };\n  const moveToLineEndPoint = (editor, forward) => {\n    const isNearMedia = forward ? isAfterMedia : isBeforeMedia;\n    return moveToLineEndPoint$3(editor, forward, isNearMedia);\n  };\n  const adt = Adt.generate([{\n    none: ['current']\n  }, {\n    first: ['current']\n  }, {\n    middle: ['current', 'target']\n  }, {\n    last: ['current']\n  }]);\n  const none = current => adt.none(current);\n  const CellLocation = {\n    ...adt,\n    none\n  };\n  const firstLayer = (scope, selector) => {\n    return filterFirstLayer(scope, selector, always);\n  };\n  const filterFirstLayer = (scope, selector, predicate) => {\n    return bind$3(children$1(scope), x => {\n      if (is$1(x, selector)) {\n        return predicate(x) ? [x] : [];\n      } else {\n        return filterFirstLayer(x, selector, predicate);\n      }\n    });\n  };\n  const lookup$1 = (tags, element, isRoot = never) => {\n    if (isRoot(element)) {\n      return Optional.none();\n    }\n    if (contains$2(tags, name(element))) {\n      return Optional.some(element);\n    }\n    const isRootOrUpperTable = elm => is$1(elm, 'table') || isRoot(elm);\n    return ancestor$3(element, tags.join(','), isRootOrUpperTable);\n  };\n  const cell = (element, isRoot) => lookup$1(['td', 'th'], element, isRoot);\n  const cells = ancestor => firstLayer(ancestor, 'th,td');\n  const table = (element, isRoot) => closest$3(element, 'table', isRoot);\n  const walk = (all, current, index, direction, isEligible = always) => {\n    const forwards = direction === 1;\n    if (!forwards && index <= 0) {\n      return CellLocation.first(all[0]);\n    } else if (forwards && index >= all.length - 1) {\n      return CellLocation.last(all[all.length - 1]);\n    } else {\n      const newIndex = index + direction;\n      const elem = all[newIndex];\n      return isEligible(elem) ? CellLocation.middle(current, elem) : walk(all, current, newIndex, direction, isEligible);\n    }\n  };\n  const detect = (current, isRoot) => {\n    return table(current, isRoot).bind(table => {\n      const all = cells(table);\n      const index = findIndex$2(all, x => eq(current, x));\n      return index.map(index => ({\n        index,\n        all\n      }));\n    });\n  };\n  const next = (current, isEligible, isRoot) => {\n    const detection = detect(current, isRoot);\n    return detection.fold(() => {\n      return CellLocation.none(current);\n    }, info => {\n      return walk(info.all, current, info.index, 1, isEligible);\n    });\n  };\n  const prev = (current, isEligible, isRoot) => {\n    const detection = detect(current, isRoot);\n    return detection.fold(() => {\n      return CellLocation.none();\n    }, info => {\n      return walk(info.all, current, info.index, -1, isEligible);\n    });\n  };\n  const isTextNodeWithCursorPosition = el => getOption(el).filter(text => text.trim().length !== 0 || text.indexOf(nbsp) > -1).isSome();\n  const isContentEditableFalse$3 = elem => isHTMLElement$1(elem) && get$9(elem, 'contenteditable') === 'false';\n  const elementsWithCursorPosition = ['img', 'br'];\n  const isCursorPosition = elem => {\n    const hasCursorPosition = isTextNodeWithCursorPosition(elem);\n    return hasCursorPosition || contains$2(elementsWithCursorPosition, name(elem)) || isContentEditableFalse$3(elem);\n  };\n  const first = element => descendant$2(element, isCursorPosition);\n  const deflate = (rect, delta) => ({\n    left: rect.left - delta,\n    top: rect.top - delta,\n    right: rect.right + delta * 2,\n    bottom: rect.bottom + delta * 2,\n    width: rect.width + delta,\n    height: rect.height + delta\n  });\n  const getCorners = (getYAxisValue, tds) => bind$3(tds, td => {\n    const rect = deflate(clone$1(td.getBoundingClientRect()), -1);\n    return [{\n      x: rect.left,\n      y: getYAxisValue(rect),\n      cell: td\n    }, {\n      x: rect.right,\n      y: getYAxisValue(rect),\n      cell: td\n    }];\n  });\n  const findClosestCorner = (corners, x, y) => foldl(corners, (acc, newCorner) => acc.fold(() => Optional.some(newCorner), oldCorner => {\n    const oldDist = Math.sqrt(Math.abs(oldCorner.x - x) + Math.abs(oldCorner.y - y));\n    const newDist = Math.sqrt(Math.abs(newCorner.x - x) + Math.abs(newCorner.y - y));\n    return Optional.some(newDist < oldDist ? newCorner : oldCorner);\n  }), Optional.none());\n  const getClosestCell = (getYAxisValue, isTargetCorner, table, x, y) => {\n    const cells = descendants(SugarElement.fromDom(table), 'td,th,caption').map(e => e.dom);\n    const corners = filter$5(getCorners(getYAxisValue, cells), corner => isTargetCorner(corner, y));\n    return findClosestCorner(corners, x, y).map(corner => corner.cell);\n  };\n  const getBottomValue = rect => rect.bottom;\n  const getTopValue = rect => rect.top;\n  const isAbove = (corner, y) => corner.y < y;\n  const isBelow = (corner, y) => corner.y > y;\n  const getClosestCellAbove = curry(getClosestCell, getBottomValue, isAbove);\n  const getClosestCellBelow = curry(getClosestCell, getTopValue, isBelow);\n  const findClosestPositionInAboveCell = (table, pos) => head(pos.getClientRects()).bind(rect => getClosestCellAbove(table, rect.left, rect.top)).bind(cell => findClosestHorizontalPosition(getLastLinePositions(cell), pos));\n  const findClosestPositionInBelowCell = (table, pos) => last$2(pos.getClientRects()).bind(rect => getClosestCellBelow(table, rect.left, rect.top)).bind(cell => findClosestHorizontalPosition(getFirstLinePositions(cell), pos));\n  const hasNextBreak = (getPositionsUntil, scope, lineInfo) => lineInfo.breakAt.exists(breakPos => getPositionsUntil(scope, breakPos).breakAt.isSome());\n  const startsWithWrapBreak = lineInfo => lineInfo.breakType === BreakType.Wrap && lineInfo.positions.length === 0;\n  const startsWithBrBreak = lineInfo => lineInfo.breakType === BreakType.Br && lineInfo.positions.length === 1;\n  const isAtTableCellLine = (getPositionsUntil, scope, pos) => {\n    const lineInfo = getPositionsUntil(scope, pos);\n    if (startsWithWrapBreak(lineInfo) || !isBr$6(pos.getNode()) && startsWithBrBreak(lineInfo)) {\n      return !hasNextBreak(getPositionsUntil, scope, lineInfo);\n    } else {\n      return lineInfo.breakAt.isNone();\n    }\n  };\n  const isAtFirstTableCellLine = curry(isAtTableCellLine, getPositionsUntilPreviousLine);\n  const isAtLastTableCellLine = curry(isAtTableCellLine, getPositionsUntilNextLine);\n  const isCaretAtStartOrEndOfTable = (forward, rng, table) => {\n    const caretPos = CaretPosition.fromRangeStart(rng);\n    return positionIn(!forward, table).exists(pos => pos.isEqual(caretPos));\n  };\n  const navigateHorizontally = (editor, forward, table, _td) => {\n    const rng = editor.selection.getRng();\n    const direction = forward ? 1 : -1;\n    if (isFakeCaretTableBrowser() && isCaretAtStartOrEndOfTable(forward, rng, table)) {\n      showCaret(direction, editor, table, !forward, false).each(newRng => {\n        moveToRange(editor, newRng);\n      });\n      return true;\n    }\n    return false;\n  };\n  const getClosestAbovePosition = (root, table, start) => findClosestPositionInAboveCell(table, start).orThunk(() => head(start.getClientRects()).bind(rect => findClosestHorizontalPositionFromPoint(getPositionsAbove(root, CaretPosition.before(table)), rect.left))).getOr(CaretPosition.before(table));\n  const getClosestBelowPosition = (root, table, start) => findClosestPositionInBelowCell(table, start).orThunk(() => head(start.getClientRects()).bind(rect => findClosestHorizontalPositionFromPoint(getPositionsBelow(root, CaretPosition.after(table)), rect.left))).getOr(CaretPosition.after(table));\n  const getTable = (previous, pos) => {\n    const node = pos.getNode(previous);\n    return isTable$2(node) ? Optional.some(node) : Optional.none();\n  };\n  const renderBlock = (down, editor, table) => {\n    editor.undoManager.transact(() => {\n      const insertFn = down ? after$4 : before$3;\n      const rng = insertEmptyLine(editor, SugarElement.fromDom(table), insertFn);\n      moveToRange(editor, rng);\n    });\n  };\n  const moveCaret = (editor, down, pos) => {\n    const table = down ? getTable(true, pos) : getTable(false, pos);\n    const last = down === false;\n    table.fold(() => moveToRange(editor, pos.toRange()), table => positionIn(last, editor.getBody()).filter(lastPos => lastPos.isEqual(pos)).fold(() => moveToRange(editor, pos.toRange()), _ => renderBlock(down, editor, table)));\n  };\n  const navigateVertically = (editor, down, table, td) => {\n    const rng = editor.selection.getRng();\n    const pos = CaretPosition.fromRangeStart(rng);\n    const root = editor.getBody();\n    if (!down && isAtFirstTableCellLine(td, pos)) {\n      const newPos = getClosestAbovePosition(root, table, pos);\n      moveCaret(editor, down, newPos);\n      return true;\n    } else if (down && isAtLastTableCellLine(td, pos)) {\n      const newPos = getClosestBelowPosition(root, table, pos);\n      moveCaret(editor, down, newPos);\n      return true;\n    } else {\n      return false;\n    }\n  };\n  const move$1 = (editor, forward, mover) => Optional.from(editor.dom.getParent(editor.selection.getNode(), 'td,th')).bind(td => Optional.from(editor.dom.getParent(td, 'table')).map(table => mover(editor, forward, table, td))).getOr(false);\n  const moveH = (editor, forward) => move$1(editor, forward, navigateHorizontally);\n  const moveV = (editor, forward) => move$1(editor, forward, navigateVertically);\n  const getCellFirstCursorPosition = cell => {\n    const selection = SimSelection.exact(cell, 0, cell, 0);\n    return toNative(selection);\n  };\n  const tabGo = (editor, isRoot, cell) => {\n    return cell.fold(Optional.none, Optional.none, (_current, next) => {\n      return first(next).map(cell => {\n        return getCellFirstCursorPosition(cell);\n      });\n    }, current => {\n      if (editor.mode.isReadOnly()) {\n        return Optional.none();\n      }\n      editor.execCommand('mceTableInsertRowAfter');\n      return tabForward(editor, isRoot, current);\n    });\n  };\n  const tabForward = (editor, isRoot, cell) => tabGo(editor, isRoot, next(cell, isEditable$2));\n  const tabBackward = (editor, isRoot, cell) => tabGo(editor, isRoot, prev(cell, isEditable$2));\n  const handleTab = (editor, forward) => {\n    const rootElements = ['table', 'li', 'dl'];\n    const body = SugarElement.fromDom(editor.getBody());\n    const isRoot = element => {\n      const name$1 = name(element);\n      return eq(element, body) || contains$2(rootElements, name$1);\n    };\n    const rng = editor.selection.getRng();\n    const container = SugarElement.fromDom(!forward ? rng.startContainer : rng.endContainer);\n    return cell(container, isRoot).map(cell => {\n      table(cell, isRoot).each(table => {\n        editor.model.table.clearSelectedCells(table.dom);\n      });\n      editor.selection.collapse(!forward);\n      const navigation = !forward ? tabBackward : tabForward;\n      const rng = navigation(editor, isRoot, cell);\n      rng.each(range => {\n        editor.selection.setRng(range);\n      });\n      return true;\n    }).getOr(false);\n  };\n  const executeKeydownOverride$4 = (editor, caret, evt) => {\n    const isMac = Env.os.isMacOS() || Env.os.isiOS();\n    execute([{\n      keyCode: VK.RIGHT,\n      action: action(moveH$2, editor, true)\n    }, {\n      keyCode: VK.LEFT,\n      action: action(moveH$2, editor, false)\n    }, {\n      keyCode: VK.UP,\n      action: action(moveV$4, editor, false)\n    }, {\n      keyCode: VK.DOWN,\n      action: action(moveV$4, editor, true)\n    }, ...(isMac ? [{\n      keyCode: VK.UP,\n      action: action(selectToEndPoint, editor, false),\n      metaKey: true,\n      shiftKey: true\n    }, {\n      keyCode: VK.DOWN,\n      action: action(selectToEndPoint, editor, true),\n      metaKey: true,\n      shiftKey: true\n    }] : []), {\n      keyCode: VK.RIGHT,\n      action: action(moveH, editor, true)\n    }, {\n      keyCode: VK.LEFT,\n      action: action(moveH, editor, false)\n    }, {\n      keyCode: VK.UP,\n      action: action(moveV, editor, false)\n    }, {\n      keyCode: VK.DOWN,\n      action: action(moveV, editor, true)\n    }, {\n      keyCode: VK.UP,\n      action: action(moveV, editor, false)\n    }, {\n      keyCode: VK.UP,\n      action: action(moveV$2, editor, false)\n    }, {\n      keyCode: VK.DOWN,\n      action: action(moveV$2, editor, true)\n    }, {\n      keyCode: VK.RIGHT,\n      action: action(moveH$1, editor, true)\n    }, {\n      keyCode: VK.LEFT,\n      action: action(moveH$1, editor, false)\n    }, {\n      keyCode: VK.UP,\n      action: action(moveV$1, editor, false)\n    }, {\n      keyCode: VK.DOWN,\n      action: action(moveV$1, editor, true)\n    }, {\n      keyCode: VK.RIGHT,\n      action: action(move$3, editor, caret, true)\n    }, {\n      keyCode: VK.LEFT,\n      action: action(move$3, editor, caret, false)\n    }, {\n      keyCode: VK.RIGHT,\n      ctrlKey: !isMac,\n      altKey: isMac,\n      action: action(moveNextWord, editor, caret)\n    }, {\n      keyCode: VK.LEFT,\n      ctrlKey: !isMac,\n      altKey: isMac,\n      action: action(movePrevWord, editor, caret)\n    }, {\n      keyCode: VK.UP,\n      action: action(moveV$3, editor, false)\n    }, {\n      keyCode: VK.DOWN,\n      action: action(moveV$3, editor, true)\n    }], evt).each(_ => {\n      evt.preventDefault();\n    });\n  };\n  const setup$l = (editor, caret) => {\n    editor.on('keydown', evt => {\n      if (!evt.isDefaultPrevented()) {\n        executeKeydownOverride$4(editor, caret, evt);\n      }\n    });\n  };\n  const point = (container, offset) => ({\n    container,\n    offset\n  });\n  const DOM$7 = DOMUtils.DOM;\n  const alwaysNext = startNode => node => startNode === node ? -1 : 0;\n  const isBoundary = dom => node => dom.isBlock(node) || contains$2(['BR', 'IMG', 'HR', 'INPUT'], node.nodeName) || dom.getContentEditable(node) === 'false';\n  const textBefore = (node, offset, rootNode) => {\n    if (isText$b(node) && offset >= 0) {\n      return Optional.some(point(node, offset));\n    } else {\n      const textSeeker = TextSeeker(DOM$7);\n      return Optional.from(textSeeker.backwards(node, offset, alwaysNext(node), rootNode)).map(prev => point(prev.container, prev.container.data.length));\n    }\n  };\n  const textAfter = (node, offset, rootNode) => {\n    if (isText$b(node) && offset >= node.length) {\n      return Optional.some(point(node, offset));\n    } else {\n      const textSeeker = TextSeeker(DOM$7);\n      return Optional.from(textSeeker.forwards(node, offset, alwaysNext(node), rootNode)).map(prev => point(prev.container, 0));\n    }\n  };\n  const scanLeft = (node, offset, rootNode) => {\n    if (!isText$b(node)) {\n      return Optional.none();\n    }\n    const text = node.data;\n    if (offset >= 0 && offset <= text.length) {\n      return Optional.some(point(node, offset));\n    } else {\n      const textSeeker = TextSeeker(DOM$7);\n      return Optional.from(textSeeker.backwards(node, offset, alwaysNext(node), rootNode)).bind(prev => {\n        const prevText = prev.container.data;\n        return scanLeft(prev.container, offset + prevText.length, rootNode);\n      });\n    }\n  };\n  const scanRight = (node, offset, rootNode) => {\n    if (!isText$b(node)) {\n      return Optional.none();\n    }\n    const text = node.data;\n    if (offset <= text.length) {\n      return Optional.some(point(node, offset));\n    } else {\n      const textSeeker = TextSeeker(DOM$7);\n      return Optional.from(textSeeker.forwards(node, offset, alwaysNext(node), rootNode)).bind(next => scanRight(next.container, offset - text.length, rootNode));\n    }\n  };\n  const repeatLeft = (dom, node, offset, process, rootNode) => {\n    const search = TextSeeker(dom, isBoundary(dom));\n    return Optional.from(search.backwards(node, offset, process, rootNode));\n  };\n  const isValidTextRange = rng => rng.collapsed && isText$b(rng.startContainer);\n  const getText = rng => trim$2(rng.toString().replace(/\\u00A0/g, ' '));\n  const isWhitespace = chr => chr !== '' && ' \\xA0\\uFEFF\\f\\n\\r\\t\\x0B'.indexOf(chr) !== -1;\n  const stripTrigger = (text, trigger) => text.substring(trigger.length);\n  const findTrigger = (text, index, trigger, includeWhitespace = false) => {\n    let i;\n    const firstChar = trigger.charAt(0);\n    for (i = index - 1; i >= 0; i--) {\n      const char = text.charAt(i);\n      if (!includeWhitespace && isWhitespace(char)) {\n        return Optional.none();\n      }\n      if (firstChar === char && contains$1(text, trigger, i, index)) {\n        break;\n      }\n    }\n    return Optional.some(i);\n  };\n  const getContext = (dom, initRange, trigger, includeWhitespace = false) => {\n    if (!isValidTextRange(initRange)) {\n      return Optional.none();\n    }\n    const buffer = {\n      text: '',\n      offset: 0\n    };\n    const findTriggerIndex = (element, offset, text) => {\n      buffer.text = text + buffer.text;\n      buffer.offset += offset;\n      return findTrigger(buffer.text, buffer.offset, trigger, includeWhitespace).getOr(offset);\n    };\n    const root = dom.getParent(initRange.startContainer, dom.isBlock) || dom.getRoot();\n    return repeatLeft(dom, initRange.startContainer, initRange.startOffset, findTriggerIndex, root).bind(spot => {\n      const range = initRange.cloneRange();\n      range.setStart(spot.container, spot.offset);\n      range.setEnd(initRange.endContainer, initRange.endOffset);\n      if (range.collapsed) {\n        return Optional.none();\n      }\n      const text = getText(range);\n      const triggerIndex = text.lastIndexOf(trigger);\n      if (triggerIndex !== 0) {\n        return Optional.none();\n      } else {\n        return Optional.some({\n          text: stripTrigger(text, trigger),\n          range,\n          trigger\n        });\n      }\n    });\n  };\n  const isText$1 = node => node.nodeType === TEXT;\n  const isElement = node => node.nodeType === ELEMENT;\n  const toLast = node => {\n    if (isText$1(node)) {\n      return point(node, node.data.length);\n    } else {\n      const children = node.childNodes;\n      return children.length > 0 ? toLast(children[children.length - 1]) : point(node, children.length);\n    }\n  };\n  const toLeaf = (node, offset) => {\n    const children = node.childNodes;\n    if (children.length > 0 && offset < children.length) {\n      return toLeaf(children[offset], 0);\n    } else if (children.length > 0 && isElement(node) && children.length === offset) {\n      return toLast(children[children.length - 1]);\n    } else {\n      return point(node, offset);\n    }\n  };\n  const isPreviousCharContent = (dom, leaf) => {\n    var _a;\n    const root = (_a = dom.getParent(leaf.container, dom.isBlock)) !== null && _a !== void 0 ? _a : dom.getRoot();\n    return repeatLeft(dom, leaf.container, leaf.offset, (_element, offset) => offset === 0 ? -1 : offset, root).filter(spot => {\n      const char = spot.container.data.charAt(spot.offset - 1);\n      return !isWhitespace(char);\n    }).isSome();\n  };\n  const isStartOfWord = dom => rng => {\n    const leaf = toLeaf(rng.startContainer, rng.startOffset);\n    return !isPreviousCharContent(dom, leaf);\n  };\n  const getTriggerContext = (dom, initRange, database) => findMap(database.triggers, trigger => getContext(dom, initRange, trigger));\n  const lookup = (editor, getDatabase) => {\n    const database = getDatabase();\n    const rng = editor.selection.getRng();\n    return getTriggerContext(editor.dom, rng, database).bind(context => lookupWithContext(editor, getDatabase, context));\n  };\n  const lookupWithContext = (editor, getDatabase, context, fetchOptions = {}) => {\n    var _a;\n    const database = getDatabase();\n    const rng = editor.selection.getRng();\n    const startText = (_a = rng.startContainer.nodeValue) !== null && _a !== void 0 ? _a : '';\n    const autocompleters = filter$5(database.lookupByTrigger(context.trigger), autocompleter => context.text.length >= autocompleter.minChars && autocompleter.matches.getOrThunk(() => isStartOfWord(editor.dom))(context.range, startText, context.text));\n    if (autocompleters.length === 0) {\n      return Optional.none();\n    }\n    const lookupData = Promise.all(map$3(autocompleters, ac => {\n      const fetchResult = ac.fetch(context.text, ac.maxResults, fetchOptions);\n      return fetchResult.then(results => ({\n        matchText: context.text,\n        items: results,\n        columns: ac.columns,\n        onAction: ac.onAction,\n        highlightOn: ac.highlightOn\n      }));\n    }));\n    return Optional.some({\n      lookupData,\n      context\n    });\n  };\n  var SimpleResultType;\n  (function (SimpleResultType) {\n    SimpleResultType[SimpleResultType['Error'] = 0] = 'Error';\n    SimpleResultType[SimpleResultType['Value'] = 1] = 'Value';\n  })(SimpleResultType || (SimpleResultType = {}));\n  const fold$1 = (res, onError, onValue) => res.stype === SimpleResultType.Error ? onError(res.serror) : onValue(res.svalue);\n  const partition = results => {\n    const values = [];\n    const errors = [];\n    each$e(results, obj => {\n      fold$1(obj, err => errors.push(err), val => values.push(val));\n    });\n    return {\n      values,\n      errors\n    };\n  };\n  const mapError = (res, f) => {\n    if (res.stype === SimpleResultType.Error) {\n      return {\n        stype: SimpleResultType.Error,\n        serror: f(res.serror)\n      };\n    } else {\n      return res;\n    }\n  };\n  const map = (res, f) => {\n    if (res.stype === SimpleResultType.Value) {\n      return {\n        stype: SimpleResultType.Value,\n        svalue: f(res.svalue)\n      };\n    } else {\n      return res;\n    }\n  };\n  const bind$1 = (res, f) => {\n    if (res.stype === SimpleResultType.Value) {\n      return f(res.svalue);\n    } else {\n      return res;\n    }\n  };\n  const bindError = (res, f) => {\n    if (res.stype === SimpleResultType.Error) {\n      return f(res.serror);\n    } else {\n      return res;\n    }\n  };\n  const svalue = v => ({\n    stype: SimpleResultType.Value,\n    svalue: v\n  });\n  const serror = e => ({\n    stype: SimpleResultType.Error,\n    serror: e\n  });\n  const toResult = res => fold$1(res, Result.error, Result.value);\n  const fromResult = res => res.fold(serror, svalue);\n  const SimpleResult = {\n    fromResult,\n    toResult,\n    svalue,\n    partition,\n    serror,\n    bind: bind$1,\n    bindError,\n    map,\n    mapError,\n    fold: fold$1\n  };\n  const formatObj = input => {\n    return isObject(input) && keys(input).length > 100 ? ' removed due to size' : JSON.stringify(input, null, 2);\n  };\n  const formatErrors = errors => {\n    const es = errors.length > 10 ? errors.slice(0, 10).concat([{\n      path: [],\n      getErrorInfo: constant('... (only showing first ten failures)')\n    }]) : errors;\n    return map$3(es, e => {\n      return 'Failed path: (' + e.path.join(' > ') + ')\\n' + e.getErrorInfo();\n    });\n  };\n  const nu = (path, getErrorInfo) => {\n    return SimpleResult.serror([{\n      path,\n      getErrorInfo\n    }]);\n  };\n  const missingRequired = (path, key, obj) => nu(path, () => 'Could not find valid *required* value for \"' + key + '\" in ' + formatObj(obj));\n  const missingKey = (path, key) => nu(path, () => 'Choice schema did not contain choice key: \"' + key + '\"');\n  const missingBranch = (path, branches, branch) => nu(path, () => 'The chosen schema: \"' + branch + '\" did not exist in branches: ' + formatObj(branches));\n  const custom = (path, err) => nu(path, constant(err));\n  const chooseFrom = (path, input, branches, ch) => {\n    const fields = get$a(branches, ch);\n    return fields.fold(() => missingBranch(path, branches, ch), vp => vp.extract(path.concat(['branch: ' + ch]), input));\n  };\n  const choose$1 = (key, branches) => {\n    const extract = (path, input) => {\n      const choice = get$a(input, key);\n      return choice.fold(() => missingKey(path, key), chosen => chooseFrom(path, input, branches, chosen));\n    };\n    const toString = () => 'chooseOn(' + key + '). Possible values: ' + keys(branches);\n    return {\n      extract,\n      toString\n    };\n  };\n  const shallow = (old, nu) => {\n    return nu;\n  };\n  const deep = (old, nu) => {\n    const bothObjects = isPlainObject(old) && isPlainObject(nu);\n    return bothObjects ? deepMerge(old, nu) : nu;\n  };\n  const baseMerge = merger => {\n    return (...objects) => {\n      if (objects.length === 0) {\n        throw new Error(`Can't merge zero objects`);\n      }\n      const ret = {};\n      for (let j = 0; j < objects.length; j++) {\n        const curObject = objects[j];\n        for (const key in curObject) {\n          if (has$2(curObject, key)) {\n            ret[key] = merger(ret[key], curObject[key]);\n          }\n        }\n      }\n      return ret;\n    };\n  };\n  const deepMerge = baseMerge(deep);\n  const merge = baseMerge(shallow);\n  const required = () => ({\n    tag: 'required',\n    process: {}\n  });\n  const defaultedThunk = fallbackThunk => ({\n    tag: 'defaultedThunk',\n    process: fallbackThunk\n  });\n  const defaulted$1 = fallback => defaultedThunk(constant(fallback));\n  const asOption = () => ({\n    tag: 'option',\n    process: {}\n  });\n  const mergeValues = (values, base) => values.length > 0 ? SimpleResult.svalue(deepMerge(base, merge.apply(undefined, values))) : SimpleResult.svalue(base);\n  const mergeErrors = errors => compose(SimpleResult.serror, flatten)(errors);\n  const consolidateObj = (objects, base) => {\n    const partition = SimpleResult.partition(objects);\n    return partition.errors.length > 0 ? mergeErrors(partition.errors) : mergeValues(partition.values, base);\n  };\n  const consolidateArr = objects => {\n    const partitions = SimpleResult.partition(objects);\n    return partitions.errors.length > 0 ? mergeErrors(partitions.errors) : SimpleResult.svalue(partitions.values);\n  };\n  const ResultCombine = {\n    consolidateObj,\n    consolidateArr\n  };\n  const field$1 = (key, newKey, presence, prop) => ({\n    tag: 'field',\n    key,\n    newKey,\n    presence,\n    prop\n  });\n  const customField$1 = (newKey, instantiator) => ({\n    tag: 'custom',\n    newKey,\n    instantiator\n  });\n  const fold = (value, ifField, ifCustom) => {\n    switch (value.tag) {\n      case 'field':\n        return ifField(value.key, value.newKey, value.presence, value.prop);\n      case 'custom':\n        return ifCustom(value.newKey, value.instantiator);\n    }\n  };\n  const value = validator => {\n    const extract = (path, val) => {\n      return SimpleResult.bindError(validator(val), err => custom(path, err));\n    };\n    const toString = constant('val');\n    return {\n      extract,\n      toString\n    };\n  };\n  const anyValue$1 = value(SimpleResult.svalue);\n  const requiredAccess = (path, obj, key, bundle) => get$a(obj, key).fold(() => missingRequired(path, key, obj), bundle);\n  const fallbackAccess = (obj, key, fallback, bundle) => {\n    const v = get$a(obj, key).getOrThunk(() => fallback(obj));\n    return bundle(v);\n  };\n  const optionAccess = (obj, key, bundle) => bundle(get$a(obj, key));\n  const optionDefaultedAccess = (obj, key, fallback, bundle) => {\n    const opt = get$a(obj, key).map(val => val === true ? fallback(obj) : val);\n    return bundle(opt);\n  };\n  const extractField = (field, path, obj, key, prop) => {\n    const bundle = av => prop.extract(path.concat([key]), av);\n    const bundleAsOption = optValue => optValue.fold(() => SimpleResult.svalue(Optional.none()), ov => {\n      const result = prop.extract(path.concat([key]), ov);\n      return SimpleResult.map(result, Optional.some);\n    });\n    switch (field.tag) {\n      case 'required':\n        return requiredAccess(path, obj, key, bundle);\n      case 'defaultedThunk':\n        return fallbackAccess(obj, key, field.process, bundle);\n      case 'option':\n        return optionAccess(obj, key, bundleAsOption);\n      case 'defaultedOptionThunk':\n        return optionDefaultedAccess(obj, key, field.process, bundleAsOption);\n      case 'mergeWithThunk':\n        {\n          return fallbackAccess(obj, key, constant({}), v => {\n            const result = deepMerge(field.process(obj), v);\n            return bundle(result);\n          });\n        }\n    }\n  };\n  const extractFields = (path, obj, fields) => {\n    const success = {};\n    const errors = [];\n    for (const field of fields) {\n      fold(field, (key, newKey, presence, prop) => {\n        const result = extractField(presence, path, obj, key, prop);\n        SimpleResult.fold(result, err => {\n          errors.push(...err);\n        }, res => {\n          success[newKey] = res;\n        });\n      }, (newKey, instantiator) => {\n        success[newKey] = instantiator(obj);\n      });\n    }\n    return errors.length > 0 ? SimpleResult.serror(errors) : SimpleResult.svalue(success);\n  };\n  const objOf = values => {\n    const extract = (path, o) => extractFields(path, o, values);\n    const toString = () => {\n      const fieldStrings = map$3(values, value => fold(value, (key, _okey, _presence, prop) => key + ' -> ' + prop.toString(), (newKey, _instantiator) => 'state(' + newKey + ')'));\n      return 'obj{\\n' + fieldStrings.join('\\n') + '}';\n    };\n    return {\n      extract,\n      toString\n    };\n  };\n  const arrOf = prop => {\n    const extract = (path, array) => {\n      const results = map$3(array, (a, i) => prop.extract(path.concat(['[' + i + ']']), a));\n      return ResultCombine.consolidateArr(results);\n    };\n    const toString = () => 'array(' + prop.toString() + ')';\n    return {\n      extract,\n      toString\n    };\n  };\n  const valueOf = validator => value(v => validator(v).fold(SimpleResult.serror, SimpleResult.svalue));\n  const extractValue = (label, prop, obj) => {\n    const res = prop.extract([label], obj);\n    return SimpleResult.mapError(res, errs => ({\n      input: obj,\n      errors: errs\n    }));\n  };\n  const asRaw = (label, prop, obj) => SimpleResult.toResult(extractValue(label, prop, obj));\n  const formatError = errInfo => {\n    return 'Errors: \\n' + formatErrors(errInfo.errors).join('\\n') + '\\n\\nInput object: ' + formatObj(errInfo.input);\n  };\n  const choose = (key, branches) => choose$1(key, map$2(branches, objOf));\n  const anyValue = constant(anyValue$1);\n  const typedValue = (validator, expectedType) => value(a => {\n    const actualType = typeof a;\n    return validator(a) ? SimpleResult.svalue(a) : SimpleResult.serror(`Expected type: ${expectedType} but got: ${actualType}`);\n  });\n  const number = typedValue(isNumber, 'number');\n  const string = typedValue(isString, 'string');\n  const boolean = typedValue(isBoolean, 'boolean');\n  const functionProcessor = typedValue(isFunction, 'function');\n  const field = field$1;\n  const customField = customField$1;\n  const validateEnum = values => valueOf(value => contains$2(values, value) ? Result.value(value) : Result.error(`Unsupported value: \"${value}\", choose one of \"${values.join(', ')}\".`));\n  const requiredOf = (key, schema) => field(key, key, required(), schema);\n  const requiredString = key => requiredOf(key, string);\n  const requiredFunction = key => requiredOf(key, functionProcessor);\n  const requiredArrayOf = (key, schema) => field(key, key, required(), arrOf(schema));\n  const optionOf = (key, schema) => field(key, key, asOption(), schema);\n  const optionString = key => optionOf(key, string);\n  const optionFunction = key => optionOf(key, functionProcessor);\n  const defaulted = (key, fallback) => field(key, key, defaulted$1(fallback), anyValue());\n  const defaultedOf = (key, fallback, schema) => field(key, key, defaulted$1(fallback), schema);\n  const defaultedNumber = (key, fallback) => defaultedOf(key, fallback, number);\n  const defaultedString = (key, fallback) => defaultedOf(key, fallback, string);\n  const defaultedStringEnum = (key, fallback, values) => defaultedOf(key, fallback, validateEnum(values));\n  const defaultedBoolean = (key, fallback) => defaultedOf(key, fallback, boolean);\n  const defaultedFunction = (key, fallback) => defaultedOf(key, fallback, functionProcessor);\n  const defaultedArrayOf = (key, fallback, schema) => defaultedOf(key, fallback, arrOf(schema));\n  const type = requiredString('type');\n  const fetch$1 = requiredFunction('fetch');\n  const onAction = requiredFunction('onAction');\n  const onSetup = defaultedFunction('onSetup', () => noop);\n  const optionalText = optionString('text');\n  const optionalIcon = optionString('icon');\n  const optionalTooltip = optionString('tooltip');\n  const optionalLabel = optionString('label');\n  const active = defaultedBoolean('active', false);\n  const enabled = defaultedBoolean('enabled', true);\n  const primary = defaultedBoolean('primary', false);\n  const defaultedColumns = num => defaulted('columns', num);\n  const defaultedType = type => defaultedString('type', type);\n  const autocompleterSchema = objOf([type, requiredString('trigger'), defaultedNumber('minChars', 1), defaultedColumns(1), defaultedNumber('maxResults', 10), optionFunction('matches'), fetch$1, onAction, defaultedArrayOf('highlightOn', [], string)]);\n  const createAutocompleter = spec => asRaw('Autocompleter', autocompleterSchema, spec);\n  const baseToolbarButtonFields = [enabled, optionalTooltip, optionalIcon, optionalText, onSetup, defaultedString('context', 'mode:design')];\n  const baseToolbarToggleButtonFields = [active].concat(baseToolbarButtonFields);\n  const contextBarFields = [defaultedFunction('predicate', never), defaultedStringEnum('scope', 'node', ['node', 'editor']), defaultedStringEnum('position', 'selection', ['node', 'selection', 'line'])];\n  const contextButtonFields = baseToolbarButtonFields.concat([defaultedType('contextformbutton'), primary, onAction, customField('original', identity)]);\n  const contextToggleButtonFields = baseToolbarToggleButtonFields.concat([defaultedType('contextformbutton'), primary, onAction, customField('original', identity)]);\n  const launchButtonFields = baseToolbarButtonFields.concat([defaultedType('contextformbutton')]);\n  const launchToggleButtonFields = baseToolbarToggleButtonFields.concat([defaultedType('contextformtogglebutton')]);\n  const toggleOrNormal = choose('type', {\n    contextformbutton: contextButtonFields,\n    contextformtogglebutton: contextToggleButtonFields\n  });\n  objOf([defaultedType('contextform'), defaultedFunction('initValue', constant('')), optionalLabel, requiredArrayOf('commands', toggleOrNormal), optionOf('launch', choose('type', {\n    contextformbutton: launchButtonFields,\n    contextformtogglebutton: launchToggleButtonFields\n  }))].concat(contextBarFields));\n  const register$2 = editor => {\n    const popups = editor.ui.registry.getAll().popups;\n    const dataset = map$2(popups, popup => createAutocompleter(popup).fold(err => {\n      throw new Error(formatError(err));\n    }, identity));\n    const triggers = stringArray(mapToArray(dataset, v => v.trigger));\n    const datasetValues = values(dataset);\n    const lookupByTrigger = trigger => filter$5(datasetValues, dv => dv.trigger === trigger);\n    return {\n      dataset,\n      triggers,\n      lookupByTrigger\n    };\n  };\n  const setupEditorInput = (editor, api) => {\n    const update = last(api.load, 50);\n    editor.on('input', e => {\n      if (e.inputType === 'insertCompositionText' && !editor.composing) {\n        return;\n      }\n      update.throttle();\n    });\n    editor.on('keydown', e => {\n      const keyCode = e.which;\n      if (keyCode === 8) {\n        update.throttle();\n      } else if (keyCode === 27) {\n        update.cancel();\n        api.cancelIfNecessary();\n      } else if (keyCode === 38 || keyCode === 40) {\n        update.cancel();\n      }\n    }, true);\n    editor.on('remove', update.cancel);\n  };\n  const setup$k = editor => {\n    const activeAutocompleter = value$2();\n    const uiActive = Cell(false);\n    const isActive = activeAutocompleter.isSet;\n    const cancelIfNecessary = () => {\n      if (isActive()) {\n        fireAutocompleterEnd(editor);\n        uiActive.set(false);\n        activeAutocompleter.clear();\n      }\n    };\n    const commenceIfNecessary = context => {\n      if (!isActive()) {\n        activeAutocompleter.set({\n          trigger: context.trigger,\n          matchLength: context.text.length\n        });\n      }\n    };\n    const getAutocompleters = cached(() => register$2(editor));\n    const doLookup = fetchOptions => activeAutocompleter.get().map(ac => getContext(editor.dom, editor.selection.getRng(), ac.trigger, true).bind(newContext => lookupWithContext(editor, getAutocompleters, newContext, fetchOptions))).getOrThunk(() => lookup(editor, getAutocompleters));\n    const load = fetchOptions => {\n      doLookup(fetchOptions).fold(cancelIfNecessary, lookupInfo => {\n        commenceIfNecessary(lookupInfo.context);\n        lookupInfo.lookupData.then(lookupData => {\n          activeAutocompleter.get().map(ac => {\n            const context = lookupInfo.context;\n            if (ac.trigger !== context.trigger) {\n              return;\n            }\n            activeAutocompleter.set({\n              ...ac,\n              matchLength: context.text.length\n            });\n            if (uiActive.get()) {\n              fireAutocompleterUpdateActiveRange(editor, {\n                range: context.range\n              });\n              fireAutocompleterUpdate(editor, {\n                lookupData\n              });\n            } else {\n              uiActive.set(true);\n              fireAutocompleterUpdateActiveRange(editor, {\n                range: context.range\n              });\n              fireAutocompleterStart(editor, {\n                lookupData\n              });\n            }\n          });\n        });\n      });\n    };\n    const isRangeInsideOrEqual = (innerRange, outerRange) => {\n      const startComparison = innerRange.compareBoundaryPoints(window.Range.START_TO_START, outerRange);\n      const endComparison = innerRange.compareBoundaryPoints(window.Range.END_TO_END, outerRange);\n      return startComparison >= 0 && endComparison <= 0;\n    };\n    const readActiveRange = () => {\n      return activeAutocompleter.get().bind(({\n        trigger\n      }) => {\n        const selRange = editor.selection.getRng();\n        return getContext(editor.dom, selRange, trigger, uiActive.get()).filter(({\n          range\n        }) => isRangeInsideOrEqual(selRange, range)).map(({\n          range\n        }) => range);\n      });\n    };\n    editor.addCommand('mceAutocompleterReload', (_ui, value) => {\n      const fetchOptions = isObject(value) ? value.fetchOptions : {};\n      load(fetchOptions);\n    });\n    editor.addCommand('mceAutocompleterClose', cancelIfNecessary);\n    editor.addCommand('mceAutocompleterRefreshActiveRange', () => {\n      readActiveRange().each(range => {\n        fireAutocompleterUpdateActiveRange(editor, {\n          range\n        });\n      });\n    });\n    editor.editorCommands.addQueryStateHandler('mceAutoCompleterInRange', () => readActiveRange().isSome());\n    setupEditorInput(editor, {\n      cancelIfNecessary,\n      load\n    });\n  };\n  const browser$1 = detect$1().browser;\n  const isSafari = browser$1.isSafari();\n  const emptyNodeContents = node => fillWithPaddingBr(SugarElement.fromDom(node));\n  const isEntireNodeSelected = (rng, node) => {\n    var _a;\n    return rng.startOffset === 0 && rng.endOffset === ((_a = node.textContent) === null || _a === void 0 ? void 0 : _a.length);\n  };\n  const getParentDetailsElementAtPos = (dom, pos) => Optional.from(dom.getParent(pos.container(), 'details'));\n  const isInDetailsElement = (dom, pos) => getParentDetailsElementAtPos(dom, pos).isSome();\n  const getDetailsElements = (dom, rng) => {\n    const startDetails = Optional.from(dom.getParent(rng.startContainer, 'details'));\n    const endDetails = Optional.from(dom.getParent(rng.endContainer, 'details'));\n    if (startDetails.isSome() || endDetails.isSome()) {\n      const startSummary = startDetails.bind(details => Optional.from(dom.select('summary', details)[0]));\n      return Optional.some({\n        startSummary,\n        startDetails,\n        endDetails\n      });\n    } else {\n      return Optional.none();\n    }\n  };\n  const isCaretInTheBeginningOf = (caretPos, element) => firstPositionIn(element).exists(pos => pos.isEqual(caretPos));\n  const isCaretInTheEndOf = (caretPos, element) => {\n    return lastPositionIn(element).exists(pos => {\n      if (isBr$6(pos.getNode())) {\n        return prevPosition(element, pos).exists(pos2 => pos2.isEqual(caretPos)) || pos.isEqual(caretPos);\n      } else {\n        return pos.isEqual(caretPos);\n      }\n    });\n  };\n  const isCaretAtStartOfSummary = (caretPos, detailsElements) => detailsElements.startSummary.exists(summary => isCaretInTheBeginningOf(caretPos, summary));\n  const isCaretAtEndOfSummary = (caretPos, detailsElements) => detailsElements.startSummary.exists(summary => isCaretInTheEndOf(caretPos, summary));\n  const isCaretInFirstPositionInBody = (caretPos, detailsElements) => detailsElements.startDetails.exists(details => prevPosition(details, caretPos).forall(pos => detailsElements.startSummary.exists(summary => !summary.contains(caretPos.container()) && summary.contains(pos.container()))));\n  const isCaretInLastPositionInBody = (root, caretPos, detailsElements) => detailsElements.startDetails.exists(details => nextPosition(root, caretPos).forall(pos => !details.contains(pos.container())));\n  const setCaretToPosition = (editor, position) => {\n    const node = position.getNode();\n    if (!isUndefined(node)) {\n      editor.selection.setCursorLocation(node, position.offset());\n    }\n  };\n  const moveCaretToDetailsPos = (editor, pos, forward) => {\n    const details = editor.dom.getParent(pos.container(), 'details');\n    if (details && !details.open) {\n      const summary = editor.dom.select('summary', details)[0];\n      if (summary) {\n        const newPos = forward ? firstPositionIn(summary) : lastPositionIn(summary);\n        newPos.each(pos => setCaretToPosition(editor, pos));\n      }\n    } else {\n      setCaretToPosition(editor, pos);\n    }\n  };\n  const isPartialDelete = (rng, detailsElements) => {\n    const containsStart = element => element.contains(rng.startContainer);\n    const containsEnd = element => element.contains(rng.endContainer);\n    const startInSummary = detailsElements.startSummary.exists(containsStart);\n    const endInSummary = detailsElements.startSummary.exists(containsEnd);\n    const isPartiallySelectedDetailsElements = detailsElements.startDetails.forall(startDetails => detailsElements.endDetails.forall(endDetails => startDetails !== endDetails));\n    const isInPartiallySelectedSummary = (startInSummary || endInSummary) && !(startInSummary && endInSummary);\n    return isInPartiallySelectedSummary || isPartiallySelectedDetailsElements;\n  };\n  const shouldPreventDeleteIntoDetails = (editor, forward, granularity) => {\n    const {\n      dom,\n      selection\n    } = editor;\n    const root = editor.getBody();\n    if (granularity === 'character') {\n      const caretPos = CaretPosition.fromRangeStart(selection.getRng());\n      const parentBlock = dom.getParent(caretPos.container(), dom.isBlock);\n      const parentDetailsAtCaret = getParentDetailsElementAtPos(dom, caretPos);\n      const inEmptyParentBlock = parentBlock && dom.isEmpty(parentBlock);\n      const isFirstBlock = isNull(parentBlock === null || parentBlock === void 0 ? void 0 : parentBlock.previousSibling);\n      const isLastBlock = isNull(parentBlock === null || parentBlock === void 0 ? void 0 : parentBlock.nextSibling);\n      if (inEmptyParentBlock) {\n        const firstOrLast = forward ? isLastBlock : isFirstBlock;\n        if (firstOrLast) {\n          const isBeforeAfterDetails = navigate(!forward, root, caretPos).exists(pos => {\n            return isInDetailsElement(dom, pos) && !equals(parentDetailsAtCaret, getParentDetailsElementAtPos(dom, pos));\n          });\n          if (isBeforeAfterDetails) {\n            return true;\n          }\n        }\n      }\n      return navigate(forward, root, caretPos).fold(never, pos => {\n        const parentDetailsAtNewPos = getParentDetailsElementAtPos(dom, pos);\n        if (isInDetailsElement(dom, pos) && !equals(parentDetailsAtCaret, parentDetailsAtNewPos)) {\n          if (!forward) {\n            moveCaretToDetailsPos(editor, pos, false);\n          }\n          if (parentBlock && inEmptyParentBlock) {\n            if (forward && isFirstBlock) {\n              return true;\n            } else if (!forward && isLastBlock) {\n              return true;\n            }\n            moveCaretToDetailsPos(editor, pos, forward);\n            editor.dom.remove(parentBlock);\n          }\n          return true;\n        } else {\n          return false;\n        }\n      });\n    } else {\n      return false;\n    }\n  };\n  const shouldPreventDeleteSummaryAction = (editor, detailElements, forward, granularity) => {\n    const selection = editor.selection;\n    const rng = selection.getRng();\n    const caretPos = CaretPosition.fromRangeStart(rng);\n    const root = editor.getBody();\n    if (granularity === 'selection') {\n      return isPartialDelete(rng, detailElements);\n    } else if (forward) {\n      return isCaretAtEndOfSummary(caretPos, detailElements) || isCaretInLastPositionInBody(root, caretPos, detailElements);\n    } else {\n      return isCaretAtStartOfSummary(caretPos, detailElements) || isCaretInFirstPositionInBody(caretPos, detailElements);\n    }\n  };\n  const shouldPreventDeleteAction = (editor, forward, granularity) => getDetailsElements(editor.dom, editor.selection.getRng()).fold(() => shouldPreventDeleteIntoDetails(editor, forward, granularity), detailsElements => shouldPreventDeleteSummaryAction(editor, detailsElements, forward, granularity) || shouldPreventDeleteIntoDetails(editor, forward, granularity));\n  const handleDeleteActionSafari = (editor, forward, granularity) => {\n    const selection = editor.selection;\n    const node = selection.getNode();\n    const rng = selection.getRng();\n    const caretPos = CaretPosition.fromRangeStart(rng);\n    if (isSummary$1(node)) {\n      if (granularity === 'selection' && isEntireNodeSelected(rng, node) || willDeleteLastPositionInElement(forward, caretPos, node)) {\n        emptyNodeContents(node);\n      } else {\n        editor.undoManager.transact(() => {\n          const sel = selection.getSel();\n          let {\n            anchorNode,\n            anchorOffset,\n            focusNode,\n            focusOffset\n          } = sel !== null && sel !== void 0 ? sel : {};\n          const applySelection = () => {\n            if (isNonNullable(anchorNode) && isNonNullable(anchorOffset) && isNonNullable(focusNode) && isNonNullable(focusOffset)) {\n              sel === null || sel === void 0 ? void 0 : sel.setBaseAndExtent(anchorNode, anchorOffset, focusNode, focusOffset);\n            }\n          };\n          const updateSelection = () => {\n            anchorNode = sel === null || sel === void 0 ? void 0 : sel.anchorNode;\n            anchorOffset = sel === null || sel === void 0 ? void 0 : sel.anchorOffset;\n            focusNode = sel === null || sel === void 0 ? void 0 : sel.focusNode;\n            focusOffset = sel === null || sel === void 0 ? void 0 : sel.focusOffset;\n          };\n          const appendAllChildNodes = (from, to) => {\n            each$e(from.childNodes, child => {\n              if (isNode(child)) {\n                to.appendChild(child);\n              }\n            });\n          };\n          const container = editor.dom.create('span', {\n            'data-mce-bogus': '1'\n          });\n          appendAllChildNodes(node, container);\n          node.appendChild(container);\n          applySelection();\n          if (granularity === 'word' || granularity === 'line') {\n            sel === null || sel === void 0 ? void 0 : sel.modify('extend', forward ? 'right' : 'left', granularity);\n          }\n          if (!selection.isCollapsed() && isEntireNodeSelected(selection.getRng(), container)) {\n            emptyNodeContents(node);\n          } else {\n            editor.execCommand(forward ? 'ForwardDelete' : 'Delete');\n            updateSelection();\n            appendAllChildNodes(container, node);\n            applySelection();\n          }\n          editor.dom.remove(container);\n        });\n      }\n      return true;\n    } else {\n      return false;\n    }\n  };\n  const backspaceDelete = (editor, forward, granularity) => shouldPreventDeleteAction(editor, forward, granularity) || isSafari && handleDeleteActionSafari(editor, forward, granularity) ? Optional.some(noop) : Optional.none();\n  const createAndFireInputEvent = eventType => (editor, inputType, specifics = {}) => {\n    const target = editor.getBody();\n    const overrides = {\n      bubbles: true,\n      composed: true,\n      data: null,\n      isComposing: false,\n      detail: 0,\n      view: null,\n      target,\n      currentTarget: target,\n      eventPhase: Event.AT_TARGET,\n      originalTarget: target,\n      explicitOriginalTarget: target,\n      isTrusted: false,\n      srcElement: target,\n      cancelable: false,\n      preventDefault: noop,\n      inputType\n    };\n    const input = clone$3(new InputEvent(eventType));\n    return editor.dispatch(eventType, {\n      ...input,\n      ...overrides,\n      ...specifics\n    });\n  };\n  const fireInputEvent = createAndFireInputEvent('input');\n  const fireBeforeInputEvent = createAndFireInputEvent('beforeinput');\n  const platform$2 = detect$1();\n  const os = platform$2.os;\n  const isMacOSOriOS = os.isMacOS() || os.isiOS();\n  const browser = platform$2.browser;\n  const isFirefox = browser.isFirefox();\n  const executeKeydownOverride$3 = (editor, caret, evt) => {\n    const inputType = evt.keyCode === VK.BACKSPACE ? 'deleteContentBackward' : 'deleteContentForward';\n    const isCollapsed = editor.selection.isCollapsed();\n    const unmodifiedGranularity = isCollapsed ? 'character' : 'selection';\n    const getModifiedGranularity = isWord => {\n      if (isCollapsed) {\n        return isWord ? 'word' : 'line';\n      } else {\n        return 'selection';\n      }\n    };\n    executeWithDelayedAction([{\n      keyCode: VK.BACKSPACE,\n      action: action(backspaceDelete$1, editor)\n    }, {\n      keyCode: VK.BACKSPACE,\n      action: action(backspaceDelete$7, editor, false)\n    }, {\n      keyCode: VK.DELETE,\n      action: action(backspaceDelete$7, editor, true)\n    }, {\n      keyCode: VK.BACKSPACE,\n      action: action(backspaceDelete$8, editor, false)\n    }, {\n      keyCode: VK.DELETE,\n      action: action(backspaceDelete$8, editor, true)\n    }, {\n      keyCode: VK.BACKSPACE,\n      action: action(backspaceDelete$4, editor, caret, false)\n    }, {\n      keyCode: VK.DELETE,\n      action: action(backspaceDelete$4, editor, caret, true)\n    }, {\n      keyCode: VK.BACKSPACE,\n      action: action(backspaceDelete$b, editor, false)\n    }, {\n      keyCode: VK.DELETE,\n      action: action(backspaceDelete$b, editor, true)\n    }, {\n      keyCode: VK.BACKSPACE,\n      action: action(backspaceDelete, editor, false, unmodifiedGranularity)\n    }, {\n      keyCode: VK.DELETE,\n      action: action(backspaceDelete, editor, true, unmodifiedGranularity)\n    }, ...(isMacOSOriOS ? [{\n      keyCode: VK.BACKSPACE,\n      altKey: true,\n      action: action(backspaceDelete, editor, false, getModifiedGranularity(true))\n    }, {\n      keyCode: VK.DELETE,\n      altKey: true,\n      action: action(backspaceDelete, editor, true, getModifiedGranularity(true))\n    }, {\n      keyCode: VK.BACKSPACE,\n      metaKey: true,\n      action: action(backspaceDelete, editor, false, getModifiedGranularity(false))\n    }] : [{\n      keyCode: VK.BACKSPACE,\n      ctrlKey: true,\n      action: action(backspaceDelete, editor, false, getModifiedGranularity(true))\n    }, {\n      keyCode: VK.DELETE,\n      ctrlKey: true,\n      action: action(backspaceDelete, editor, true, getModifiedGranularity(true))\n    }]), {\n      keyCode: VK.BACKSPACE,\n      action: action(backspaceDelete$5, editor, false)\n    }, {\n      keyCode: VK.DELETE,\n      action: action(backspaceDelete$5, editor, true)\n    }, {\n      keyCode: VK.BACKSPACE,\n      action: action(backspaceDelete$2, editor, false)\n    }, {\n      keyCode: VK.DELETE,\n      action: action(backspaceDelete$2, editor, true)\n    }, {\n      keyCode: VK.BACKSPACE,\n      action: action(backspaceDelete$9, editor, false)\n    }, {\n      keyCode: VK.DELETE,\n      action: action(backspaceDelete$9, editor, true)\n    }, {\n      keyCode: VK.BACKSPACE,\n      action: action(backspaceDelete$a, editor, false)\n    }, {\n      keyCode: VK.DELETE,\n      action: action(backspaceDelete$a, editor, true)\n    }, {\n      keyCode: VK.BACKSPACE,\n      action: action(backspaceDelete$3, editor, false)\n    }, {\n      keyCode: VK.DELETE,\n      action: action(backspaceDelete$3, editor, true)\n    }, {\n      keyCode: VK.BACKSPACE,\n      action: action(backspaceDelete$6, editor, false)\n    }, {\n      keyCode: VK.DELETE,\n      action: action(backspaceDelete$6, editor, true)\n    }], evt).filter(_ => editor.selection.isEditable()).each(applyAction => {\n      evt.preventDefault();\n      const beforeInput = fireBeforeInputEvent(editor, inputType);\n      if (!beforeInput.isDefaultPrevented()) {\n        applyAction();\n        fireInputEvent(editor, inputType);\n      }\n    });\n  };\n  const executeKeyupOverride = (editor, evt, isBackspaceKeydown) => execute([{\n    keyCode: VK.BACKSPACE,\n    action: action(paddEmptyElement, editor)\n  }, {\n    keyCode: VK.DELETE,\n    action: action(paddEmptyElement, editor)\n  }, ...(isMacOSOriOS ? [{\n    keyCode: VK.BACKSPACE,\n    altKey: true,\n    action: action(refreshCaret, editor)\n  }, {\n    keyCode: VK.DELETE,\n    altKey: true,\n    action: action(refreshCaret, editor)\n  }, ...(isBackspaceKeydown ? [{\n    keyCode: isFirefox ? 224 : 91,\n    action: action(refreshCaret, editor)\n  }] : [])] : [{\n    keyCode: VK.BACKSPACE,\n    ctrlKey: true,\n    action: action(refreshCaret, editor)\n  }, {\n    keyCode: VK.DELETE,\n    ctrlKey: true,\n    action: action(refreshCaret, editor)\n  }])], evt);\n  const setup$j = (editor, caret) => {\n    let isBackspaceKeydown = false;\n    editor.on('keydown', evt => {\n      isBackspaceKeydown = evt.keyCode === VK.BACKSPACE;\n      if (!evt.isDefaultPrevented()) {\n        executeKeydownOverride$3(editor, caret, evt);\n      }\n    });\n    editor.on('keyup', evt => {\n      if (!evt.isDefaultPrevented()) {\n        executeKeyupOverride(editor, evt, isBackspaceKeydown);\n      }\n      isBackspaceKeydown = false;\n    });\n  };\n  const firstNonWhiteSpaceNodeSibling = node => {\n    while (node) {\n      if (isElement$6(node) || isText$b(node) && node.data && /[\\r\\n\\s]/.test(node.data)) {\n        return node;\n      }\n      node = node.nextSibling;\n    }\n    return null;\n  };\n  const moveToCaretPosition = (editor, root) => {\n    const dom = editor.dom;\n    const moveCaretBeforeOnEnterElementsMap = editor.schema.getMoveCaretBeforeOnEnterElements();\n    if (!root) {\n      return;\n    }\n    if (/^(LI|DT|DD)$/.test(root.nodeName)) {\n      const firstChild = firstNonWhiteSpaceNodeSibling(root.firstChild);\n      if (firstChild && /^(UL|OL|DL)$/.test(firstChild.nodeName)) {\n        root.insertBefore(dom.doc.createTextNode(nbsp), root.firstChild);\n      }\n    }\n    const rng = dom.createRng();\n    root.normalize();\n    if (root.hasChildNodes()) {\n      const walker = new DomTreeWalker(root, root);\n      let lastNode = root;\n      let node;\n      while (node = walker.current()) {\n        if (isText$b(node)) {\n          rng.setStart(node, 0);\n          rng.setEnd(node, 0);\n          break;\n        }\n        if (moveCaretBeforeOnEnterElementsMap[node.nodeName.toLowerCase()]) {\n          rng.setStartBefore(node);\n          rng.setEndBefore(node);\n          break;\n        }\n        lastNode = node;\n        node = walker.next();\n      }\n      if (!node) {\n        rng.setStart(lastNode, 0);\n        rng.setEnd(lastNode, 0);\n      }\n    } else {\n      if (isBr$6(root)) {\n        if (root.nextSibling && dom.isBlock(root.nextSibling)) {\n          rng.setStartBefore(root);\n          rng.setEndBefore(root);\n        } else {\n          rng.setStartAfter(root);\n          rng.setEndAfter(root);\n        }\n      } else {\n        rng.setStart(root, 0);\n        rng.setEnd(root, 0);\n      }\n    }\n    editor.selection.setRng(rng);\n    scrollRangeIntoView(editor, rng);\n  };\n  const getEditableRoot = (dom, node) => {\n    const root = dom.getRoot();\n    let editableRoot;\n    let parent = node;\n    while (parent !== root && parent && dom.getContentEditable(parent) !== 'false') {\n      if (dom.getContentEditable(parent) === 'true') {\n        editableRoot = parent;\n        break;\n      }\n      parent = parent.parentNode;\n    }\n    return parent !== root ? editableRoot : root;\n  };\n  const getParentBlock$1 = editor => {\n    return Optional.from(editor.dom.getParent(editor.selection.getStart(true), editor.dom.isBlock));\n  };\n  const getParentBlockName = editor => {\n    return getParentBlock$1(editor).fold(constant(''), parentBlock => {\n      return parentBlock.nodeName.toUpperCase();\n    });\n  };\n  const isListItemParentBlock = editor => {\n    return getParentBlock$1(editor).filter(elm => {\n      return isListItem$1(SugarElement.fromDom(elm));\n    }).isSome();\n  };\n  const emptyBlock = elm => {\n    elm.innerHTML = '<br data-mce-bogus=\"1\">';\n  };\n  const applyAttributes = (editor, node, forcedRootBlockAttrs) => {\n    const dom = editor.dom;\n    Optional.from(forcedRootBlockAttrs.style).map(dom.parseStyle).each(attrStyles => {\n      const currentStyles = getAllRaw(SugarElement.fromDom(node));\n      const newStyles = {\n        ...currentStyles,\n        ...attrStyles\n      };\n      dom.setStyles(node, newStyles);\n    });\n    const attrClassesOpt = Optional.from(forcedRootBlockAttrs.class).map(attrClasses => attrClasses.split(/\\s+/));\n    const currentClassesOpt = Optional.from(node.className).map(currentClasses => filter$5(currentClasses.split(/\\s+/), clazz => clazz !== ''));\n    lift2(attrClassesOpt, currentClassesOpt, (attrClasses, currentClasses) => {\n      const filteredClasses = filter$5(currentClasses, clazz => !contains$2(attrClasses, clazz));\n      const newClasses = [...attrClasses, ...filteredClasses];\n      dom.setAttrib(node, 'class', newClasses.join(' '));\n    });\n    const appliedAttrs = ['style', 'class'];\n    const remainingAttrs = filter$4(forcedRootBlockAttrs, (_, attrs) => !contains$2(appliedAttrs, attrs));\n    dom.setAttribs(node, remainingAttrs);\n  };\n  const setForcedBlockAttrs = (editor, node) => {\n    const forcedRootBlockName = getForcedRootBlock(editor);\n    if (forcedRootBlockName.toLowerCase() === node.tagName.toLowerCase()) {\n      const forcedRootBlockAttrs = getForcedRootBlockAttrs(editor);\n      applyAttributes(editor, node, forcedRootBlockAttrs);\n    }\n  };\n  const createNewBlock = (editor, container, parentBlock, editableRoot, keepStyles = true, name, styles) => {\n    const dom = editor.dom;\n    const schema = editor.schema;\n    const newBlockName = getForcedRootBlock(editor);\n    const parentBlockName = parentBlock ? parentBlock.nodeName.toUpperCase() : '';\n    let node = container;\n    const textInlineElements = schema.getTextInlineElements();\n    let block;\n    if (name || parentBlockName === 'TABLE' || parentBlockName === 'HR') {\n      block = dom.create(name || newBlockName, styles || {});\n    } else {\n      block = parentBlock.cloneNode(false);\n    }\n    let caretNode = block;\n    if (!keepStyles) {\n      dom.setAttrib(block, 'style', null);\n      dom.setAttrib(block, 'class', null);\n    } else {\n      do {\n        if (textInlineElements[node.nodeName]) {\n          if (isCaretNode(node) || isBookmarkNode$1(node)) {\n            continue;\n          }\n          const clonedNode = node.cloneNode(false);\n          dom.setAttrib(clonedNode, 'id', '');\n          if (block.hasChildNodes()) {\n            clonedNode.appendChild(block.firstChild);\n            block.appendChild(clonedNode);\n          } else {\n            caretNode = clonedNode;\n            block.appendChild(clonedNode);\n          }\n        }\n      } while ((node = node.parentNode) && node !== editableRoot);\n    }\n    setForcedBlockAttrs(editor, block);\n    emptyBlock(caretNode);\n    return block;\n  };\n  const getDetailsRoot = (editor, element) => editor.dom.getParent(element, isDetails);\n  const isAtDetailsEdge = (root, element, isTextBlock) => {\n    let node = element;\n    while (node && node !== root && isNull(node.nextSibling)) {\n      const parent = node.parentElement;\n      if (!parent || !isTextBlock(parent)) {\n        return isDetails(parent);\n      }\n      node = parent;\n    }\n    return false;\n  };\n  const isLastEmptyBlockInDetails = (editor, shiftKey, element) => !shiftKey && element.nodeName.toLowerCase() === getForcedRootBlock(editor) && editor.dom.isEmpty(element) && isAtDetailsEdge(editor.getBody(), element, el => has$2(editor.schema.getTextBlockElements(), el.nodeName.toLowerCase()));\n  const insertNewLine = (editor, createNewBlock, parentBlock) => {\n    var _a, _b, _c;\n    const newBlock = createNewBlock(getForcedRootBlock(editor));\n    const root = getDetailsRoot(editor, parentBlock);\n    if (!root) {\n      return;\n    }\n    editor.dom.insertAfter(newBlock, root);\n    moveToCaretPosition(editor, newBlock);\n    if (((_c = (_b = (_a = parentBlock.parentElement) === null || _a === void 0 ? void 0 : _a.childNodes) === null || _b === void 0 ? void 0 : _b.length) !== null && _c !== void 0 ? _c : 0) > 1) {\n      editor.dom.remove(parentBlock);\n    }\n  };\n  const hasFirstChild = (elm, name) => {\n    return elm.firstChild && elm.firstChild.nodeName === name;\n  };\n  const isFirstChild = elm => {\n    var _a;\n    return ((_a = elm.parentNode) === null || _a === void 0 ? void 0 : _a.firstChild) === elm;\n  };\n  const hasParent = (elm, parentName) => {\n    const parentNode = elm === null || elm === void 0 ? void 0 : elm.parentNode;\n    return isNonNullable(parentNode) && parentNode.nodeName === parentName;\n  };\n  const isListBlock = elm => {\n    return isNonNullable(elm) && /^(OL|UL|LI)$/.test(elm.nodeName);\n  };\n  const isListItem = elm => {\n    return isNonNullable(elm) && /^(LI|DT|DD)$/.test(elm.nodeName);\n  };\n  const isNestedList = elm => {\n    return isListBlock(elm) && isListBlock(elm.parentNode);\n  };\n  const getContainerBlock = containerBlock => {\n    const containerBlockParent = containerBlock.parentNode;\n    return isListItem(containerBlockParent) ? containerBlockParent : containerBlock;\n  };\n  const isFirstOrLastLi = (containerBlock, parentBlock, first) => {\n    let node = containerBlock[first ? 'firstChild' : 'lastChild'];\n    while (node) {\n      if (isElement$6(node)) {\n        break;\n      }\n      node = node[first ? 'nextSibling' : 'previousSibling'];\n    }\n    return node === parentBlock;\n  };\n  const getStyles = elm => foldl(mapToArray(getAllRaw(SugarElement.fromDom(elm)), (style, styleName) => `${styleName}: ${style};`), (acc, s) => acc + s, '');\n  const insert$4 = (editor, createNewBlock, containerBlock, parentBlock, newBlockName) => {\n    const dom = editor.dom;\n    const rng = editor.selection.getRng();\n    const containerParent = containerBlock.parentNode;\n    if (containerBlock === editor.getBody() || !containerParent) {\n      return;\n    }\n    if (isNestedList(containerBlock)) {\n      newBlockName = 'LI';\n    }\n    const parentBlockStyles = isListItem(parentBlock) ? getStyles(parentBlock) : undefined;\n    let newBlock = isListItem(parentBlock) && parentBlockStyles ? createNewBlock(newBlockName, {\n      style: getStyles(parentBlock)\n    }) : createNewBlock(newBlockName);\n    if (isFirstOrLastLi(containerBlock, parentBlock, true) && isFirstOrLastLi(containerBlock, parentBlock, false)) {\n      if (hasParent(containerBlock, 'LI')) {\n        const containerBlockParent = getContainerBlock(containerBlock);\n        dom.insertAfter(newBlock, containerBlockParent);\n        if (isFirstChild(containerBlock)) {\n          dom.remove(containerBlockParent);\n        } else {\n          dom.remove(containerBlock);\n        }\n      } else {\n        dom.replace(newBlock, containerBlock);\n      }\n    } else if (isFirstOrLastLi(containerBlock, parentBlock, true)) {\n      if (hasParent(containerBlock, 'LI')) {\n        dom.insertAfter(newBlock, getContainerBlock(containerBlock));\n        newBlock.appendChild(dom.doc.createTextNode(' '));\n        newBlock.appendChild(containerBlock);\n      } else {\n        containerParent.insertBefore(newBlock, containerBlock);\n      }\n      dom.remove(parentBlock);\n    } else if (isFirstOrLastLi(containerBlock, parentBlock, false)) {\n      dom.insertAfter(newBlock, getContainerBlock(containerBlock));\n      dom.remove(parentBlock);\n    } else {\n      containerBlock = getContainerBlock(containerBlock);\n      const tmpRng = rng.cloneRange();\n      tmpRng.setStartAfter(parentBlock);\n      tmpRng.setEndAfter(containerBlock);\n      const fragment = tmpRng.extractContents();\n      if (newBlockName === 'LI' && hasFirstChild(fragment, 'LI')) {\n        const previousChildren = filter$5(map$3(newBlock.children, SugarElement.fromDom), not(isTag('br')));\n        newBlock = fragment.firstChild;\n        dom.insertAfter(fragment, containerBlock);\n        each$e(previousChildren, child => prepend(SugarElement.fromDom(newBlock), child));\n        if (parentBlockStyles) {\n          newBlock.setAttribute('style', parentBlockStyles);\n        }\n      } else {\n        dom.insertAfter(fragment, containerBlock);\n        dom.insertAfter(newBlock, containerBlock);\n      }\n      dom.remove(parentBlock);\n    }\n    moveToCaretPosition(editor, newBlock);\n  };\n  const trimZwsp = fragment => {\n    each$e(descendants$1(SugarElement.fromDom(fragment), isText$c), text => {\n      const rawNode = text.dom;\n      rawNode.nodeValue = trim$2(rawNode.data);\n    });\n  };\n  const isWithinNonEditableList = (editor, node) => {\n    const parentList = editor.dom.getParent(node, 'ol,ul,dl');\n    return parentList !== null && editor.dom.getContentEditableParent(parentList) === 'false';\n  };\n  const isEmptyAnchor = (dom, elm) => {\n    return elm && elm.nodeName === 'A' && dom.isEmpty(elm);\n  };\n  const containerAndPreviousSiblingName = (container, nodeName) => {\n    return container.nodeName === nodeName || container.previousSibling && container.previousSibling.nodeName === nodeName;\n  };\n  const containerAndNextSiblingName = (container, nodeName) => {\n    return container.nodeName === nodeName || container.nextSibling && container.nextSibling.nodeName === nodeName;\n  };\n  const canSplitBlock = (dom, node) => {\n    return isNonNullable(node) && dom.isBlock(node) && !/^(TD|TH|CAPTION|FORM)$/.test(node.nodeName) && !/^(fixed|absolute)/i.test(node.style.position) && dom.isEditable(node.parentNode) && dom.getContentEditable(node) !== 'false';\n  };\n  const trimInlineElementsOnLeftSideOfBlock = (dom, nonEmptyElementsMap, block) => {\n    var _a;\n    const firstChilds = [];\n    if (!block) {\n      return;\n    }\n    let currentNode = block;\n    while (currentNode = currentNode.firstChild) {\n      if (dom.isBlock(currentNode)) {\n        return;\n      }\n      if (isElement$6(currentNode) && !nonEmptyElementsMap[currentNode.nodeName.toLowerCase()]) {\n        firstChilds.push(currentNode);\n      }\n    }\n    let i = firstChilds.length;\n    while (i--) {\n      currentNode = firstChilds[i];\n      if (!currentNode.hasChildNodes() || currentNode.firstChild === currentNode.lastChild && ((_a = currentNode.firstChild) === null || _a === void 0 ? void 0 : _a.nodeValue) === '') {\n        dom.remove(currentNode);\n      } else {\n        if (isEmptyAnchor(dom, currentNode)) {\n          dom.remove(currentNode);\n        }\n      }\n    }\n  };\n  const normalizeZwspOffset = (start, container, offset) => {\n    if (!isText$b(container)) {\n      return offset;\n    } else if (start) {\n      return offset === 1 && container.data.charAt(offset - 1) === ZWSP$1 ? 0 : offset;\n    } else {\n      return offset === container.data.length - 1 && container.data.charAt(offset) === ZWSP$1 ? container.data.length : offset;\n    }\n  };\n  const includeZwspInRange = rng => {\n    const newRng = rng.cloneRange();\n    newRng.setStart(rng.startContainer, normalizeZwspOffset(true, rng.startContainer, rng.startOffset));\n    newRng.setEnd(rng.endContainer, normalizeZwspOffset(false, rng.endContainer, rng.endOffset));\n    return newRng;\n  };\n  const trimLeadingLineBreaks = node => {\n    let currentNode = node;\n    do {\n      if (isText$b(currentNode)) {\n        currentNode.data = currentNode.data.replace(/^[\\r\\n]+/, '');\n      }\n      currentNode = currentNode.firstChild;\n    } while (currentNode);\n  };\n  const wrapSelfAndSiblingsInDefaultBlock = (editor, newBlockName, rng, container, offset) => {\n    var _a, _b;\n    const dom = editor.dom;\n    const editableRoot = (_a = getEditableRoot(dom, container)) !== null && _a !== void 0 ? _a : dom.getRoot();\n    let parentBlock = dom.getParent(container, dom.isBlock);\n    if (!parentBlock || !canSplitBlock(dom, parentBlock)) {\n      parentBlock = parentBlock || editableRoot;\n      if (!parentBlock.hasChildNodes()) {\n        const newBlock = dom.create(newBlockName);\n        setForcedBlockAttrs(editor, newBlock);\n        parentBlock.appendChild(newBlock);\n        rng.setStart(newBlock, 0);\n        rng.setEnd(newBlock, 0);\n        return newBlock;\n      }\n      let node = container;\n      while (node && node.parentNode !== parentBlock) {\n        node = node.parentNode;\n      }\n      let startNode;\n      while (node && !dom.isBlock(node)) {\n        startNode = node;\n        node = node.previousSibling;\n      }\n      const startNodeName = (_b = startNode === null || startNode === void 0 ? void 0 : startNode.parentElement) === null || _b === void 0 ? void 0 : _b.nodeName;\n      if (startNode && startNodeName && editor.schema.isValidChild(startNodeName, newBlockName.toLowerCase())) {\n        const startNodeParent = startNode.parentNode;\n        const newBlock = dom.create(newBlockName);\n        setForcedBlockAttrs(editor, newBlock);\n        startNodeParent.insertBefore(newBlock, startNode);\n        node = startNode;\n        while (node && !dom.isBlock(node)) {\n          const next = node.nextSibling;\n          newBlock.appendChild(node);\n          node = next;\n        }\n        rng.setStart(container, offset);\n        rng.setEnd(container, offset);\n      }\n    }\n    return container;\n  };\n  const addBrToBlockIfNeeded = (dom, block) => {\n    block.normalize();\n    const lastChild = block.lastChild;\n    if (!lastChild || isElement$6(lastChild) && /^(left|right)$/gi.test(dom.getStyle(lastChild, 'float', true))) {\n      dom.add(block, 'br');\n    }\n  };\n  const shouldEndContainer = (editor, container) => {\n    const optionValue = shouldEndContainerOnEmptyBlock(editor);\n    if (isNullable(container)) {\n      return false;\n    } else if (isString(optionValue)) {\n      return contains$2(Tools.explode(optionValue), container.nodeName.toLowerCase());\n    } else {\n      return optionValue;\n    }\n  };\n  const insert$3 = (editor, evt) => {\n    let container;\n    let offset;\n    let parentBlockName;\n    let containerBlock;\n    let isAfterLastNodeInContainer = false;\n    const dom = editor.dom;\n    const schema = editor.schema,\n      nonEmptyElementsMap = schema.getNonEmptyElements();\n    const rng = editor.selection.getRng();\n    const newBlockName = getForcedRootBlock(editor);\n    const start = SugarElement.fromDom(rng.startContainer);\n    const child = child$1(start, rng.startOffset);\n    const isCef = child.exists(element => isHTMLElement$1(element) && !isEditable$2(element));\n    const collapsedAndCef = rng.collapsed && isCef;\n    const createNewBlock$1 = (name, styles) => {\n      return createNewBlock(editor, container, parentBlock, editableRoot, shouldKeepStyles(editor), name, styles);\n    };\n    const isCaretAtStartOrEndOfBlock = start => {\n      const normalizedOffset = normalizeZwspOffset(start, container, offset);\n      if (isText$b(container) && (start ? normalizedOffset > 0 : normalizedOffset < container.data.length)) {\n        return false;\n      }\n      if ((container.parentNode === parentBlock || container === parentBlock) && isAfterLastNodeInContainer && !start) {\n        return true;\n      }\n      if (start && isElement$6(container) && container === parentBlock.firstChild) {\n        return true;\n      }\n      if (containerAndPreviousSiblingName(container, 'TABLE') || containerAndPreviousSiblingName(container, 'HR')) {\n        if (containerAndNextSiblingName(container, 'BR')) {\n          return !start;\n        }\n        return isAfterLastNodeInContainer && !start || !isAfterLastNodeInContainer && start;\n      }\n      const walker = new DomTreeWalker(container, parentBlock);\n      if (isText$b(container)) {\n        if (start && normalizedOffset === 0) {\n          walker.prev();\n        } else if (!start && normalizedOffset === container.data.length) {\n          walker.next();\n        }\n      }\n      let node;\n      while (node = walker.current()) {\n        if (isElement$6(node)) {\n          if (!node.getAttribute('data-mce-bogus')) {\n            const name = node.nodeName.toLowerCase();\n            if (nonEmptyElementsMap[name] && name !== 'br') {\n              return false;\n            }\n          }\n        } else if (isText$b(node) && !isWhitespaceText(node.data)) {\n          return false;\n        }\n        if (start) {\n          walker.prev();\n        } else {\n          walker.next();\n        }\n      }\n      return true;\n    };\n    const insertNewBlockAfter = () => {\n      let block;\n      if (/^(H[1-6]|PRE|FIGURE)$/.test(parentBlockName) && containerBlockName !== 'HGROUP') {\n        block = createNewBlock$1(newBlockName);\n      } else {\n        block = createNewBlock$1();\n      }\n      if (shouldEndContainer(editor, containerBlock) && canSplitBlock(dom, containerBlock) && dom.isEmpty(parentBlock, undefined, {\n        includeZwsp: true\n      })) {\n        block = dom.split(containerBlock, parentBlock);\n      } else {\n        dom.insertAfter(block, parentBlock);\n      }\n      moveToCaretPosition(editor, block);\n      return block;\n    };\n    normalize$2(dom, rng).each(normRng => {\n      rng.setStart(normRng.startContainer, normRng.startOffset);\n      rng.setEnd(normRng.endContainer, normRng.endOffset);\n    });\n    container = rng.startContainer;\n    offset = rng.startOffset;\n    const shiftKey = !!(evt && evt.shiftKey);\n    const ctrlKey = !!(evt && evt.ctrlKey);\n    if (isElement$6(container) && container.hasChildNodes() && !collapsedAndCef) {\n      isAfterLastNodeInContainer = offset > container.childNodes.length - 1;\n      container = container.childNodes[Math.min(offset, container.childNodes.length - 1)] || container;\n      if (isAfterLastNodeInContainer && isText$b(container)) {\n        offset = container.data.length;\n      } else {\n        offset = 0;\n      }\n    }\n    const editableRoot = getEditableRoot(dom, container);\n    if (!editableRoot || isWithinNonEditableList(editor, container)) {\n      return;\n    }\n    if (!shiftKey) {\n      container = wrapSelfAndSiblingsInDefaultBlock(editor, newBlockName, rng, container, offset);\n    }\n    let parentBlock = dom.getParent(container, dom.isBlock) || dom.getRoot();\n    containerBlock = isNonNullable(parentBlock === null || parentBlock === void 0 ? void 0 : parentBlock.parentNode) ? dom.getParent(parentBlock.parentNode, dom.isBlock) : null;\n    parentBlockName = parentBlock ? parentBlock.nodeName.toUpperCase() : '';\n    const containerBlockName = containerBlock ? containerBlock.nodeName.toUpperCase() : '';\n    if (containerBlockName === 'LI' && !ctrlKey) {\n      const liBlock = containerBlock;\n      parentBlock = liBlock;\n      containerBlock = liBlock.parentNode;\n      parentBlockName = containerBlockName;\n    }\n    if (isElement$6(containerBlock) && isLastEmptyBlockInDetails(editor, shiftKey, parentBlock)) {\n      return insertNewLine(editor, createNewBlock$1, parentBlock);\n    }\n    if (/^(LI|DT|DD)$/.test(parentBlockName) && isElement$6(containerBlock)) {\n      if (dom.isEmpty(parentBlock)) {\n        insert$4(editor, createNewBlock$1, containerBlock, parentBlock, newBlockName);\n        return;\n      }\n    }\n    if (!collapsedAndCef && (parentBlock === editor.getBody() || !canSplitBlock(dom, parentBlock))) {\n      return;\n    }\n    const parentBlockParent = parentBlock.parentNode;\n    let newBlock;\n    if (collapsedAndCef) {\n      newBlock = createNewBlock$1(newBlockName);\n      child.fold(() => {\n        append$1(start, SugarElement.fromDom(newBlock));\n      }, child => {\n        before$3(child, SugarElement.fromDom(newBlock));\n      });\n      editor.selection.setCursorLocation(newBlock, 0);\n    } else if (isCaretContainerBlock$1(parentBlock)) {\n      newBlock = showCaretContainerBlock(parentBlock);\n      if (dom.isEmpty(parentBlock)) {\n        emptyBlock(parentBlock);\n      }\n      setForcedBlockAttrs(editor, newBlock);\n      moveToCaretPosition(editor, newBlock);\n    } else if (isCaretAtStartOrEndOfBlock(false)) {\n      newBlock = insertNewBlockAfter();\n    } else if (isCaretAtStartOrEndOfBlock(true) && parentBlockParent) {\n      const caretPos = CaretPosition.fromRangeStart(rng);\n      const afterTable = isAfterTable(caretPos);\n      const parentBlockSugar = SugarElement.fromDom(parentBlock);\n      const afterBr = isAfterBr(parentBlockSugar, caretPos, editor.schema);\n      const prevBrOpt = afterBr ? findPreviousBr(parentBlockSugar, caretPos, editor.schema).bind(pos => Optional.from(pos.getNode())) : Optional.none();\n      newBlock = parentBlockParent.insertBefore(createNewBlock$1(), parentBlock);\n      const root = containerAndPreviousSiblingName(parentBlock, 'HR') || afterTable ? newBlock : prevBrOpt.getOr(parentBlock);\n      moveToCaretPosition(editor, root);\n    } else {\n      const tmpRng = includeZwspInRange(rng).cloneRange();\n      tmpRng.setEndAfter(parentBlock);\n      const fragment = tmpRng.extractContents();\n      trimZwsp(fragment);\n      trimLeadingLineBreaks(fragment);\n      newBlock = fragment.firstChild;\n      dom.insertAfter(fragment, parentBlock);\n      trimInlineElementsOnLeftSideOfBlock(dom, nonEmptyElementsMap, newBlock);\n      addBrToBlockIfNeeded(dom, parentBlock);\n      if (dom.isEmpty(parentBlock)) {\n        emptyBlock(parentBlock);\n      }\n      newBlock.normalize();\n      if (dom.isEmpty(newBlock)) {\n        dom.remove(newBlock);\n        insertNewBlockAfter();\n      } else {\n        setForcedBlockAttrs(editor, newBlock);\n        moveToCaretPosition(editor, newBlock);\n      }\n    }\n    dom.setAttrib(newBlock, 'id', '');\n    editor.dispatch('NewBlock', {\n      newBlock\n    });\n  };\n  const fakeEventName$1 = 'insertParagraph';\n  const blockbreak = {\n    insert: insert$3,\n    fakeEventName: fakeEventName$1\n  };\n  const hasRightSideContent = (schema, container, parentBlock) => {\n    const walker = new DomTreeWalker(container, parentBlock);\n    let node;\n    const nonEmptyElementsMap = schema.getNonEmptyElements();\n    while (node = walker.next()) {\n      if (nonEmptyElementsMap[node.nodeName.toLowerCase()] || isText$b(node) && node.length > 0) {\n        return true;\n      }\n    }\n    return false;\n  };\n  const moveSelectionToBr = (editor, brElm, extraBr) => {\n    const rng = editor.dom.createRng();\n    if (!extraBr) {\n      rng.setStartAfter(brElm);\n      rng.setEndAfter(brElm);\n    } else {\n      rng.setStartBefore(brElm);\n      rng.setEndBefore(brElm);\n    }\n    editor.selection.setRng(rng);\n    scrollRangeIntoView(editor, rng);\n  };\n  const insertBrAtCaret = (editor, evt) => {\n    const selection = editor.selection;\n    const dom = editor.dom;\n    const rng = selection.getRng();\n    let brElm;\n    let extraBr = false;\n    normalize$2(dom, rng).each(normRng => {\n      rng.setStart(normRng.startContainer, normRng.startOffset);\n      rng.setEnd(normRng.endContainer, normRng.endOffset);\n    });\n    let offset = rng.startOffset;\n    let container = rng.startContainer;\n    if (isElement$6(container) && container.hasChildNodes()) {\n      const isAfterLastNodeInContainer = offset > container.childNodes.length - 1;\n      container = container.childNodes[Math.min(offset, container.childNodes.length - 1)] || container;\n      if (isAfterLastNodeInContainer && isText$b(container)) {\n        offset = container.data.length;\n      } else {\n        offset = 0;\n      }\n    }\n    let parentBlock = dom.getParent(container, dom.isBlock);\n    const containerBlock = parentBlock && parentBlock.parentNode ? dom.getParent(parentBlock.parentNode, dom.isBlock) : null;\n    const containerBlockName = containerBlock ? containerBlock.nodeName.toUpperCase() : '';\n    const isControlKey = !!(evt && evt.ctrlKey);\n    if (containerBlockName === 'LI' && !isControlKey) {\n      parentBlock = containerBlock;\n    }\n    if (isText$b(container) && offset >= container.data.length) {\n      if (!hasRightSideContent(editor.schema, container, parentBlock || dom.getRoot())) {\n        brElm = dom.create('br');\n        rng.insertNode(brElm);\n        rng.setStartAfter(brElm);\n        rng.setEndAfter(brElm);\n        extraBr = true;\n      }\n    }\n    brElm = dom.create('br');\n    rangeInsertNode(dom, rng, brElm);\n    moveSelectionToBr(editor, brElm, extraBr);\n    editor.undoManager.add();\n  };\n  const insertBrBefore = (editor, inline) => {\n    const br = SugarElement.fromTag('br');\n    before$3(SugarElement.fromDom(inline), br);\n    editor.undoManager.add();\n  };\n  const insertBrAfter = (editor, inline) => {\n    if (!hasBrAfter(editor.getBody(), inline)) {\n      after$4(SugarElement.fromDom(inline), SugarElement.fromTag('br'));\n    }\n    const br = SugarElement.fromTag('br');\n    after$4(SugarElement.fromDom(inline), br);\n    moveSelectionToBr(editor, br.dom, false);\n    editor.undoManager.add();\n  };\n  const isBeforeBr = pos => {\n    return isBr$6(pos.getNode());\n  };\n  const hasBrAfter = (rootNode, startNode) => {\n    if (isBeforeBr(CaretPosition.after(startNode))) {\n      return true;\n    } else {\n      return nextPosition(rootNode, CaretPosition.after(startNode)).map(pos => {\n        return isBr$6(pos.getNode());\n      }).getOr(false);\n    }\n  };\n  const isAnchorLink = elm => {\n    return elm && elm.nodeName === 'A' && 'href' in elm;\n  };\n  const isInsideAnchor = location => {\n    return location.fold(never, isAnchorLink, isAnchorLink, never);\n  };\n  const readInlineAnchorLocation = editor => {\n    const isInlineTarget$1 = curry(isInlineTarget, editor);\n    const position = CaretPosition.fromRangeStart(editor.selection.getRng());\n    return readLocation(isInlineTarget$1, editor.getBody(), position).filter(isInsideAnchor);\n  };\n  const insertBrOutsideAnchor = (editor, location) => {\n    location.fold(noop, curry(insertBrBefore, editor), curry(insertBrAfter, editor), noop);\n  };\n  const insert$2 = (editor, evt) => {\n    const anchorLocation = readInlineAnchorLocation(editor);\n    if (anchorLocation.isSome()) {\n      anchorLocation.each(curry(insertBrOutsideAnchor, editor));\n    } else {\n      insertBrAtCaret(editor, evt);\n    }\n  };\n  const fakeEventName = 'insertLineBreak';\n  const linebreak = {\n    insert: insert$2,\n    fakeEventName\n  };\n  const matchesSelector = (editor, selector) => {\n    return getParentBlock$1(editor).filter(parentBlock => {\n      return selector.length > 0 && is$1(SugarElement.fromDom(parentBlock), selector);\n    }).isSome();\n  };\n  const shouldInsertBr = editor => {\n    return matchesSelector(editor, getBrNewLineSelector(editor));\n  };\n  const shouldBlockNewLine$1 = editor => {\n    return matchesSelector(editor, getNoNewLineSelector(editor));\n  };\n  const newLineAction = Adt.generate([{\n    br: []\n  }, {\n    block: []\n  }, {\n    none: []\n  }]);\n  const shouldBlockNewLine = (editor, _shiftKey) => {\n    return shouldBlockNewLine$1(editor);\n  };\n  const inListBlock = requiredState => {\n    return (editor, _shiftKey) => {\n      return isListItemParentBlock(editor) === requiredState;\n    };\n  };\n  const inBlock = (blockName, requiredState) => (editor, _shiftKey) => {\n    const state = getParentBlockName(editor) === blockName.toUpperCase();\n    return state === requiredState;\n  };\n  const inCefBlock = editor => {\n    const editableRoot = getEditableRoot(editor.dom, editor.selection.getStart());\n    return isNullable(editableRoot);\n  };\n  const inPreBlock = requiredState => inBlock('pre', requiredState);\n  const inSummaryBlock = () => inBlock('summary', true);\n  const shouldPutBrInPre = requiredState => {\n    return (editor, _shiftKey) => {\n      return shouldPutBrInPre$1(editor) === requiredState;\n    };\n  };\n  const inBrContext = (editor, _shiftKey) => {\n    return shouldInsertBr(editor);\n  };\n  const hasShiftKey = (_editor, shiftKey) => {\n    return shiftKey;\n  };\n  const canInsertIntoEditableRoot = editor => {\n    const forcedRootBlock = getForcedRootBlock(editor);\n    const rootEditable = getEditableRoot(editor.dom, editor.selection.getStart());\n    return isNonNullable(rootEditable) && editor.schema.isValidChild(rootEditable.nodeName, forcedRootBlock);\n  };\n  const isInRootWithEmptyOrCEF = editor => {\n    const rng = editor.selection.getRng();\n    const start = SugarElement.fromDom(rng.startContainer);\n    const child = child$1(start, rng.startOffset);\n    const isCefOpt = child.map(element => isHTMLElement$1(element) && !isEditable$2(element));\n    return rng.collapsed && isCefOpt.getOr(true);\n  };\n  const match = (predicates, action) => {\n    return (editor, shiftKey) => {\n      const isMatch = foldl(predicates, (res, p) => {\n        return res && p(editor, shiftKey);\n      }, true);\n      return isMatch ? Optional.some(action) : Optional.none();\n    };\n  };\n  const getAction = (editor, evt) => {\n    return evaluateUntil([match([shouldBlockNewLine], newLineAction.none()), match([inPreBlock(true), inCefBlock], newLineAction.none()), match([inSummaryBlock()], newLineAction.br()), match([inPreBlock(true), shouldPutBrInPre(false), hasShiftKey], newLineAction.br()), match([inPreBlock(true), shouldPutBrInPre(false)], newLineAction.block()), match([inPreBlock(true), shouldPutBrInPre(true), hasShiftKey], newLineAction.block()), match([inPreBlock(true), shouldPutBrInPre(true)], newLineAction.br()), match([inListBlock(true), hasShiftKey], newLineAction.br()), match([inListBlock(true)], newLineAction.block()), match([inBrContext], newLineAction.br()), match([hasShiftKey], newLineAction.br()), match([canInsertIntoEditableRoot], newLineAction.block()), match([isInRootWithEmptyOrCEF], newLineAction.block())], [editor, !!(evt && evt.shiftKey)]).getOr(newLineAction.none());\n  };\n  const insertBreak = (breakType, editor, evt) => {\n    if (editor.mode.isReadOnly()) {\n      return;\n    }\n    if (!editor.selection.isCollapsed()) {\n      execEditorDeleteCommand(editor);\n    }\n    if (isNonNullable(evt)) {\n      const event = fireBeforeInputEvent(editor, breakType.fakeEventName);\n      if (event.isDefaultPrevented()) {\n        return;\n      }\n    }\n    breakType.insert(editor, evt);\n    if (isNonNullable(evt)) {\n      fireInputEvent(editor, breakType.fakeEventName);\n    }\n  };\n  const insert$1 = (editor, evt) => {\n    if (editor.mode.isReadOnly()) {\n      return;\n    }\n    const br = () => insertBreak(linebreak, editor, evt);\n    const block = () => insertBreak(blockbreak, editor, evt);\n    const logicalAction = getAction(editor, evt);\n    switch (getNewlineBehavior(editor)) {\n      case 'linebreak':\n        logicalAction.fold(br, br, noop);\n        break;\n      case 'block':\n        logicalAction.fold(block, block, noop);\n        break;\n      case 'invert':\n        logicalAction.fold(block, br, noop);\n        break;\n      default:\n        logicalAction.fold(br, block, noop);\n        break;\n    }\n  };\n  const platform$1 = detect$1();\n  const isIOSSafari = platform$1.os.isiOS() && platform$1.browser.isSafari();\n  const handleEnterKeyEvent = (editor, event) => {\n    if (event.isDefaultPrevented()) {\n      return;\n    }\n    event.preventDefault();\n    endTypingLevelIgnoreLocks(editor.undoManager);\n    editor.undoManager.transact(() => {\n      insert$1(editor, event);\n    });\n  };\n  const isCaretAfterKoreanCharacter = rng => {\n    if (!rng.collapsed) {\n      return false;\n    }\n    const startContainer = rng.startContainer;\n    if (isText$b(startContainer)) {\n      const koreanCharRegex = /^[\\uAC00-\\uD7AF\\u1100-\\u11FF\\u3130-\\u318F\\uA960-\\uA97F\\uD7B0-\\uD7FF]$/;\n      const char = startContainer.data.charAt(rng.startOffset - 1);\n      return koreanCharRegex.test(char);\n    } else {\n      return false;\n    }\n  };\n  const setup$i = editor => {\n    let iOSSafariKeydownBookmark = Optional.none();\n    const iOSSafariKeydownOverride = editor => {\n      iOSSafariKeydownBookmark = Optional.some(editor.selection.getBookmark());\n      editor.undoManager.add();\n    };\n    const iOSSafariKeyupOverride = (editor, event) => {\n      editor.undoManager.undo();\n      iOSSafariKeydownBookmark.fold(noop, b => editor.selection.moveToBookmark(b));\n      handleEnterKeyEvent(editor, event);\n      iOSSafariKeydownBookmark = Optional.none();\n    };\n    editor.on('keydown', event => {\n      if (event.keyCode === VK.ENTER) {\n        if (isIOSSafari && isCaretAfterKoreanCharacter(editor.selection.getRng())) {\n          iOSSafariKeydownOverride(editor);\n        } else {\n          handleEnterKeyEvent(editor, event);\n        }\n      }\n    });\n    editor.on('keyup', event => {\n      if (event.keyCode === VK.ENTER) {\n        iOSSafariKeydownBookmark.each(() => iOSSafariKeyupOverride(editor, event));\n      }\n    });\n  };\n  const executeKeydownOverride$2 = (editor, caret, evt) => {\n    const isMac = Env.os.isMacOS() || Env.os.isiOS();\n    execute([{\n      keyCode: VK.END,\n      action: action(moveToLineEndPoint$1, editor, true)\n    }, {\n      keyCode: VK.HOME,\n      action: action(moveToLineEndPoint$1, editor, false)\n    }, ...(!isMac ? [{\n      keyCode: VK.HOME,\n      action: action(selectToEndPoint, editor, false),\n      ctrlKey: true,\n      shiftKey: true\n    }, {\n      keyCode: VK.END,\n      action: action(selectToEndPoint, editor, true),\n      ctrlKey: true,\n      shiftKey: true\n    }] : []), {\n      keyCode: VK.END,\n      action: action(moveToLineEndPoint, editor, true)\n    }, {\n      keyCode: VK.HOME,\n      action: action(moveToLineEndPoint, editor, false)\n    }, {\n      keyCode: VK.END,\n      action: action(moveToLineEndPoint$2, editor, true, caret)\n    }, {\n      keyCode: VK.HOME,\n      action: action(moveToLineEndPoint$2, editor, false, caret)\n    }], evt).each(_ => {\n      evt.preventDefault();\n    });\n  };\n  const setup$h = (editor, caret) => {\n    editor.on('keydown', evt => {\n      if (!evt.isDefaultPrevented()) {\n        executeKeydownOverride$2(editor, caret, evt);\n      }\n    });\n  };\n  const setup$g = editor => {\n    editor.on('input', e => {\n      if (!e.isComposing) {\n        normalizeNbspsInEditor(editor);\n      }\n    });\n  };\n  const platform = detect$1();\n  const executeKeyupAction = (editor, caret, evt) => {\n    execute([{\n      keyCode: VK.PAGE_UP,\n      action: action(moveToLineEndPoint$2, editor, false, caret)\n    }, {\n      keyCode: VK.PAGE_DOWN,\n      action: action(moveToLineEndPoint$2, editor, true, caret)\n    }], evt);\n  };\n  const stopImmediatePropagation = e => e.stopImmediatePropagation();\n  const isPageUpDown = evt => evt.keyCode === VK.PAGE_UP || evt.keyCode === VK.PAGE_DOWN;\n  const setNodeChangeBlocker = (blocked, editor, block) => {\n    if (block && !blocked.get()) {\n      editor.on('NodeChange', stopImmediatePropagation, true);\n    } else if (!block && blocked.get()) {\n      editor.off('NodeChange', stopImmediatePropagation);\n    }\n    blocked.set(block);\n  };\n  const setup$f = (editor, caret) => {\n    if (platform.os.isMacOS()) {\n      return;\n    }\n    const blocked = Cell(false);\n    editor.on('keydown', evt => {\n      if (isPageUpDown(evt)) {\n        setNodeChangeBlocker(blocked, editor, true);\n      }\n    });\n    editor.on('keyup', evt => {\n      if (!evt.isDefaultPrevented()) {\n        executeKeyupAction(editor, caret, evt);\n      }\n      if (isPageUpDown(evt) && blocked.get()) {\n        setNodeChangeBlocker(blocked, editor, false);\n        editor.nodeChanged();\n      }\n    });\n  };\n  const setup$e = editor => {\n    editor.on('beforeinput', e => {\n      if (!editor.selection.isEditable() || exists(e.getTargetRanges(), rng => !isEditableRange(editor.dom, rng))) {\n        e.preventDefault();\n      }\n    });\n  };\n  const insertTextAtPosition = (text, pos) => {\n    const container = pos.container();\n    const offset = pos.offset();\n    if (isText$b(container)) {\n      container.insertData(offset, text);\n      return Optional.some(CaretPosition(container, offset + text.length));\n    } else {\n      return getElementFromPosition(pos).map(elm => {\n        const textNode = SugarElement.fromText(text);\n        if (pos.isAtEnd()) {\n          after$4(elm, textNode);\n        } else {\n          before$3(elm, textNode);\n        }\n        return CaretPosition(textNode.dom, text.length);\n      });\n    }\n  };\n  const insertNbspAtPosition = curry(insertTextAtPosition, nbsp);\n  const insertSpaceAtPosition = curry(insertTextAtPosition, ' ');\n  const insertSpaceOrNbspAtPosition = (root, pos, schema) => needsToHaveNbsp(root, pos, schema) ? insertNbspAtPosition(pos) : insertSpaceAtPosition(pos);\n  const locationToCaretPosition = root => location => location.fold(element => prevPosition(root.dom, CaretPosition.before(element)), element => firstPositionIn(element), element => lastPositionIn(element), element => nextPosition(root.dom, CaretPosition.after(element)));\n  const insertInlineBoundarySpaceOrNbsp = (root, pos, schema) => checkPos => needsToHaveNbsp(root, checkPos, schema) ? insertNbspAtPosition(pos) : insertSpaceAtPosition(pos);\n  const setSelection = editor => pos => {\n    editor.selection.setRng(pos.toRange());\n    editor.nodeChanged();\n  };\n  const isInsideSummary = (domUtils, node) => domUtils.isEditable(domUtils.getParent(node, 'summary'));\n  const insertSpaceOrNbspAtSelection = editor => {\n    const pos = CaretPosition.fromRangeStart(editor.selection.getRng());\n    const root = SugarElement.fromDom(editor.getBody());\n    if (editor.selection.isCollapsed()) {\n      const isInlineTarget$1 = curry(isInlineTarget, editor);\n      const caretPosition = CaretPosition.fromRangeStart(editor.selection.getRng());\n      return readLocation(isInlineTarget$1, editor.getBody(), caretPosition).bind(locationToCaretPosition(root)).map(checkPos => () => insertInlineBoundarySpaceOrNbsp(root, pos, editor.schema)(checkPos).each(setSelection(editor)));\n    } else {\n      return Optional.none();\n    }\n  };\n  const insertSpaceInSummaryAtSelectionOnFirefox = editor => {\n    const insertSpaceThunk = () => {\n      const root = SugarElement.fromDom(editor.getBody());\n      if (!editor.selection.isCollapsed()) {\n        editor.getDoc().execCommand('Delete');\n      }\n      const pos = CaretPosition.fromRangeStart(editor.selection.getRng());\n      insertSpaceOrNbspAtPosition(root, pos, editor.schema).each(setSelection(editor));\n    };\n    return someIf(Env.browser.isFirefox() && editor.selection.isEditable() && isInsideSummary(editor.dom, editor.selection.getRng().startContainer), insertSpaceThunk);\n  };\n  const executeKeydownOverride$1 = (editor, evt) => {\n    executeWithDelayedAction([{\n      keyCode: VK.SPACEBAR,\n      action: action(insertSpaceOrNbspAtSelection, editor)\n    }, {\n      keyCode: VK.SPACEBAR,\n      action: action(insertSpaceInSummaryAtSelectionOnFirefox, editor)\n    }], evt).each(applyAction => {\n      evt.preventDefault();\n      const event = fireBeforeInputEvent(editor, 'insertText', {\n        data: ' '\n      });\n      if (!event.isDefaultPrevented()) {\n        applyAction();\n        fireInputEvent(editor, 'insertText', {\n          data: ' '\n        });\n      }\n    });\n  };\n  const setup$d = editor => {\n    editor.on('keydown', evt => {\n      if (!evt.isDefaultPrevented()) {\n        executeKeydownOverride$1(editor, evt);\n      }\n    });\n  };\n  const tableTabNavigation = editor => {\n    if (hasTableTabNavigation(editor)) {\n      return [{\n        keyCode: VK.TAB,\n        action: action(handleTab, editor, true)\n      }, {\n        keyCode: VK.TAB,\n        shiftKey: true,\n        action: action(handleTab, editor, false)\n      }];\n    } else {\n      return [];\n    }\n  };\n  const executeKeydownOverride = (editor, evt) => {\n    execute([...tableTabNavigation(editor)], evt).each(_ => {\n      evt.preventDefault();\n    });\n  };\n  const setup$c = editor => {\n    editor.on('keydown', evt => {\n      if (!evt.isDefaultPrevented()) {\n        executeKeydownOverride(editor, evt);\n      }\n    });\n  };\n  const setup$b = editor => {\n    editor.addShortcut('Meta+P', '', 'mcePrint');\n    setup$k(editor);\n    if (isRtc(editor)) {\n      return Cell(null);\n    } else {\n      const caret = setupSelectedState(editor);\n      setup$e(editor);\n      setup$m(editor);\n      setup$l(editor, caret);\n      setup$j(editor, caret);\n      setup$i(editor);\n      setup$d(editor);\n      setup$g(editor);\n      setup$c(editor);\n      setup$h(editor, caret);\n      setup$f(editor, caret);\n      return caret;\n    }\n  };\n  class NodeChange {\n    constructor(editor) {\n      this.lastPath = [];\n      this.editor = editor;\n      let lastRng;\n      const self = this;\n      if (!('onselectionchange' in editor.getDoc())) {\n        editor.on('NodeChange click mouseup keyup focus', e => {\n          const nativeRng = editor.selection.getRng();\n          const fakeRng = {\n            startContainer: nativeRng.startContainer,\n            startOffset: nativeRng.startOffset,\n            endContainer: nativeRng.endContainer,\n            endOffset: nativeRng.endOffset\n          };\n          if (e.type === 'nodechange' || !isEq$4(fakeRng, lastRng)) {\n            editor.dispatch('SelectionChange');\n          }\n          lastRng = fakeRng;\n        });\n      }\n      editor.on('contextmenu', () => {\n        store(editor);\n        editor.dispatch('SelectionChange');\n      });\n      editor.on('SelectionChange', () => {\n        const startElm = editor.selection.getStart(true);\n        if (!startElm) {\n          return;\n        }\n        if (hasAnyRanges(editor) && !self.isSameElementPath(startElm) && editor.dom.isChildOf(startElm, editor.getBody())) {\n          editor.nodeChanged({\n            selectionChange: true\n          });\n        }\n      });\n      editor.on('mouseup', e => {\n        if (!e.isDefaultPrevented() && hasAnyRanges(editor)) {\n          if (editor.selection.getNode().nodeName === 'IMG') {\n            Delay.setEditorTimeout(editor, () => {\n              editor.nodeChanged();\n            });\n          } else {\n            editor.nodeChanged();\n          }\n        }\n      });\n    }\n    nodeChanged(args = {}) {\n      const editor = this.editor;\n      const selection = editor.selection;\n      let node;\n      if (editor.initialized && selection && !shouldDisableNodeChange(editor)) {\n        const root = editor.getBody();\n        node = selection.getStart(true) || root;\n        if (node.ownerDocument !== editor.getDoc() || !editor.dom.isChildOf(node, root)) {\n          node = root;\n        }\n        const parents = [];\n        editor.dom.getParent(node, node => {\n          if (node === root) {\n            return true;\n          } else {\n            parents.push(node);\n            return false;\n          }\n        });\n        editor.dispatch('NodeChange', {\n          ...args,\n          element: node,\n          parents\n        });\n      }\n    }\n    isSameElementPath(startElm) {\n      let i;\n      const editor = this.editor;\n      const currentPath = reverse(editor.dom.getParents(startElm, always, editor.getBody()));\n      if (currentPath.length === this.lastPath.length) {\n        for (i = currentPath.length; i >= 0; i--) {\n          if (currentPath[i] !== this.lastPath[i]) {\n            break;\n          }\n        }\n        if (i === -1) {\n          this.lastPath = currentPath;\n          return true;\n        }\n      }\n      this.lastPath = currentPath;\n      return false;\n    }\n  }\n  const imageId = generate$1('image');\n  const getDragImage = transfer => {\n    const dt = transfer;\n    return Optional.from(dt[imageId]);\n  };\n  const setDragImage = (transfer, imageData) => {\n    const dt = transfer;\n    dt[imageId] = imageData;\n  };\n  const eventId = generate$1('event');\n  const getEvent = transfer => {\n    const dt = transfer;\n    return Optional.from(dt[eventId]);\n  };\n  const mkSetEventFn = type => transfer => {\n    const dt = transfer;\n    dt[eventId] = type;\n  };\n  const setEvent = (transfer, type) => mkSetEventFn(type)(transfer);\n  const setDragstartEvent = mkSetEventFn(0);\n  const setDropEvent = mkSetEventFn(2);\n  const setDragendEvent = mkSetEventFn(1);\n  const checkEvent = expectedType => transfer => {\n    const dt = transfer;\n    return Optional.from(dt[eventId]).exists(type => type === expectedType);\n  };\n  const isInDragStartEvent = checkEvent(0);\n  const createEmptyFileList = () => Object.freeze({\n    length: 0,\n    item: _ => null\n  });\n  const modeId = generate$1('mode');\n  const getMode = transfer => {\n    const dt = transfer;\n    return Optional.from(dt[modeId]);\n  };\n  const mkSetModeFn = mode => transfer => {\n    const dt = transfer;\n    dt[modeId] = mode;\n  };\n  const setMode$1 = (transfer, mode) => mkSetModeFn(mode)(transfer);\n  const setReadWriteMode = mkSetModeFn(0);\n  const setReadOnlyMode = mkSetModeFn(2);\n  const setProtectedMode = mkSetModeFn(1);\n  const checkMode = expectedMode => transfer => {\n    const dt = transfer;\n    return Optional.from(dt[modeId]).exists(mode => mode === expectedMode);\n  };\n  const isInReadWriteMode = checkMode(0);\n  const isInProtectedMode = checkMode(1);\n  const normalizeItems = (dataTransfer, itemsImpl) => ({\n    ...itemsImpl,\n    get length() {\n      return itemsImpl.length;\n    },\n    add: (data, type) => {\n      if (isInReadWriteMode(dataTransfer)) {\n        if (isString(data)) {\n          if (!isUndefined(type)) {\n            return itemsImpl.add(data, type);\n          }\n        } else {\n          return itemsImpl.add(data);\n        }\n      }\n      return null;\n    },\n    remove: idx => {\n      if (isInReadWriteMode(dataTransfer)) {\n        itemsImpl.remove(idx);\n      }\n    },\n    clear: () => {\n      if (isInReadWriteMode(dataTransfer)) {\n        itemsImpl.clear();\n      }\n    }\n  });\n  const validDropEffects = ['none', 'copy', 'link', 'move'];\n  const validEffectAlloweds = ['none', 'copy', 'copyLink', 'copyMove', 'link', 'linkMove', 'move', 'all', 'uninitialized'];\n  const createDataTransfer = () => {\n    const dataTransferImpl = new window.DataTransfer();\n    let dropEffect = 'move';\n    let effectAllowed = 'all';\n    const dataTransfer = {\n      get dropEffect() {\n        return dropEffect;\n      },\n      set dropEffect(effect) {\n        if (contains$2(validDropEffects, effect)) {\n          dropEffect = effect;\n        }\n      },\n      get effectAllowed() {\n        return effectAllowed;\n      },\n      set effectAllowed(allowed) {\n        if (isInDragStartEvent(dataTransfer) && contains$2(validEffectAlloweds, allowed)) {\n          effectAllowed = allowed;\n        }\n      },\n      get items() {\n        return normalizeItems(dataTransfer, dataTransferImpl.items);\n      },\n      get files() {\n        if (isInProtectedMode(dataTransfer)) {\n          return createEmptyFileList();\n        } else {\n          return dataTransferImpl.files;\n        }\n      },\n      get types() {\n        return dataTransferImpl.types;\n      },\n      setDragImage: (image, x, y) => {\n        if (isInReadWriteMode(dataTransfer)) {\n          setDragImage(dataTransfer, {\n            image,\n            x,\n            y\n          });\n          dataTransferImpl.setDragImage(image, x, y);\n        }\n      },\n      getData: format => {\n        if (isInProtectedMode(dataTransfer)) {\n          return '';\n        } else {\n          return dataTransferImpl.getData(format);\n        }\n      },\n      setData: (format, data) => {\n        if (isInReadWriteMode(dataTransfer)) {\n          dataTransferImpl.setData(format, data);\n        }\n      },\n      clearData: format => {\n        if (isInReadWriteMode(dataTransfer)) {\n          dataTransferImpl.clearData(format);\n        }\n      }\n    };\n    setReadWriteMode(dataTransfer);\n    return dataTransfer;\n  };\n  const cloneDataTransfer = original => {\n    const clone = createDataTransfer();\n    const originalMode = getMode(original);\n    setReadOnlyMode(original);\n    setDragstartEvent(clone);\n    clone.dropEffect = original.dropEffect;\n    clone.effectAllowed = original.effectAllowed;\n    getDragImage(original).each(imageData => clone.setDragImage(imageData.image, imageData.x, imageData.y));\n    each$e(original.types, type => {\n      if (type !== 'Files') {\n        clone.setData(type, original.getData(type));\n      }\n    });\n    each$e(original.files, file => clone.items.add(file));\n    getEvent(original).each(type => {\n      setEvent(clone, type);\n    });\n    originalMode.each(mode => {\n      setMode$1(original, mode);\n      setMode$1(clone, mode);\n    });\n    return clone;\n  };\n  const getHtmlData = dataTransfer => {\n    const html = dataTransfer.getData('text/html');\n    return html === '' ? Optional.none() : Optional.some(html);\n  };\n  const setHtmlData = (dataTransfer, html) => dataTransfer.setData('text/html', html);\n  const internalMimeType = 'x-tinymce/html';\n  const internalHtmlMime = constant(internalMimeType);\n  const internalMark = '<!-- ' + internalMimeType + ' -->';\n  const mark = html => internalMark + html;\n  const unmark = html => html.replace(internalMark, '');\n  const isMarked = html => html.indexOf(internalMark) !== -1;\n  const isPlainText = text => {\n    return !/<(?:\\/?(?!(?:div|p|br|span)>)\\w+|(?:(?!(?:span style=\"white-space:\\s?pre;?\">)|br\\s?\\/>))\\w+\\s[^>]+)>/i.test(text);\n  };\n  const openContainer = (rootTag, rootAttrs) => {\n    let tag = '<' + rootTag;\n    const attrs = mapToArray(rootAttrs, (value, key) => key + '=\"' + Entities.encodeAllRaw(value) + '\"');\n    if (attrs.length) {\n      tag += ' ' + attrs.join(' ');\n    }\n    return tag + '>';\n  };\n  const toBlockElements = (text, rootTag, rootAttrs) => {\n    const blocks = text.split(/\\n\\n/);\n    const tagOpen = openContainer(rootTag, rootAttrs);\n    const tagClose = '</' + rootTag + '>';\n    const paragraphs = map$3(blocks, p => {\n      return p.split(/\\n/).join('<br />');\n    });\n    const stitch = p => {\n      return tagOpen + p + tagClose;\n    };\n    return paragraphs.length === 1 ? paragraphs[0] : map$3(paragraphs, stitch).join('');\n  };\n  const pasteBinDefaultContent = '%MCEPASTEBIN%';\n  const create$6 = (editor, lastRngCell) => {\n    const {\n      dom,\n      selection\n    } = editor;\n    const body = editor.getBody();\n    lastRngCell.set(selection.getRng());\n    const pasteBinElm = dom.add(editor.getBody(), 'div', {\n      'id': 'mcepastebin',\n      'class': 'mce-pastebin',\n      'contentEditable': true,\n      'data-mce-bogus': 'all',\n      'style': 'position: fixed; top: 50%; width: 10px; height: 10px; overflow: hidden; opacity: 0'\n    }, pasteBinDefaultContent);\n    if (Env.browser.isFirefox()) {\n      dom.setStyle(pasteBinElm, 'left', dom.getStyle(body, 'direction', true) === 'rtl' ? 65535 : -65535);\n    }\n    dom.bind(pasteBinElm, 'beforedeactivate focusin focusout', e => {\n      e.stopPropagation();\n    });\n    pasteBinElm.focus();\n    selection.select(pasteBinElm, true);\n  };\n  const remove = (editor, lastRngCell) => {\n    const dom = editor.dom;\n    if (getEl(editor)) {\n      let pasteBinClone;\n      const lastRng = lastRngCell.get();\n      while (pasteBinClone = getEl(editor)) {\n        dom.remove(pasteBinClone);\n        dom.unbind(pasteBinClone);\n      }\n      if (lastRng) {\n        editor.selection.setRng(lastRng);\n      }\n    }\n    lastRngCell.set(null);\n  };\n  const getEl = editor => editor.dom.get('mcepastebin');\n  const isPasteBin = elm => isNonNullable(elm) && elm.id === 'mcepastebin';\n  const getHtml = editor => {\n    const dom = editor.dom;\n    const copyAndRemove = (toElm, fromElm) => {\n      toElm.appendChild(fromElm);\n      dom.remove(fromElm, true);\n    };\n    const [pasteBinElm, ...pasteBinClones] = filter$5(editor.getBody().childNodes, isPasteBin);\n    each$e(pasteBinClones, pasteBinClone => {\n      copyAndRemove(pasteBinElm, pasteBinClone);\n    });\n    const dirtyWrappers = dom.select('div[id=mcepastebin]', pasteBinElm);\n    for (let i = dirtyWrappers.length - 1; i >= 0; i--) {\n      const cleanWrapper = dom.create('div');\n      pasteBinElm.insertBefore(cleanWrapper, dirtyWrappers[i]);\n      copyAndRemove(cleanWrapper, dirtyWrappers[i]);\n    }\n    return pasteBinElm ? pasteBinElm.innerHTML : '';\n  };\n  const isDefaultPasteBinContent = content => content === pasteBinDefaultContent;\n  const PasteBin = editor => {\n    const lastRng = Cell(null);\n    return {\n      create: () => create$6(editor, lastRng),\n      remove: () => remove(editor, lastRng),\n      getEl: () => getEl(editor),\n      getHtml: () => getHtml(editor),\n      getLastRng: lastRng.get\n    };\n  };\n  const filter$1 = (content, items) => {\n    Tools.each(items, v => {\n      if (is$4(v, RegExp)) {\n        content = content.replace(v, '');\n      } else {\n        content = content.replace(v[0], v[1]);\n      }\n    });\n    return content;\n  };\n  const innerText = html => {\n    const schema = Schema();\n    const domParser = DomParser({}, schema);\n    let text = '';\n    const voidElements = schema.getVoidElements();\n    const ignoreElements = Tools.makeMap('script noscript style textarea video audio iframe object', ' ');\n    const blockElements = schema.getBlockElements();\n    const walk = node => {\n      const name = node.name,\n        currentNode = node;\n      if (name === 'br') {\n        text += '\\n';\n        return;\n      }\n      if (name === 'wbr') {\n        return;\n      }\n      if (voidElements[name]) {\n        text += ' ';\n      }\n      if (ignoreElements[name]) {\n        text += ' ';\n        return;\n      }\n      if (node.type === 3) {\n        text += node.value;\n      }\n      if (!(node.name in schema.getVoidElements())) {\n        let currentNode = node.firstChild;\n        if (currentNode) {\n          do {\n            walk(currentNode);\n          } while (currentNode = currentNode.next);\n        }\n      }\n      if (blockElements[name] && currentNode.next) {\n        text += '\\n';\n        if (name === 'p') {\n          text += '\\n';\n        }\n      }\n    };\n    html = filter$1(html, [/<!\\[[^\\]]+\\]>/g]);\n    walk(domParser.parse(html));\n    return text;\n  };\n  const trimHtml = html => {\n    const trimSpaces = (all, s1, s2) => {\n      if (!s1 && !s2) {\n        return ' ';\n      }\n      return nbsp;\n    };\n    html = filter$1(html, [/^[\\s\\S]*<body[^>]*>\\s*|\\s*<\\/body[^>]*>[\\s\\S]*$/ig, /<!--StartFragment-->|<!--EndFragment-->/g, [/( ?)<span class=\"Apple-converted-space\">\\u00a0<\\/span>( ?)/g, trimSpaces], /<br class=\"Apple-interchange-newline\">/g, /<br>$/i]);\n    return html;\n  };\n  const createIdGenerator = prefix => {\n    let count = 0;\n    return () => {\n      return prefix + count++;\n    };\n  };\n  const getImageMimeType = ext => {\n    const lowerExt = ext.toLowerCase();\n    const mimeOverrides = {\n      jpg: 'jpeg',\n      jpe: 'jpeg',\n      jfi: 'jpeg',\n      jif: 'jpeg',\n      jfif: 'jpeg',\n      pjpeg: 'jpeg',\n      pjp: 'jpeg',\n      svg: 'svg+xml'\n    };\n    return Tools.hasOwn(mimeOverrides, lowerExt) ? 'image/' + mimeOverrides[lowerExt] : 'image/' + lowerExt;\n  };\n  const preProcess = (editor, html) => {\n    const parser = DomParser({\n      sanitize: shouldSanitizeXss(editor),\n      sandbox_iframes: shouldSandboxIframes(editor),\n      sandbox_iframes_exclusions: getSandboxIframesExclusions(editor),\n      convert_unsafe_embeds: shouldConvertUnsafeEmbeds(editor)\n    }, editor.schema);\n    parser.addNodeFilter('meta', nodes => {\n      Tools.each(nodes, node => {\n        node.remove();\n      });\n    });\n    const fragment = parser.parse(html, {\n      forced_root_block: false,\n      isRootContent: true\n    });\n    return HtmlSerializer({\n      validate: true\n    }, editor.schema).serialize(fragment);\n  };\n  const processResult = (content, cancelled) => ({\n    content,\n    cancelled\n  });\n  const postProcessFilter = (editor, html, internal) => {\n    const tempBody = editor.dom.create('div', {\n      style: 'display:none'\n    }, html);\n    const postProcessArgs = firePastePostProcess(editor, tempBody, internal);\n    return processResult(postProcessArgs.node.innerHTML, postProcessArgs.isDefaultPrevented());\n  };\n  const filterContent = (editor, content, internal) => {\n    const preProcessArgs = firePastePreProcess(editor, content, internal);\n    const filteredContent = preProcess(editor, preProcessArgs.content);\n    if (editor.hasEventListeners('PastePostProcess') && !preProcessArgs.isDefaultPrevented()) {\n      return postProcessFilter(editor, filteredContent, internal);\n    } else {\n      return processResult(filteredContent, preProcessArgs.isDefaultPrevented());\n    }\n  };\n  const process = (editor, html, internal) => {\n    return filterContent(editor, html, internal);\n  };\n  const pasteHtml$1 = (editor, html) => {\n    editor.insertContent(html, {\n      merge: shouldPasteMergeFormats(editor),\n      paste: true\n    });\n    return true;\n  };\n  const isAbsoluteUrl = url => /^https?:\\/\\/[\\w\\-\\/+=.,!;:&%@^~(){}?#]+$/i.test(url);\n  const isImageUrl = (editor, url) => {\n    return isAbsoluteUrl(url) && exists(getAllowedImageFileTypes(editor), type => endsWith(url.toLowerCase(), `.${type.toLowerCase()}`));\n  };\n  const createImage = (editor, url, pasteHtmlFn) => {\n    editor.undoManager.extra(() => {\n      pasteHtmlFn(editor, url);\n    }, () => {\n      editor.insertContent('<img src=\"' + url + '\">');\n    });\n    return true;\n  };\n  const createLink = (editor, url, pasteHtmlFn) => {\n    editor.undoManager.extra(() => {\n      pasteHtmlFn(editor, url);\n    }, () => {\n      editor.execCommand('mceInsertLink', false, url);\n    });\n    return true;\n  };\n  const linkSelection = (editor, html, pasteHtmlFn) => !editor.selection.isCollapsed() && isAbsoluteUrl(html) ? createLink(editor, html, pasteHtmlFn) : false;\n  const insertImage = (editor, html, pasteHtmlFn) => isImageUrl(editor, html) ? createImage(editor, html, pasteHtmlFn) : false;\n  const smartInsertContent = (editor, html) => {\n    Tools.each([linkSelection, insertImage, pasteHtml$1], action => {\n      return !action(editor, html, pasteHtml$1);\n    });\n  };\n  const insertContent = (editor, html, pasteAsText) => {\n    if (pasteAsText || !isSmartPasteEnabled(editor)) {\n      pasteHtml$1(editor, html);\n    } else {\n      smartInsertContent(editor, html);\n    }\n  };\n  const uniqueId = createIdGenerator('mceclip');\n  const createPasteDataTransfer = html => {\n    const dataTransfer = createDataTransfer();\n    setHtmlData(dataTransfer, html);\n    setReadOnlyMode(dataTransfer);\n    return dataTransfer;\n  };\n  const doPaste = (editor, content, internal, pasteAsText, shouldSimulateInputEvent) => {\n    const res = process(editor, content, internal);\n    if (!res.cancelled) {\n      const content = res.content;\n      const doPasteAction = () => insertContent(editor, content, pasteAsText);\n      if (shouldSimulateInputEvent) {\n        const args = fireBeforeInputEvent(editor, 'insertFromPaste', {\n          dataTransfer: createPasteDataTransfer(content)\n        });\n        if (!args.isDefaultPrevented()) {\n          doPasteAction();\n          fireInputEvent(editor, 'insertFromPaste');\n        }\n      } else {\n        doPasteAction();\n      }\n    }\n  };\n  const pasteHtml = (editor, html, internalFlag, shouldSimulateInputEvent) => {\n    const internal = internalFlag ? internalFlag : isMarked(html);\n    doPaste(editor, unmark(html), internal, false, shouldSimulateInputEvent);\n  };\n  const pasteText = (editor, text, shouldSimulateInputEvent) => {\n    const encodedText = editor.dom.encode(text).replace(/\\r\\n/g, '\\n');\n    const normalizedText = normalize$4(encodedText, getPasteTabSpaces(editor));\n    const html = toBlockElements(normalizedText, getForcedRootBlock(editor), getForcedRootBlockAttrs(editor));\n    doPaste(editor, html, false, true, shouldSimulateInputEvent);\n  };\n  const getDataTransferItems = dataTransfer => {\n    const items = {};\n    if (dataTransfer && dataTransfer.types) {\n      for (let i = 0; i < dataTransfer.types.length; i++) {\n        const contentType = dataTransfer.types[i];\n        try {\n          items[contentType] = dataTransfer.getData(contentType);\n        } catch (ex) {\n          items[contentType] = '';\n        }\n      }\n    }\n    return items;\n  };\n  const hasContentType = (clipboardContent, mimeType) => mimeType in clipboardContent && clipboardContent[mimeType].length > 0;\n  const hasHtmlOrText = content => hasContentType(content, 'text/html') || hasContentType(content, 'text/plain');\n  const extractFilename = (editor, str) => {\n    const m = str.match(/([\\s\\S]+?)(?:\\.[a-z0-9.]+)$/i);\n    return isNonNullable(m) ? editor.dom.encode(m[1]) : undefined;\n  };\n  const createBlobInfo = (editor, blobCache, file, base64) => {\n    const id = uniqueId();\n    const useFileName = shouldReuseFileName(editor) && isNonNullable(file.name);\n    const name = useFileName ? extractFilename(editor, file.name) : id;\n    const filename = useFileName ? file.name : undefined;\n    const blobInfo = blobCache.create(id, file, base64, name, filename);\n    blobCache.add(blobInfo);\n    return blobInfo;\n  };\n  const pasteImage = (editor, imageItem) => {\n    parseDataUri(imageItem.uri).each(({\n      data,\n      type,\n      base64Encoded\n    }) => {\n      const base64 = base64Encoded ? data : btoa(data);\n      const file = imageItem.file;\n      const blobCache = editor.editorUpload.blobCache;\n      const existingBlobInfo = blobCache.getByData(base64, type);\n      const blobInfo = existingBlobInfo !== null && existingBlobInfo !== void 0 ? existingBlobInfo : createBlobInfo(editor, blobCache, file, base64);\n      pasteHtml(editor, `<img src=\"${blobInfo.blobUri()}\">`, false, true);\n    });\n  };\n  const isClipboardEvent = event => event.type === 'paste';\n  const readFilesAsDataUris = items => Promise.all(map$3(items, file => {\n    return blobToDataUri(file).then(uri => ({\n      file,\n      uri\n    }));\n  }));\n  const isImage = editor => {\n    const allowedExtensions = getAllowedImageFileTypes(editor);\n    return file => startsWith(file.type, 'image/') && exists(allowedExtensions, extension => {\n      return getImageMimeType(extension) === file.type;\n    });\n  };\n  const getImagesFromDataTransfer = (editor, dataTransfer) => {\n    const items = dataTransfer.items ? bind$3(from(dataTransfer.items), item => {\n      return item.kind === 'file' ? [item.getAsFile()] : [];\n    }) : [];\n    const files = dataTransfer.files ? from(dataTransfer.files) : [];\n    return filter$5(items.length > 0 ? items : files, isImage(editor));\n  };\n  const pasteImageData = (editor, e, rng) => {\n    const dataTransfer = isClipboardEvent(e) ? e.clipboardData : e.dataTransfer;\n    if (shouldPasteDataImages(editor) && dataTransfer) {\n      const images = getImagesFromDataTransfer(editor, dataTransfer);\n      if (images.length > 0) {\n        e.preventDefault();\n        readFilesAsDataUris(images).then(fileResults => {\n          if (rng) {\n            editor.selection.setRng(rng);\n          }\n          each$e(fileResults, result => {\n            pasteImage(editor, result);\n          });\n        });\n        return true;\n      }\n    }\n    return false;\n  };\n  const isBrokenAndroidClipboardEvent = e => {\n    var _a, _b;\n    return Env.os.isAndroid() && ((_b = (_a = e.clipboardData) === null || _a === void 0 ? void 0 : _a.items) === null || _b === void 0 ? void 0 : _b.length) === 0;\n  };\n  const isKeyboardPasteEvent = e => VK.metaKeyPressed(e) && e.keyCode === 86 || e.shiftKey && e.keyCode === 45;\n  const insertClipboardContent = (editor, clipboardContent, html, plainTextMode, shouldSimulateInputEvent) => {\n    let content = trimHtml(html);\n    const isInternal = hasContentType(clipboardContent, internalHtmlMime()) || isMarked(html);\n    const isPlainTextHtml = !isInternal && isPlainText(content);\n    const isAbsoluteUrl$1 = isAbsoluteUrl(content);\n    if (isDefaultPasteBinContent(content) || !content.length || isPlainTextHtml && !isAbsoluteUrl$1) {\n      plainTextMode = true;\n    }\n    if (plainTextMode || isAbsoluteUrl$1) {\n      if (hasContentType(clipboardContent, 'text/plain') && isPlainTextHtml) {\n        content = clipboardContent['text/plain'];\n      } else {\n        content = innerText(content);\n      }\n    }\n    if (isDefaultPasteBinContent(content)) {\n      return;\n    }\n    if (plainTextMode) {\n      pasteText(editor, content, shouldSimulateInputEvent);\n    } else {\n      pasteHtml(editor, content, isInternal, shouldSimulateInputEvent);\n    }\n  };\n  const registerEventHandlers = (editor, pasteBin, pasteFormat) => {\n    let keyboardPastePlainTextState;\n    const getLastRng = () => pasteBin.getLastRng() || editor.selection.getRng();\n    editor.on('keydown', e => {\n      if (isKeyboardPasteEvent(e) && !e.isDefaultPrevented()) {\n        keyboardPastePlainTextState = e.shiftKey && e.keyCode === 86;\n      }\n    });\n    editor.on('paste', e => {\n      if (e.isDefaultPrevented() || isBrokenAndroidClipboardEvent(e)) {\n        return;\n      }\n      const plainTextMode = pasteFormat.get() === 'text' || keyboardPastePlainTextState;\n      keyboardPastePlainTextState = false;\n      const clipboardContent = getDataTransferItems(e.clipboardData);\n      if (!hasHtmlOrText(clipboardContent) && pasteImageData(editor, e, getLastRng())) {\n        return;\n      }\n      if (hasContentType(clipboardContent, 'text/html')) {\n        e.preventDefault();\n        insertClipboardContent(editor, clipboardContent, clipboardContent['text/html'], plainTextMode, true);\n      } else if (hasContentType(clipboardContent, 'text/plain') && hasContentType(clipboardContent, 'text/uri-list')) {\n        e.preventDefault();\n        insertClipboardContent(editor, clipboardContent, clipboardContent['text/plain'], plainTextMode, true);\n      } else {\n        pasteBin.create();\n        Delay.setEditorTimeout(editor, () => {\n          const html = pasteBin.getHtml();\n          pasteBin.remove();\n          insertClipboardContent(editor, clipboardContent, html, plainTextMode, false);\n        }, 0);\n      }\n    });\n  };\n  const registerDataImageFilter = editor => {\n    const isWebKitFakeUrl = src => startsWith(src, 'webkit-fake-url');\n    const isDataUri = src => startsWith(src, 'data:');\n    const isPasteInsert = args => {\n      var _a;\n      return ((_a = args.data) === null || _a === void 0 ? void 0 : _a.paste) === true;\n    };\n    editor.parser.addNodeFilter('img', (nodes, name, args) => {\n      if (!shouldPasteDataImages(editor) && isPasteInsert(args)) {\n        for (const node of nodes) {\n          const src = node.attr('src');\n          if (isString(src) && !node.attr('data-mce-object') && src !== Env.transparentSrc) {\n            if (isWebKitFakeUrl(src)) {\n              node.remove();\n            } else if (!shouldAllowHtmlDataUrls(editor) && isDataUri(src)) {\n              node.remove();\n            }\n          }\n        }\n      }\n    });\n  };\n  const registerEventsAndFilters = (editor, pasteBin, pasteFormat) => {\n    registerEventHandlers(editor, pasteBin, pasteFormat);\n    registerDataImageFilter(editor);\n  };\n  const togglePlainTextPaste = (editor, pasteFormat) => {\n    if (pasteFormat.get() === 'text') {\n      pasteFormat.set('html');\n      firePastePlainTextToggle(editor, false);\n    } else {\n      pasteFormat.set('text');\n      firePastePlainTextToggle(editor, true);\n    }\n    editor.focus();\n  };\n  const register$1 = (editor, pasteFormat) => {\n    editor.addCommand('mceTogglePlainTextPaste', () => {\n      togglePlainTextPaste(editor, pasteFormat);\n    });\n    editor.addCommand('mceInsertClipboardContent', (ui, value) => {\n      if (value.html) {\n        pasteHtml(editor, value.html, value.internal, false);\n      }\n      if (value.text) {\n        pasteText(editor, value.text, false);\n      }\n    });\n  };\n  const setHtml5Clipboard = (clipboardData, html, text) => {\n    if (clipboardData) {\n      try {\n        clipboardData.clearData();\n        clipboardData.setData('text/html', html);\n        clipboardData.setData('text/plain', text);\n        clipboardData.setData(internalHtmlMime(), html);\n        return true;\n      } catch (e) {\n        return false;\n      }\n    } else {\n      return false;\n    }\n  };\n  const setClipboardData = (evt, data, fallback, done) => {\n    if (setHtml5Clipboard(evt.clipboardData, data.html, data.text)) {\n      evt.preventDefault();\n      done();\n    } else {\n      fallback(data.html, done);\n    }\n  };\n  const fallback = editor => (html, done) => {\n    const {\n      dom,\n      selection\n    } = editor;\n    const outer = dom.create('div', {\n      'contenteditable': 'false',\n      'data-mce-bogus': 'all'\n    });\n    const inner = dom.create('div', {\n      contenteditable: 'true'\n    }, html);\n    dom.setStyles(outer, {\n      position: 'fixed',\n      top: '0',\n      left: '-3000px',\n      width: '1000px',\n      overflow: 'hidden'\n    });\n    outer.appendChild(inner);\n    dom.add(editor.getBody(), outer);\n    const range = selection.getRng();\n    inner.focus();\n    const offscreenRange = dom.createRng();\n    offscreenRange.selectNodeContents(inner);\n    selection.setRng(offscreenRange);\n    Delay.setEditorTimeout(editor, () => {\n      selection.setRng(range);\n      dom.remove(outer);\n      done();\n    }, 0);\n  };\n  const getData = editor => ({\n    html: mark(editor.selection.getContent({\n      contextual: true\n    })),\n    text: editor.selection.getContent({\n      format: 'text'\n    })\n  });\n  const isTableSelection = editor => !!editor.dom.getParent(editor.selection.getStart(), 'td[data-mce-selected],th[data-mce-selected]', editor.getBody());\n  const hasSelectedContent = editor => !editor.selection.isCollapsed() || isTableSelection(editor);\n  const cut = editor => evt => {\n    if (!evt.isDefaultPrevented() && hasSelectedContent(editor) && editor.selection.isEditable()) {\n      setClipboardData(evt, getData(editor), fallback(editor), () => {\n        if (Env.browser.isChromium() || Env.browser.isFirefox()) {\n          const rng = editor.selection.getRng();\n          Delay.setEditorTimeout(editor, () => {\n            editor.selection.setRng(rng);\n            editor.execCommand('Delete');\n          }, 0);\n        } else {\n          editor.execCommand('Delete');\n        }\n      });\n    }\n  };\n  const copy = editor => evt => {\n    if (!evt.isDefaultPrevented() && hasSelectedContent(editor)) {\n      setClipboardData(evt, getData(editor), fallback(editor), noop);\n    }\n  };\n  const register = editor => {\n    editor.on('cut', cut(editor));\n    editor.on('copy', copy(editor));\n  };\n  const getCaretRangeFromEvent = (editor, e) => {\n    var _a, _b;\n    return RangeUtils.getCaretRangeFromPoint((_a = e.clientX) !== null && _a !== void 0 ? _a : 0, (_b = e.clientY) !== null && _b !== void 0 ? _b : 0, editor.getDoc());\n  };\n  const isPlainTextFileUrl = content => {\n    const plainTextContent = content['text/plain'];\n    return plainTextContent ? plainTextContent.indexOf('file://') === 0 : false;\n  };\n  const setFocusedRange = (editor, rng) => {\n    editor.focus();\n    if (rng) {\n      editor.selection.setRng(rng);\n    }\n  };\n  const hasImage = dataTransfer => exists(dataTransfer.files, file => /^image\\//.test(file.type));\n  const needsCustomInternalDrop = (dom, schema, target, dropContent) => {\n    const parentTransparent = dom.getParent(target, node => isTransparentBlock(schema, node));\n    const inSummary = !isNull(dom.getParent(target, 'summary'));\n    if (inSummary) {\n      return true;\n    } else if (parentTransparent && has$2(dropContent, 'text/html')) {\n      const fragment = new DOMParser().parseFromString(dropContent['text/html'], 'text/html').body;\n      return !isNull(fragment.querySelector(parentTransparent.nodeName.toLowerCase()));\n    } else {\n      return false;\n    }\n  };\n  const setupSummaryDeleteByDragFix = editor => {\n    editor.on('input', e => {\n      const hasNoSummary = el => isNull(el.querySelector('summary'));\n      if (e.inputType === 'deleteByDrag') {\n        const brokenDetailElements = filter$5(editor.dom.select('details'), hasNoSummary);\n        each$e(brokenDetailElements, details => {\n          if (isBr$6(details.firstChild)) {\n            details.firstChild.remove();\n          }\n          const summary = editor.dom.create('summary');\n          summary.appendChild(createPaddingBr().dom);\n          details.prepend(summary);\n        });\n      }\n    });\n  };\n  const setup$a = (editor, draggingInternallyState) => {\n    if (shouldPasteBlockDrop(editor)) {\n      editor.on('dragend dragover draggesture dragdrop drop drag', e => {\n        e.preventDefault();\n        e.stopPropagation();\n      });\n    }\n    if (!shouldPasteDataImages(editor)) {\n      editor.on('drop', e => {\n        const dataTransfer = e.dataTransfer;\n        if (dataTransfer && hasImage(dataTransfer)) {\n          e.preventDefault();\n        }\n      });\n    }\n    editor.on('drop', e => {\n      if (e.isDefaultPrevented()) {\n        return;\n      }\n      const rng = getCaretRangeFromEvent(editor, e);\n      if (isNullable(rng)) {\n        return;\n      }\n      const dropContent = getDataTransferItems(e.dataTransfer);\n      const internal = hasContentType(dropContent, internalHtmlMime());\n      if ((!hasHtmlOrText(dropContent) || isPlainTextFileUrl(dropContent)) && pasteImageData(editor, e, rng)) {\n        return;\n      }\n      const internalContent = dropContent[internalHtmlMime()];\n      const content = internalContent || dropContent['text/html'] || dropContent['text/plain'];\n      const needsInternalDrop = needsCustomInternalDrop(editor.dom, editor.schema, rng.startContainer, dropContent);\n      const isInternalDrop = draggingInternallyState.get();\n      if (isInternalDrop && !needsInternalDrop) {\n        return;\n      }\n      if (content) {\n        e.preventDefault();\n        Delay.setEditorTimeout(editor, () => {\n          editor.undoManager.transact(() => {\n            if (internalContent || isInternalDrop && needsInternalDrop) {\n              editor.execCommand('Delete');\n            }\n            setFocusedRange(editor, rng);\n            const trimmedContent = trimHtml(content);\n            if (dropContent['text/html']) {\n              pasteHtml(editor, trimmedContent, internal, true);\n            } else {\n              pasteText(editor, trimmedContent, true);\n            }\n          });\n        });\n      }\n    });\n    editor.on('dragstart', _e => {\n      draggingInternallyState.set(true);\n    });\n    editor.on('dragover dragend', e => {\n      if (shouldPasteDataImages(editor) && !draggingInternallyState.get()) {\n        e.preventDefault();\n        setFocusedRange(editor, getCaretRangeFromEvent(editor, e));\n      }\n      if (e.type === 'dragend') {\n        draggingInternallyState.set(false);\n      }\n    });\n    setupSummaryDeleteByDragFix(editor);\n  };\n  const setup$9 = editor => {\n    const processEvent = f => e => {\n      f(editor, e);\n    };\n    const preProcess = getPastePreProcess(editor);\n    if (isFunction(preProcess)) {\n      editor.on('PastePreProcess', processEvent(preProcess));\n    }\n    const postProcess = getPastePostProcess(editor);\n    if (isFunction(postProcess)) {\n      editor.on('PastePostProcess', processEvent(postProcess));\n    }\n  };\n  const addPreProcessFilter = (editor, filterFunc) => {\n    editor.on('PastePreProcess', e => {\n      e.content = filterFunc(editor, e.content, e.internal);\n    });\n  };\n  const rgbRegExp = /rgb\\s*\\(\\s*([0-9]+)\\s*,\\s*([0-9]+)\\s*,\\s*([0-9]+)\\s*\\)/gi;\n  const rgbToHex = value => Tools.trim(value).replace(rgbRegExp, rgbaToHexString).toLowerCase();\n  const removeWebKitStyles = (editor, content, internal) => {\n    const webKitStylesOption = getPasteWebkitStyles(editor);\n    if (internal || webKitStylesOption === 'all' || !shouldPasteRemoveWebKitStyles(editor)) {\n      return content;\n    }\n    const webKitStyles = webKitStylesOption ? webKitStylesOption.split(/[, ]/) : [];\n    if (webKitStyles && webKitStylesOption !== 'none') {\n      const dom = editor.dom,\n        node = editor.selection.getNode();\n      content = content.replace(/(<[^>]+) style=\"([^\"]*)\"([^>]*>)/gi, (all, before, value, after) => {\n        const inputStyles = dom.parseStyle(dom.decode(value));\n        const outputStyles = {};\n        for (let i = 0; i < webKitStyles.length; i++) {\n          const inputValue = inputStyles[webKitStyles[i]];\n          let compareInput = inputValue;\n          let currentValue = dom.getStyle(node, webKitStyles[i], true);\n          if (/color/.test(webKitStyles[i])) {\n            compareInput = rgbToHex(compareInput);\n            currentValue = rgbToHex(currentValue);\n          }\n          if (currentValue !== compareInput) {\n            outputStyles[webKitStyles[i]] = inputValue;\n          }\n        }\n        const outputStyle = dom.serializeStyle(outputStyles, 'span');\n        if (outputStyle) {\n          return before + ' style=\"' + outputStyle + '\"' + after;\n        }\n        return before + after;\n      });\n    } else {\n      content = content.replace(/(<[^>]+) style=\"([^\"]*)\"([^>]*>)/gi, '$1$3');\n    }\n    content = content.replace(/(<[^>]+) data-mce-style=\"([^\"]+)\"([^>]*>)/gi, (all, before, value, after) => {\n      return before + ' style=\"' + value + '\"' + after;\n    });\n    return content;\n  };\n  const setup$8 = editor => {\n    if (Env.browser.isChromium() || Env.browser.isSafari()) {\n      addPreProcessFilter(editor, removeWebKitStyles);\n    }\n  };\n  const setup$7 = editor => {\n    const draggingInternallyState = Cell(false);\n    const pasteFormat = Cell(isPasteAsTextEnabled(editor) ? 'text' : 'html');\n    const pasteBin = PasteBin(editor);\n    setup$8(editor);\n    register$1(editor, pasteFormat);\n    setup$9(editor);\n    editor.addQueryStateHandler('mceTogglePlainTextPaste', () => pasteFormat.get() === 'text');\n    editor.on('PreInit', () => {\n      register(editor);\n      setup$a(editor, draggingInternallyState);\n      registerEventsAndFilters(editor, pasteBin, pasteFormat);\n    });\n  };\n  const preventSummaryToggle = editor => {\n    editor.on('click', e => {\n      if (editor.dom.getParent(e.target, 'details')) {\n        e.preventDefault();\n      }\n    });\n  };\n  const filterDetails = editor => {\n    editor.parser.addNodeFilter('details', elms => {\n      const initialStateOption = getDetailsInitialState(editor);\n      each$e(elms, details => {\n        if (initialStateOption === 'expanded') {\n          details.attr('open', 'open');\n        } else if (initialStateOption === 'collapsed') {\n          details.attr('open', null);\n        }\n      });\n    });\n    editor.serializer.addNodeFilter('details', elms => {\n      const serializedStateOption = getDetailsSerializedState(editor);\n      each$e(elms, details => {\n        if (serializedStateOption === 'expanded') {\n          details.attr('open', 'open');\n        } else if (serializedStateOption === 'collapsed') {\n          details.attr('open', null);\n        }\n      });\n    });\n  };\n  const setup$6 = editor => {\n    preventSummaryToggle(editor);\n    filterDetails(editor);\n  };\n  const isBr = isBr$6;\n  const isText = isText$b;\n  const isContentEditableFalse$2 = elm => isContentEditableFalse$b(elm.dom);\n  const isContentEditableTrue = elm => isContentEditableTrue$3(elm.dom);\n  const isRoot = rootNode => elm => eq(SugarElement.fromDom(rootNode), elm);\n  const getClosestScope = (node, rootNode, schema) => closest$4(SugarElement.fromDom(node), elm => isContentEditableTrue(elm) || schema.isBlock(name(elm)), isRoot(rootNode)).getOr(SugarElement.fromDom(rootNode)).dom;\n  const getClosestCef = (node, rootNode) => closest$4(SugarElement.fromDom(node), isContentEditableFalse$2, isRoot(rootNode));\n  const findEdgeCaretCandidate = (startNode, scope, forward) => {\n    const walker = new DomTreeWalker(startNode, scope);\n    const next = forward ? walker.next.bind(walker) : walker.prev.bind(walker);\n    let result = startNode;\n    for (let current = forward ? startNode : next(); current && !isBr(current); current = next()) {\n      if (isCaretCandidate$3(current)) {\n        result = current;\n      }\n    }\n    return result;\n  };\n  const findClosestBlockRange = (startRng, rootNode, schema) => {\n    const startPos = CaretPosition.fromRangeStart(startRng);\n    const clickNode = startPos.getNode();\n    const scope = getClosestScope(clickNode, rootNode, schema);\n    const startNode = findEdgeCaretCandidate(clickNode, scope, false);\n    const endNode = findEdgeCaretCandidate(clickNode, scope, true);\n    const rng = document.createRange();\n    getClosestCef(startNode, scope).fold(() => {\n      if (isText(startNode)) {\n        rng.setStart(startNode, 0);\n      } else {\n        rng.setStartBefore(startNode);\n      }\n    }, cef => rng.setStartBefore(cef.dom));\n    getClosestCef(endNode, scope).fold(() => {\n      if (isText(endNode)) {\n        rng.setEnd(endNode, endNode.data.length);\n      } else {\n        rng.setEndAfter(endNode);\n      }\n    }, cef => rng.setEndAfter(cef.dom));\n    return rng;\n  };\n  const onTripleClickSelect = editor => {\n    const rng = findClosestBlockRange(editor.selection.getRng(), editor.getBody(), editor.schema);\n    editor.selection.setRng(normalize(rng));\n  };\n  const setup$5 = editor => {\n    editor.on('mousedown', e => {\n      if (e.detail >= 3) {\n        e.preventDefault();\n        onTripleClickSelect(editor);\n      }\n    });\n  };\n  var FakeCaretPosition;\n  (function (FakeCaretPosition) {\n    FakeCaretPosition['Before'] = 'before';\n    FakeCaretPosition['After'] = 'after';\n  })(FakeCaretPosition || (FakeCaretPosition = {}));\n  const distanceToRectLeft = (clientRect, clientX) => Math.abs(clientRect.left - clientX);\n  const distanceToRectRight = (clientRect, clientX) => Math.abs(clientRect.right - clientX);\n  const isInsideY = (clientY, clientRect) => clientY >= clientRect.top && clientY <= clientRect.bottom;\n  const collidesY = (r1, r2) => r1.top < r2.bottom && r1.bottom > r2.top;\n  const isOverlapping = (r1, r2) => {\n    const overlap = overlapY(r1, r2) / Math.min(r1.height, r2.height);\n    return collidesY(r1, r2) && overlap > 0.5;\n  };\n  const splitRectsPerAxis = (rects, y) => {\n    const intersectingRects = filter$5(rects, rect => isInsideY(y, rect));\n    return boundingClientRectFromRects(intersectingRects).fold(() => [[], rects], boundingRect => {\n      const {\n        pass: horizontal,\n        fail: vertical\n      } = partition$2(rects, rect => isOverlapping(rect, boundingRect));\n      return [horizontal, vertical];\n    });\n  };\n  const clientInfo = (rect, clientX) => {\n    return {\n      node: rect.node,\n      position: distanceToRectLeft(rect, clientX) < distanceToRectRight(rect, clientX) ? FakeCaretPosition.Before : FakeCaretPosition.After\n    };\n  };\n  const horizontalDistance = (rect, x, _y) => x > rect.left && x < rect.right ? 0 : Math.min(Math.abs(rect.left - x), Math.abs(rect.right - x));\n  const closestChildCaretCandidateNodeRect = (children, clientX, clientY, findCloserTextNode) => {\n    const caretCandidateRect = rect => {\n      if (isCaretCandidate$3(rect.node)) {\n        return Optional.some(rect);\n      } else if (isElement$6(rect.node)) {\n        return closestChildCaretCandidateNodeRect(from(rect.node.childNodes), clientX, clientY, false);\n      } else {\n        return Optional.none();\n      }\n    };\n    const tryFindSecondBestTextNode = (closest, sndClosest, distance) => {\n      return caretCandidateRect(sndClosest).filter(rect => {\n        const deltaDistance = Math.abs(distance(closest, clientX, clientY) - distance(rect, clientX, clientY));\n        return deltaDistance < 2 && isText$b(rect.node);\n      });\n    };\n    const findClosestCaretCandidateNodeRect = (rects, distance) => {\n      const sortedRects = sort(rects, (r1, r2) => distance(r1, clientX, clientY) - distance(r2, clientX, clientY));\n      return findMap(sortedRects, caretCandidateRect).map(closest => {\n        if (findCloserTextNode && !isText$b(closest.node) && sortedRects.length > 1) {\n          return tryFindSecondBestTextNode(closest, sortedRects[1], distance).getOr(closest);\n        } else {\n          return closest;\n        }\n      });\n    };\n    const [horizontalRects, verticalRects] = splitRectsPerAxis(getClientRects(children), clientY);\n    const {\n      pass: above,\n      fail: below\n    } = partition$2(verticalRects, rect => rect.top < clientY);\n    return findClosestCaretCandidateNodeRect(horizontalRects, horizontalDistance).orThunk(() => findClosestCaretCandidateNodeRect(below, distanceToRectEdgeFromXY)).orThunk(() => findClosestCaretCandidateNodeRect(above, distanceToRectEdgeFromXY));\n  };\n  const traverseUp = (rootElm, scope, clientX, clientY) => {\n    const helper = (scope, prevScope) => {\n      const isDragGhostContainer = node => isElement$6(node) && node.classList.contains('mce-drag-container');\n      const childNodesWithoutGhost = filter$5(scope.dom.childNodes, not(isDragGhostContainer));\n      return prevScope.fold(() => closestChildCaretCandidateNodeRect(childNodesWithoutGhost, clientX, clientY, true), prevScope => {\n        const uncheckedChildren = filter$5(childNodesWithoutGhost, node => node !== prevScope.dom);\n        return closestChildCaretCandidateNodeRect(uncheckedChildren, clientX, clientY, true);\n      }).orThunk(() => {\n        const parent = eq(scope, rootElm) ? Optional.none() : parentElement(scope);\n        return parent.bind(newScope => helper(newScope, Optional.some(scope)));\n      });\n    };\n    return helper(scope, Optional.none());\n  };\n  const closestCaretCandidateNodeRect = (root, clientX, clientY) => {\n    const rootElm = SugarElement.fromDom(root);\n    const ownerDoc = documentOrOwner(rootElm);\n    const elementAtPoint = SugarElement.fromPoint(ownerDoc, clientX, clientY).filter(elm => contains(rootElm, elm));\n    const element = elementAtPoint.getOr(rootElm);\n    return traverseUp(rootElm, element, clientX, clientY);\n  };\n  const closestFakeCaretCandidate = (root, clientX, clientY) => closestCaretCandidateNodeRect(root, clientX, clientY).filter(rect => isFakeCaretTarget(rect.node)).map(rect => clientInfo(rect, clientX));\n  const getAbsolutePosition = elm => {\n    var _a, _b;\n    const clientRect = elm.getBoundingClientRect();\n    const doc = elm.ownerDocument;\n    const docElem = doc.documentElement;\n    const win = doc.defaultView;\n    return {\n      top: clientRect.top + ((_a = win === null || win === void 0 ? void 0 : win.scrollY) !== null && _a !== void 0 ? _a : 0) - docElem.clientTop,\n      left: clientRect.left + ((_b = win === null || win === void 0 ? void 0 : win.scrollX) !== null && _b !== void 0 ? _b : 0) - docElem.clientLeft\n    };\n  };\n  const getBodyPosition = editor => editor.inline ? getAbsolutePosition(editor.getBody()) : {\n    left: 0,\n    top: 0\n  };\n  const getScrollPosition = editor => {\n    const body = editor.getBody();\n    return editor.inline ? {\n      left: body.scrollLeft,\n      top: body.scrollTop\n    } : {\n      left: 0,\n      top: 0\n    };\n  };\n  const getBodyScroll = editor => {\n    const body = editor.getBody(),\n      docElm = editor.getDoc().documentElement;\n    const inlineScroll = {\n      left: body.scrollLeft,\n      top: body.scrollTop\n    };\n    const iframeScroll = {\n      left: body.scrollLeft || docElm.scrollLeft,\n      top: body.scrollTop || docElm.scrollTop\n    };\n    return editor.inline ? inlineScroll : iframeScroll;\n  };\n  const getMousePosition = (editor, event) => {\n    if (event.target.ownerDocument !== editor.getDoc()) {\n      const iframePosition = getAbsolutePosition(editor.getContentAreaContainer());\n      const scrollPosition = getBodyScroll(editor);\n      return {\n        left: event.pageX - iframePosition.left + scrollPosition.left,\n        top: event.pageY - iframePosition.top + scrollPosition.top\n      };\n    }\n    return {\n      left: event.pageX,\n      top: event.pageY\n    };\n  };\n  const calculatePosition = (bodyPosition, scrollPosition, mousePosition) => ({\n    pageX: mousePosition.left - bodyPosition.left + scrollPosition.left,\n    pageY: mousePosition.top - bodyPosition.top + scrollPosition.top\n  });\n  const calc = (editor, event) => calculatePosition(getBodyPosition(editor), getScrollPosition(editor), getMousePosition(editor, event));\n  const getTargetProps = target => ({\n    target,\n    srcElement: target\n  });\n  const makeDndEventFromMouseEvent = (type, mouseEvent, target, dataTransfer) => ({\n    ...mouseEvent,\n    dataTransfer,\n    type,\n    ...getTargetProps(target)\n  });\n  const makeDndEvent = (type, target, dataTransfer) => {\n    const fail = die('Function not supported on simulated event.');\n    const event = {\n      bubbles: true,\n      cancelBubble: false,\n      cancelable: true,\n      composed: false,\n      currentTarget: null,\n      defaultPrevented: false,\n      eventPhase: 0,\n      isTrusted: true,\n      returnValue: false,\n      timeStamp: 0,\n      type,\n      composedPath: fail,\n      initEvent: fail,\n      preventDefault: noop,\n      stopImmediatePropagation: noop,\n      stopPropagation: noop,\n      AT_TARGET: window.Event.AT_TARGET,\n      BUBBLING_PHASE: window.Event.BUBBLING_PHASE,\n      CAPTURING_PHASE: window.Event.CAPTURING_PHASE,\n      NONE: window.Event.NONE,\n      altKey: false,\n      button: 0,\n      buttons: 0,\n      clientX: 0,\n      clientY: 0,\n      ctrlKey: false,\n      metaKey: false,\n      movementX: 0,\n      movementY: 0,\n      offsetX: 0,\n      offsetY: 0,\n      pageX: 0,\n      pageY: 0,\n      relatedTarget: null,\n      screenX: 0,\n      screenY: 0,\n      shiftKey: false,\n      x: 0,\n      y: 0,\n      detail: 0,\n      view: null,\n      which: 0,\n      initUIEvent: fail,\n      initMouseEvent: fail,\n      getModifierState: fail,\n      dataTransfer,\n      ...getTargetProps(target)\n    };\n    return event;\n  };\n  const makeDataTransferCopyForDragEvent = (dataTransfer, eventType) => {\n    const copy = cloneDataTransfer(dataTransfer);\n    if (eventType === 'dragstart') {\n      setDragstartEvent(copy);\n      setReadWriteMode(copy);\n    } else if (eventType === 'drop') {\n      setDropEvent(copy);\n      setReadOnlyMode(copy);\n    } else {\n      setDragendEvent(copy);\n      setProtectedMode(copy);\n    }\n    return copy;\n  };\n  const makeDragEvent = (type, target, dataTransfer, mouseEvent) => {\n    const dataTransferForDispatch = makeDataTransferCopyForDragEvent(dataTransfer, type);\n    return isUndefined(mouseEvent) ? makeDndEvent(type, target, dataTransferForDispatch) : makeDndEventFromMouseEvent(type, mouseEvent, target, dataTransferForDispatch);\n  };\n  const scrollPixelsPerInterval = 32;\n  const scrollIntervalValue = 100;\n  const mouseRangeToTriggerScrollInsideEditor = 8;\n  const mouseRangeToTriggerScrollOutsideEditor = 16;\n  const isContentEditableFalse$1 = isContentEditableFalse$b;\n  const isContentEditable = or(isContentEditableFalse$1, isContentEditableTrue$3);\n  const isDraggable = (dom, rootElm, elm) => isContentEditableFalse$1(elm) && elm !== rootElm && dom.isEditable(elm.parentElement);\n  const isValidDropTarget = (editor, targetElement, dragElement) => {\n    if (isNullable(targetElement)) {\n      return false;\n    } else if (targetElement === dragElement || editor.dom.isChildOf(targetElement, dragElement)) {\n      return false;\n    } else {\n      return editor.dom.isEditable(targetElement);\n    }\n  };\n  const createGhost = (editor, elm, width, height) => {\n    const dom = editor.dom;\n    const clonedElm = elm.cloneNode(true);\n    dom.setStyles(clonedElm, {\n      width,\n      height\n    });\n    dom.setAttrib(clonedElm, 'data-mce-selected', null);\n    const ghostElm = dom.create('div', {\n      'class': 'mce-drag-container',\n      'data-mce-bogus': 'all',\n      'unselectable': 'on',\n      'contenteditable': 'false'\n    });\n    dom.setStyles(ghostElm, {\n      position: 'absolute',\n      opacity: 0.5,\n      overflow: 'hidden',\n      border: 0,\n      padding: 0,\n      margin: 0,\n      width,\n      height\n    });\n    dom.setStyles(clonedElm, {\n      margin: 0,\n      boxSizing: 'border-box'\n    });\n    ghostElm.appendChild(clonedElm);\n    return ghostElm;\n  };\n  const appendGhostToBody = (ghostElm, bodyElm) => {\n    if (ghostElm.parentNode !== bodyElm) {\n      bodyElm.appendChild(ghostElm);\n    }\n  };\n  const scrollEditor = (direction, amount) => win => () => {\n    const current = direction === 'left' ? win.scrollX : win.scrollY;\n    win.scroll({\n      [direction]: current + amount,\n      behavior: 'smooth'\n    });\n  };\n  const scrollLeft = scrollEditor('left', -scrollPixelsPerInterval);\n  const scrollRight = scrollEditor('left', scrollPixelsPerInterval);\n  const scrollUp = scrollEditor('top', -scrollPixelsPerInterval);\n  const scrollDown = scrollEditor('top', scrollPixelsPerInterval);\n  const moveGhost = (ghostElm, position, width, height, maxX, maxY, mouseY, mouseX, contentAreaContainer, win, state, mouseEventOriginatedFromWithinTheEditor) => {\n    let overflowX = 0,\n      overflowY = 0;\n    ghostElm.style.left = position.pageX + 'px';\n    ghostElm.style.top = position.pageY + 'px';\n    if (position.pageX + width > maxX) {\n      overflowX = position.pageX + width - maxX;\n    }\n    if (position.pageY + height > maxY) {\n      overflowY = position.pageY + height - maxY;\n    }\n    ghostElm.style.width = width - overflowX + 'px';\n    ghostElm.style.height = height - overflowY + 'px';\n    const clientHeight = contentAreaContainer.clientHeight;\n    const clientWidth = contentAreaContainer.clientWidth;\n    const outerMouseY = mouseY + contentAreaContainer.getBoundingClientRect().top;\n    const outerMouseX = mouseX + contentAreaContainer.getBoundingClientRect().left;\n    state.on(state => {\n      state.intervalId.clear();\n      if (state.dragging && mouseEventOriginatedFromWithinTheEditor) {\n        if (mouseY + mouseRangeToTriggerScrollInsideEditor >= clientHeight) {\n          state.intervalId.set(scrollDown(win));\n        } else if (mouseY - mouseRangeToTriggerScrollInsideEditor <= 0) {\n          state.intervalId.set(scrollUp(win));\n        } else if (mouseX + mouseRangeToTriggerScrollInsideEditor >= clientWidth) {\n          state.intervalId.set(scrollRight(win));\n        } else if (mouseX - mouseRangeToTriggerScrollInsideEditor <= 0) {\n          state.intervalId.set(scrollLeft(win));\n        } else if (outerMouseY + mouseRangeToTriggerScrollOutsideEditor >= window.innerHeight) {\n          state.intervalId.set(scrollDown(window));\n        } else if (outerMouseY - mouseRangeToTriggerScrollOutsideEditor <= 0) {\n          state.intervalId.set(scrollUp(window));\n        } else if (outerMouseX + mouseRangeToTriggerScrollOutsideEditor >= window.innerWidth) {\n          state.intervalId.set(scrollRight(window));\n        } else if (outerMouseX - mouseRangeToTriggerScrollOutsideEditor <= 0) {\n          state.intervalId.set(scrollLeft(window));\n        }\n      }\n    });\n  };\n  const removeElement = elm => {\n    if (elm && elm.parentNode) {\n      elm.parentNode.removeChild(elm);\n    }\n  };\n  const removeElementWithPadding = (dom, elm) => {\n    const parentBlock = dom.getParent(elm.parentNode, dom.isBlock);\n    removeElement(elm);\n    if (parentBlock && parentBlock !== dom.getRoot() && dom.isEmpty(parentBlock)) {\n      fillWithPaddingBr(SugarElement.fromDom(parentBlock));\n    }\n  };\n  const isLeftMouseButtonPressed = e => e.button === 0;\n  const applyRelPos = (state, position) => ({\n    pageX: position.pageX - state.relX,\n    pageY: position.pageY + 5\n  });\n  const start = (state, editor) => e => {\n    if (isLeftMouseButtonPressed(e)) {\n      const ceElm = find$2(editor.dom.getParents(e.target), isContentEditable).getOr(null);\n      if (isNonNullable(ceElm) && isDraggable(editor.dom, editor.getBody(), ceElm)) {\n        const elmPos = editor.dom.getPos(ceElm);\n        const bodyElm = editor.getBody();\n        const docElm = editor.getDoc().documentElement;\n        state.set({\n          element: ceElm,\n          dataTransfer: createDataTransfer(),\n          dragging: false,\n          screenX: e.screenX,\n          screenY: e.screenY,\n          maxX: (editor.inline ? bodyElm.scrollWidth : docElm.offsetWidth) - 2,\n          maxY: (editor.inline ? bodyElm.scrollHeight : docElm.offsetHeight) - 2,\n          relX: e.pageX - elmPos.x,\n          relY: e.pageY - elmPos.y,\n          width: ceElm.offsetWidth,\n          height: ceElm.offsetHeight,\n          ghost: createGhost(editor, ceElm, ceElm.offsetWidth, ceElm.offsetHeight),\n          intervalId: repeatable(scrollIntervalValue)\n        });\n      }\n    }\n  };\n  const placeCaretAt = (editor, clientX, clientY) => {\n    editor._selectionOverrides.hideFakeCaret();\n    closestFakeCaretCandidate(editor.getBody(), clientX, clientY).fold(() => editor.selection.placeCaretAt(clientX, clientY), caretInfo => {\n      const range = editor._selectionOverrides.showCaret(1, caretInfo.node, caretInfo.position === FakeCaretPosition.Before, false);\n      if (range) {\n        editor.selection.setRng(range);\n      } else {\n        editor.selection.placeCaretAt(clientX, clientY);\n      }\n    });\n  };\n  const dispatchDragEvent = (editor, type, target, dataTransfer, mouseEvent) => {\n    if (type === 'dragstart') {\n      setHtmlData(dataTransfer, editor.dom.getOuterHTML(target));\n    }\n    const event = makeDragEvent(type, target, dataTransfer, mouseEvent);\n    const args = editor.dispatch(type, event);\n    return args;\n  };\n  const move = (state, editor) => {\n    const throttledPlaceCaretAt = first$1((clientX, clientY) => placeCaretAt(editor, clientX, clientY), 0);\n    editor.on('remove', throttledPlaceCaretAt.cancel);\n    const state_ = state;\n    return e => state.on(state => {\n      const movement = Math.max(Math.abs(e.screenX - state.screenX), Math.abs(e.screenY - state.screenY));\n      if (!state.dragging && movement > 10) {\n        const args = dispatchDragEvent(editor, 'dragstart', state.element, state.dataTransfer, e);\n        if (isNonNullable(args.dataTransfer)) {\n          state.dataTransfer = args.dataTransfer;\n        }\n        if (args.isDefaultPrevented()) {\n          return;\n        }\n        state.dragging = true;\n        editor.focus();\n      }\n      if (state.dragging) {\n        const mouseEventOriginatedFromWithinTheEditor = e.currentTarget === editor.getDoc().documentElement;\n        const targetPos = applyRelPos(state, calc(editor, e));\n        appendGhostToBody(state.ghost, editor.getBody());\n        moveGhost(state.ghost, targetPos, state.width, state.height, state.maxX, state.maxY, e.clientY, e.clientX, editor.getContentAreaContainer(), editor.getWin(), state_, mouseEventOriginatedFromWithinTheEditor);\n        throttledPlaceCaretAt.throttle(e.clientX, e.clientY);\n      }\n    });\n  };\n  const getRawTarget = selection => {\n    const sel = selection.getSel();\n    if (isNonNullable(sel)) {\n      const rng = sel.getRangeAt(0);\n      const startContainer = rng.startContainer;\n      return isText$b(startContainer) ? startContainer.parentNode : startContainer;\n    } else {\n      return null;\n    }\n  };\n  const drop = (state, editor) => e => {\n    state.on(state => {\n      var _a;\n      state.intervalId.clear();\n      if (state.dragging) {\n        if (isValidDropTarget(editor, getRawTarget(editor.selection), state.element)) {\n          const dropTarget = (_a = editor.getDoc().elementFromPoint(e.clientX, e.clientY)) !== null && _a !== void 0 ? _a : editor.getBody();\n          const args = dispatchDragEvent(editor, 'drop', dropTarget, state.dataTransfer, e);\n          if (!args.isDefaultPrevented()) {\n            editor.undoManager.transact(() => {\n              removeElementWithPadding(editor.dom, state.element);\n              getHtmlData(state.dataTransfer).each(content => editor.insertContent(content));\n              editor._selectionOverrides.hideFakeCaret();\n            });\n          }\n        }\n        dispatchDragEvent(editor, 'dragend', editor.getBody(), state.dataTransfer, e);\n      }\n    });\n    removeDragState(state);\n  };\n  const stopDragging = (state, editor, e) => {\n    state.on(state => {\n      state.intervalId.clear();\n      if (state.dragging) {\n        e.fold(() => dispatchDragEvent(editor, 'dragend', state.element, state.dataTransfer), mouseEvent => dispatchDragEvent(editor, 'dragend', state.element, state.dataTransfer, mouseEvent));\n      }\n    });\n    removeDragState(state);\n  };\n  const stop = (state, editor) => e => stopDragging(state, editor, Optional.some(e));\n  const removeDragState = state => {\n    state.on(state => {\n      state.intervalId.clear();\n      removeElement(state.ghost);\n    });\n    state.clear();\n  };\n  const bindFakeDragEvents = editor => {\n    const state = value$2();\n    const pageDom = DOMUtils.DOM;\n    const rootDocument = document;\n    const dragStartHandler = start(state, editor);\n    const dragHandler = move(state, editor);\n    const dropHandler = drop(state, editor);\n    const dragEndHandler = stop(state, editor);\n    editor.on('mousedown', dragStartHandler);\n    editor.on('mousemove', dragHandler);\n    editor.on('mouseup', dropHandler);\n    pageDom.bind(rootDocument, 'mousemove', dragHandler);\n    pageDom.bind(rootDocument, 'mouseup', dragEndHandler);\n    editor.on('remove', () => {\n      pageDom.unbind(rootDocument, 'mousemove', dragHandler);\n      pageDom.unbind(rootDocument, 'mouseup', dragEndHandler);\n    });\n    editor.on('keydown', e => {\n      if (e.keyCode === VK.ESC) {\n        stopDragging(state, editor, Optional.none());\n      }\n    });\n  };\n  const blockUnsupportedFileDrop = editor => {\n    const preventFileDrop = e => {\n      if (!e.isDefaultPrevented()) {\n        const dataTransfer = e.dataTransfer;\n        if (dataTransfer && (contains$2(dataTransfer.types, 'Files') || dataTransfer.files.length > 0)) {\n          e.preventDefault();\n          if (e.type === 'drop') {\n            displayError(editor, 'Dropped file type is not supported');\n          }\n        }\n      }\n    };\n    const preventFileDropIfUIElement = e => {\n      if (isUIElement(editor, e.target)) {\n        preventFileDrop(e);\n      }\n    };\n    const setup = () => {\n      const pageDom = DOMUtils.DOM;\n      const dom = editor.dom;\n      const doc = document;\n      const editorRoot = editor.inline ? editor.getBody() : editor.getDoc();\n      const eventNames = ['drop', 'dragover'];\n      each$e(eventNames, name => {\n        pageDom.bind(doc, name, preventFileDropIfUIElement);\n        dom.bind(editorRoot, name, preventFileDrop);\n      });\n      editor.on('remove', () => {\n        each$e(eventNames, name => {\n          pageDom.unbind(doc, name, preventFileDropIfUIElement);\n          dom.unbind(editorRoot, name, preventFileDrop);\n        });\n      });\n    };\n    editor.on('init', () => {\n      Delay.setEditorTimeout(editor, setup, 0);\n    });\n  };\n  const init$2 = editor => {\n    bindFakeDragEvents(editor);\n    if (shouldBlockUnsupportedDrop(editor)) {\n      blockUnsupportedFileDrop(editor);\n    }\n  };\n  const setup$4 = editor => {\n    const renderFocusCaret = first$1(() => {\n      if (!editor.removed && editor.getBody().contains(document.activeElement)) {\n        const rng = editor.selection.getRng();\n        if (rng.collapsed) {\n          const caretRange = renderRangeCaret(editor, rng, false);\n          editor.selection.setRng(caretRange);\n        }\n      }\n    }, 0);\n    editor.on('focus', () => {\n      renderFocusCaret.throttle();\n    });\n    editor.on('blur', () => {\n      renderFocusCaret.cancel();\n    });\n  };\n  const setup$3 = editor => {\n    editor.on('init', () => {\n      editor.on('focusin', e => {\n        const target = e.target;\n        if (isMedia$2(target)) {\n          const ceRoot = getContentEditableRoot$1(editor.getBody(), target);\n          const node = isContentEditableFalse$b(ceRoot) ? ceRoot : target;\n          if (editor.selection.getNode() !== node) {\n            selectNode(editor, node).each(rng => editor.selection.setRng(rng));\n          }\n        }\n      });\n    });\n  };\n  const isContentEditableFalse = isContentEditableFalse$b;\n  const getContentEditableRoot = (editor, node) => getContentEditableRoot$1(editor.getBody(), node);\n  const SelectionOverrides = editor => {\n    const selection = editor.selection,\n      dom = editor.dom;\n    const rootNode = editor.getBody();\n    const fakeCaret = FakeCaret(editor, rootNode, dom.isBlock, () => hasFocus(editor));\n    const realSelectionId = 'sel-' + dom.uniqueId();\n    const elementSelectionAttr = 'data-mce-selected';\n    let selectedElement;\n    const isFakeSelectionElement = node => isNonNullable(node) && dom.hasClass(node, 'mce-offscreen-selection');\n    const isFakeSelectionTargetElement = node => node !== rootNode && (isContentEditableFalse(node) || isMedia$2(node)) && dom.isChildOf(node, rootNode) && dom.isEditable(node.parentNode);\n    const setRange = range => {\n      if (range) {\n        selection.setRng(range);\n      }\n    };\n    const showCaret = (direction, node, before, scrollIntoView = true) => {\n      const e = editor.dispatch('ShowCaret', {\n        target: node,\n        direction,\n        before\n      });\n      if (e.isDefaultPrevented()) {\n        return null;\n      }\n      if (scrollIntoView) {\n        selection.scrollIntoView(node, direction === -1);\n      }\n      return fakeCaret.show(before, node);\n    };\n    const showBlockCaretContainer = blockCaretContainer => {\n      if (blockCaretContainer.hasAttribute('data-mce-caret')) {\n        showCaretContainerBlock(blockCaretContainer);\n        selection.scrollIntoView(blockCaretContainer);\n      }\n    };\n    const registerEvents = () => {\n      editor.on('click', e => {\n        if (!dom.isEditable(e.target)) {\n          e.preventDefault();\n          editor.focus();\n        }\n      });\n      editor.on('blur NewBlock', removeElementSelection);\n      editor.on('ResizeWindow FullscreenStateChanged', fakeCaret.reposition);\n      editor.on('tap', e => {\n        const targetElm = e.target;\n        const contentEditableRoot = getContentEditableRoot(editor, targetElm);\n        if (isContentEditableFalse(contentEditableRoot)) {\n          e.preventDefault();\n          selectNode(editor, contentEditableRoot).each(setElementSelection);\n        } else if (isFakeSelectionTargetElement(targetElm)) {\n          selectNode(editor, targetElm).each(setElementSelection);\n        }\n      }, true);\n      editor.on('mousedown', e => {\n        const targetElm = e.target;\n        if (targetElm !== rootNode && targetElm.nodeName !== 'HTML' && !dom.isChildOf(targetElm, rootNode)) {\n          return;\n        }\n        if (!isXYInContentArea(editor, e.clientX, e.clientY)) {\n          return;\n        }\n        removeElementSelection();\n        hideFakeCaret();\n        const closestContentEditable = getContentEditableRoot(editor, targetElm);\n        if (isContentEditableFalse(closestContentEditable)) {\n          e.preventDefault();\n          selectNode(editor, closestContentEditable).each(setElementSelection);\n        } else {\n          closestFakeCaretCandidate(rootNode, e.clientX, e.clientY).each(caretInfo => {\n            e.preventDefault();\n            const range = showCaret(1, caretInfo.node, caretInfo.position === FakeCaretPosition.Before, false);\n            setRange(range);\n            if (isHTMLElement(closestContentEditable)) {\n              closestContentEditable.focus();\n            } else {\n              editor.getBody().focus();\n            }\n          });\n        }\n      });\n      editor.on('keypress', e => {\n        if (VK.modifierPressed(e)) {\n          return;\n        }\n        if (isContentEditableFalse(selection.getNode())) {\n          e.preventDefault();\n        }\n      });\n      editor.on('GetSelectionRange', e => {\n        let rng = e.range;\n        if (selectedElement) {\n          if (!selectedElement.parentNode) {\n            selectedElement = null;\n            return;\n          }\n          rng = rng.cloneRange();\n          rng.selectNode(selectedElement);\n          e.range = rng;\n        }\n      });\n      editor.on('SetSelectionRange', e => {\n        e.range = normalizeVoidElementSelection(e.range);\n        const rng = setElementSelection(e.range, e.forward);\n        if (rng) {\n          e.range = rng;\n        }\n      });\n      const isPasteBin = node => isElement$6(node) && node.id === 'mcepastebin';\n      editor.on('AfterSetSelectionRange', e => {\n        const rng = e.range;\n        const parent = rng.startContainer.parentElement;\n        if (!isRangeInCaretContainer(rng) && !isPasteBin(parent)) {\n          hideFakeCaret();\n        }\n        if (!isFakeSelectionElement(parent)) {\n          removeElementSelection();\n        }\n      });\n      init$2(editor);\n      setup$4(editor);\n      setup$3(editor);\n    };\n    const isWithinCaretContainer = node => isCaretContainer$2(node) || startsWithCaretContainer$1(node) || endsWithCaretContainer$1(node);\n    const isRangeInCaretContainer = rng => isWithinCaretContainer(rng.startContainer) || isWithinCaretContainer(rng.endContainer);\n    const normalizeVoidElementSelection = rng => {\n      const voidElements = editor.schema.getVoidElements();\n      const newRng = dom.createRng();\n      const startContainer = rng.startContainer;\n      const startOffset = rng.startOffset;\n      const endContainer = rng.endContainer;\n      const endOffset = rng.endOffset;\n      if (has$2(voidElements, startContainer.nodeName.toLowerCase())) {\n        if (startOffset === 0) {\n          newRng.setStartBefore(startContainer);\n        } else {\n          newRng.setStartAfter(startContainer);\n        }\n      } else {\n        newRng.setStart(startContainer, startOffset);\n      }\n      if (has$2(voidElements, endContainer.nodeName.toLowerCase())) {\n        if (endOffset === 0) {\n          newRng.setEndBefore(endContainer);\n        } else {\n          newRng.setEndAfter(endContainer);\n        }\n      } else {\n        newRng.setEnd(endContainer, endOffset);\n      }\n      return newRng;\n    };\n    const setupOffscreenSelection = (node, targetClone) => {\n      const body = SugarElement.fromDom(editor.getBody());\n      const doc = editor.getDoc();\n      const realSelectionContainer = descendant$1(body, '#' + realSelectionId).getOrThunk(() => {\n        const newContainer = SugarElement.fromHtml('<div data-mce-bogus=\"all\" class=\"mce-offscreen-selection\"></div>', doc);\n        set$3(newContainer, 'id', realSelectionId);\n        append$1(body, newContainer);\n        return newContainer;\n      });\n      const newRange = dom.createRng();\n      empty(realSelectionContainer);\n      append(realSelectionContainer, [SugarElement.fromText(nbsp, doc), SugarElement.fromDom(targetClone), SugarElement.fromText(nbsp, doc)]);\n      newRange.setStart(realSelectionContainer.dom.firstChild, 1);\n      newRange.setEnd(realSelectionContainer.dom.lastChild, 0);\n      setAll(realSelectionContainer, {\n        top: dom.getPos(node, editor.getBody()).y + 'px'\n      });\n      focus$1(realSelectionContainer);\n      const sel = selection.getSel();\n      if (sel) {\n        sel.removeAllRanges();\n        sel.addRange(newRange);\n      }\n      return newRange;\n    };\n    const selectElement = elm => {\n      const targetClone = elm.cloneNode(true);\n      const e = editor.dispatch('ObjectSelected', {\n        target: elm,\n        targetClone\n      });\n      if (e.isDefaultPrevented()) {\n        return null;\n      }\n      const range = setupOffscreenSelection(elm, e.targetClone);\n      const nodeElm = SugarElement.fromDom(elm);\n      each$e(descendants(SugarElement.fromDom(editor.getBody()), `*[${elementSelectionAttr}]`), elm => {\n        if (!eq(nodeElm, elm)) {\n          remove$9(elm, elementSelectionAttr);\n        }\n      });\n      if (!dom.getAttrib(elm, elementSelectionAttr)) {\n        elm.setAttribute(elementSelectionAttr, '1');\n      }\n      selectedElement = elm;\n      hideFakeCaret();\n      return range;\n    };\n    const setElementSelection = (range, forward) => {\n      if (!range) {\n        return null;\n      }\n      if (range.collapsed) {\n        if (!isRangeInCaretContainer(range)) {\n          const dir = forward ? 1 : -1;\n          const caretPosition = getNormalizedRangeEndPoint(dir, rootNode, range);\n          const beforeNode = caretPosition.getNode(!forward);\n          if (isNonNullable(beforeNode)) {\n            if (isFakeCaretTarget(beforeNode)) {\n              return showCaret(dir, beforeNode, forward ? !caretPosition.isAtEnd() : false, false);\n            }\n            if (isCaretContainerInline(beforeNode) && isContentEditableFalse$b(beforeNode.nextSibling)) {\n              const rng = dom.createRng();\n              rng.setStart(beforeNode, 0);\n              rng.setEnd(beforeNode, 0);\n              return rng;\n            }\n          }\n          const afterNode = caretPosition.getNode(forward);\n          if (isNonNullable(afterNode)) {\n            if (isFakeCaretTarget(afterNode)) {\n              return showCaret(dir, afterNode, forward ? false : !caretPosition.isAtEnd(), false);\n            }\n            if (isCaretContainerInline(afterNode) && isContentEditableFalse$b(afterNode.previousSibling)) {\n              const rng = dom.createRng();\n              rng.setStart(afterNode, 1);\n              rng.setEnd(afterNode, 1);\n              return rng;\n            }\n          }\n        }\n        return null;\n      }\n      let startContainer = range.startContainer;\n      let startOffset = range.startOffset;\n      const endOffset = range.endOffset;\n      if (isText$b(startContainer) && startOffset === 0 && isContentEditableFalse(startContainer.parentNode)) {\n        startContainer = startContainer.parentNode;\n        startOffset = dom.nodeIndex(startContainer);\n        startContainer = startContainer.parentNode;\n      }\n      if (!isElement$6(startContainer)) {\n        return null;\n      }\n      if (endOffset === startOffset + 1 && startContainer === range.endContainer) {\n        const node = startContainer.childNodes[startOffset];\n        if (isFakeSelectionTargetElement(node)) {\n          return selectElement(node);\n        }\n      }\n      return null;\n    };\n    const removeElementSelection = () => {\n      if (selectedElement) {\n        selectedElement.removeAttribute(elementSelectionAttr);\n      }\n      descendant$1(SugarElement.fromDom(editor.getBody()), '#' + realSelectionId).each(remove$4);\n      selectedElement = null;\n    };\n    const destroy = () => {\n      fakeCaret.destroy();\n      selectedElement = null;\n    };\n    const hideFakeCaret = () => {\n      fakeCaret.hide();\n    };\n    if (!isRtc(editor)) {\n      registerEvents();\n    }\n    return {\n      showCaret,\n      showBlockCaretContainer,\n      hideFakeCaret,\n      destroy\n    };\n  };\n  const getNormalizedTextOffset = (container, offset) => {\n    let normalizedOffset = offset;\n    for (let node = container.previousSibling; isText$b(node); node = node.previousSibling) {\n      normalizedOffset += node.data.length;\n    }\n    return normalizedOffset;\n  };\n  const generatePath = (dom, root, node, offset, normalized) => {\n    if (isText$b(node) && (offset < 0 || offset > node.data.length)) {\n      return [];\n    }\n    const p = normalized && isText$b(node) ? [getNormalizedTextOffset(node, offset)] : [offset];\n    let current = node;\n    while (current !== root && current.parentNode) {\n      p.push(dom.nodeIndex(current, normalized));\n      current = current.parentNode;\n    }\n    return current === root ? p.reverse() : [];\n  };\n  const generatePathRange = (dom, root, startNode, startOffset, endNode, endOffset, normalized = false) => {\n    const start = generatePath(dom, root, startNode, startOffset, normalized);\n    const end = generatePath(dom, root, endNode, endOffset, normalized);\n    return {\n      start,\n      end\n    };\n  };\n  const resolvePath = (root, path) => {\n    const nodePath = path.slice();\n    const offset = nodePath.pop();\n    if (!isNumber(offset)) {\n      return Optional.none();\n    } else {\n      const resolvedNode = foldl(nodePath, (optNode, index) => optNode.bind(node => Optional.from(node.childNodes[index])), Optional.some(root));\n      return resolvedNode.bind(node => {\n        if (isText$b(node) && (offset < 0 || offset > node.data.length)) {\n          return Optional.none();\n        } else {\n          return Optional.some({\n            node,\n            offset\n          });\n        }\n      });\n    }\n  };\n  const resolvePathRange = (root, range) => resolvePath(root, range.start).bind(({\n    node: startNode,\n    offset: startOffset\n  }) => resolvePath(root, range.end).map(({\n    node: endNode,\n    offset: endOffset\n  }) => {\n    const rng = document.createRange();\n    rng.setStart(startNode, startOffset);\n    rng.setEnd(endNode, endOffset);\n    return rng;\n  }));\n  const generatePathRangeFromRange = (dom, root, range, normalized = false) => generatePathRange(dom, root, range.startContainer, range.startOffset, range.endContainer, range.endOffset, normalized);\n  const cleanEmptyNodes = (dom, node, isRoot) => {\n    if (node && dom.isEmpty(node) && !isRoot(node)) {\n      const parent = node.parentNode;\n      dom.remove(node, isText$b(node.firstChild) && isWhitespaceText(node.firstChild.data));\n      cleanEmptyNodes(dom, parent, isRoot);\n    }\n  };\n  const deleteRng = (dom, rng, isRoot, clean = true) => {\n    const startParent = rng.startContainer.parentNode;\n    const endParent = rng.endContainer.parentNode;\n    rng.deleteContents();\n    if (clean && !isRoot(rng.startContainer)) {\n      if (isText$b(rng.startContainer) && rng.startContainer.data.length === 0) {\n        dom.remove(rng.startContainer);\n      }\n      if (isText$b(rng.endContainer) && rng.endContainer.data.length === 0) {\n        dom.remove(rng.endContainer);\n      }\n      cleanEmptyNodes(dom, startParent, isRoot);\n      if (startParent !== endParent) {\n        cleanEmptyNodes(dom, endParent, isRoot);\n      }\n    }\n  };\n  const getParentBlock = (editor, rng) => Optional.from(editor.dom.getParent(rng.startContainer, editor.dom.isBlock));\n  const resolveFromDynamicPatterns = (patternSet, block, beforeText) => {\n    const dynamicPatterns = patternSet.dynamicPatternsLookup({\n      text: beforeText,\n      block\n    });\n    return {\n      ...patternSet,\n      blockPatterns: getBlockPatterns(dynamicPatterns).concat(patternSet.blockPatterns),\n      inlinePatterns: getInlinePatterns(dynamicPatterns).concat(patternSet.inlinePatterns)\n    };\n  };\n  const getBeforeText = (dom, block, node, offset) => {\n    const rng = dom.createRng();\n    rng.setStart(block, 0);\n    rng.setEnd(node, offset);\n    return rng.toString();\n  };\n  const newMarker = (dom, id) => dom.create('span', {\n    'data-mce-type': 'bookmark',\n    id\n  });\n  const rangeFromMarker = (dom, marker) => {\n    const rng = dom.createRng();\n    rng.setStartAfter(marker.start);\n    rng.setEndBefore(marker.end);\n    return rng;\n  };\n  const createMarker = (dom, markerPrefix, pathRange) => {\n    const rng = resolvePathRange(dom.getRoot(), pathRange).getOrDie('Unable to resolve path range');\n    const startNode = rng.startContainer;\n    const endNode = rng.endContainer;\n    const textEnd = rng.endOffset === 0 ? endNode : endNode.splitText(rng.endOffset);\n    const textStart = rng.startOffset === 0 ? startNode : startNode.splitText(rng.startOffset);\n    const startParentNode = textStart.parentNode;\n    const endParentNode = textEnd.parentNode;\n    return {\n      prefix: markerPrefix,\n      end: endParentNode.insertBefore(newMarker(dom, markerPrefix + '-end'), textEnd),\n      start: startParentNode.insertBefore(newMarker(dom, markerPrefix + '-start'), textStart)\n    };\n  };\n  const removeMarker = (dom, marker, isRoot) => {\n    cleanEmptyNodes(dom, dom.get(marker.prefix + '-end'), isRoot);\n    cleanEmptyNodes(dom, dom.get(marker.prefix + '-start'), isRoot);\n  };\n  const isReplacementPattern = pattern => pattern.start.length === 0;\n  const matchesPattern = patternContent => (element, offset) => {\n    const text = element.data;\n    const searchText = text.substring(0, offset);\n    const startEndIndex = searchText.lastIndexOf(patternContent.charAt(patternContent.length - 1));\n    const startIndex = searchText.lastIndexOf(patternContent);\n    if (startIndex !== -1) {\n      return startIndex + patternContent.length;\n    } else if (startEndIndex !== -1) {\n      return startEndIndex + 1;\n    } else {\n      return -1;\n    }\n  };\n  const findPatternStartFromSpot = (dom, pattern, block, spot) => {\n    const startPattern = pattern.start;\n    const startSpot = repeatLeft(dom, spot.container, spot.offset, matchesPattern(startPattern), block);\n    return startSpot.bind(spot => {\n      var _a, _b;\n      const startPatternIndex = (_b = (_a = block.textContent) === null || _a === void 0 ? void 0 : _a.indexOf(startPattern)) !== null && _b !== void 0 ? _b : -1;\n      const isCompleteMatch = startPatternIndex !== -1 && spot.offset >= startPatternIndex + startPattern.length;\n      if (isCompleteMatch) {\n        const rng = dom.createRng();\n        rng.setStart(spot.container, spot.offset - startPattern.length);\n        rng.setEnd(spot.container, spot.offset);\n        return Optional.some(rng);\n      } else {\n        const offset = spot.offset - startPattern.length;\n        return scanLeft(spot.container, offset, block).map(nextSpot => {\n          const rng = dom.createRng();\n          rng.setStart(nextSpot.container, nextSpot.offset);\n          rng.setEnd(spot.container, spot.offset);\n          return rng;\n        }).filter(rng => rng.toString() === startPattern).orThunk(() => findPatternStartFromSpot(dom, pattern, block, point(spot.container, 0)));\n      }\n    });\n  };\n  const findPatternStart = (dom, pattern, node, offset, block, requireGap = false) => {\n    if (pattern.start.length === 0 && !requireGap) {\n      const rng = dom.createRng();\n      rng.setStart(node, offset);\n      rng.setEnd(node, offset);\n      return Optional.some(rng);\n    }\n    return textBefore(node, offset, block).bind(spot => {\n      const start = findPatternStartFromSpot(dom, pattern, block, spot);\n      return start.bind(startRange => {\n        var _a;\n        if (requireGap) {\n          if (startRange.endContainer === spot.container && startRange.endOffset === spot.offset) {\n            return Optional.none();\n          } else if (spot.offset === 0 && ((_a = startRange.endContainer.textContent) === null || _a === void 0 ? void 0 : _a.length) === startRange.endOffset) {\n            return Optional.none();\n          }\n        }\n        return Optional.some(startRange);\n      });\n    });\n  };\n  const findPattern$3 = (editor, block, details, normalizedMatches) => {\n    const dom = editor.dom;\n    const root = dom.getRoot();\n    const pattern = details.pattern;\n    const endNode = details.position.container;\n    const endOffset = details.position.offset;\n    return scanLeft(endNode, endOffset - details.pattern.end.length, block).bind(spot => {\n      const endPathRng = generatePathRange(dom, root, spot.container, spot.offset, endNode, endOffset, normalizedMatches);\n      if (isReplacementPattern(pattern)) {\n        return Optional.some({\n          matches: [{\n            pattern,\n            startRng: endPathRng,\n            endRng: endPathRng\n          }],\n          position: spot\n        });\n      } else {\n        const resultsOpt = findPatternsRec(editor, details.remainingPatterns, spot.container, spot.offset, block, normalizedMatches);\n        const results = resultsOpt.getOr({\n          matches: [],\n          position: spot\n        });\n        const pos = results.position;\n        const start = findPatternStart(dom, pattern, pos.container, pos.offset, block, resultsOpt.isNone());\n        return start.map(startRng => {\n          const startPathRng = generatePathRangeFromRange(dom, root, startRng, normalizedMatches);\n          return {\n            matches: results.matches.concat([{\n              pattern,\n              startRng: startPathRng,\n              endRng: endPathRng\n            }]),\n            position: point(startRng.startContainer, startRng.startOffset)\n          };\n        });\n      }\n    });\n  };\n  const findPatternsRec = (editor, patterns, node, offset, block, normalizedMatches) => {\n    const dom = editor.dom;\n    return textBefore(node, offset, dom.getRoot()).bind(endSpot => {\n      const text = getBeforeText(dom, block, node, offset);\n      for (let i = 0; i < patterns.length; i++) {\n        const pattern = patterns[i];\n        if (!endsWith(text, pattern.end)) {\n          continue;\n        }\n        const patternsWithoutCurrent = patterns.slice();\n        patternsWithoutCurrent.splice(i, 1);\n        const result = findPattern$3(editor, block, {\n          pattern,\n          remainingPatterns: patternsWithoutCurrent,\n          position: endSpot\n        }, normalizedMatches);\n        if (result.isNone() && offset > 0) {\n          return findPatternsRec(editor, patterns, node, offset - 1, block, normalizedMatches);\n        }\n        if (result.isSome()) {\n          return result;\n        }\n      }\n      return Optional.none();\n    });\n  };\n  const applyPattern$2 = (editor, pattern, patternRange) => {\n    editor.selection.setRng(patternRange);\n    if (pattern.type === 'inline-format') {\n      each$e(pattern.format, format => {\n        editor.formatter.apply(format);\n      });\n    } else {\n      editor.execCommand(pattern.cmd, false, pattern.value);\n    }\n  };\n  const applyReplacementPattern = (editor, pattern, marker, isRoot) => {\n    const markerRange = rangeFromMarker(editor.dom, marker);\n    deleteRng(editor.dom, markerRange, isRoot);\n    applyPattern$2(editor, pattern, markerRange);\n  };\n  const applyPatternWithContent = (editor, pattern, startMarker, endMarker, isRoot) => {\n    const dom = editor.dom;\n    const markerEndRange = rangeFromMarker(dom, endMarker);\n    const markerStartRange = rangeFromMarker(dom, startMarker);\n    deleteRng(dom, markerStartRange, isRoot);\n    deleteRng(dom, markerEndRange, isRoot);\n    const patternMarker = {\n      prefix: startMarker.prefix,\n      start: startMarker.end,\n      end: endMarker.start\n    };\n    const patternRange = rangeFromMarker(dom, patternMarker);\n    applyPattern$2(editor, pattern, patternRange);\n  };\n  const addMarkers = (dom, matches) => {\n    const markerPrefix = generate$1('mce_textpattern');\n    const matchesWithEnds = foldr(matches, (acc, match) => {\n      const endMarker = createMarker(dom, markerPrefix + `_end${acc.length}`, match.endRng);\n      return acc.concat([{\n        ...match,\n        endMarker\n      }]);\n    }, []);\n    return foldr(matchesWithEnds, (acc, match) => {\n      const idx = matchesWithEnds.length - acc.length - 1;\n      const startMarker = isReplacementPattern(match.pattern) ? match.endMarker : createMarker(dom, markerPrefix + `_start${idx}`, match.startRng);\n      return acc.concat([{\n        ...match,\n        startMarker\n      }]);\n    }, []);\n  };\n  const sortPatterns$1 = patterns => sort(patterns, (a, b) => b.end.length - a.end.length);\n  const getBestMatches = (matches, matchesWithSortedPatterns) => {\n    const hasSameMatches = forall(matches, match => exists(matchesWithSortedPatterns, sortedMatch => match.pattern.start === sortedMatch.pattern.start && match.pattern.end === sortedMatch.pattern.end));\n    if (matches.length === matchesWithSortedPatterns.length) {\n      if (hasSameMatches) {\n        return matches;\n      } else {\n        return matchesWithSortedPatterns;\n      }\n    }\n    return matches.length > matchesWithSortedPatterns.length ? matches : matchesWithSortedPatterns;\n  };\n  const findPatterns$2 = (editor, block, node, offset, patternSet, normalizedMatches) => {\n    const matches = findPatternsRec(editor, patternSet.inlinePatterns, node, offset, block, normalizedMatches).fold(() => [], result => result.matches);\n    const matchesWithSortedPatterns = findPatternsRec(editor, sortPatterns$1(patternSet.inlinePatterns), node, offset, block, normalizedMatches).fold(() => [], result => result.matches);\n    return getBestMatches(matches, matchesWithSortedPatterns);\n  };\n  const applyMatches$2 = (editor, matches) => {\n    if (matches.length === 0) {\n      return;\n    }\n    const dom = editor.dom;\n    const bookmark = editor.selection.getBookmark();\n    const matchesWithMarkers = addMarkers(dom, matches);\n    each$e(matchesWithMarkers, match => {\n      const block = dom.getParent(match.startMarker.start, dom.isBlock);\n      const isRoot = node => node === block;\n      if (isReplacementPattern(match.pattern)) {\n        applyReplacementPattern(editor, match.pattern, match.endMarker, isRoot);\n      } else {\n        applyPatternWithContent(editor, match.pattern, match.startMarker, match.endMarker, isRoot);\n      }\n      removeMarker(dom, match.endMarker, isRoot);\n      removeMarker(dom, match.startMarker, isRoot);\n    });\n    editor.selection.moveToBookmark(bookmark);\n  };\n  const stripPattern$1 = (dom, block, pattern) => {\n    return textAfter(block, 0, block).map(spot => {\n      const node = spot.container;\n      scanRight(node, pattern.start.length, block).each(end => {\n        const rng = dom.createRng();\n        rng.setStart(node, 0);\n        rng.setEnd(end.container, end.offset);\n        deleteRng(dom, rng, e => e === block);\n      });\n      return node;\n    });\n  };\n  const createApplyPattern = stripPattern => (editor, match) => {\n    const dom = editor.dom;\n    const pattern = match.pattern;\n    const rng = resolvePathRange(dom.getRoot(), match.range).getOrDie('Unable to resolve path range');\n    const isBlockFormatName = (name, formatter) => {\n      const formatSet = formatter.get(name);\n      return isArray$1(formatSet) && head(formatSet).exists(format => has$2(format, 'block'));\n    };\n    getParentBlock(editor, rng).each(block => {\n      if (pattern.type === 'block-format') {\n        if (isBlockFormatName(pattern.format, editor.formatter)) {\n          editor.undoManager.transact(() => {\n            stripPattern(editor.dom, block, pattern);\n            editor.formatter.apply(pattern.format);\n          });\n        }\n      } else if (pattern.type === 'block-command') {\n        editor.undoManager.transact(() => {\n          stripPattern(editor.dom, block, pattern);\n          editor.execCommand(pattern.cmd, false, pattern.value);\n        });\n      }\n    });\n    return true;\n  };\n  const sortPatterns = patterns => sort(patterns, (a, b) => b.start.length - a.start.length);\n  const findPattern$2 = predicate => (patterns, text) => {\n    const sortedPatterns = sortPatterns(patterns);\n    const nuText = text.replace(nbsp, ' ');\n    return find$2(sortedPatterns, pattern => predicate(pattern, text, nuText));\n  };\n  const createFindPatterns = (findPattern, skipFullMatch) => (editor, block, patternSet, normalizedMatches, text) => {\n    var _a;\n    if (text === void 0) {\n      text = (_a = block.textContent) !== null && _a !== void 0 ? _a : '';\n    }\n    const dom = editor.dom;\n    const forcedRootBlock = getForcedRootBlock(editor);\n    if (!dom.is(block, forcedRootBlock)) {\n      return [];\n    }\n    return findPattern(patternSet.blockPatterns, text).map(pattern => {\n      if (skipFullMatch && Tools.trim(text).length === pattern.start.length) {\n        return [];\n      }\n      return [{\n        pattern,\n        range: generatePathRange(dom, dom.getRoot(), block, 0, block, 0, normalizedMatches)\n      }];\n    }).getOr([]);\n  };\n  const startsWithSingleSpace = s => /^\\s[^\\s]/.test(s);\n  const stripPattern = (dom, block, pattern) => {\n    stripPattern$1(dom, block, pattern).each(node => {\n      const text = SugarElement.fromDom(node);\n      const textContent = get$3(text);\n      if (startsWithSingleSpace(textContent)) {\n        set(text, textContent.slice(1));\n      }\n    });\n  };\n  const applyPattern$1 = createApplyPattern(stripPattern);\n  const findPattern$1 = findPattern$2((pattern, text, nuText) => text.indexOf(pattern.start) === 0 || nuText.indexOf(pattern.start) === 0);\n  const findPatterns$1 = createFindPatterns(findPattern$1, true);\n  const getMatches$1 = (editor, patternSet) => {\n    const rng = editor.selection.getRng();\n    return getParentBlock(editor, rng).map(block => {\n      var _a;\n      const offset = Math.max(0, rng.startOffset);\n      const dynamicPatternSet = resolveFromDynamicPatterns(patternSet, block, (_a = block.textContent) !== null && _a !== void 0 ? _a : '');\n      const inlineMatches = findPatterns$2(editor, block, rng.startContainer, offset, dynamicPatternSet, true);\n      const blockMatches = findPatterns$1(editor, block, dynamicPatternSet, true);\n      return {\n        inlineMatches,\n        blockMatches\n      };\n    }).filter(({\n      inlineMatches,\n      blockMatches\n    }) => blockMatches.length > 0 || inlineMatches.length > 0);\n  };\n  const applyMatches$1 = (editor, matches) => {\n    if (matches.length === 0) {\n      return;\n    }\n    const bookmark = editor.selection.getBookmark();\n    each$e(matches, match => applyPattern$1(editor, match));\n    editor.selection.moveToBookmark(bookmark);\n  };\n  const applyPattern = createApplyPattern(stripPattern$1);\n  const findPattern = findPattern$2((pattern, text, nuText) => text === pattern.start || nuText === pattern.start);\n  const findPatterns = createFindPatterns(findPattern, false);\n  const getMatches = (editor, patternSet) => {\n    const rng = editor.selection.getRng();\n    return getParentBlock(editor, rng).map(block => {\n      const offset = Math.max(0, rng.startOffset);\n      const beforeText = getBeforeText(editor.dom, block, rng.startContainer, offset);\n      const dynamicPatternSet = resolveFromDynamicPatterns(patternSet, block, beforeText);\n      return findPatterns(editor, block, dynamicPatternSet, false, beforeText);\n    }).filter(matches => matches.length > 0);\n  };\n  const applyMatches = (editor, matches) => {\n    each$e(matches, match => applyPattern(editor, match));\n  };\n  const handleEnter = (editor, patternSet) => getMatches$1(editor, patternSet).fold(never, ({\n    inlineMatches,\n    blockMatches\n  }) => {\n    editor.undoManager.add();\n    editor.undoManager.extra(() => {\n      editor.execCommand('mceInsertNewLine');\n    }, () => {\n      insert$5(editor);\n      applyMatches$2(editor, inlineMatches);\n      applyMatches$1(editor, blockMatches);\n      const range = editor.selection.getRng();\n      const spot = textBefore(range.startContainer, range.startOffset, editor.dom.getRoot());\n      editor.execCommand('mceInsertNewLine');\n      spot.each(s => {\n        const node = s.container;\n        if (node.data.charAt(s.offset - 1) === zeroWidth) {\n          node.deleteData(s.offset - 1, 1);\n          cleanEmptyNodes(editor.dom, node.parentNode, e => e === editor.dom.getRoot());\n        }\n      });\n    });\n    return true;\n  });\n  const handleInlineKey = (editor, patternSet) => {\n    const rng = editor.selection.getRng();\n    getParentBlock(editor, rng).map(block => {\n      const offset = Math.max(0, rng.startOffset - 1);\n      const beforeText = getBeforeText(editor.dom, block, rng.startContainer, offset);\n      const dynamicPatternSet = resolveFromDynamicPatterns(patternSet, block, beforeText);\n      const inlineMatches = findPatterns$2(editor, block, rng.startContainer, offset, dynamicPatternSet, false);\n      if (inlineMatches.length > 0) {\n        editor.undoManager.transact(() => {\n          applyMatches$2(editor, inlineMatches);\n        });\n      }\n    });\n  };\n  const handleBlockPatternOnSpace = (editor, patternSet) => getMatches(editor, patternSet).fold(never, matches => {\n    editor.undoManager.transact(() => {\n      applyMatches(editor, matches);\n    });\n    return true;\n  });\n  const checkKeyEvent = (codes, event, predicate) => {\n    for (let i = 0; i < codes.length; i++) {\n      if (predicate(codes[i], event)) {\n        return true;\n      }\n    }\n    return false;\n  };\n  const checkKeyCode = (codes, event) => checkKeyEvent(codes, event, (code, event) => {\n    return code === event.keyCode && !VK.modifierPressed(event);\n  });\n  const checkCharCode = (chars, event) => checkKeyEvent(chars, event, (chr, event) => {\n    return chr.charCodeAt(0) === event.charCode;\n  });\n  const setup$2 = editor => {\n    const charCodes = [',', '.', ';', ':', '!', '?'];\n    const keyCodes = [32];\n    const getPatternSet = () => createPatternSet(getTextPatterns(editor).filter(pattern => {\n      if (pattern.type === 'inline-command' || pattern.type === 'block-command') {\n        return editor.queryCommandSupported(pattern.cmd);\n      }\n      return true;\n    }), getTextPatternsLookup(editor));\n    const hasDynamicPatterns = () => hasTextPatternsLookup(editor);\n    editor.on('keydown', e => {\n      if (e.keyCode === 13 && !VK.modifierPressed(e) && editor.selection.isCollapsed() && editor.selection.isEditable()) {\n        const patternSet = filterByTrigger(getPatternSet(), 'enter');\n        const hasPatterns = patternSet.inlinePatterns.length > 0 || patternSet.blockPatterns.length > 0 || hasDynamicPatterns();\n        if (hasPatterns && handleEnter(editor, patternSet)) {\n          e.preventDefault();\n        }\n      }\n    }, true);\n    editor.on('keydown', e => {\n      if (e.keyCode === 32 && editor.selection.isCollapsed() && editor.selection.isEditable()) {\n        const patternSet = filterByTrigger(getPatternSet(), 'space');\n        const hasPatterns = patternSet.blockPatterns.length > 0 || hasDynamicPatterns();\n        if (hasPatterns && handleBlockPatternOnSpace(editor, patternSet)) {\n          e.preventDefault();\n        }\n      }\n    }, true);\n    const handleInlineTrigger = () => {\n      if (editor.selection.isCollapsed() && editor.selection.isEditable()) {\n        const patternSet = filterByTrigger(getPatternSet(), 'space');\n        const hasPatterns = patternSet.inlinePatterns.length > 0 || hasDynamicPatterns();\n        if (hasPatterns) {\n          handleInlineKey(editor, patternSet);\n        }\n      }\n    };\n    editor.on('keyup', e => {\n      if (checkKeyCode(keyCodes, e)) {\n        handleInlineTrigger();\n      }\n    });\n    editor.on('keypress', e => {\n      if (checkCharCode(charCodes, e)) {\n        Delay.setEditorTimeout(editor, handleInlineTrigger);\n      }\n    });\n  };\n  const setup$1 = editor => {\n    setup$2(editor);\n  };\n  const Quirks = editor => {\n    const each = Tools.each;\n    const BACKSPACE = VK.BACKSPACE,\n      DELETE = VK.DELETE,\n      dom = editor.dom,\n      selection = editor.selection,\n      parser = editor.parser;\n    const browser = Env.browser;\n    const isGecko = browser.isFirefox();\n    const isWebKit = browser.isChromium() || browser.isSafari();\n    const isiOS = Env.deviceType.isiPhone() || Env.deviceType.isiPad();\n    const isMac = Env.os.isMacOS() || Env.os.isiOS();\n    const setEditorCommandState = (cmd, state) => {\n      try {\n        editor.getDoc().execCommand(cmd, false, String(state));\n      } catch (ex) {}\n    };\n    const isDefaultPrevented = e => {\n      return e.isDefaultPrevented();\n    };\n    const emptyEditorWhenDeleting = () => {\n      const serializeRng = rng => {\n        const body = dom.create('body');\n        const contents = rng.cloneContents();\n        body.appendChild(contents);\n        return selection.serializer.serialize(body, {\n          format: 'html'\n        });\n      };\n      const allContentsSelected = rng => {\n        const selection = serializeRng(rng);\n        const allRng = dom.createRng();\n        allRng.selectNode(editor.getBody());\n        const allSelection = serializeRng(allRng);\n        return selection === allSelection;\n      };\n      editor.on('keydown', e => {\n        const keyCode = e.keyCode;\n        if (!isDefaultPrevented(e) && (keyCode === DELETE || keyCode === BACKSPACE) && editor.selection.isEditable()) {\n          const isCollapsed = editor.selection.isCollapsed();\n          const body = editor.getBody();\n          if (isCollapsed && !isEmptyNode(editor.schema, body)) {\n            return;\n          }\n          if (!isCollapsed && !allContentsSelected(editor.selection.getRng())) {\n            return;\n          }\n          e.preventDefault();\n          editor.setContent('');\n          if (body.firstChild && dom.isBlock(body.firstChild)) {\n            editor.selection.setCursorLocation(body.firstChild, 0);\n          } else {\n            editor.selection.setCursorLocation(body, 0);\n          }\n          editor.nodeChanged();\n        }\n      });\n    };\n    const selectAll = () => {\n      editor.shortcuts.add('meta+a', null, 'SelectAll');\n    };\n    const documentElementEditingFocus = () => {\n      if (!editor.inline) {\n        dom.bind(editor.getDoc(), 'mousedown mouseup', e => {\n          let rng;\n          if (e.target === editor.getDoc().documentElement) {\n            rng = selection.getRng();\n            editor.getBody().focus();\n            if (e.type === 'mousedown') {\n              if (isCaretContainer$2(rng.startContainer)) {\n                return;\n              }\n              selection.placeCaretAt(e.clientX, e.clientY);\n            } else {\n              selection.setRng(rng);\n            }\n          }\n        });\n      }\n    };\n    const removeHrOnBackspace = () => {\n      editor.on('keydown', e => {\n        if (!isDefaultPrevented(e) && e.keyCode === BACKSPACE) {\n          if (!editor.getBody().getElementsByTagName('hr').length) {\n            return;\n          }\n          if (selection.isCollapsed() && selection.getRng().startOffset === 0) {\n            const node = selection.getNode();\n            const previousSibling = node.previousSibling;\n            if (node.nodeName === 'HR') {\n              dom.remove(node);\n              e.preventDefault();\n              return;\n            }\n            if (previousSibling && previousSibling.nodeName && previousSibling.nodeName.toLowerCase() === 'hr') {\n              dom.remove(previousSibling);\n              e.preventDefault();\n            }\n          }\n        }\n      });\n    };\n    const focusBody = () => {\n      if (!Range.prototype.getClientRects) {\n        editor.on('mousedown', e => {\n          if (!isDefaultPrevented(e) && e.target.nodeName === 'HTML') {\n            const body = editor.getBody();\n            body.blur();\n            Delay.setEditorTimeout(editor, () => {\n              body.focus();\n            });\n          }\n        });\n      }\n    };\n    const selectControlElements = () => {\n      const visualAidsAnchorClass = getVisualAidsAnchorClass(editor);\n      editor.on('click', e => {\n        const target = e.target;\n        if (/^(IMG|HR)$/.test(target.nodeName) && dom.isEditable(target)) {\n          e.preventDefault();\n          editor.selection.select(target);\n          editor.nodeChanged();\n        }\n        if (target.nodeName === 'A' && dom.hasClass(target, visualAidsAnchorClass) && target.childNodes.length === 0 && dom.isEditable(target.parentNode)) {\n          e.preventDefault();\n          selection.select(target);\n        }\n      });\n    };\n    const removeStylesWhenDeletingAcrossBlockElements = () => {\n      const getAttributeApplyFunction = () => {\n        const template = dom.getAttribs(selection.getStart().cloneNode(false));\n        return () => {\n          const target = selection.getStart();\n          if (target !== editor.getBody()) {\n            dom.setAttrib(target, 'style', null);\n            each(template, attr => {\n              target.setAttributeNode(attr.cloneNode(true));\n            });\n          }\n        };\n      };\n      const isSelectionAcrossElements = () => {\n        return !selection.isCollapsed() && dom.getParent(selection.getStart(), dom.isBlock) !== dom.getParent(selection.getEnd(), dom.isBlock);\n      };\n      editor.on('keypress', e => {\n        let applyAttributes;\n        if (!isDefaultPrevented(e) && (e.keyCode === 8 || e.keyCode === 46) && isSelectionAcrossElements()) {\n          applyAttributes = getAttributeApplyFunction();\n          editor.getDoc().execCommand('delete', false);\n          applyAttributes();\n          e.preventDefault();\n          return false;\n        } else {\n          return true;\n        }\n      });\n      dom.bind(editor.getDoc(), 'cut', e => {\n        if (!isDefaultPrevented(e) && isSelectionAcrossElements()) {\n          const applyAttributes = getAttributeApplyFunction();\n          Delay.setEditorTimeout(editor, () => {\n            applyAttributes();\n          });\n        }\n      });\n    };\n    const disableBackspaceIntoATable = () => {\n      editor.on('keydown', e => {\n        if (!isDefaultPrevented(e) && e.keyCode === BACKSPACE) {\n          if (selection.isCollapsed() && selection.getRng().startOffset === 0) {\n            const previousSibling = selection.getNode().previousSibling;\n            if (previousSibling && previousSibling.nodeName && previousSibling.nodeName.toLowerCase() === 'table') {\n              e.preventDefault();\n              return false;\n            }\n          }\n        }\n        return true;\n      });\n    };\n    const removeBlockQuoteOnBackSpace = () => {\n      editor.on('keydown', e => {\n        if (isDefaultPrevented(e) || e.keyCode !== VK.BACKSPACE) {\n          return;\n        }\n        let rng = selection.getRng();\n        const container = rng.startContainer;\n        const offset = rng.startOffset;\n        const root = dom.getRoot();\n        let parent = container;\n        if (!rng.collapsed || offset !== 0) {\n          return;\n        }\n        while (parent.parentNode && parent.parentNode.firstChild === parent && parent.parentNode !== root) {\n          parent = parent.parentNode;\n        }\n        if (parent.nodeName === 'BLOCKQUOTE') {\n          editor.formatter.toggle('blockquote', undefined, parent);\n          rng = dom.createRng();\n          rng.setStart(container, 0);\n          rng.setEnd(container, 0);\n          selection.setRng(rng);\n        }\n      });\n    };\n    const setGeckoEditingOptions = () => {\n      const setOpts = () => {\n        setEditorCommandState('StyleWithCSS', false);\n        setEditorCommandState('enableInlineTableEditing', false);\n        if (!getObjectResizing(editor)) {\n          setEditorCommandState('enableObjectResizing', false);\n        }\n      };\n      if (!isReadOnly$1(editor)) {\n        editor.on('BeforeExecCommand mousedown', setOpts);\n      }\n    };\n    const addBrAfterLastLinks = () => {\n      const fixLinks = () => {\n        each(dom.select('a:not([data-mce-block])'), node => {\n          var _a;\n          let parentNode = node.parentNode;\n          const root = dom.getRoot();\n          if ((parentNode === null || parentNode === void 0 ? void 0 : parentNode.lastChild) === node) {\n            while (parentNode && !dom.isBlock(parentNode)) {\n              if (((_a = parentNode.parentNode) === null || _a === void 0 ? void 0 : _a.lastChild) !== parentNode || parentNode === root) {\n                return;\n              }\n              parentNode = parentNode.parentNode;\n            }\n            dom.add(parentNode, 'br', {\n              'data-mce-bogus': 1\n            });\n          }\n        });\n      };\n      editor.on('SetContent ExecCommand', e => {\n        if (e.type === 'setcontent' || e.command === 'mceInsertLink') {\n          fixLinks();\n        }\n      });\n    };\n    const setDefaultBlockType = () => {\n      editor.on('init', () => {\n        setEditorCommandState('DefaultParagraphSeparator', getForcedRootBlock(editor));\n      });\n    };\n    const isAllContentSelected = editor => {\n      const body = editor.getBody();\n      const rng = editor.selection.getRng();\n      return rng.startContainer === rng.endContainer && rng.startContainer === body && rng.startOffset === 0 && rng.endOffset === body.childNodes.length;\n    };\n    const normalizeSelection = () => {\n      editor.on('keyup focusin mouseup', e => {\n        if (!VK.modifierPressed(e) && !isAllContentSelected(editor)) {\n          selection.normalize();\n        }\n      }, true);\n    };\n    const showBrokenImageIcon = () => {\n      editor.contentStyles.push('img:-moz-broken {' + '-moz-force-broken-image-icon:1;' + 'min-width:24px;' + 'min-height:24px' + '}');\n    };\n    const restoreFocusOnKeyDown = () => {\n      if (!editor.inline) {\n        editor.on('keydown', () => {\n          if (document.activeElement === document.body) {\n            editor.getWin().focus();\n          }\n        });\n      }\n    };\n    const bodyHeight = () => {\n      if (!editor.inline) {\n        editor.contentStyles.push('body {min-height: 150px}');\n        editor.on('click', e => {\n          let rng;\n          if (e.target.nodeName === 'HTML') {\n            rng = editor.selection.getRng();\n            editor.getBody().focus();\n            editor.selection.setRng(rng);\n            editor.selection.normalize();\n            editor.nodeChanged();\n          }\n        });\n      }\n    };\n    const blockCmdArrowNavigation = () => {\n      if (isMac) {\n        editor.on('keydown', e => {\n          if (VK.metaKeyPressed(e) && !e.shiftKey && (e.keyCode === 37 || e.keyCode === 39)) {\n            e.preventDefault();\n            const selection = editor.selection.getSel();\n            selection.modify('move', e.keyCode === 37 ? 'backward' : 'forward', 'lineboundary');\n          }\n        });\n      }\n    };\n    const tapLinksAndImages = () => {\n      editor.on('click', e => {\n        let elm = e.target;\n        do {\n          if (elm.tagName === 'A') {\n            e.preventDefault();\n            return;\n          }\n        } while (elm = elm.parentNode);\n      });\n      editor.contentStyles.push('.mce-content-body {-webkit-touch-callout: none}');\n    };\n    const blockFormSubmitInsideEditor = () => {\n      editor.on('init', () => {\n        editor.dom.bind(editor.getBody(), 'submit', e => {\n          e.preventDefault();\n        });\n      });\n    };\n    const removeAppleInterchangeBrs = () => {\n      parser.addNodeFilter('br', nodes => {\n        let i = nodes.length;\n        while (i--) {\n          if (nodes[i].attr('class') === 'Apple-interchange-newline') {\n            nodes[i].remove();\n          }\n        }\n      });\n    };\n    const refreshContentEditable = noop;\n    const isHidden = () => {\n      if (!isGecko || editor.removed) {\n        return false;\n      }\n      const sel = editor.selection.getSel();\n      return !sel || !sel.rangeCount || sel.rangeCount === 0;\n    };\n    const setupRtc = () => {\n      if (isWebKit) {\n        documentElementEditingFocus();\n        selectControlElements();\n        blockFormSubmitInsideEditor();\n        selectAll();\n        if (isiOS) {\n          restoreFocusOnKeyDown();\n          bodyHeight();\n          tapLinksAndImages();\n        }\n      }\n      if (isGecko) {\n        focusBody();\n        setGeckoEditingOptions();\n        showBrokenImageIcon();\n        blockCmdArrowNavigation();\n      }\n    };\n    const setup = () => {\n      removeBlockQuoteOnBackSpace();\n      emptyEditorWhenDeleting();\n      if (!Env.windowsPhone) {\n        normalizeSelection();\n      }\n      if (isWebKit) {\n        documentElementEditingFocus();\n        selectControlElements();\n        setDefaultBlockType();\n        blockFormSubmitInsideEditor();\n        disableBackspaceIntoATable();\n        removeAppleInterchangeBrs();\n        if (isiOS) {\n          restoreFocusOnKeyDown();\n          bodyHeight();\n          tapLinksAndImages();\n        } else {\n          selectAll();\n        }\n      }\n      if (isGecko) {\n        removeHrOnBackspace();\n        focusBody();\n        removeStylesWhenDeletingAcrossBlockElements();\n        setGeckoEditingOptions();\n        addBrAfterLastLinks();\n        showBrokenImageIcon();\n        blockCmdArrowNavigation();\n        disableBackspaceIntoATable();\n      }\n    };\n    if (isRtc(editor)) {\n      setupRtc();\n    } else {\n      setup();\n    }\n    return {\n      refreshContentEditable,\n      isHidden\n    };\n  };\n  const isGplKey = key => key.toLowerCase() === 'gpl';\n  const isValidGeneratedKey = key => key.length >= 64 && key.length <= 255;\n  const validateLicenseKey = key => isGplKey(key) || isValidGeneratedKey(key) ? 'VALID' : 'INVALID';\n  const validateEditorLicenseKey = editor => {\n    const licenseKey = getLicenseKey(editor);\n    const hasApiKey = isString(getApiKey(editor));\n    if (!hasApiKey && (isUndefined(licenseKey) || validateLicenseKey(licenseKey) === 'INVALID')) {\n      console.warn(`TinyMCE is running in evaluation mode. Provide a valid license key or add license_key: 'gpl' to the init config to agree to the open source license terms. Read more at https://www.tiny.cloud/license-key/`);\n    }\n  };\n  const DOM$6 = DOMUtils.DOM;\n  const appendStyle = (editor, text) => {\n    const body = SugarElement.fromDom(editor.getBody());\n    const container = getStyleContainer(getRootNode(body));\n    const style = SugarElement.fromTag('style');\n    set$3(style, 'type', 'text/css');\n    append$1(style, SugarElement.fromText(text));\n    append$1(container, style);\n    editor.on('remove', () => {\n      remove$4(style);\n    });\n  };\n  const getRootName = editor => editor.inline ? editor.getElement().nodeName.toLowerCase() : undefined;\n  const removeUndefined = obj => filter$4(obj, v => isUndefined(v) === false);\n  const mkParserSettings = editor => {\n    const getOption = editor.options.get;\n    const blobCache = editor.editorUpload.blobCache;\n    return removeUndefined({\n      allow_conditional_comments: getOption('allow_conditional_comments'),\n      allow_html_data_urls: getOption('allow_html_data_urls'),\n      allow_svg_data_urls: getOption('allow_svg_data_urls'),\n      allow_html_in_named_anchor: getOption('allow_html_in_named_anchor'),\n      allow_script_urls: getOption('allow_script_urls'),\n      allow_mathml_annotation_encodings: getOption('allow_mathml_annotation_encodings'),\n      allow_unsafe_link_target: getOption('allow_unsafe_link_target'),\n      convert_unsafe_embeds: getOption('convert_unsafe_embeds'),\n      convert_fonts_to_spans: getOption('convert_fonts_to_spans'),\n      fix_list_elements: getOption('fix_list_elements'),\n      font_size_legacy_values: getOption('font_size_legacy_values'),\n      forced_root_block: getOption('forced_root_block'),\n      forced_root_block_attrs: getOption('forced_root_block_attrs'),\n      preserve_cdata: getOption('preserve_cdata'),\n      inline_styles: getOption('inline_styles'),\n      root_name: getRootName(editor),\n      sandbox_iframes: getOption('sandbox_iframes'),\n      sandbox_iframes_exclusions: getSandboxIframesExclusions(editor),\n      sanitize: getOption('xss_sanitization'),\n      validate: true,\n      blob_cache: blobCache,\n      document: editor.getDoc()\n    });\n  };\n  const mkSchemaSettings = editor => {\n    const getOption = editor.options.get;\n    return removeUndefined({\n      custom_elements: getOption('custom_elements'),\n      extended_valid_elements: getOption('extended_valid_elements'),\n      invalid_elements: getOption('invalid_elements'),\n      invalid_styles: getOption('invalid_styles'),\n      schema: getOption('schema'),\n      valid_children: getOption('valid_children'),\n      valid_classes: getOption('valid_classes'),\n      valid_elements: getOption('valid_elements'),\n      valid_styles: getOption('valid_styles'),\n      verify_html: getOption('verify_html'),\n      padd_empty_block_inline_children: getOption('format_empty_lines')\n    });\n  };\n  const mkSerializerSettings = editor => {\n    const getOption = editor.options.get;\n    return {\n      ...mkParserSettings(editor),\n      ...mkSchemaSettings(editor),\n      ...removeUndefined({\n        remove_trailing_brs: getOption('remove_trailing_brs'),\n        pad_empty_with_br: getOption('pad_empty_with_br'),\n        url_converter: getOption('url_converter'),\n        url_converter_scope: getOption('url_converter_scope'),\n        element_format: getOption('element_format'),\n        entities: getOption('entities'),\n        entity_encoding: getOption('entity_encoding'),\n        indent: getOption('indent'),\n        indent_after: getOption('indent_after'),\n        indent_before: getOption('indent_before')\n      })\n    };\n  };\n  const createParser = editor => {\n    const parser = DomParser(mkParserSettings(editor), editor.schema);\n    parser.addAttributeFilter('src,href,style,tabindex', (nodes, name) => {\n      const dom = editor.dom;\n      const internalName = 'data-mce-' + name;\n      let i = nodes.length;\n      while (i--) {\n        const node = nodes[i];\n        let value = node.attr(name);\n        if (value && !node.attr(internalName)) {\n          if (value.indexOf('data:') === 0 || value.indexOf('blob:') === 0) {\n            continue;\n          }\n          if (name === 'style') {\n            value = dom.serializeStyle(dom.parseStyle(value), node.name);\n            if (!value.length) {\n              value = null;\n            }\n            node.attr(internalName, value);\n            node.attr(name, value);\n          } else if (name === 'tabindex') {\n            node.attr(internalName, value);\n            node.attr(name, null);\n          } else {\n            node.attr(internalName, editor.convertURL(value, name, node.name));\n          }\n        }\n      }\n    });\n    parser.addNodeFilter('script', nodes => {\n      let i = nodes.length;\n      while (i--) {\n        const node = nodes[i];\n        const type = node.attr('type') || 'no/type';\n        if (type.indexOf('mce-') !== 0) {\n          node.attr('type', 'mce-' + type);\n        }\n      }\n    });\n    if (shouldPreserveCData(editor)) {\n      parser.addNodeFilter('#cdata', nodes => {\n        var _a;\n        let i = nodes.length;\n        while (i--) {\n          const node = nodes[i];\n          node.type = 8;\n          node.name = '#comment';\n          node.value = '[CDATA[' + editor.dom.encode((_a = node.value) !== null && _a !== void 0 ? _a : '') + ']]';\n        }\n      });\n    }\n    parser.addNodeFilter('p,h1,h2,h3,h4,h5,h6,div', nodes => {\n      let i = nodes.length;\n      const nonEmptyElements = editor.schema.getNonEmptyElements();\n      while (i--) {\n        const node = nodes[i];\n        if (node.isEmpty(nonEmptyElements) && node.getAll('br').length === 0) {\n          node.append(new AstNode('br', 1));\n        }\n      }\n    });\n    return parser;\n  };\n  const autoFocus = editor => {\n    const autoFocus = getAutoFocus(editor);\n    if (autoFocus) {\n      Delay.setEditorTimeout(editor, () => {\n        let focusEditor;\n        if (autoFocus === true) {\n          focusEditor = editor;\n        } else {\n          focusEditor = editor.editorManager.get(autoFocus);\n        }\n        if (focusEditor && !focusEditor.destroyed) {\n          focusEditor.focus();\n          focusEditor.selection.scrollIntoView();\n        }\n      }, 100);\n    }\n  };\n  const moveSelectionToFirstCaretPosition = editor => {\n    const root = editor.dom.getRoot();\n    if (!editor.inline && (!hasAnyRanges(editor) || editor.selection.getStart(true) === root)) {\n      firstPositionIn(root).each(pos => {\n        const node = pos.getNode();\n        const caretPos = isTable$2(node) ? firstPositionIn(node).getOr(pos) : pos;\n        editor.selection.setRng(caretPos.toRange());\n      });\n    }\n  };\n  const initEditor = editor => {\n    editor.bindPendingEventDelegates();\n    editor.initialized = true;\n    fireInit(editor);\n    editor.focus(true);\n    moveSelectionToFirstCaretPosition(editor);\n    editor.nodeChanged({\n      initial: true\n    });\n    const initInstanceCallback = getInitInstanceCallback(editor);\n    if (isFunction(initInstanceCallback)) {\n      initInstanceCallback.call(editor, editor);\n    }\n    autoFocus(editor);\n  };\n  const getStyleSheetLoader$1 = editor => editor.inline ? editor.ui.styleSheetLoader : editor.dom.styleSheetLoader;\n  const makeStylesheetLoadingPromises = (editor, css, framedFonts) => {\n    const {\n      pass: bundledCss,\n      fail: normalCss\n    } = partition$2(css, name => tinymce.Resource.has(toContentSkinResourceName(name)));\n    const bundledPromises = bundledCss.map(url => {\n      const css = tinymce.Resource.get(toContentSkinResourceName(url));\n      if (isString(css)) {\n        return Promise.resolve(getStyleSheetLoader$1(editor).loadRawCss(url, css));\n      }\n      return Promise.resolve();\n    });\n    const promises = [...bundledPromises, getStyleSheetLoader$1(editor).loadAll(normalCss)];\n    if (editor.inline) {\n      return promises;\n    } else {\n      return promises.concat([editor.ui.styleSheetLoader.loadAll(framedFonts)]);\n    }\n  };\n  const loadContentCss = editor => {\n    const styleSheetLoader = getStyleSheetLoader$1(editor);\n    const fontCss = getFontCss(editor);\n    const css = editor.contentCSS;\n    const removeCss = () => {\n      styleSheetLoader.unloadAll(css);\n      if (!editor.inline) {\n        editor.ui.styleSheetLoader.unloadAll(fontCss);\n      }\n    };\n    const loaded = () => {\n      if (editor.removed) {\n        removeCss();\n      } else {\n        editor.on('remove', removeCss);\n      }\n    };\n    if (editor.contentStyles.length > 0) {\n      let contentCssText = '';\n      Tools.each(editor.contentStyles, style => {\n        contentCssText += style + '\\r\\n';\n      });\n      editor.dom.addStyle(contentCssText);\n    }\n    const allStylesheets = Promise.all(makeStylesheetLoadingPromises(editor, css, fontCss)).then(loaded).catch(loaded);\n    const contentStyle = getContentStyle(editor);\n    if (contentStyle) {\n      appendStyle(editor, contentStyle);\n    }\n    return allStylesheets;\n  };\n  const preInit = editor => {\n    const doc = editor.getDoc(),\n      body = editor.getBody();\n    firePreInit(editor);\n    if (!shouldBrowserSpellcheck(editor)) {\n      doc.body.spellcheck = false;\n      DOM$6.setAttrib(body, 'spellcheck', 'false');\n    }\n    editor.quirks = Quirks(editor);\n    firePostRender(editor);\n    const directionality = getDirectionality(editor);\n    if (directionality !== undefined) {\n      body.dir = directionality;\n    }\n    const protect = getProtect(editor);\n    if (protect) {\n      editor.on('BeforeSetContent', e => {\n        Tools.each(protect, pattern => {\n          e.content = e.content.replace(pattern, str => {\n            return '<!--mce:protected ' + escape(str) + '-->';\n          });\n        });\n      });\n    }\n    editor.on('SetContent', () => {\n      editor.addVisual(editor.getBody());\n    });\n    editor.on('compositionstart compositionend', e => {\n      editor.composing = e.type === 'compositionstart';\n    });\n  };\n  const loadInitialContent = editor => {\n    if (!isRtc(editor)) {\n      editor.load({\n        initial: true,\n        format: 'html'\n      });\n    }\n    editor.startContent = editor.getContent({\n      format: 'raw'\n    });\n  };\n  const initEditorWithInitialContent = editor => {\n    if (editor.removed !== true) {\n      loadInitialContent(editor);\n      initEditor(editor);\n    }\n  };\n  const startProgress = editor => {\n    let canceled = false;\n    const progressTimeout = setTimeout(() => {\n      if (!canceled) {\n        editor.setProgressState(true);\n      }\n    }, 500);\n    return () => {\n      clearTimeout(progressTimeout);\n      canceled = true;\n      editor.setProgressState(false);\n    };\n  };\n  const contentBodyLoaded = editor => {\n    const targetElm = editor.getElement();\n    let doc = editor.getDoc();\n    if (editor.inline) {\n      DOM$6.addClass(targetElm, 'mce-content-body');\n      editor.contentDocument = doc = document;\n      editor.contentWindow = window;\n      editor.bodyElement = targetElm;\n      editor.contentAreaContainer = targetElm;\n    }\n    const body = editor.getBody();\n    body.disabled = true;\n    editor.readonly = isReadOnly$1(editor);\n    editor._editableRoot = hasEditableRoot$1(editor);\n    if (editor.hasEditableRoot()) {\n      if (editor.inline && DOM$6.getStyle(body, 'position', true) === 'static') {\n        body.style.position = 'relative';\n      }\n      body.contentEditable = 'true';\n    }\n    body.disabled = false;\n    editor.editorUpload = EditorUpload(editor);\n    editor.schema = Schema(mkSchemaSettings(editor));\n    editor.dom = DOMUtils(doc, {\n      keep_values: true,\n      url_converter: editor.convertURL,\n      url_converter_scope: editor,\n      update_styles: true,\n      root_element: editor.inline ? editor.getBody() : null,\n      collect: editor.inline,\n      schema: editor.schema,\n      contentCssCors: shouldUseContentCssCors(editor),\n      referrerPolicy: getReferrerPolicy(editor),\n      onSetAttrib: e => {\n        editor.dispatch('SetAttrib', e);\n      }\n    });\n    editor.parser = createParser(editor);\n    editor.serializer = DomSerializer(mkSerializerSettings(editor), editor);\n    editor.selection = EditorSelection(editor.dom, editor.getWin(), editor.serializer, editor);\n    editor.annotator = Annotator(editor);\n    editor.formatter = Formatter(editor);\n    editor.undoManager = UndoManager(editor);\n    editor._nodeChangeDispatcher = new NodeChange(editor);\n    editor._selectionOverrides = SelectionOverrides(editor);\n    setup$p(editor);\n    setup$6(editor);\n    setup$n(editor);\n    if (!isRtc(editor)) {\n      setup$5(editor);\n      setup$1(editor);\n    }\n    const caret = setup$b(editor);\n    setup$q(editor, caret);\n    setup$o(editor);\n    setup$r(editor);\n    setup$7(editor);\n    const setupRtcThunk = setup$t(editor);\n    preInit(editor);\n    validateEditorLicenseKey(editor);\n    setupRtcThunk.fold(() => {\n      const cancelProgress = startProgress(editor);\n      loadContentCss(editor).then(() => {\n        initEditorWithInitialContent(editor);\n        cancelProgress();\n      });\n    }, setupRtc => {\n      editor.setProgressState(true);\n      loadContentCss(editor).then(() => {\n        setupRtc().then(_rtcMode => {\n          editor.setProgressState(false);\n          initEditorWithInitialContent(editor);\n          bindEvents(editor);\n        }, err => {\n          editor.notificationManager.open({\n            type: 'error',\n            text: String(err)\n          });\n          initEditorWithInitialContent(editor);\n          bindEvents(editor);\n        });\n      });\n    });\n  };\n  const filter = always;\n  const bind = (element, event, handler) => bind$2(element, event, filter, handler);\n  const DOM$5 = DOMUtils.DOM;\n  const createIframeElement = (id, title, customAttrs, tabindex) => {\n    const iframe = SugarElement.fromTag('iframe');\n    tabindex.each(t => set$3(iframe, 'tabindex', t));\n    setAll$1(iframe, customAttrs);\n    setAll$1(iframe, {\n      id: id + '_ifr',\n      frameBorder: '0',\n      allowTransparency: 'true',\n      title\n    });\n    add$2(iframe, 'tox-edit-area__iframe');\n    return iframe;\n  };\n  const getIframeHtml = editor => {\n    let iframeHTML = getDocType(editor) + '<html><head>';\n    if (getDocumentBaseUrl(editor) !== editor.documentBaseUrl) {\n      iframeHTML += '<base href=\"' + editor.documentBaseURI.getURI() + '\" />';\n    }\n    iframeHTML += '<meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\" />';\n    const bodyId = getBodyId(editor);\n    const bodyClass = getBodyClass(editor);\n    const translatedAriaText = editor.translate(getIframeAriaText(editor));\n    if (getContentSecurityPolicy(editor)) {\n      iframeHTML += '<meta http-equiv=\"Content-Security-Policy\" content=\"' + getContentSecurityPolicy(editor) + '\" />';\n    }\n    iframeHTML += '</head>' + `<body id=\"${bodyId}\" class=\"mce-content-body ${bodyClass}\" data-id=\"${editor.id}\" aria-label=\"${translatedAriaText}\">` + '<br>' + '</body></html>';\n    return iframeHTML;\n  };\n  const createIframe = (editor, boxInfo) => {\n    const iframeTitle = Env.browser.isFirefox() ? getIframeAriaText(editor) : 'Rich Text Area';\n    const translatedTitle = editor.translate(iframeTitle);\n    const tabindex = getOpt(SugarElement.fromDom(editor.getElement()), 'tabindex').bind(toInt);\n    const ifr = createIframeElement(editor.id, translatedTitle, getIframeAttrs(editor), tabindex).dom;\n    ifr.onload = () => {\n      ifr.onload = null;\n      editor.dispatch('load');\n    };\n    editor.contentAreaContainer = boxInfo.iframeContainer;\n    editor.iframeElement = ifr;\n    editor.iframeHTML = getIframeHtml(editor);\n    DOM$5.add(boxInfo.iframeContainer, ifr);\n  };\n  const setupIframeBody = editor => {\n    const iframe = editor.iframeElement;\n    const ready = () => {\n      editor.contentDocument = iframe.contentDocument;\n      contentBodyLoaded(editor);\n    };\n    if (shouldUseDocumentWrite(editor) || Env.browser.isFirefox()) {\n      const doc = editor.getDoc();\n      doc.open();\n      doc.write(editor.iframeHTML);\n      doc.close();\n      ready();\n    } else {\n      const binder = bind(SugarElement.fromDom(iframe), 'load', () => {\n        binder.unbind();\n        ready();\n      });\n      iframe.srcdoc = editor.iframeHTML;\n    }\n  };\n  const init$1 = (editor, boxInfo) => {\n    createIframe(editor, boxInfo);\n    if (boxInfo.editorContainer) {\n      boxInfo.editorContainer.style.display = editor.orgDisplay;\n      editor.hidden = DOM$5.isHidden(boxInfo.editorContainer);\n    }\n    editor.getElement().style.display = 'none';\n    DOM$5.setAttrib(editor.id, 'aria-hidden', 'true');\n    editor.getElement().style.visibility = editor.orgVisibility;\n    setupIframeBody(editor);\n  };\n  const DOM$4 = DOMUtils.DOM;\n  const initPlugin = (editor, initializedPlugins, plugin) => {\n    const Plugin = PluginManager.get(plugin);\n    const pluginUrl = PluginManager.urls[plugin] || editor.documentBaseUrl.replace(/\\/$/, '');\n    plugin = Tools.trim(plugin);\n    if (Plugin && Tools.inArray(initializedPlugins, plugin) === -1) {\n      if (editor.plugins[plugin]) {\n        return;\n      }\n      try {\n        const pluginInstance = Plugin(editor, pluginUrl) || {};\n        editor.plugins[plugin] = pluginInstance;\n        if (isFunction(pluginInstance.init)) {\n          pluginInstance.init(editor, pluginUrl);\n          initializedPlugins.push(plugin);\n        }\n      } catch (e) {\n        pluginInitError(editor, plugin, e);\n      }\n    }\n  };\n  const trimLegacyPrefix = name => {\n    return name.replace(/^\\-/, '');\n  };\n  const initPlugins = editor => {\n    const initializedPlugins = [];\n    each$e(getPlugins(editor), name => {\n      initPlugin(editor, initializedPlugins, trimLegacyPrefix(name));\n    });\n  };\n  const initIcons = editor => {\n    const iconPackName = Tools.trim(getIconPackName(editor));\n    const currentIcons = editor.ui.registry.getAll().icons;\n    const loadIcons = {\n      ...IconManager.get('default').icons,\n      ...IconManager.get(iconPackName).icons\n    };\n    each$d(loadIcons, (svgData, icon) => {\n      if (!has$2(currentIcons, icon)) {\n        editor.ui.registry.addIcon(icon, svgData);\n      }\n    });\n  };\n  const initTheme = editor => {\n    const theme = getTheme(editor);\n    if (isString(theme)) {\n      const Theme = ThemeManager.get(theme);\n      editor.theme = Theme(editor, ThemeManager.urls[theme]) || {};\n      if (isFunction(editor.theme.init)) {\n        editor.theme.init(editor, ThemeManager.urls[theme] || editor.documentBaseUrl.replace(/\\/$/, ''));\n      }\n    } else {\n      editor.theme = {};\n    }\n  };\n  const initModel = editor => {\n    const model = getModel(editor);\n    const Model = ModelManager.get(model);\n    editor.model = Model(editor, ModelManager.urls[model]);\n  };\n  const renderFromLoadedTheme = editor => {\n    const render = editor.theme.renderUI;\n    return render ? render() : renderThemeFalse(editor);\n  };\n  const renderFromThemeFunc = editor => {\n    const elm = editor.getElement();\n    const theme = getTheme(editor);\n    const info = theme(editor, elm);\n    if (info.editorContainer.nodeType) {\n      info.editorContainer.id = info.editorContainer.id || editor.id + '_parent';\n    }\n    if (info.iframeContainer && info.iframeContainer.nodeType) {\n      info.iframeContainer.id = info.iframeContainer.id || editor.id + '_iframecontainer';\n    }\n    info.height = info.iframeHeight ? info.iframeHeight : elm.offsetHeight;\n    return info;\n  };\n  const createThemeFalseResult = (element, iframe) => {\n    return {\n      editorContainer: element,\n      iframeContainer: iframe,\n      api: {}\n    };\n  };\n  const renderThemeFalseIframe = targetElement => {\n    const iframeContainer = DOM$4.create('div');\n    DOM$4.insertAfter(iframeContainer, targetElement);\n    return createThemeFalseResult(iframeContainer, iframeContainer);\n  };\n  const renderThemeFalse = editor => {\n    const targetElement = editor.getElement();\n    return editor.inline ? createThemeFalseResult(null) : renderThemeFalseIframe(targetElement);\n  };\n  const renderThemeUi = editor => {\n    const elm = editor.getElement();\n    editor.orgDisplay = elm.style.display;\n    if (isString(getTheme(editor))) {\n      return renderFromLoadedTheme(editor);\n    } else if (isFunction(getTheme(editor))) {\n      return renderFromThemeFunc(editor);\n    } else {\n      return renderThemeFalse(editor);\n    }\n  };\n  const augmentEditorUiApi = (editor, api) => {\n    const uiApiFacade = {\n      show: Optional.from(api.show).getOr(noop),\n      hide: Optional.from(api.hide).getOr(noop),\n      isEnabled: Optional.from(api.isEnabled).getOr(always),\n      setEnabled: state => {\n        const shouldSkip = state && editor.mode.get() === 'readonly';\n        if (!shouldSkip) {\n          Optional.from(api.setEnabled).each(f => f(state));\n        }\n      }\n    };\n    editor.ui = {\n      ...editor.ui,\n      ...uiApiFacade\n    };\n  };\n  const init = async editor => {\n    editor.dispatch('ScriptsLoaded');\n    initIcons(editor);\n    initTheme(editor);\n    initModel(editor);\n    initPlugins(editor);\n    const renderInfo = await renderThemeUi(editor);\n    augmentEditorUiApi(editor, Optional.from(renderInfo.api).getOr({}));\n    editor.editorContainer = renderInfo.editorContainer;\n    appendContentCssFromSettings(editor);\n    if (editor.inline) {\n      contentBodyLoaded(editor);\n    } else {\n      init$1(editor, {\n        editorContainer: renderInfo.editorContainer,\n        iframeContainer: renderInfo.iframeContainer\n      });\n    }\n  };\n  const DOM$3 = DOMUtils.DOM;\n  const hasSkipLoadPrefix = name => name.charAt(0) === '-';\n  const loadLanguage = (scriptLoader, editor) => {\n    const languageCode = getLanguageCode(editor);\n    const languageUrl = getLanguageUrl(editor);\n    if (!I18n.hasCode(languageCode) && languageCode !== 'en') {\n      const url = isNotEmpty(languageUrl) ? languageUrl : `${editor.editorManager.baseURL}/langs/${languageCode}.js`;\n      scriptLoader.add(url).catch(() => {\n        languageLoadError(editor, url, languageCode);\n      });\n    }\n  };\n  const loadTheme = (editor, suffix) => {\n    const theme = getTheme(editor);\n    if (isString(theme) && !hasSkipLoadPrefix(theme) && !has$2(ThemeManager.urls, theme)) {\n      const themeUrl = getThemeUrl(editor);\n      const url = themeUrl ? editor.documentBaseURI.toAbsolute(themeUrl) : `themes/${theme}/theme${suffix}.js`;\n      ThemeManager.load(theme, url).catch(() => {\n        themeLoadError(editor, url, theme);\n      });\n    }\n  };\n  const loadModel = (editor, suffix) => {\n    const model = getModel(editor);\n    if (model !== 'plugin' && !has$2(ModelManager.urls, model)) {\n      const modelUrl = getModelUrl(editor);\n      const url = isString(modelUrl) ? editor.documentBaseURI.toAbsolute(modelUrl) : `models/${model}/model${suffix}.js`;\n      ModelManager.load(model, url).catch(() => {\n        modelLoadError(editor, url, model);\n      });\n    }\n  };\n  const getIconsUrlMetaFromUrl = editor => Optional.from(getIconsUrl(editor)).filter(isNotEmpty).map(url => ({\n    url,\n    name: Optional.none()\n  }));\n  const getIconsUrlMetaFromName = (editor, name, suffix) => Optional.from(name).filter(name => isNotEmpty(name) && !IconManager.has(name)).map(name => ({\n    url: `${editor.editorManager.baseURL}/icons/${name}/icons${suffix}.js`,\n    name: Optional.some(name)\n  }));\n  const loadIcons = (scriptLoader, editor, suffix) => {\n    const defaultIconsUrl = getIconsUrlMetaFromName(editor, 'default', suffix);\n    const customIconsUrl = getIconsUrlMetaFromUrl(editor).orThunk(() => getIconsUrlMetaFromName(editor, getIconPackName(editor), ''));\n    each$e(cat([defaultIconsUrl, customIconsUrl]), urlMeta => {\n      scriptLoader.add(urlMeta.url).catch(() => {\n        iconsLoadError(editor, urlMeta.url, urlMeta.name.getOrUndefined());\n      });\n    });\n  };\n  const loadPlugins = (editor, suffix) => {\n    const loadPlugin = (name, url) => {\n      PluginManager.load(name, url).catch(() => {\n        pluginLoadError(editor, url, name);\n      });\n    };\n    each$d(getExternalPlugins$1(editor), (url, name) => {\n      loadPlugin(name, url);\n      editor.options.set('plugins', getPlugins(editor).concat(name));\n    });\n    each$e(getPlugins(editor), plugin => {\n      plugin = Tools.trim(plugin);\n      if (plugin && !PluginManager.urls[plugin] && !hasSkipLoadPrefix(plugin)) {\n        loadPlugin(plugin, `plugins/${plugin}/plugin${suffix}.js`);\n      }\n    });\n  };\n  const isThemeLoaded = editor => {\n    const theme = getTheme(editor);\n    return !isString(theme) || isNonNullable(ThemeManager.get(theme));\n  };\n  const isModelLoaded = editor => {\n    const model = getModel(editor);\n    return isNonNullable(ModelManager.get(model));\n  };\n  const loadScripts = (editor, suffix) => {\n    const scriptLoader = ScriptLoader.ScriptLoader;\n    const initEditor = () => {\n      if (!editor.removed && isThemeLoaded(editor) && isModelLoaded(editor)) {\n        init(editor);\n      }\n    };\n    loadTheme(editor, suffix);\n    loadModel(editor, suffix);\n    loadLanguage(scriptLoader, editor);\n    loadIcons(scriptLoader, editor, suffix);\n    loadPlugins(editor, suffix);\n    scriptLoader.loadQueue().then(initEditor, initEditor);\n  };\n  const getStyleSheetLoader = (element, editor) => instance.forElement(element, {\n    contentCssCors: hasContentCssCors(editor),\n    referrerPolicy: getReferrerPolicy(editor)\n  });\n  const render = editor => {\n    const id = editor.id;\n    I18n.setCode(getLanguageCode(editor));\n    const readyHandler = () => {\n      DOM$3.unbind(window, 'ready', readyHandler);\n      editor.render();\n    };\n    if (!EventUtils.Event.domLoaded) {\n      DOM$3.bind(window, 'ready', readyHandler);\n      return;\n    }\n    if (!editor.getElement()) {\n      return;\n    }\n    const element = SugarElement.fromDom(editor.getElement());\n    const snapshot = clone$4(element);\n    editor.on('remove', () => {\n      eachr(element.dom.attributes, attr => remove$9(element, attr.name));\n      setAll$1(element, snapshot);\n    });\n    editor.ui.styleSheetLoader = getStyleSheetLoader(element, editor);\n    if (!isInline$1(editor)) {\n      editor.orgVisibility = editor.getElement().style.visibility;\n      editor.getElement().style.visibility = 'hidden';\n    } else {\n      editor.inline = true;\n    }\n    const form = editor.getElement().form || DOM$3.getParent(id, 'form');\n    if (form) {\n      editor.formElement = form;\n      if (hasHiddenInput(editor) && !isTextareaOrInput(editor.getElement())) {\n        DOM$3.insertAfter(DOM$3.create('input', {\n          type: 'hidden',\n          name: id\n        }), id);\n        editor.hasHiddenInput = true;\n      }\n      editor.formEventDelegate = e => {\n        editor.dispatch(e.type, e);\n      };\n      DOM$3.bind(form, 'submit reset', editor.formEventDelegate);\n      editor.on('reset', () => {\n        editor.resetContent();\n      });\n      if (shouldPatchSubmit(editor) && !form.submit.nodeType && !form.submit.length && !form._mceOldSubmit) {\n        form._mceOldSubmit = form.submit;\n        form.submit = () => {\n          editor.editorManager.triggerSave();\n          editor.setDirty(false);\n          return form._mceOldSubmit(form);\n        };\n      }\n    }\n    editor.windowManager = WindowManager(editor);\n    editor.notificationManager = NotificationManager(editor);\n    if (isEncodingXml(editor)) {\n      editor.on('GetContent', e => {\n        if (e.save) {\n          e.content = DOM$3.encode(e.content);\n        }\n      });\n    }\n    if (shouldAddFormSubmitTrigger(editor)) {\n      editor.on('submit', () => {\n        if (editor.initialized) {\n          editor.save();\n        }\n      });\n    }\n    if (shouldAddUnloadTrigger(editor)) {\n      editor._beforeUnload = () => {\n        if (editor.initialized && !editor.destroyed && !editor.isHidden()) {\n          editor.save({\n            format: 'raw',\n            no_events: true,\n            set_dirty: false\n          });\n        }\n      };\n      editor.editorManager.on('BeforeUnload', editor._beforeUnload);\n    }\n    editor.editorManager.add(editor);\n    loadScripts(editor, editor.suffix);\n  };\n  const setEditableRoot = (editor, state) => {\n    if (editor._editableRoot !== state) {\n      editor._editableRoot = state;\n      editor.getBody().contentEditable = String(editor.hasEditableRoot());\n      editor.nodeChanged();\n      fireEditableRootStateChange(editor, state);\n    }\n  };\n  const hasEditableRoot = editor => editor._editableRoot;\n  const sectionResult = (sections, settings) => ({\n    sections: constant(sections),\n    options: constant(settings)\n  });\n  const deviceDetection = detect$1().deviceType;\n  const isPhone = deviceDetection.isPhone();\n  const isTablet = deviceDetection.isTablet();\n  const normalizePlugins = plugins => {\n    if (isNullable(plugins)) {\n      return [];\n    } else {\n      const pluginNames = isArray$1(plugins) ? plugins : plugins.split(/[ ,]/);\n      const trimmedPlugins = map$3(pluginNames, trim$4);\n      return filter$5(trimmedPlugins, isNotEmpty);\n    }\n  };\n  const extractSections = (keys, options) => {\n    const result = bifilter(options, (value, key) => {\n      return contains$2(keys, key);\n    });\n    return sectionResult(result.t, result.f);\n  };\n  const getSection = (sectionResult, name, defaults = {}) => {\n    const sections = sectionResult.sections();\n    const sectionOptions = get$a(sections, name).getOr({});\n    return Tools.extend({}, defaults, sectionOptions);\n  };\n  const hasSection = (sectionResult, name) => {\n    return has$2(sectionResult.sections(), name);\n  };\n  const getSectionConfig = (sectionResult, name) => {\n    return hasSection(sectionResult, name) ? sectionResult.sections()[name] : {};\n  };\n  const getMobileOverrideOptions = (mobileOptions, isPhone) => {\n    const defaultMobileOptions = {\n      table_grid: false,\n      object_resizing: false,\n      resize: false,\n      toolbar_mode: get$a(mobileOptions, 'toolbar_mode').getOr('scrolling'),\n      toolbar_sticky: false\n    };\n    const defaultPhoneOptions = {\n      menubar: false\n    };\n    return {\n      ...defaultMobileOptions,\n      ...(isPhone ? defaultPhoneOptions : {})\n    };\n  };\n  const getExternalPlugins = (overrideOptions, options) => {\n    var _a;\n    const userDefinedExternalPlugins = (_a = options.external_plugins) !== null && _a !== void 0 ? _a : {};\n    if (overrideOptions && overrideOptions.external_plugins) {\n      return Tools.extend({}, overrideOptions.external_plugins, userDefinedExternalPlugins);\n    } else {\n      return userDefinedExternalPlugins;\n    }\n  };\n  const combinePlugins = (forcedPlugins, plugins) => [...normalizePlugins(forcedPlugins), ...normalizePlugins(plugins)];\n  const getPlatformPlugins = (isMobileDevice, sectionResult, desktopPlugins, mobilePlugins) => {\n    if (isMobileDevice && hasSection(sectionResult, 'mobile')) {\n      return mobilePlugins;\n    } else {\n      return desktopPlugins;\n    }\n  };\n  const processPlugins = (isMobileDevice, sectionResult, defaultOverrideOptions, options) => {\n    const forcedPlugins = normalizePlugins(defaultOverrideOptions.forced_plugins);\n    const desktopPlugins = normalizePlugins(options.plugins);\n    const mobileConfig = getSectionConfig(sectionResult, 'mobile');\n    const mobilePlugins = mobileConfig.plugins ? normalizePlugins(mobileConfig.plugins) : desktopPlugins;\n    const platformPlugins = getPlatformPlugins(isMobileDevice, sectionResult, desktopPlugins, mobilePlugins);\n    const combinedPlugins = combinePlugins(forcedPlugins, platformPlugins);\n    return Tools.extend(options, {\n      forced_plugins: forcedPlugins,\n      plugins: combinedPlugins\n    });\n  };\n  const isOnMobile = (isMobileDevice, sectionResult) => {\n    return isMobileDevice && hasSection(sectionResult, 'mobile');\n  };\n  const combineOptions = (isMobileDevice, isPhone, defaultOptions, defaultOverrideOptions, options) => {\n    var _a;\n    const deviceOverrideOptions = isMobileDevice ? {\n      mobile: getMobileOverrideOptions((_a = options.mobile) !== null && _a !== void 0 ? _a : {}, isPhone)\n    } : {};\n    const sectionResult = extractSections(['mobile'], deepMerge(deviceOverrideOptions, options));\n    const extendedOptions = Tools.extend(defaultOptions, defaultOverrideOptions, sectionResult.options(), isOnMobile(isMobileDevice, sectionResult) ? getSection(sectionResult, 'mobile') : {}, {\n      external_plugins: getExternalPlugins(defaultOverrideOptions, sectionResult.options())\n    });\n    return processPlugins(isMobileDevice, sectionResult, defaultOverrideOptions, extendedOptions);\n  };\n  const normalizeOptions = (defaultOverrideOptions, options) => {\n    const copiedOptions = merge(options);\n    return combineOptions(isPhone || isTablet, isPhone, copiedOptions, defaultOverrideOptions, copiedOptions);\n  };\n  const addVisual = (editor, elm) => addVisual$1(editor, elm);\n  const registerExecCommands$2 = editor => {\n    const toggleFormat = (name, value) => {\n      editor.formatter.toggle(name, value);\n      editor.nodeChanged();\n    };\n    const toggleAlign = align => () => {\n      each$e('left,center,right,justify'.split(','), name => {\n        if (align !== name) {\n          editor.formatter.remove('align' + name);\n        }\n      });\n      if (align !== 'none') {\n        toggleFormat('align' + align);\n      }\n    };\n    editor.editorCommands.addCommands({\n      JustifyLeft: toggleAlign('left'),\n      JustifyCenter: toggleAlign('center'),\n      JustifyRight: toggleAlign('right'),\n      JustifyFull: toggleAlign('justify'),\n      JustifyNone: toggleAlign('none')\n    });\n  };\n  const registerQueryStateCommands = editor => {\n    const alignStates = name => () => {\n      const selection = editor.selection;\n      const nodes = selection.isCollapsed() ? [editor.dom.getParent(selection.getNode(), editor.dom.isBlock)] : selection.getSelectedBlocks();\n      return exists(nodes, node => isNonNullable(editor.formatter.matchNode(node, name)));\n    };\n    editor.editorCommands.addCommands({\n      JustifyLeft: alignStates('alignleft'),\n      JustifyCenter: alignStates('aligncenter'),\n      JustifyRight: alignStates('alignright'),\n      JustifyFull: alignStates('alignjustify')\n    }, 'state');\n  };\n  const registerCommands$a = editor => {\n    registerExecCommands$2(editor);\n    registerQueryStateCommands(editor);\n  };\n  const registerCommands$9 = editor => {\n    editor.editorCommands.addCommands({\n      'Cut,Copy,Paste': command => {\n        const doc = editor.getDoc();\n        let failed;\n        try {\n          doc.execCommand(command);\n        } catch (ex) {\n          failed = true;\n        }\n        if (command === 'paste' && !doc.queryCommandEnabled(command)) {\n          failed = true;\n        }\n        if (failed || !doc.queryCommandSupported(command)) {\n          let msg = editor.translate(`Your browser doesn't support direct access to the clipboard. ` + 'Please use the Ctrl+X/C/V keyboard shortcuts instead.');\n          if (Env.os.isMacOS() || Env.os.isiOS()) {\n            msg = msg.replace(/Ctrl\\+/g, '\\u2318+');\n          }\n          editor.notificationManager.open({\n            text: msg,\n            type: 'error'\n          });\n        }\n      }\n    });\n  };\n  const trimOrPadLeftRight = (dom, rng, html, schema) => {\n    const root = SugarElement.fromDom(dom.getRoot());\n    if (needsToBeNbspLeft(root, CaretPosition.fromRangeStart(rng), schema)) {\n      html = html.replace(/^ /, '&nbsp;');\n    } else {\n      html = html.replace(/^&nbsp;/, ' ');\n    }\n    if (needsToBeNbspRight(root, CaretPosition.fromRangeEnd(rng), schema)) {\n      html = html.replace(/(&nbsp;| )(<br( \\/)>)?$/, '&nbsp;');\n    } else {\n      html = html.replace(/&nbsp;(<br( \\/)?>)?$/, ' ');\n    }\n    return html;\n  };\n  const processValue$1 = value => {\n    if (typeof value !== 'string') {\n      const details = Tools.extend({\n        paste: value.paste,\n        data: {\n          paste: value.paste\n        }\n      }, value);\n      return {\n        content: value.content,\n        details\n      };\n    }\n    return {\n      content: value,\n      details: {}\n    };\n  };\n  const trimOrPad = (editor, value) => {\n    const selection = editor.selection;\n    const dom = editor.dom;\n    if (/^ | $/.test(value)) {\n      return trimOrPadLeftRight(dom, selection.getRng(), value, editor.schema);\n    } else {\n      return value;\n    }\n  };\n  const insertAtCaret = (editor, value) => {\n    if (editor.selection.isEditable()) {\n      const {\n        content,\n        details\n      } = processValue$1(value);\n      preProcessSetContent(editor, {\n        ...details,\n        content: trimOrPad(editor, content),\n        format: 'html',\n        set: false,\n        selection: true\n      }).each(args => {\n        const insertedContent = insertContent$1(editor, args.content, details);\n        postProcessSetContent(editor, insertedContent, args);\n        editor.addVisual();\n      });\n    }\n  };\n  const registerCommands$8 = editor => {\n    editor.editorCommands.addCommands({\n      mceCleanup: () => {\n        const bm = editor.selection.getBookmark();\n        editor.setContent(editor.getContent());\n        editor.selection.moveToBookmark(bm);\n      },\n      insertImage: (_command, _ui, value) => {\n        insertAtCaret(editor, editor.dom.createHTML('img', {\n          src: value\n        }));\n      },\n      insertHorizontalRule: () => {\n        editor.execCommand('mceInsertContent', false, '<hr>');\n      },\n      insertText: (_command, _ui, value) => {\n        insertAtCaret(editor, editor.dom.encode(value));\n      },\n      insertHTML: (_command, _ui, value) => {\n        insertAtCaret(editor, value);\n      },\n      mceInsertContent: (_command, _ui, value) => {\n        insertAtCaret(editor, value);\n      },\n      mceSetContent: (_command, _ui, value) => {\n        editor.setContent(value);\n      },\n      mceReplaceContent: (_command, _ui, value) => {\n        editor.execCommand('mceInsertContent', false, value.replace(/\\{\\$selection\\}/g, editor.selection.getContent({\n          format: 'text'\n        })));\n      },\n      mceNewDocument: () => {\n        editor.setContent(getNewDocumentContent(editor));\n      }\n    });\n  };\n  const legacyPropNames = {\n    'font-size': 'size',\n    'font-family': 'face'\n  };\n  const isFont = isTag('font');\n  const getSpecifiedFontProp = (propName, rootElm, elm) => {\n    const getProperty = elm => getRaw(elm, propName).orThunk(() => {\n      if (isFont(elm)) {\n        return get$a(legacyPropNames, propName).bind(legacyPropName => getOpt(elm, legacyPropName));\n      } else {\n        return Optional.none();\n      }\n    });\n    const isRoot = elm => eq(SugarElement.fromDom(rootElm), elm);\n    return closest$1(SugarElement.fromDom(elm), elm => getProperty(elm), isRoot);\n  };\n  const normalizeFontFamily = fontFamily => fontFamily.replace(/[\\'\\\"\\\\]/g, '').replace(/,\\s+/g, ',');\n  const getComputedFontProp = (propName, elm) => Optional.from(DOMUtils.DOM.getStyle(elm, propName, true));\n  const getFontProp = propName => (rootElm, elm) => Optional.from(elm).map(SugarElement.fromDom).filter(isElement$7).bind(element => getSpecifiedFontProp(propName, rootElm, element.dom).or(getComputedFontProp(propName, element.dom))).getOr('');\n  const getFontSize = getFontProp('font-size');\n  const getFontFamily = compose(normalizeFontFamily, getFontProp('font-family'));\n  const findFirstCaretElement = editor => firstPositionIn(editor.getBody()).bind(caret => {\n    const container = caret.container();\n    return Optional.from(isText$b(container) ? container.parentNode : container);\n  });\n  const getCaretElement = editor => Optional.from(editor.selection.getRng()).bind(rng => {\n    const root = editor.getBody();\n    const atStartOfNode = rng.startContainer === root && rng.startOffset === 0;\n    return atStartOfNode ? Optional.none() : Optional.from(editor.selection.getStart(true));\n  });\n  const bindRange = (editor, binder) => getCaretElement(editor).orThunk(curry(findFirstCaretElement, editor)).map(SugarElement.fromDom).filter(isElement$7).bind(binder);\n  const mapRange = (editor, mapper) => bindRange(editor, compose1(Optional.some, mapper));\n  const fromFontSizeNumber = (editor, value) => {\n    if (/^[0-9.]+$/.test(value)) {\n      const fontSizeNumber = parseInt(value, 10);\n      if (fontSizeNumber >= 1 && fontSizeNumber <= 7) {\n        const fontSizes = getFontStyleValues(editor);\n        const fontClasses = getFontSizeClasses(editor);\n        if (fontClasses.length > 0) {\n          return fontClasses[fontSizeNumber - 1] || value;\n        } else {\n          return fontSizes[fontSizeNumber - 1] || value;\n        }\n      } else {\n        return value;\n      }\n    } else {\n      return value;\n    }\n  };\n  const normalizeFontNames = font => {\n    const fonts = font.split(/\\s*,\\s*/);\n    return map$3(fonts, font => {\n      if (font.indexOf(' ') !== -1 && !(startsWith(font, '\"') || startsWith(font, `'`))) {\n        return `'${font}'`;\n      } else {\n        return font;\n      }\n    }).join(',');\n  };\n  const fontNameAction = (editor, value) => {\n    const font = fromFontSizeNumber(editor, value);\n    editor.formatter.toggle('fontname', {\n      value: normalizeFontNames(font)\n    });\n    editor.nodeChanged();\n  };\n  const fontNameQuery = editor => mapRange(editor, elm => getFontFamily(editor.getBody(), elm.dom)).getOr('');\n  const fontSizeAction = (editor, value) => {\n    editor.formatter.toggle('fontsize', {\n      value: fromFontSizeNumber(editor, value)\n    });\n    editor.nodeChanged();\n  };\n  const fontSizeQuery = editor => mapRange(editor, elm => getFontSize(editor.getBody(), elm.dom)).getOr('');\n  const lineHeightQuery = editor => mapRange(editor, elm => {\n    const root = SugarElement.fromDom(editor.getBody());\n    const specifiedStyle = closest$1(elm, elm => getRaw(elm, 'line-height'), curry(eq, root));\n    const computedStyle = () => {\n      const lineHeight = parseFloat(get$7(elm, 'line-height'));\n      const fontSize = parseFloat(get$7(elm, 'font-size'));\n      return String(lineHeight / fontSize);\n    };\n    return specifiedStyle.getOrThunk(computedStyle);\n  }).getOr('');\n  const lineHeightAction = (editor, lineHeight) => {\n    editor.formatter.toggle('lineheight', {\n      value: String(lineHeight)\n    });\n    editor.nodeChanged();\n  };\n  const registerExecCommands$1 = editor => {\n    const toggleFormat = (name, value) => {\n      editor.formatter.toggle(name, value);\n      editor.nodeChanged();\n    };\n    editor.editorCommands.addCommands({\n      'Bold,Italic,Underline,Strikethrough,Superscript,Subscript': command => {\n        toggleFormat(command);\n      },\n      'ForeColor,HiliteColor': (command, _ui, value) => {\n        toggleFormat(command, {\n          value\n        });\n      },\n      'BackColor': (_command, _ui, value) => {\n        toggleFormat('hilitecolor', {\n          value\n        });\n      },\n      'FontName': (_command, _ui, value) => {\n        fontNameAction(editor, value);\n      },\n      'FontSize': (_command, _ui, value) => {\n        fontSizeAction(editor, value);\n      },\n      'LineHeight': (_command, _ui, value) => {\n        lineHeightAction(editor, value);\n      },\n      'Lang': (command, _ui, lang) => {\n        var _a;\n        toggleFormat(command, {\n          value: lang.code,\n          customValue: (_a = lang.customCode) !== null && _a !== void 0 ? _a : null\n        });\n      },\n      'RemoveFormat': command => {\n        editor.formatter.remove(command);\n      },\n      'mceBlockQuote': () => {\n        toggleFormat('blockquote');\n      },\n      'FormatBlock': (_command, _ui, value) => {\n        toggleFormat(isString(value) ? value : 'p');\n      },\n      'mceToggleFormat': (_command, _ui, value) => {\n        toggleFormat(value);\n      }\n    });\n  };\n  const registerQueryValueCommands = editor => {\n    const isFormatMatch = name => editor.formatter.match(name);\n    editor.editorCommands.addCommands({\n      'Bold,Italic,Underline,Strikethrough,Superscript,Subscript': command => isFormatMatch(command),\n      'mceBlockQuote': () => isFormatMatch('blockquote')\n    }, 'state');\n    editor.editorCommands.addQueryValueHandler('FontName', () => fontNameQuery(editor));\n    editor.editorCommands.addQueryValueHandler('FontSize', () => fontSizeQuery(editor));\n    editor.editorCommands.addQueryValueHandler('LineHeight', () => lineHeightQuery(editor));\n  };\n  const registerCommands$7 = editor => {\n    registerExecCommands$1(editor);\n    registerQueryValueCommands(editor);\n  };\n  const registerCommands$6 = editor => {\n    editor.editorCommands.addCommands({\n      mceAddUndoLevel: () => {\n        editor.undoManager.add();\n      },\n      mceEndUndoLevel: () => {\n        editor.undoManager.add();\n      },\n      Undo: () => {\n        editor.undoManager.undo();\n      },\n      Redo: () => {\n        editor.undoManager.redo();\n      }\n    });\n  };\n  const registerCommands$5 = editor => {\n    editor.editorCommands.addCommands({\n      Indent: () => {\n        indent(editor);\n      },\n      Outdent: () => {\n        outdent(editor);\n      }\n    });\n    editor.editorCommands.addCommands({\n      Outdent: () => canOutdent(editor)\n    }, 'state');\n  };\n  const registerCommands$4 = editor => {\n    const applyLinkToSelection = (_command, _ui, value) => {\n      if (editor.mode.isReadOnly()) {\n        return;\n      }\n      const linkDetails = isString(value) ? {\n        href: value\n      } : value;\n      const anchor = editor.dom.getParent(editor.selection.getNode(), 'a');\n      if (isObject(linkDetails) && isString(linkDetails.href)) {\n        linkDetails.href = linkDetails.href.replace(/ /g, '%20');\n        if (!anchor || !linkDetails.href) {\n          editor.formatter.remove('link');\n        }\n        if (linkDetails.href) {\n          editor.formatter.apply('link', linkDetails, anchor);\n        }\n      }\n    };\n    editor.editorCommands.addCommands({\n      unlink: () => {\n        if (editor.selection.isEditable()) {\n          if (editor.selection.isCollapsed()) {\n            const elm = editor.dom.getParent(editor.selection.getStart(), 'a');\n            if (elm) {\n              editor.dom.remove(elm, true);\n            }\n            return;\n          }\n          editor.formatter.remove('link');\n        }\n      },\n      mceInsertLink: applyLinkToSelection,\n      createLink: applyLinkToSelection\n    });\n  };\n  const getTopParentBlock = (editor, node, root, container) => {\n    const dom = editor.dom;\n    const selector = node => dom.isBlock(node) && node.parentElement === root;\n    const topParentBlock = selector(node) ? node : dom.getParent(container, selector, root);\n    return Optional.from(topParentBlock).map(SugarElement.fromDom);\n  };\n  const insert = (editor, before) => {\n    if (editor.mode.isReadOnly()) {\n      return;\n    }\n    const dom = editor.dom;\n    const rng = editor.selection.getRng();\n    const node = before ? editor.selection.getStart() : editor.selection.getEnd();\n    const container = before ? rng.startContainer : rng.endContainer;\n    const root = getEditableRoot(dom, container);\n    if (!root || !root.isContentEditable) {\n      return;\n    }\n    const insertFn = before ? before$3 : after$4;\n    const newBlockName = getForcedRootBlock(editor);\n    getTopParentBlock(editor, node, root, container).each(parentBlock => {\n      const newBlock = createNewBlock(editor, container, parentBlock.dom, root, false, newBlockName);\n      insertFn(parentBlock, SugarElement.fromDom(newBlock));\n      editor.selection.setCursorLocation(newBlock, 0);\n      editor.dispatch('NewBlock', {\n        newBlock\n      });\n      fireInputEvent(editor, 'insertParagraph');\n    });\n  };\n  const insertBefore = editor => insert(editor, true);\n  const insertAfter = editor => insert(editor, false);\n  const registerCommands$3 = editor => {\n    editor.editorCommands.addCommands({\n      InsertNewBlockBefore: () => {\n        insertBefore(editor);\n      },\n      InsertNewBlockAfter: () => {\n        insertAfter(editor);\n      }\n    });\n  };\n  const registerCommands$2 = editor => {\n    editor.editorCommands.addCommands({\n      insertParagraph: () => {\n        insertBreak(blockbreak, editor);\n      },\n      mceInsertNewLine: (_command, _ui, value) => {\n        insert$1(editor, value);\n      },\n      InsertLineBreak: (_command, _ui, _value) => {\n        insertBreak(linebreak, editor);\n      }\n    });\n  };\n  const registerCommands$1 = editor => {\n    editor.editorCommands.addCommands({\n      mceSelectNodeDepth: (_command, _ui, value) => {\n        let counter = 0;\n        editor.dom.getParent(editor.selection.getNode(), node => {\n          if (isElement$6(node) && counter++ === value) {\n            editor.selection.select(node);\n            return false;\n          } else {\n            return true;\n          }\n        }, editor.getBody());\n      },\n      mceSelectNode: (_command, _ui, value) => {\n        editor.selection.select(value);\n      },\n      selectAll: () => {\n        const editingHost = editor.dom.getParent(editor.selection.getStart(), isContentEditableTrue$3);\n        if (editingHost) {\n          const rng = editor.dom.createRng();\n          rng.selectNodeContents(editingHost);\n          editor.selection.setRng(rng);\n        }\n      }\n    });\n  };\n  const registerExecCommands = editor => {\n    editor.editorCommands.addCommands({\n      mceRemoveNode: (_command, _ui, value) => {\n        const node = value !== null && value !== void 0 ? value : editor.selection.getNode();\n        if (node !== editor.getBody()) {\n          const bm = editor.selection.getBookmark();\n          editor.dom.remove(node, true);\n          editor.selection.moveToBookmark(bm);\n        }\n      },\n      mcePrint: () => {\n        editor.getWin().print();\n      },\n      mceFocus: (_command, _ui, value) => {\n        focus(editor, value === true);\n      },\n      mceToggleVisualAid: () => {\n        editor.hasVisual = !editor.hasVisual;\n        editor.addVisual();\n      }\n    });\n  };\n  const registerCommands = editor => {\n    registerCommands$a(editor);\n    registerCommands$9(editor);\n    registerCommands$6(editor);\n    registerCommands$1(editor);\n    registerCommands$8(editor);\n    registerCommands$4(editor);\n    registerCommands$5(editor);\n    registerCommands$3(editor);\n    registerCommands$2(editor);\n    registerCommands$7(editor);\n    registerExecCommands(editor);\n  };\n  const selectionSafeCommands = ['toggleview'];\n  const isSelectionSafeCommand = command => contains$2(selectionSafeCommands, command.toLowerCase());\n  class EditorCommands {\n    constructor(editor) {\n      this.commands = {\n        state: {},\n        exec: {},\n        value: {}\n      };\n      this.editor = editor;\n    }\n    execCommand(command, ui = false, value, args) {\n      const editor = this.editor;\n      const lowerCaseCommand = command.toLowerCase();\n      const skipFocus = args === null || args === void 0 ? void 0 : args.skip_focus;\n      if (editor.removed) {\n        return false;\n      }\n      if (lowerCaseCommand !== 'mcefocus') {\n        if (!/^(mceAddUndoLevel|mceEndUndoLevel)$/i.test(lowerCaseCommand) && !skipFocus) {\n          editor.focus();\n        } else {\n          restore(editor);\n        }\n      }\n      const eventArgs = editor.dispatch('BeforeExecCommand', {\n        command,\n        ui,\n        value\n      });\n      if (eventArgs.isDefaultPrevented()) {\n        return false;\n      }\n      const func = this.commands.exec[lowerCaseCommand];\n      if (isFunction(func)) {\n        func(lowerCaseCommand, ui, value);\n        editor.dispatch('ExecCommand', {\n          command,\n          ui,\n          value\n        });\n        return true;\n      }\n      return false;\n    }\n    queryCommandState(command) {\n      if (!isSelectionSafeCommand(command) && this.editor.quirks.isHidden() || this.editor.removed) {\n        return false;\n      }\n      const lowerCaseCommand = command.toLowerCase();\n      const func = this.commands.state[lowerCaseCommand];\n      if (isFunction(func)) {\n        return func(lowerCaseCommand);\n      }\n      return false;\n    }\n    queryCommandValue(command) {\n      if (!isSelectionSafeCommand(command) && this.editor.quirks.isHidden() || this.editor.removed) {\n        return '';\n      }\n      const lowerCaseCommand = command.toLowerCase();\n      const func = this.commands.value[lowerCaseCommand];\n      if (isFunction(func)) {\n        return func(lowerCaseCommand);\n      }\n      return '';\n    }\n    addCommands(commandList, type = 'exec') {\n      const commands = this.commands;\n      each$d(commandList, (callback, command) => {\n        each$e(command.toLowerCase().split(','), command => {\n          commands[type][command] = callback;\n        });\n      });\n    }\n    addCommand(command, callback, scope) {\n      const lowerCaseCommand = command.toLowerCase();\n      this.commands.exec[lowerCaseCommand] = (_command, ui, value) => callback.call(scope !== null && scope !== void 0 ? scope : this.editor, ui, value);\n    }\n    queryCommandSupported(command) {\n      const lowerCaseCommand = command.toLowerCase();\n      if (this.commands.exec[lowerCaseCommand]) {\n        return true;\n      } else {\n        return false;\n      }\n    }\n    addQueryStateHandler(command, callback, scope) {\n      this.commands.state[command.toLowerCase()] = () => callback.call(scope !== null && scope !== void 0 ? scope : this.editor);\n    }\n    addQueryValueHandler(command, callback, scope) {\n      this.commands.value[command.toLowerCase()] = () => callback.call(scope !== null && scope !== void 0 ? scope : this.editor);\n    }\n  }\n  const toggleClass = (elm, cls, state) => {\n    if (has(elm, cls) && !state) {\n      remove$6(elm, cls);\n    } else if (state) {\n      add$2(elm, cls);\n    }\n  };\n  const setEditorCommandState = (editor, cmd, state) => {\n    try {\n      editor.getDoc().execCommand(cmd, false, String(state));\n    } catch (ex) {}\n  };\n  const setContentEditable = (elm, state) => {\n    elm.dom.contentEditable = state ? 'true' : 'false';\n  };\n  const removeFakeSelection = editor => {\n    Optional.from(editor.selection.getNode()).each(elm => {\n      elm.removeAttribute('data-mce-selected');\n    });\n  };\n  const restoreFakeSelection = editor => {\n    editor.selection.setRng(editor.selection.getRng());\n  };\n  const setCommonEditorCommands = (editor, state) => {\n    setEditorCommandState(editor, 'StyleWithCSS', state);\n    setEditorCommandState(editor, 'enableInlineTableEditing', state);\n    setEditorCommandState(editor, 'enableObjectResizing', state);\n  };\n  const setEditorReadonly = editor => {\n    editor.readonly = true;\n    editor.selection.controlSelection.hideResizeRect();\n    editor._selectionOverrides.hideFakeCaret();\n    removeFakeSelection(editor);\n  };\n  const unsetEditorReadonly = (editor, body) => {\n    editor.readonly = false;\n    if (editor.hasEditableRoot()) {\n      setContentEditable(body, true);\n    }\n    setCommonEditorCommands(editor, false);\n    if (hasEditorOrUiFocus(editor)) {\n      editor.focus();\n    }\n    restoreFakeSelection(editor);\n    editor.nodeChanged();\n  };\n  const toggleReadOnly = (editor, state) => {\n    const body = SugarElement.fromDom(editor.getBody());\n    toggleClass(body, 'mce-content-readonly', state);\n    if (state) {\n      setEditorReadonly(editor);\n      if (editor.hasEditableRoot()) {\n        setContentEditable(body, true);\n      }\n    } else {\n      unsetEditorReadonly(editor, body);\n    }\n  };\n  const isReadOnly = editor => editor.readonly;\n  const isClickEvent = e => e.type === 'click';\n  const allowedEvents = ['copy'];\n  const isReadOnlyAllowedEvent = e => contains$2(allowedEvents, e.type);\n  const getAnchorHrefOpt = (editor, elm) => {\n    const isRoot = elm => eq(elm, SugarElement.fromDom(editor.getBody()));\n    return closest$3(elm, 'a', isRoot).bind(a => getOpt(a, 'href'));\n  };\n  const processReadonlyEvents = (editor, e) => {\n    if (isClickEvent(e) && !VK.metaKeyPressed(e)) {\n      const elm = SugarElement.fromDom(e.target);\n      getAnchorHrefOpt(editor, elm).each(href => {\n        e.preventDefault();\n        if (/^#/.test(href)) {\n          const targetEl = editor.dom.select(`${href},[name=\"${removeLeading(href, '#')}\"]`);\n          if (targetEl.length) {\n            editor.selection.scrollIntoView(targetEl[0], true);\n          }\n        } else {\n          window.open(href, '_blank', 'rel=noopener noreferrer,menubar=yes,toolbar=yes,location=yes,status=yes,resizable=yes,scrollbars=yes');\n        }\n      });\n    } else if (isReadOnlyAllowedEvent(e)) {\n      editor.dispatch(e.type, e);\n    }\n  };\n  const registerReadOnlySelectionBlockers = editor => {\n    editor.on('beforeinput paste cut dragend dragover draggesture dragdrop drop drag', e => {\n      if (isReadOnly(editor)) {\n        e.preventDefault();\n      }\n    });\n    editor.on('BeforeExecCommand', e => {\n      if ((e.command === 'Undo' || e.command === 'Redo') && isReadOnly(editor)) {\n        e.preventDefault();\n      }\n    });\n    editor.on('input', e => {\n      if (!e.isComposing && isReadOnly(editor)) {\n        const undoLevel = editor.undoManager.add();\n        if (isNonNullable(undoLevel)) {\n          editor.undoManager.undo();\n        }\n      }\n    });\n    editor.on('compositionend', () => {\n      if (isReadOnly(editor)) {\n        const undoLevel = editor.undoManager.add();\n        if (isNonNullable(undoLevel)) {\n          editor.undoManager.undo();\n        }\n      }\n    });\n  };\n  const nativeEvents = Tools.makeMap('focus blur focusin focusout click dblclick mousedown mouseup mousemove mouseover beforepaste paste cut copy selectionchange ' + 'mouseout mouseenter mouseleave wheel keydown keypress keyup input beforeinput contextmenu dragstart dragend dragover ' + 'draggesture dragdrop drop drag submit ' + 'compositionstart compositionend compositionupdate touchstart touchmove touchend touchcancel', ' ');\n  class EventDispatcher {\n    static isNative(name) {\n      return !!nativeEvents[name.toLowerCase()];\n    }\n    constructor(settings) {\n      this.bindings = {};\n      this.settings = settings || {};\n      this.scope = this.settings.scope || this;\n      this.toggleEvent = this.settings.toggleEvent || never;\n    }\n    fire(name, args) {\n      return this.dispatch(name, args);\n    }\n    dispatch(name, args) {\n      const lcName = name.toLowerCase();\n      const event = normalize$3(lcName, args !== null && args !== void 0 ? args : {}, this.scope);\n      if (this.settings.beforeFire) {\n        this.settings.beforeFire(event);\n      }\n      const handlers = this.bindings[lcName];\n      if (handlers) {\n        for (let i = 0, l = handlers.length; i < l; i++) {\n          const callback = handlers[i];\n          if (callback.removed) {\n            continue;\n          }\n          if (callback.once) {\n            this.off(lcName, callback.func);\n          }\n          if (event.isImmediatePropagationStopped()) {\n            return event;\n          }\n          if (callback.func.call(this.scope, event) === false) {\n            event.preventDefault();\n            return event;\n          }\n        }\n      }\n      return event;\n    }\n    on(name, callback, prepend, extra) {\n      if (callback === false) {\n        callback = never;\n      }\n      if (callback) {\n        const wrappedCallback = {\n          func: callback,\n          removed: false\n        };\n        if (extra) {\n          Tools.extend(wrappedCallback, extra);\n        }\n        const names = name.toLowerCase().split(' ');\n        let i = names.length;\n        while (i--) {\n          const currentName = names[i];\n          let handlers = this.bindings[currentName];\n          if (!handlers) {\n            handlers = [];\n            this.toggleEvent(currentName, true);\n          }\n          if (prepend) {\n            handlers = [wrappedCallback, ...handlers];\n          } else {\n            handlers = [...handlers, wrappedCallback];\n          }\n          this.bindings[currentName] = handlers;\n        }\n      }\n      return this;\n    }\n    off(name, callback) {\n      if (name) {\n        const names = name.toLowerCase().split(' ');\n        let i = names.length;\n        while (i--) {\n          const currentName = names[i];\n          let handlers = this.bindings[currentName];\n          if (!currentName) {\n            each$d(this.bindings, (_value, bindingName) => {\n              this.toggleEvent(bindingName, false);\n              delete this.bindings[bindingName];\n            });\n            return this;\n          }\n          if (handlers) {\n            if (!callback) {\n              handlers.length = 0;\n            } else {\n              const filteredHandlers = partition$2(handlers, handler => handler.func === callback);\n              handlers = filteredHandlers.fail;\n              this.bindings[currentName] = handlers;\n              each$e(filteredHandlers.pass, handler => {\n                handler.removed = true;\n              });\n            }\n            if (!handlers.length) {\n              this.toggleEvent(name, false);\n              delete this.bindings[currentName];\n            }\n          }\n        }\n      } else {\n        each$d(this.bindings, (_value, name) => {\n          this.toggleEvent(name, false);\n        });\n        this.bindings = {};\n      }\n      return this;\n    }\n    once(name, callback, prepend) {\n      return this.on(name, callback, prepend, {\n        once: true\n      });\n    }\n    has(name) {\n      name = name.toLowerCase();\n      const binding = this.bindings[name];\n      return !(!binding || binding.length === 0);\n    }\n  }\n  const getEventDispatcher = obj => {\n    if (!obj._eventDispatcher) {\n      obj._eventDispatcher = new EventDispatcher({\n        scope: obj,\n        toggleEvent: (name, state) => {\n          if (EventDispatcher.isNative(name) && obj.toggleNativeEvent) {\n            obj.toggleNativeEvent(name, state);\n          }\n        }\n      });\n    }\n    return obj._eventDispatcher;\n  };\n  const Observable = {\n    fire(name, args, bubble) {\n      return this.dispatch(name, args, bubble);\n    },\n    dispatch(name, args, bubble) {\n      const self = this;\n      if (self.removed && name !== 'remove' && name !== 'detach') {\n        return normalize$3(name.toLowerCase(), args !== null && args !== void 0 ? args : {}, self);\n      }\n      const dispatcherArgs = getEventDispatcher(self).dispatch(name, args);\n      if (bubble !== false && self.parent) {\n        let parent = self.parent();\n        while (parent && !dispatcherArgs.isPropagationStopped()) {\n          parent.dispatch(name, dispatcherArgs, false);\n          parent = parent.parent ? parent.parent() : undefined;\n        }\n      }\n      return dispatcherArgs;\n    },\n    on(name, callback, prepend) {\n      return getEventDispatcher(this).on(name, callback, prepend);\n    },\n    off(name, callback) {\n      return getEventDispatcher(this).off(name, callback);\n    },\n    once(name, callback) {\n      return getEventDispatcher(this).once(name, callback);\n    },\n    hasEventListeners(name) {\n      return getEventDispatcher(this).has(name);\n    }\n  };\n  const DOM$2 = DOMUtils.DOM;\n  let customEventRootDelegates;\n  const getEventTarget = (editor, eventName) => {\n    if (eventName === 'selectionchange') {\n      return editor.getDoc();\n    }\n    if (!editor.inline && /^(?:mouse|touch|click|contextmenu|drop|dragover|dragend)/.test(eventName)) {\n      return editor.getDoc().documentElement;\n    }\n    const eventRoot = getEventRoot(editor);\n    if (eventRoot) {\n      if (!editor.eventRoot) {\n        editor.eventRoot = DOM$2.select(eventRoot)[0];\n      }\n      return editor.eventRoot;\n    }\n    return editor.getBody();\n  };\n  const isListening = editor => !editor.hidden;\n  const fireEvent = (editor, eventName, e) => {\n    if (isListening(editor)) {\n      editor.dispatch(eventName, e);\n    } else if (isReadOnly(editor)) {\n      processReadonlyEvents(editor, e);\n    }\n  };\n  const bindEventDelegate = (editor, eventName) => {\n    if (!editor.delegates) {\n      editor.delegates = {};\n    }\n    if (editor.delegates[eventName] || editor.removed) {\n      return;\n    }\n    const eventRootElm = getEventTarget(editor, eventName);\n    if (getEventRoot(editor)) {\n      if (!customEventRootDelegates) {\n        customEventRootDelegates = {};\n        editor.editorManager.on('removeEditor', () => {\n          if (!editor.editorManager.activeEditor) {\n            if (customEventRootDelegates) {\n              each$d(customEventRootDelegates, (_value, name) => {\n                editor.dom.unbind(getEventTarget(editor, name));\n              });\n              customEventRootDelegates = null;\n            }\n          }\n        });\n      }\n      if (customEventRootDelegates[eventName]) {\n        return;\n      }\n      const delegate = e => {\n        const target = e.target;\n        const editors = editor.editorManager.get();\n        let i = editors.length;\n        while (i--) {\n          const body = editors[i].getBody();\n          if (body === target || DOM$2.isChildOf(target, body)) {\n            fireEvent(editors[i], eventName, e);\n          }\n        }\n      };\n      customEventRootDelegates[eventName] = delegate;\n      DOM$2.bind(eventRootElm, eventName, delegate);\n    } else {\n      const delegate = e => {\n        fireEvent(editor, eventName, e);\n      };\n      DOM$2.bind(eventRootElm, eventName, delegate);\n      editor.delegates[eventName] = delegate;\n    }\n  };\n  const EditorObservable = {\n    ...Observable,\n    bindPendingEventDelegates() {\n      const self = this;\n      Tools.each(self._pendingNativeEvents, name => {\n        bindEventDelegate(self, name);\n      });\n    },\n    toggleNativeEvent(name, state) {\n      const self = this;\n      if (name === 'focus' || name === 'blur') {\n        return;\n      }\n      if (self.removed) {\n        return;\n      }\n      if (state) {\n        if (self.initialized) {\n          bindEventDelegate(self, name);\n        } else {\n          if (!self._pendingNativeEvents) {\n            self._pendingNativeEvents = [name];\n          } else {\n            self._pendingNativeEvents.push(name);\n          }\n        }\n      } else if (self.initialized && self.delegates) {\n        self.dom.unbind(getEventTarget(self, name), name, self.delegates[name]);\n        delete self.delegates[name];\n      }\n    },\n    unbindAllNativeEvents() {\n      const self = this;\n      const body = self.getBody();\n      const dom = self.dom;\n      if (self.delegates) {\n        each$d(self.delegates, (value, name) => {\n          self.dom.unbind(getEventTarget(self, name), name, value);\n        });\n        delete self.delegates;\n      }\n      if (!self.inline && body && dom) {\n        body.onload = null;\n        dom.unbind(self.getWin());\n        dom.unbind(self.getDoc());\n      }\n      if (dom) {\n        dom.unbind(body);\n        dom.unbind(self.getContainer());\n      }\n    }\n  };\n  const stringListProcessor = value => {\n    if (isString(value)) {\n      return {\n        value: value.split(/[ ,]/),\n        valid: true\n      };\n    } else if (isArrayOf(value, isString)) {\n      return {\n        value,\n        valid: true\n      };\n    } else {\n      return {\n        valid: false,\n        message: `The value must be a string[] or a comma/space separated string.`\n      };\n    }\n  };\n  const getBuiltInProcessor = type => {\n    const validator = (() => {\n      switch (type) {\n        case 'array':\n          return isArray$1;\n        case 'boolean':\n          return isBoolean;\n        case 'function':\n          return isFunction;\n        case 'number':\n          return isNumber;\n        case 'object':\n          return isObject;\n        case 'string':\n          return isString;\n        case 'string[]':\n          return stringListProcessor;\n        case 'object[]':\n          return val => isArrayOf(val, isObject);\n        case 'regexp':\n          return val => is$4(val, RegExp);\n        default:\n          return always;\n      }\n    })();\n    return value => processValue(value, validator, `The value must be a ${type}.`);\n  };\n  const isBuiltInSpec = spec => isString(spec.processor);\n  const getErrorMessage = (message, result) => {\n    const additionalText = isEmpty$3(result.message) ? '' : `. ${result.message}`;\n    return message + additionalText;\n  };\n  const isValidResult = result => result.valid;\n  const processValue = (value, processor, message = '') => {\n    const result = processor(value);\n    if (isBoolean(result)) {\n      return result ? {\n        value: value,\n        valid: true\n      } : {\n        valid: false,\n        message\n      };\n    } else {\n      return result;\n    }\n  };\n  const processDefaultValue = (name, defaultValue, processor) => {\n    if (!isUndefined(defaultValue)) {\n      const result = processValue(defaultValue, processor);\n      if (isValidResult(result)) {\n        return result.value;\n      } else {\n        console.error(getErrorMessage(`Invalid default value passed for the \"${name}\" option`, result));\n      }\n    }\n    return undefined;\n  };\n  const create$5 = (editor, initialOptions, rawInitialOptions = initialOptions) => {\n    const registry = {};\n    const values = {};\n    const setValue = (name, value, processor) => {\n      const result = processValue(value, processor);\n      if (isValidResult(result)) {\n        values[name] = result.value;\n        return true;\n      } else {\n        console.warn(getErrorMessage(`Invalid value passed for the ${name} option`, result));\n        return false;\n      }\n    };\n    const register = (name, spec) => {\n      const processor = isBuiltInSpec(spec) ? getBuiltInProcessor(spec.processor) : spec.processor;\n      const defaultValue = processDefaultValue(name, spec.default, processor);\n      registry[name] = {\n        ...spec,\n        default: defaultValue,\n        processor\n      };\n      const initValue = get$a(values, name).orThunk(() => get$a(initialOptions, name));\n      initValue.each(value => setValue(name, value, processor));\n    };\n    const isRegistered = name => has$2(registry, name);\n    const get = name => get$a(values, name).orThunk(() => get$a(registry, name).map(spec => spec.default)).getOrUndefined();\n    const set = (name, value) => {\n      if (!isRegistered(name)) {\n        console.warn(`\"${name}\" is not a registered option. Ensure the option has been registered before setting a value.`);\n        return false;\n      } else {\n        const spec = registry[name];\n        if (spec.immutable) {\n          console.error(`\"${name}\" is an immutable option and cannot be updated`);\n          return false;\n        } else {\n          return setValue(name, value, spec.processor);\n        }\n      }\n    };\n    const unset = name => {\n      const registered = isRegistered(name);\n      if (registered) {\n        delete values[name];\n      }\n      return registered;\n    };\n    const isSet = name => has$2(values, name);\n    const debug = () => {\n      try {\n        console.log(JSON.parse(JSON.stringify(rawInitialOptions, (_key, value) => {\n          if (isBoolean(value) || isNumber(value) || isString(value) || isNull(value) || isArray$1(value) || isPlainObject(value)) {\n            return value;\n          }\n          return Object.prototype.toString.call(value);\n        })));\n      } catch (error) {\n        console.error(error);\n      }\n    };\n    return {\n      register,\n      isRegistered,\n      get,\n      set,\n      unset,\n      isSet,\n      debug\n    };\n  };\n  const defaultModes = ['design', 'readonly'];\n  const switchToMode = (editor, activeMode, availableModes, mode) => {\n    const oldMode = availableModes[activeMode.get()];\n    const newMode = availableModes[mode];\n    try {\n      newMode.activate();\n    } catch (e) {\n      console.error(`problem while activating editor mode ${mode}:`, e);\n      return;\n    }\n    oldMode.deactivate();\n    if (oldMode.editorReadOnly !== newMode.editorReadOnly) {\n      toggleReadOnly(editor, newMode.editorReadOnly);\n    }\n    activeMode.set(mode);\n    fireSwitchMode(editor, mode);\n  };\n  const setMode = (editor, availableModes, activeMode, mode) => {\n    if (mode === activeMode.get()) {\n      return;\n    } else if (!has$2(availableModes, mode)) {\n      throw new Error(`Editor mode '${mode}' is invalid`);\n    }\n    if (editor.initialized) {\n      switchToMode(editor, activeMode, availableModes, mode);\n    } else {\n      editor.on('init', () => switchToMode(editor, activeMode, availableModes, mode));\n    }\n  };\n  const registerMode = (availableModes, mode, api) => {\n    if (contains$2(defaultModes, mode)) {\n      throw new Error(`Cannot override default mode ${mode}`);\n    }\n    return {\n      ...availableModes,\n      [mode]: {\n        ...api,\n        deactivate: () => {\n          try {\n            api.deactivate();\n          } catch (e) {\n            console.error(`problem while deactivating editor mode ${mode}:`, e);\n          }\n        }\n      }\n    };\n  };\n  const create$4 = editor => {\n    const activeMode = Cell('design');\n    const availableModes = Cell({\n      design: {\n        activate: noop,\n        deactivate: noop,\n        editorReadOnly: false\n      },\n      readonly: {\n        activate: noop,\n        deactivate: noop,\n        editorReadOnly: true\n      }\n    });\n    registerReadOnlySelectionBlockers(editor);\n    return {\n      isReadOnly: () => isReadOnly(editor),\n      set: mode => setMode(editor, availableModes.get(), activeMode, mode),\n      get: () => activeMode.get(),\n      register: (mode, api) => {\n        availableModes.set(registerMode(availableModes.get(), mode, api));\n      }\n    };\n  };\n  const each$2 = Tools.each,\n    explode = Tools.explode;\n  const keyCodeLookup = {\n    f1: 112,\n    f2: 113,\n    f3: 114,\n    f4: 115,\n    f5: 116,\n    f6: 117,\n    f7: 118,\n    f8: 119,\n    f9: 120,\n    f10: 121,\n    f11: 122,\n    f12: 123\n  };\n  const modifierNames = Tools.makeMap('alt,ctrl,shift,meta,access');\n  const isModifier = key => key in modifierNames;\n  const parseShortcut = pattern => {\n    const shortcut = {};\n    const isMac = Env.os.isMacOS() || Env.os.isiOS();\n    each$2(explode(pattern.toLowerCase(), '+'), value => {\n      if (isModifier(value)) {\n        shortcut[value] = true;\n      } else {\n        if (/^[0-9]{2,}$/.test(value)) {\n          shortcut.keyCode = parseInt(value, 10);\n        } else {\n          shortcut.charCode = value.charCodeAt(0);\n          shortcut.keyCode = keyCodeLookup[value] || value.toUpperCase().charCodeAt(0);\n        }\n      }\n    });\n    const id = [shortcut.keyCode];\n    let key;\n    for (key in modifierNames) {\n      if (shortcut[key]) {\n        id.push(key);\n      } else {\n        shortcut[key] = false;\n      }\n    }\n    shortcut.id = id.join(',');\n    if (shortcut.access) {\n      shortcut.alt = true;\n      if (isMac) {\n        shortcut.ctrl = true;\n      } else {\n        shortcut.shift = true;\n      }\n    }\n    if (shortcut.meta) {\n      if (isMac) {\n        shortcut.meta = true;\n      } else {\n        shortcut.ctrl = true;\n        shortcut.meta = false;\n      }\n    }\n    return shortcut;\n  };\n  class Shortcuts {\n    constructor(editor) {\n      this.shortcuts = {};\n      this.pendingPatterns = [];\n      this.editor = editor;\n      const self = this;\n      editor.on('keyup keypress keydown', e => {\n        if ((self.hasModifier(e) || self.isFunctionKey(e)) && !e.isDefaultPrevented()) {\n          each$2(self.shortcuts, shortcut => {\n            if (self.matchShortcut(e, shortcut)) {\n              self.pendingPatterns = shortcut.subpatterns.slice(0);\n              if (e.type === 'keydown') {\n                self.executeShortcutAction(shortcut);\n              }\n            }\n          });\n          if (self.matchShortcut(e, self.pendingPatterns[0])) {\n            if (self.pendingPatterns.length === 1) {\n              if (e.type === 'keydown') {\n                self.executeShortcutAction(self.pendingPatterns[0]);\n              }\n            }\n            self.pendingPatterns.shift();\n          }\n        }\n      });\n    }\n    add(pattern, desc, cmdFunc, scope) {\n      const self = this;\n      const func = self.normalizeCommandFunc(cmdFunc);\n      each$2(explode(Tools.trim(pattern)), pattern => {\n        const shortcut = self.createShortcut(pattern, desc, func, scope);\n        self.shortcuts[shortcut.id] = shortcut;\n      });\n      return true;\n    }\n    remove(pattern) {\n      const shortcut = this.createShortcut(pattern);\n      if (this.shortcuts[shortcut.id]) {\n        delete this.shortcuts[shortcut.id];\n        return true;\n      }\n      return false;\n    }\n    normalizeCommandFunc(cmdFunc) {\n      const self = this;\n      const cmd = cmdFunc;\n      if (typeof cmd === 'string') {\n        return () => {\n          self.editor.execCommand(cmd, false, null);\n        };\n      } else if (Tools.isArray(cmd)) {\n        return () => {\n          self.editor.execCommand(cmd[0], cmd[1], cmd[2]);\n        };\n      } else {\n        return cmd;\n      }\n    }\n    createShortcut(pattern, desc, cmdFunc, scope) {\n      const shortcuts = Tools.map(explode(pattern, '>'), parseShortcut);\n      shortcuts[shortcuts.length - 1] = Tools.extend(shortcuts[shortcuts.length - 1], {\n        func: cmdFunc,\n        scope: scope || this.editor\n      });\n      return Tools.extend(shortcuts[0], {\n        desc: this.editor.translate(desc),\n        subpatterns: shortcuts.slice(1)\n      });\n    }\n    hasModifier(e) {\n      return e.altKey || e.ctrlKey || e.metaKey;\n    }\n    isFunctionKey(e) {\n      return e.type === 'keydown' && e.keyCode >= 112 && e.keyCode <= 123;\n    }\n    matchShortcut(e, shortcut) {\n      if (!shortcut) {\n        return false;\n      }\n      if (shortcut.ctrl !== e.ctrlKey || shortcut.meta !== e.metaKey) {\n        return false;\n      }\n      if (shortcut.alt !== e.altKey || shortcut.shift !== e.shiftKey) {\n        return false;\n      }\n      if (e.keyCode === shortcut.keyCode || e.charCode && e.charCode === shortcut.charCode) {\n        e.preventDefault();\n        return true;\n      }\n      return false;\n    }\n    executeShortcutAction(shortcut) {\n      return shortcut.func ? shortcut.func.call(shortcut.scope) : null;\n    }\n  }\n  const create$3 = () => {\n    const buttons = {};\n    const menuItems = {};\n    const popups = {};\n    const icons = {};\n    const contextMenus = {};\n    const contextToolbars = {};\n    const contexts = {};\n    const sidebars = {};\n    const views = {};\n    const add = (collection, type) => (name, spec) => {\n      collection[name.toLowerCase()] = {\n        ...spec,\n        type\n      };\n    };\n    const addIcon = (name, svgData) => icons[name.toLowerCase()] = svgData;\n    const addContext = (name, pred) => contexts[name.toLowerCase()] = pred;\n    return {\n      addButton: add(buttons, 'button'),\n      addGroupToolbarButton: add(buttons, 'grouptoolbarbutton'),\n      addToggleButton: add(buttons, 'togglebutton'),\n      addMenuButton: add(buttons, 'menubutton'),\n      addSplitButton: add(buttons, 'splitbutton'),\n      addMenuItem: add(menuItems, 'menuitem'),\n      addNestedMenuItem: add(menuItems, 'nestedmenuitem'),\n      addToggleMenuItem: add(menuItems, 'togglemenuitem'),\n      addAutocompleter: add(popups, 'autocompleter'),\n      addContextMenu: add(contextMenus, 'contextmenu'),\n      addContextToolbar: add(contextToolbars, 'contexttoolbar'),\n      addContextForm: add(contextToolbars, 'contextform'),\n      addSidebar: add(sidebars, 'sidebar'),\n      addView: add(views, 'views'),\n      addIcon,\n      addContext,\n      getAll: () => ({\n        buttons,\n        menuItems,\n        icons,\n        popups,\n        contextMenus,\n        contextToolbars,\n        sidebars,\n        views,\n        contexts\n      })\n    };\n  };\n  const registry = () => {\n    const bridge = create$3();\n    return {\n      addAutocompleter: bridge.addAutocompleter,\n      addButton: bridge.addButton,\n      addContextForm: bridge.addContextForm,\n      addContextMenu: bridge.addContextMenu,\n      addContextToolbar: bridge.addContextToolbar,\n      addIcon: bridge.addIcon,\n      addMenuButton: bridge.addMenuButton,\n      addMenuItem: bridge.addMenuItem,\n      addNestedMenuItem: bridge.addNestedMenuItem,\n      addSidebar: bridge.addSidebar,\n      addSplitButton: bridge.addSplitButton,\n      addToggleButton: bridge.addToggleButton,\n      addGroupToolbarButton: bridge.addGroupToolbarButton,\n      addToggleMenuItem: bridge.addToggleMenuItem,\n      addView: bridge.addView,\n      addContext: bridge.addContext,\n      getAll: bridge.getAll\n    };\n  };\n  const DOM$1 = DOMUtils.DOM;\n  const extend = Tools.extend,\n    each$1 = Tools.each;\n  class Editor {\n    constructor(id, options, editorManager) {\n      this.plugins = {};\n      this.contentCSS = [];\n      this.contentStyles = [];\n      this.loadedCSS = {};\n      this.isNotDirty = false;\n      this.composing = false;\n      this.destroyed = false;\n      this.hasHiddenInput = false;\n      this.iframeElement = null;\n      this.initialized = false;\n      this.readonly = false;\n      this.removed = false;\n      this.startContent = '';\n      this._pendingNativeEvents = [];\n      this._skinLoaded = false;\n      this._editableRoot = true;\n      this.editorManager = editorManager;\n      this.documentBaseUrl = editorManager.documentBaseURL;\n      extend(this, EditorObservable);\n      const self = this;\n      this.id = id;\n      this.hidden = false;\n      const normalizedOptions = normalizeOptions(editorManager.defaultOptions, options);\n      this.options = create$5(self, normalizedOptions, options);\n      register$7(self);\n      const getOption = this.options.get;\n      if (getOption('deprecation_warnings')) {\n        logWarnings(options, normalizedOptions);\n      }\n      const suffix = getOption('suffix');\n      if (suffix) {\n        editorManager.suffix = suffix;\n      }\n      this.suffix = editorManager.suffix;\n      const baseUrl = getOption('base_url');\n      if (baseUrl) {\n        editorManager._setBaseUrl(baseUrl);\n      }\n      this.baseUri = editorManager.baseURI;\n      const referrerPolicy = getReferrerPolicy(self);\n      if (referrerPolicy) {\n        ScriptLoader.ScriptLoader._setReferrerPolicy(referrerPolicy);\n        DOMUtils.DOM.styleSheetLoader._setReferrerPolicy(referrerPolicy);\n      }\n      const contentCssCors = hasContentCssCors(self);\n      if (isNonNullable(contentCssCors)) {\n        DOMUtils.DOM.styleSheetLoader._setContentCssCors(contentCssCors);\n      }\n      AddOnManager.languageLoad = getOption('language_load');\n      AddOnManager.baseURL = editorManager.baseURL;\n      this.setDirty(false);\n      this.documentBaseURI = new URI(getDocumentBaseUrl(self), {\n        base_uri: this.baseUri\n      });\n      this.baseURI = this.baseUri;\n      this.inline = isInline$1(self);\n      this.hasVisual = isVisualAidsEnabled(self);\n      this.shortcuts = new Shortcuts(this);\n      this.editorCommands = new EditorCommands(this);\n      registerCommands(this);\n      const cacheSuffix = getOption('cache_suffix');\n      if (cacheSuffix) {\n        Env.cacheSuffix = cacheSuffix.replace(/^[\\?\\&]+/, '');\n      }\n      this.ui = {\n        registry: registry(),\n        styleSheetLoader: undefined,\n        show: noop,\n        hide: noop,\n        setEnabled: noop,\n        isEnabled: always\n      };\n      this.mode = create$4(self);\n      editorManager.dispatch('SetupEditor', {\n        editor: this\n      });\n      const setupCallback = getSetupCallback(self);\n      if (isFunction(setupCallback)) {\n        setupCallback.call(self, self);\n      }\n    }\n    render() {\n      render(this);\n    }\n    focus(skipFocus) {\n      this.execCommand('mceFocus', false, skipFocus);\n    }\n    hasFocus() {\n      return hasFocus(this);\n    }\n    translate(text) {\n      return I18n.translate(text);\n    }\n    getParam(name, defaultVal, type) {\n      const options = this.options;\n      if (!options.isRegistered(name)) {\n        if (isNonNullable(type)) {\n          options.register(name, {\n            processor: type,\n            default: defaultVal\n          });\n        } else {\n          options.register(name, {\n            processor: always,\n            default: defaultVal\n          });\n        }\n      }\n      return !options.isSet(name) && !isUndefined(defaultVal) ? defaultVal : options.get(name);\n    }\n    hasPlugin(name, loaded) {\n      const hasPlugin = contains$2(getPlugins(this), name);\n      if (hasPlugin) {\n        return loaded ? PluginManager.get(name) !== undefined : true;\n      } else {\n        return false;\n      }\n    }\n    nodeChanged(args) {\n      this._nodeChangeDispatcher.nodeChanged(args);\n    }\n    addCommand(name, callback, scope) {\n      this.editorCommands.addCommand(name, callback, scope);\n    }\n    addQueryStateHandler(name, callback, scope) {\n      this.editorCommands.addQueryStateHandler(name, callback, scope);\n    }\n    addQueryValueHandler(name, callback, scope) {\n      this.editorCommands.addQueryValueHandler(name, callback, scope);\n    }\n    addShortcut(pattern, desc, cmdFunc, scope) {\n      this.shortcuts.add(pattern, desc, cmdFunc, scope);\n    }\n    execCommand(cmd, ui, value, args) {\n      return this.editorCommands.execCommand(cmd, ui, value, args);\n    }\n    queryCommandState(cmd) {\n      return this.editorCommands.queryCommandState(cmd);\n    }\n    queryCommandValue(cmd) {\n      return this.editorCommands.queryCommandValue(cmd);\n    }\n    queryCommandSupported(cmd) {\n      return this.editorCommands.queryCommandSupported(cmd);\n    }\n    show() {\n      const self = this;\n      if (self.hidden) {\n        self.hidden = false;\n        if (self.inline) {\n          self.getBody().contentEditable = 'true';\n        } else {\n          DOM$1.show(self.getContainer());\n          DOM$1.hide(self.id);\n        }\n        self.load();\n        self.dispatch('show');\n      }\n    }\n    hide() {\n      const self = this;\n      if (!self.hidden) {\n        self.save();\n        if (self.inline) {\n          self.getBody().contentEditable = 'false';\n          if (self === self.editorManager.focusedEditor) {\n            self.editorManager.focusedEditor = null;\n          }\n        } else {\n          DOM$1.hide(self.getContainer());\n          DOM$1.setStyle(self.id, 'display', self.orgDisplay);\n        }\n        self.hidden = true;\n        self.dispatch('hide');\n      }\n    }\n    isHidden() {\n      return this.hidden;\n    }\n    setProgressState(state, time) {\n      this.dispatch('ProgressState', {\n        state,\n        time\n      });\n    }\n    load(args = {}) {\n      const self = this;\n      const elm = self.getElement();\n      if (self.removed) {\n        return '';\n      }\n      if (elm) {\n        const loadArgs = {\n          ...args,\n          load: true\n        };\n        const value = isTextareaOrInput(elm) ? elm.value : elm.innerHTML;\n        const html = self.setContent(value, loadArgs);\n        if (!loadArgs.no_events) {\n          self.dispatch('LoadContent', {\n            ...loadArgs,\n            element: elm\n          });\n        }\n        return html;\n      } else {\n        return '';\n      }\n    }\n    save(args = {}) {\n      const self = this;\n      let elm = self.getElement();\n      if (!elm || !self.initialized || self.removed) {\n        return '';\n      }\n      const getArgs = {\n        ...args,\n        save: true,\n        element: elm\n      };\n      let html = self.getContent(getArgs);\n      const saveArgs = {\n        ...getArgs,\n        content: html\n      };\n      if (!saveArgs.no_events) {\n        self.dispatch('SaveContent', saveArgs);\n      }\n      if (saveArgs.format === 'raw') {\n        self.dispatch('RawSaveContent', saveArgs);\n      }\n      html = saveArgs.content;\n      if (!isTextareaOrInput(elm)) {\n        if (args.is_removing || !self.inline) {\n          elm.innerHTML = html;\n        }\n        const form = DOM$1.getParent(self.id, 'form');\n        if (form) {\n          each$1(form.elements, elm => {\n            if (elm.name === self.id) {\n              elm.value = html;\n              return false;\n            } else {\n              return true;\n            }\n          });\n        }\n      } else {\n        elm.value = html;\n      }\n      saveArgs.element = getArgs.element = elm = null;\n      if (saveArgs.set_dirty !== false) {\n        self.setDirty(false);\n      }\n      return html;\n    }\n    setContent(content, args) {\n      return setContent(this, content, args);\n    }\n    getContent(args) {\n      return getContent(this, args);\n    }\n    insertContent(content, args) {\n      if (args) {\n        content = extend({\n          content\n        }, args);\n      }\n      this.execCommand('mceInsertContent', false, content);\n    }\n    resetContent(initialContent) {\n      if (initialContent === undefined) {\n        setContent(this, this.startContent, {\n          format: 'raw'\n        });\n      } else {\n        setContent(this, initialContent);\n      }\n      this.undoManager.reset();\n      this.setDirty(false);\n      this.nodeChanged();\n    }\n    isDirty() {\n      return !this.isNotDirty;\n    }\n    setDirty(state) {\n      const oldState = !this.isNotDirty;\n      this.isNotDirty = !state;\n      if (state && state !== oldState) {\n        this.dispatch('dirty');\n      }\n    }\n    getContainer() {\n      const self = this;\n      if (!self.container) {\n        self.container = self.editorContainer || DOM$1.get(self.id + '_parent');\n      }\n      return self.container;\n    }\n    getContentAreaContainer() {\n      return this.contentAreaContainer;\n    }\n    getElement() {\n      if (!this.targetElm) {\n        this.targetElm = DOM$1.get(this.id);\n      }\n      return this.targetElm;\n    }\n    getWin() {\n      const self = this;\n      if (!self.contentWindow) {\n        const elm = self.iframeElement;\n        if (elm) {\n          self.contentWindow = elm.contentWindow;\n        }\n      }\n      return self.contentWindow;\n    }\n    getDoc() {\n      const self = this;\n      if (!self.contentDocument) {\n        const win = self.getWin();\n        if (win) {\n          self.contentDocument = win.document;\n        }\n      }\n      return self.contentDocument;\n    }\n    getBody() {\n      var _a, _b;\n      const doc = this.getDoc();\n      return (_b = (_a = this.bodyElement) !== null && _a !== void 0 ? _a : doc === null || doc === void 0 ? void 0 : doc.body) !== null && _b !== void 0 ? _b : null;\n    }\n    convertURL(url, name, elm) {\n      const self = this,\n        getOption = self.options.get;\n      const urlConverterCallback = getUrlConverterCallback(self);\n      if (isFunction(urlConverterCallback)) {\n        return urlConverterCallback.call(self, url, elm, true, name);\n      }\n      if (!getOption('convert_urls') || elm === 'link' || isObject(elm) && elm.nodeName === 'LINK' || url.indexOf('file:') === 0 || url.length === 0) {\n        return url;\n      }\n      const urlObject = new URI(url);\n      if (urlObject.protocol !== 'http' && urlObject.protocol !== 'https' && urlObject.protocol !== '') {\n        return url;\n      }\n      if (getOption('relative_urls')) {\n        return self.documentBaseURI.toRelative(url);\n      }\n      url = self.documentBaseURI.toAbsolute(url, getOption('remove_script_host'));\n      return url;\n    }\n    addVisual(elm) {\n      addVisual(this, elm);\n    }\n    setEditableRoot(state) {\n      setEditableRoot(this, state);\n    }\n    hasEditableRoot() {\n      return hasEditableRoot(this);\n    }\n    remove() {\n      remove$1(this);\n    }\n    destroy(automatic) {\n      destroy(this, automatic);\n    }\n    uploadImages() {\n      return this.editorUpload.uploadImages();\n    }\n    _scanForImages() {\n      return this.editorUpload.scanForImages();\n    }\n  }\n  const DOM = DOMUtils.DOM;\n  const each = Tools.each;\n  let boundGlobalEvents = false;\n  let beforeUnloadDelegate;\n  let editors = [];\n  const globalEventDelegate = e => {\n    const type = e.type;\n    each(EditorManager.get(), editor => {\n      switch (type) {\n        case 'scroll':\n          editor.dispatch('ScrollWindow', e);\n          break;\n        case 'resize':\n          editor.dispatch('ResizeWindow', e);\n          break;\n      }\n    });\n  };\n  const toggleGlobalEvents = state => {\n    if (state !== boundGlobalEvents) {\n      const DOM = DOMUtils.DOM;\n      if (state) {\n        DOM.bind(window, 'resize', globalEventDelegate);\n        DOM.bind(window, 'scroll', globalEventDelegate);\n      } else {\n        DOM.unbind(window, 'resize', globalEventDelegate);\n        DOM.unbind(window, 'scroll', globalEventDelegate);\n      }\n      boundGlobalEvents = state;\n    }\n  };\n  const removeEditorFromList = targetEditor => {\n    const oldEditors = editors;\n    editors = filter$5(editors, editor => {\n      return targetEditor !== editor;\n    });\n    if (EditorManager.activeEditor === targetEditor) {\n      EditorManager.activeEditor = editors.length > 0 ? editors[0] : null;\n    }\n    if (EditorManager.focusedEditor === targetEditor) {\n      EditorManager.focusedEditor = null;\n    }\n    return oldEditors.length !== editors.length;\n  };\n  const purgeDestroyedEditor = editor => {\n    if (editor && editor.initialized && !(editor.getContainer() || editor.getBody()).parentNode) {\n      removeEditorFromList(editor);\n      editor.unbindAllNativeEvents();\n      editor.destroy(true);\n      editor.removed = true;\n    }\n  };\n  const isQuirksMode = document.compatMode !== 'CSS1Compat';\n  const EditorManager = {\n    ...Observable,\n    baseURI: null,\n    baseURL: null,\n    defaultOptions: {},\n    documentBaseURL: null,\n    suffix: null,\n    majorVersion: '7',\n    minorVersion: '5.1',\n    releaseDate: 'TBD',\n    i18n: I18n,\n    activeEditor: null,\n    focusedEditor: null,\n    setup() {\n      const self = this;\n      let baseURL = '';\n      let suffix = '';\n      let documentBaseURL = URI.getDocumentBaseUrl(document.location);\n      if (/^[^:]+:\\/\\/\\/?[^\\/]+\\//.test(documentBaseURL)) {\n        documentBaseURL = documentBaseURL.replace(/[\\?#].*$/, '').replace(/[\\/\\\\][^\\/]+$/, '');\n        if (!/[\\/\\\\]$/.test(documentBaseURL)) {\n          documentBaseURL += '/';\n        }\n      }\n      const preInit = window.tinymce || window.tinyMCEPreInit;\n      if (preInit) {\n        baseURL = preInit.base || preInit.baseURL;\n        suffix = preInit.suffix;\n      } else {\n        const scripts = document.getElementsByTagName('script');\n        for (let i = 0; i < scripts.length; i++) {\n          const src = scripts[i].src || '';\n          if (src === '') {\n            continue;\n          }\n          const srcScript = src.substring(src.lastIndexOf('/'));\n          if (/tinymce(\\.full|\\.jquery|)(\\.min|\\.dev|)\\.js/.test(src)) {\n            if (srcScript.indexOf('.min') !== -1) {\n              suffix = '.min';\n            }\n            baseURL = src.substring(0, src.lastIndexOf('/'));\n            break;\n          }\n        }\n        if (!baseURL && document.currentScript) {\n          const src = document.currentScript.src;\n          if (src.indexOf('.min') !== -1) {\n            suffix = '.min';\n          }\n          baseURL = src.substring(0, src.lastIndexOf('/'));\n        }\n      }\n      self.baseURL = new URI(documentBaseURL).toAbsolute(baseURL);\n      self.documentBaseURL = documentBaseURL;\n      self.baseURI = new URI(self.baseURL);\n      self.suffix = suffix;\n      setup$w(self);\n    },\n    overrideDefaults(defaultOptions) {\n      const baseUrl = defaultOptions.base_url;\n      if (baseUrl) {\n        this._setBaseUrl(baseUrl);\n      }\n      const suffix = defaultOptions.suffix;\n      if (suffix) {\n        this.suffix = suffix;\n      }\n      this.defaultOptions = defaultOptions;\n      const pluginBaseUrls = defaultOptions.plugin_base_urls;\n      if (pluginBaseUrls !== undefined) {\n        each$d(pluginBaseUrls, (pluginBaseUrl, pluginName) => {\n          AddOnManager.PluginManager.urls[pluginName] = pluginBaseUrl;\n        });\n      }\n    },\n    init(options) {\n      const self = this;\n      let result;\n      const invalidInlineTargets = Tools.makeMap('area base basefont br col frame hr img input isindex link meta param embed source wbr track ' + 'colgroup option table tbody tfoot thead tr th td script noscript style textarea video audio iframe object menu', ' ');\n      const isInvalidInlineTarget = (options, elm) => options.inline && elm.tagName.toLowerCase() in invalidInlineTargets;\n      const createId = elm => {\n        let id = elm.id;\n        if (!id) {\n          id = get$a(elm, 'name').filter(name => !DOM.get(name)).getOrThunk(DOM.uniqueId);\n          elm.setAttribute('id', id);\n        }\n        return id;\n      };\n      const execCallback = name => {\n        const callback = options[name];\n        if (!callback) {\n          return;\n        }\n        return callback.apply(self, []);\n      };\n      const findTargets = options => {\n        if (Env.browser.isIE() || Env.browser.isEdge()) {\n          initError('TinyMCE does not support the browser you are using. For a list of supported' + ' browsers please see: https://www.tiny.cloud/docs/tinymce/7/support/#supportedwebbrowsers');\n          return [];\n        } else if (isQuirksMode) {\n          initError('Failed to initialize the editor as the document is not in standards mode. ' + 'TinyMCE requires standards mode.');\n          return [];\n        } else if (isString(options.selector)) {\n          return DOM.select(options.selector);\n        } else if (isNonNullable(options.target)) {\n          return [options.target];\n        } else {\n          return [];\n        }\n      };\n      let provideResults = editors => {\n        result = editors;\n      };\n      const initEditors = () => {\n        let initCount = 0;\n        const editors = [];\n        let targets;\n        const createEditor = (id, options, targetElm) => {\n          const editor = new Editor(id, options, self);\n          editors.push(editor);\n          editor.on('init', () => {\n            if (++initCount === targets.length) {\n              provideResults(editors);\n            }\n          });\n          editor.targetElm = editor.targetElm || targetElm;\n          editor.render();\n        };\n        DOM.unbind(window, 'ready', initEditors);\n        execCallback('onpageload');\n        targets = unique$1(findTargets(options));\n        Tools.each(targets, elm => {\n          purgeDestroyedEditor(self.get(elm.id));\n        });\n        targets = Tools.grep(targets, elm => {\n          return !self.get(elm.id);\n        });\n        if (targets.length === 0) {\n          provideResults([]);\n        } else {\n          each(targets, elm => {\n            if (isInvalidInlineTarget(options, elm)) {\n              initError('Could not initialize inline editor on invalid inline target element', elm);\n            } else {\n              createEditor(createId(elm), options, elm);\n            }\n          });\n        }\n      };\n      DOM.bind(window, 'ready', initEditors);\n      return new Promise(resolve => {\n        if (result) {\n          resolve(result);\n        } else {\n          provideResults = editors => {\n            resolve(editors);\n          };\n        }\n      });\n    },\n    get(id) {\n      if (arguments.length === 0) {\n        return editors.slice(0);\n      } else if (isString(id)) {\n        return find$2(editors, editor => {\n          return editor.id === id;\n        }).getOr(null);\n      } else if (isNumber(id)) {\n        return editors[id] ? editors[id] : null;\n      } else {\n        return null;\n      }\n    },\n    add(editor) {\n      const self = this;\n      const existingEditor = self.get(editor.id);\n      if (existingEditor === editor) {\n        return editor;\n      }\n      if (existingEditor === null) {\n        editors.push(editor);\n      }\n      toggleGlobalEvents(true);\n      self.activeEditor = editor;\n      self.dispatch('AddEditor', {\n        editor\n      });\n      if (!beforeUnloadDelegate) {\n        beforeUnloadDelegate = e => {\n          const event = self.dispatch('BeforeUnload');\n          if (event.returnValue) {\n            e.preventDefault();\n            e.returnValue = event.returnValue;\n            return event.returnValue;\n          }\n        };\n        window.addEventListener('beforeunload', beforeUnloadDelegate);\n      }\n      return editor;\n    },\n    createEditor(id, options) {\n      return this.add(new Editor(id, options, this));\n    },\n    remove(selector) {\n      const self = this;\n      let editor;\n      if (!selector) {\n        for (let i = editors.length - 1; i >= 0; i--) {\n          self.remove(editors[i]);\n        }\n        return;\n      }\n      if (isString(selector)) {\n        each(DOM.select(selector), elm => {\n          editor = self.get(elm.id);\n          if (editor) {\n            self.remove(editor);\n          }\n        });\n        return;\n      }\n      editor = selector;\n      if (isNull(self.get(editor.id))) {\n        return null;\n      }\n      if (removeEditorFromList(editor)) {\n        self.dispatch('RemoveEditor', {\n          editor\n        });\n      }\n      if (editors.length === 0) {\n        window.removeEventListener('beforeunload', beforeUnloadDelegate);\n      }\n      editor.remove();\n      toggleGlobalEvents(editors.length > 0);\n      return editor;\n    },\n    execCommand(cmd, ui, value) {\n      var _a;\n      const self = this;\n      const editorId = isObject(value) ? (_a = value.id) !== null && _a !== void 0 ? _a : value.index : value;\n      switch (cmd) {\n        case 'mceAddEditor':\n          {\n            if (!self.get(editorId)) {\n              const editorOptions = value.options;\n              new Editor(editorId, editorOptions, self).render();\n            }\n            return true;\n          }\n        case 'mceRemoveEditor':\n          {\n            const editor = self.get(editorId);\n            if (editor) {\n              editor.remove();\n            }\n            return true;\n          }\n        case 'mceToggleEditor':\n          {\n            const editor = self.get(editorId);\n            if (!editor) {\n              self.execCommand('mceAddEditor', false, value);\n              return true;\n            }\n            if (editor.isHidden()) {\n              editor.show();\n            } else {\n              editor.hide();\n            }\n            return true;\n          }\n      }\n      if (self.activeEditor) {\n        return self.activeEditor.execCommand(cmd, ui, value);\n      }\n      return false;\n    },\n    triggerSave: () => {\n      each(editors, editor => {\n        editor.save();\n      });\n    },\n    addI18n: (code, items) => {\n      I18n.add(code, items);\n    },\n    translate: text => {\n      return I18n.translate(text);\n    },\n    setActive(editor) {\n      const activeEditor = this.activeEditor;\n      if (this.activeEditor !== editor) {\n        if (activeEditor) {\n          activeEditor.dispatch('deactivate', {\n            relatedTarget: editor\n          });\n        }\n        editor.dispatch('activate', {\n          relatedTarget: activeEditor\n        });\n      }\n      this.activeEditor = editor;\n    },\n    _setBaseUrl(baseUrl) {\n      this.baseURL = new URI(this.documentBaseURL).toAbsolute(baseUrl.replace(/\\/+$/, ''));\n      this.baseURI = new URI(this.baseURL);\n    }\n  };\n  EditorManager.setup();\n  const setup = () => {\n    const dataValue = value$2();\n    const FakeClipboardItem = items => ({\n      items,\n      types: keys(items),\n      getType: type => get$a(items, type).getOrUndefined()\n    });\n    const write = data => {\n      dataValue.set(data);\n    };\n    const read = () => dataValue.get().getOrUndefined();\n    const clear = dataValue.clear;\n    return {\n      FakeClipboardItem,\n      write,\n      read,\n      clear\n    };\n  };\n  const FakeClipboard = setup();\n  const min = Math.min,\n    max = Math.max,\n    round = Math.round;\n  const relativePosition = (rect, targetRect, rel) => {\n    let x = targetRect.x;\n    let y = targetRect.y;\n    const w = rect.w;\n    const h = rect.h;\n    const targetW = targetRect.w;\n    const targetH = targetRect.h;\n    const relChars = (rel || '').split('');\n    if (relChars[0] === 'b') {\n      y += targetH;\n    }\n    if (relChars[1] === 'r') {\n      x += targetW;\n    }\n    if (relChars[0] === 'c') {\n      y += round(targetH / 2);\n    }\n    if (relChars[1] === 'c') {\n      x += round(targetW / 2);\n    }\n    if (relChars[3] === 'b') {\n      y -= h;\n    }\n    if (relChars[4] === 'r') {\n      x -= w;\n    }\n    if (relChars[3] === 'c') {\n      y -= round(h / 2);\n    }\n    if (relChars[4] === 'c') {\n      x -= round(w / 2);\n    }\n    return create$2(x, y, w, h);\n  };\n  const findBestRelativePosition = (rect, targetRect, constrainRect, rels) => {\n    for (let i = 0; i < rels.length; i++) {\n      const pos = relativePosition(rect, targetRect, rels[i]);\n      if (pos.x >= constrainRect.x && pos.x + pos.w <= constrainRect.w + constrainRect.x && pos.y >= constrainRect.y && pos.y + pos.h <= constrainRect.h + constrainRect.y) {\n        return rels[i];\n      }\n    }\n    return null;\n  };\n  const inflate = (rect, w, h) => {\n    return create$2(rect.x - w, rect.y - h, rect.w + w * 2, rect.h + h * 2);\n  };\n  const intersect = (rect, cropRect) => {\n    const x1 = max(rect.x, cropRect.x);\n    const y1 = max(rect.y, cropRect.y);\n    const x2 = min(rect.x + rect.w, cropRect.x + cropRect.w);\n    const y2 = min(rect.y + rect.h, cropRect.y + cropRect.h);\n    if (x2 - x1 < 0 || y2 - y1 < 0) {\n      return null;\n    }\n    return create$2(x1, y1, x2 - x1, y2 - y1);\n  };\n  const clamp = (rect, clampRect, fixedSize) => {\n    let x1 = rect.x;\n    let y1 = rect.y;\n    let x2 = rect.x + rect.w;\n    let y2 = rect.y + rect.h;\n    const cx2 = clampRect.x + clampRect.w;\n    const cy2 = clampRect.y + clampRect.h;\n    const underflowX1 = max(0, clampRect.x - x1);\n    const underflowY1 = max(0, clampRect.y - y1);\n    const overflowX2 = max(0, x2 - cx2);\n    const overflowY2 = max(0, y2 - cy2);\n    x1 += underflowX1;\n    y1 += underflowY1;\n    if (fixedSize) {\n      x2 += underflowX1;\n      y2 += underflowY1;\n      x1 -= overflowX2;\n      y1 -= overflowY2;\n    }\n    x2 -= overflowX2;\n    y2 -= overflowY2;\n    return create$2(x1, y1, x2 - x1, y2 - y1);\n  };\n  const create$2 = (x, y, w, h) => {\n    return {\n      x,\n      y,\n      w,\n      h\n    };\n  };\n  const fromClientRect = clientRect => {\n    return create$2(clientRect.left, clientRect.top, clientRect.width, clientRect.height);\n  };\n  const Rect = {\n    inflate,\n    relativePosition,\n    findBestRelativePosition,\n    intersect,\n    clamp,\n    create: create$2,\n    fromClientRect\n  };\n  const awaiter = (resolveCb, rejectCb, timeout = 1000) => {\n    let done = false;\n    let timer = null;\n    const complete = completer => (...args) => {\n      if (!done) {\n        done = true;\n        if (timer !== null) {\n          clearTimeout(timer);\n          timer = null;\n        }\n        completer.apply(null, args);\n      }\n    };\n    const resolve = complete(resolveCb);\n    const reject = complete(rejectCb);\n    const start = (...args) => {\n      if (!done && timer === null) {\n        timer = setTimeout(() => reject.apply(null, args), timeout);\n      }\n    };\n    return {\n      start,\n      resolve,\n      reject\n    };\n  };\n  const create$1 = () => {\n    const tasks = {};\n    const resultFns = {};\n    const resources = {};\n    const load = (id, url) => {\n      const loadErrMsg = `Script at URL \"${url}\" failed to load`;\n      const runErrMsg = `Script at URL \"${url}\" did not call \\`tinymce.Resource.add('${id}', data)\\` within 1 second`;\n      if (tasks[id] !== undefined) {\n        return tasks[id];\n      } else {\n        const task = new Promise((resolve, reject) => {\n          const waiter = awaiter(resolve, reject);\n          resultFns[id] = waiter.resolve;\n          ScriptLoader.ScriptLoader.loadScript(url).then(() => waiter.start(runErrMsg), () => waiter.reject(loadErrMsg));\n        });\n        tasks[id] = task;\n        return task;\n      }\n    };\n    const add = (id, data) => {\n      if (resultFns[id] !== undefined) {\n        resultFns[id](data);\n        delete resultFns[id];\n      }\n      tasks[id] = Promise.resolve(data);\n      resources[id] = data;\n    };\n    const has = id => {\n      return id in resources;\n    };\n    const unload = id => {\n      delete tasks[id];\n      delete resources[id];\n    };\n    const get = id => resources[id];\n    return {\n      load,\n      add,\n      has,\n      get,\n      unload\n    };\n  };\n  const Resource = create$1();\n  const create = () => (() => {\n    let data = {};\n    let keys = [];\n    const storage = {\n      getItem: key => {\n        const item = data[key];\n        return item ? item : null;\n      },\n      setItem: (key, value) => {\n        keys.push(key);\n        data[key] = String(value);\n      },\n      key: index => {\n        return keys[index];\n      },\n      removeItem: key => {\n        keys = keys.filter(k => k === key);\n        delete data[key];\n      },\n      clear: () => {\n        keys = [];\n        data = {};\n      },\n      length: 0\n    };\n    Object.defineProperty(storage, 'length', {\n      get: () => keys.length,\n      configurable: false,\n      enumerable: false\n    });\n    return storage;\n  })();\n  let localStorage;\n  try {\n    const test = '__storage_test__';\n    localStorage = window.localStorage;\n    localStorage.setItem(test, test);\n    localStorage.removeItem(test);\n  } catch (e) {\n    localStorage = create();\n  }\n  var LocalStorage = localStorage;\n  const publicApi = {\n    geom: {\n      Rect\n    },\n    util: {\n      Delay,\n      Tools,\n      VK,\n      URI,\n      EventDispatcher,\n      Observable,\n      I18n,\n      LocalStorage,\n      ImageUploader\n    },\n    dom: {\n      EventUtils,\n      TreeWalker: DomTreeWalker,\n      TextSeeker,\n      DOMUtils,\n      ScriptLoader,\n      RangeUtils,\n      Serializer: DomSerializer,\n      StyleSheetLoader,\n      ControlSelection,\n      BookmarkManager,\n      Selection: EditorSelection,\n      Event: EventUtils.Event\n    },\n    html: {\n      Styles,\n      Entities,\n      Node: AstNode,\n      Schema,\n      DomParser,\n      Writer,\n      Serializer: HtmlSerializer\n    },\n    Env,\n    AddOnManager,\n    Annotator,\n    Formatter,\n    UndoManager,\n    EditorCommands,\n    WindowManager,\n    NotificationManager,\n    EditorObservable,\n    Shortcuts,\n    Editor,\n    FocusManager,\n    EditorManager,\n    DOM: DOMUtils.DOM,\n    ScriptLoader: ScriptLoader.ScriptLoader,\n    PluginManager,\n    ThemeManager,\n    ModelManager,\n    IconManager,\n    Resource,\n    FakeClipboard,\n    trim: Tools.trim,\n    isArray: Tools.isArray,\n    is: Tools.is,\n    toArray: Tools.toArray,\n    makeMap: Tools.makeMap,\n    each: Tools.each,\n    map: Tools.map,\n    grep: Tools.grep,\n    inArray: Tools.inArray,\n    extend: Tools.extend,\n    walk: Tools.walk,\n    resolve: Tools.resolve,\n    explode: Tools.explode,\n    _addCacheSuffix: Tools._addCacheSuffix\n  };\n  const tinymce$1 = Tools.extend(EditorManager, publicApi);\n  const exportToModuleLoaders = tinymce => {\n    if (typeof module === 'object') {\n      try {\n        module.exports = tinymce;\n      } catch (_) {}\n    }\n  };\n  const exportToWindowGlobal = tinymce => {\n    window.tinymce = tinymce;\n    window.tinyMCE = tinymce;\n  };\n  exportToWindowGlobal(tinymce$1);\n  exportToModuleLoaders(tinymce$1);\n})();","map":{"version":3,"names":["typeOf$1","x","undefined","t","Array","prototype","isPrototypeOf","constructor","name","String","isEquatableType","indexOf","sort$1","xs","compareFn","clone","slice","call","sort","contramap","eqa","f","eq$2","y","eq","tripleEq","eqString","eqArray","length","len","i","eqSortedArray","eqRecord","kx","Object","keys","ky","q","eqAny","tx","ty","getPrototypeOf$2","getPrototypeOf","hasProto","v","predicate","_a","typeOf","isArray","o","proto","isType$1","type","value","isSimpleType","eq$1","a","is$4","isObject","isString","isPlainObject","isArray$1","isNull","isBoolean","isUndefined","isNullable","isNonNullable","isFunction","isNumber","isArrayOf","pred","noop","compose","fa","fb","args","apply","compose1","fbc","fab","constant","identity","tripleEquals","b","curry","fn","initialArgs","restArgs","all","concat","not","die","msg","Error","apply$1","never","always","Optional","tag","some","none","singletonNone","fold","onNone","onSome","isSome","isNone","map","mapper","bind","binder","exists","forall","filter","getOr","replacement","or","getOrThunk","thunk","orThunk","getOrDie","message","from","getOrNull","getOrUndefined","each","worker","toArray","toString","nativeSlice","nativeIndexOf","nativePush","push","rawIndexOf","ts","indexOf$1","r","contains$2","map$3","each$e","eachr","partition$2","pass","fail","arr","filter$5","foldr","acc","foldl","findUntil$1","until","find$2","findIndex$2","flatten","bind$3","reverse","difference","a1","a2","mapToObject","comparator","copy","get$b","head","last$2","findMap","unique$1","isDuplicated","hasOwnProperty$1","hasOwnProperty","each$d","obj","props","k","map$2","tupleMap","tuple","objAcc","internalFilter","onTrue","onFalse","bifilter","filter$4","mapToArray","values","get$a","key","has$2","hasNonNullableKey","equal$1","stringArray","isArrayLike","toArray$1","array","l","each$c","cb","s","n","map$1","callback","out","item","index","filter$3","reduce","collection","iteratee","accumulator","thisArg","findIndex$1","last$1","cached","called","DeviceType","os","browser","userAgent","mediaMatch","isiPad","isiOS","test","isiPhone","isMobile","isAndroid","isTouch","isTablet","isPhone","iOSwebview","isSafari","isDesktop","isWebView","firstMatch","regexes","find$1","agent","major","minor","group","Number","replace","nu$3","detect$4","versionRegexes","cleanedAgent","toLowerCase","unknown$2","Version","nu","detect","unknown","detectBrowser$1","browsers","userAgentData","brands","uaBrand","lcBrand","brand","info","current","version","parseInt","detect$3","candidates","candidate","search","detectBrowser","detectOs","oses","removeFromStart","str","numChars","substring","checkRange","substr","start","removeLeading","prefix","startsWith","contains$1","end","idx","endsWith","suffix","blank","trim$4","lTrim","rTrim","isNotEmpty","isEmpty$3","repeat","count","join","toInt","radix","num","isNaN","normalVersionRegex","checkContains","target","uastring","PlatformInfo","edge","chromium","ie","opera","firefox","safari","unknown$1","nu$2","isBrowser","isEdge","isChromium","isIE","isOpera","isFirefox","Browser","windows","ios","android","linux","macos","solaris","freebsd","chromeos","nu$1","isOS","isWindows","isMacOS","isLinux","isSolaris","isFreeBSD","isChromeOS","OperatingSystem","detect$2","userAgentDataOpt","deviceType","PlatformDetection","query","window","matchMedia","matches","platform$4","navigator","detect$1","platform$3","browser$3","os$1","windowsPhone","Env","transparentSrc","documentMode","document","cacheSuffix","container","canHaveCSP","whiteSpaceRegExp$1","trim$3","is$3","makeMap$4","items","delim","resolvedItems","split","extend$3","exts","ext","walk$4","resolve$3","path","explode$3","d","_addCacheSuffix","url","Tools","trim","is","makeMap","grep","inArray","hasOwn","extend","walk","resolve","explode","is$2","lhs","rhs","left","equals","lift2","cat","oa","ob","lift3","oc","someIf","Global","Function","parts","scope","resolve$2","p","unsafe","actual","getPrototypeOf$1","sandHTMLElement","COMMENT","DOCUMENT","DOCUMENT_FRAGMENT","ELEMENT","TEXT","element","dom","nodeName","type$1","nodeType","isType","isComment$1","isHTMLElement$1","isElement$7","isText$c","isDocument$2","isDocumentFragment$1","isTag","e","rawSet","setAttribute","console","error","set$3","setAll$1","attrs","get$9","getAttribute","getOpt","has$1","hasAttribute","remove$9","removeAttribute","hasNone","attributes","clone$4","attr","read$4","add$4","id","old","remove$8","supports","classList","get$8","add$3","clazz","remove$7","toggle$2","add$2","add","cleanClass","remove$6","remove","toggle$1","result","toggle","has","contains","fromHtml$1","html","doc","div","createElement","innerHTML","hasChildNodes","childNodes","fromDom$2","fromTag","node","fromText","text","createTextNode","fromPoint$2","docElm","elementFromPoint","SugarElement","fromHtml","fromDom","fromPoint","recurse","cur","is$1","selector","elem","msMatchesSelector","webkitMatchesSelector","mozMatchesSelector","bypassSelector","childElementCount","base","querySelectorAll","one","querySelector","e1","e2","d1","d2","owner$1","ownerDocument","documentOrOwner","dos","documentElement","defaultView","parent","parentNode","parentElement","parents$1","isRoot","stop","ret","rawParent","siblings","filterSelf","elements","children$1","prevSibling","previousSibling","nextSibling","prevSiblings","nextSiblings","child$1","cs","firstChild","lastChild","childNodesCount","getHead","isShadowRoot","host","getRootNode","getStyleContainer","getContentContainer","body","getShadowRoot","getShadowHost","getOriginalEventTarget","event","el","isOpenShadowHost","composed","composedPath","shadowRoot","inBody","ClosestOrAncestor","ancestor","ancestor$4","closest$4","sibling$1","child","descendant$2","descend","res","ancestor$3","descendant$1","closest$3","closest$2","isEditable$2","assumeEditable","isContentEditable","editable","getRaw$1","contentEditable","isSupported","style","getPropertyValue","internalSet","property","setProperty","internalRemove","removeProperty","set$2","setAll","css","get$7","styles","getComputedStyle","getUnsafeProperty","getRaw","raw","getAllRaw","ruleName","remove$5","reflow","offsetWidth","before$3","marker","parent$1","insertBefore","after$4","sibling","append$1","prepend","firstChild$1","appendChild","wrap$2","wrapper","after$3","append","empty","textContent","rogue","remove$4","removeChild","unwrap","children","fromDom$1","nodes","get$6","set$1","content","owner","docDom","fragment","createDocumentFragment","contentElements","getOuter","cloneNode","mkEvent","prevent","kill","fromRawEvent","rawEvent","stopPropagation","preventDefault","clientX","clientY","handle$1","handler","useCapture","wrapped","addEventListener","unbind","bind$2","removeEventListener","top","translate","SugarPosition","boxPosition","box","getBoundingClientRect","firstDefinedOrZero","absolute","win","offsetLeft","offsetTop","scrollTop","pageYOffset","scrollLeft","pageXOffset","clientTop","clientLeft","viewport","get$5","_DOC","to","scrollTo","intoView","alignToTop","scrollIntoViewIfNeeded","scrollIntoView","get$4","_win","visualViewport","bounds","width","height","right","bottom","getBounds","scroll","clientWidth","clientHeight","Math","max","pageLeft","pageTop","descendants$1","descendants","ancestor$2","descendant","DomTreeWalker","startNode","rootNode","next","prev","prev2","shallow","findSibling","findPreviousNode","startName","siblingName","zeroWidth","nbsp","isZwsp$2","char","removeZwsp","whiteSpaceRegExp","isWhitespaceText","isZwsp$1","c","isCollapsibleWhitespace$1","isNewLineChar","isNewline","normalize$4","tabSpaces","isStartOfContent","isEndOfContent","tabSpace","normalizedText","pcIsSpace","isNodeType","isRestrictedNode","isElement$6","isHTMLElement","isSVGElement","namespaceURI","matchNodeName","lowerCasedName","matchNodeNames","names","lowerCasedNames","matchStyleValues","computed","cssValue","attrName","isBogus$1","isBogusAll","isTable$2","tagName","hasContentEditableState","isTextareaOrInput","isText$b","isCData","isPi","isComment","isDocument$1","isDocumentFragment","isBr$6","isImg","isContentEditableTrue$3","isContentEditableFalse$b","isTableCell$3","isTableCellOrCaption","isMedia$2","isListItem$2","isDetails","isSummary$1","defaultOptionValues","skipBogus","includeZwsp","checkRootAsContent","hasWhitespacePreserveParent","schema","rootElement","whitespaceElements","getWhitespaceElements","isNamedAnchor","isNonEmptyElement$1","getNonEmptyElements","isBookmark","hasNonEditableParent","isWhitespace$1","data","isText$a","options","isContentNode","isContent","isEmptyNode","targetNode","opts","brCount","walker","bogusValue","isEmpty$2","elm","isContent$1","Cell","initial","get","set","singleton","doRevoke","subject","revoke","clear","isSet","repeatable","delay","intervalId","clearInterval","functionToRepeat","setInterval","value$2","on","nodeNameToNamespaceType","lowerCaseName","isNonHtmlElementRootName","isNonHtmlElementRoot","toScopeType","namespaceElements","createNamespaceTracker","currentScope","track","scopeNode","reset","transparentBlockAttr","elementNames","makeSelectorFromSchemaMap","escapedName","CSS","escape","ns","updateTransparent","blocksSelector","transparent","updateBlockStateOnChildren","transparentSelector","getTransparentElements","getBlockElements","trimEdge","leftSide","childPropertyName","split$2","parentElm","splitElm","range","createRange","setStartBefore","setEndBefore","beforeFragment","extractContents","setStartAfter","setEndAfter","afterFragment","splitInvalidChildren","transparentBlocks","blocksElements","isBlock","transparentBlock","parentBlock","invalidChildren","isValidChild","stateScope","unwrapInvalidChildren","isTransparentBlock","block","isTransparentInline","updateChildren","updateElement","isTransparentElement","updateCaret","root","caretParent","parents","hasBlockAttr","isTransparentElementName","isTransparentAstBlock","browser$2","firstElement","getTableCaptionDeltaY","caption","bodyTop","captionTop","captionHeight","offsetHeight","hasChild","getPos","rootElm","pos","offsetParent","castOffsetParent","StyleSheetLoader","documentOrShadowRoot","settings","idCount","loadedStates","edos","_setReferrerPolicy","referrerPolicy","_setContentCssCors","contentCssCors","addStyle","removeStyle","styleContainer","getOrCreateState","passed","failed","load","Promise","success","failure","link","urlWithSuffix","state","callbacks","status","onload","onerror","linkElem","rel","loadRawCss","styleElem","loadAll","urls","loadedUrls","allSettled","then","results","reject","reason","unload","unloadRawCss","unloadAll","create$c","WeakMap","forElement","referenceElement","rootDom","sl","instance","isSpan","isInlineContent","isInline","surroundedByInlineContent","prevIsInline","nextIsInline","isBookmarkNode$2","isKeepTextNode","isKeepElement","isDocument","trimNode","currentChildren","makeMap$3","attrsCharsRegExp","textCharsRegExp","rawCharsRegExp","entityRegExp","asciiMap","baseEntities","reverseEntities","nativeDecode","innerText","buildEntitiesLookup","lookup","itemList","chr","fromCharCode","entity","namedEntities","encodeRaw","encodeAllRaw","encodeNumeric","charCodeAt","encodeNamed","entities","resolveEntities","getEncodeFunc","entitiesMap","encodeNamedAndNumeric","encodeCustomNamed","nameMap","named","numeric","decode","charAt","Entities","split$1","patternToRegExp","RegExp","isRegExp$1","source","deepCloneElementRule","helper","flags","parseCustomElementsRules","customElementRegExp","rule","exec","inline","cloneName","getGlobalAttributeSet","freeze","getElementSetsAsStrings","blockContent","phrasingContent","transparentContent","html4PhrasingContent","html4BlockContent","flowContent","getElementSets","toArr","cachedSets","getElementsPreset","makeSchema","globalAttributes","addElement","attributesOrder","childNames","ni","allAttributes","addAttrs","schemaItem","video","audio","table","script","prefixToOperation","parseValidChild","validChildRegExp","preset","parseValidChildrenRules","childRuleRegExp","operation","validChildren","validChild","parseValidElementsAttrDataIntoElement","attrData","targetElement","attrRuleRegExp","hasPatternsRegExp","attrType","attrPrefix","attributesRequired","required","splice","attributesDefault","defaultValue","attributesForced","forcedValue","validValues","attrPattern","attributePatterns","pattern","cloneAttributesInto","parseValidElementsRules","globalElement","validElements","elementRuleRegExp","elementName","outputName","attrsPrefix","paddEmpty","removeEmpty","removeEmptyAttrs","aliasName","mapCache","makeMap$2","each$b","extend$2","explode$2","createMap","extendWith","toUpperCase","getTextRootBlockElements","getTextBlockElements","compileElementMap","mode","Schema","patternElements","customElementsMap","specialElements","createLookupTable","option","newValue","schemaType","schemaItems","verify_html","valid_elements","validStyles","valid_styles","invalidStyles","invalid_styles","validClasses","valid_classes","whitespaceElementsMap","selfClosingElementsMap","voidElementsMap","boolAttrMap","nonEmptyOrMoveCaretBeforeOnEnter","nonEmptyElementsMap","moveCaretBeforeOnEnterElementsMap","headings","textBlockElementsMap","blockElementsMap","textInlineElementsMap","transparentElementsMap","wrapBlockElementsMap","addValidElements","patternElement","setValidElements","addCustomElement","spec","_b","text_block_elements","block_elements","extends","customRule","processAttrName","globalAttrs","padEmpty","customElementChildren","processNodeName","processPreset","elmName","addCustomElementsFromString","customElements","addCustomElements","addValidChildren","getElementRule","setup","_val","padd_empty_block_inline_children","paddInEmptyBlock","svg","custom_elements","valid_children","extended_valid_elements","dd","dt","li","td","th","tr","tbody","thead","tfoot","legend","area","param","parentsRequired","invalid_elements","getValidStyles","getInvalidStyles","getValidClasses","getBoolAttrs","getTextInlineElements","getVoidElements","seal","getSelfClosingElements","getMoveCaretBeforeOnEnterElements","getWrapBlockElements","getSpecialElements","isValid","attrPatterns","isWrapper","getCustomElements","hexColour","normalizeHex","hex","toHex","component","fromRgba","rgbaColour","red","green","blue","rgbRegex","rgbaRegex","alpha","fromStringValues","g","parseFloat","getColorFormat","colorString","fromString","rgbaString","rgbMatch","rgbaMatch","rgba","rgbaToHexString","color","h","Styles","urlOrStrRegExp","styleRegExp","trimRightRegExp","encodingLookup","invisibleChar","encodingItems","self","parse","isEncoded","urlConverter","url_converter","urlConverterScope","url_converter_scope","compress","noJoin","canCompress","compress2","encode","keepSlashes","decodeSingleHexSequence","escSeq","decodeHexSequences","processUrl","match","url2","url3","str2","allow_script_urls","scriptUrl","allow_svg_data_urls","lastIndex","border","serialize","serializeStyles","elemName","validStyleList","styleList","styleMap","deprecated","keyLocation","layerX","layerY","returnValue","webkitMovementX","webkitMovementY","keyIdentifier","mozPressure","isNativeEvent","Event","initEvent","hasIsDefaultPrevented","isDefaultPrevented","needsNormalizing","clone$3","originalEvent","getModifierState","keyArg","getTargetRanges","normalize$3","fallbackTarget","srcElement","defaultPrevented","cancelBubble","isPropagationStopped","stopImmediatePropagation","isImmediatePropagationStopped","eventExpandoPrefix","mouseEventRe","addEvent","capture","removeEvent","isMouseEvent","fix","pageX","eventDoc","mouseEvent","pageY","bindOnReady","eventUtils","domLoaded","isDocReady","readyState","readyHandler","EventUtils","events","expando","Date","hasFocusIn","callbackList","defaultNativeHandler","evt","executeHandlers","namesList","nativeHandler","fakeName","func","eventMap","ci","newCallbackList","ex","fire","dispatch","parentWindow","clean","getElementsByTagName","destroy","cancel","each$a","internalStyleName","numericalCssMap","legacySetAttribute","camelCaseToHyphens","findNodeIndex","normalized","lastNodeType","tempNode","updateInternalStyleAttr","rawValue","convertStyleToString","cssName","applyStyle$1","$elm","normalizedName","setupAttrHooks","getContext","keepValues","keep_values","keepUrlHook","sugarElm","internalName","attrHooks","href","src","DOMUtils","addedStyles","files","counter","stdMode","boxModel","styleSheetLoader","boundEvents","ownEvents","getElementById","_get","getAttrib","defaultVal","hook","getAttribs","setAttrib","run","val","originalValue","onSetAttrib","attrElm","attrValue","deep","getRoot","root_element","getViewPort","argWin","vp","w","getPos$1","setStyle","update_styles","setStyles","stylesArg","getStyle","getSize","getRect","size","elms","getParents","collect","resolvedRoot","selectorVal","getParent","_findSib","getNext","getPrev","isParentNode","select","context","setAttribs","setHTML","create","newElm","createHTML","outHtml","createFragment","frag","keepChildren","$node","removeAllAttribs","removeAttributeNode","parseStyle","cssText","serializeStyle","DOM","styleElm","styleSheet","loadCSS","catch","toggleClass","cls","classes","addClass","removeClass","hasClass","show","hide","isHidden","uniqueId","getOuterHTML","outerHTML","setOuterHTML","insertAfter","reference","referenceNode","oldElm","replacee","replaceChild","rename","attrNode","findCommonAncestor","ps","pe","isEmpty","Boolean","createRng","replacementElm","setStart","setEnd","rv","boundTarget","boundName","boundFunc","getContentEditable","getContentEditableParent","isEditable","_","isChildOf","dumpRng","startContainer","startOffset","endContainer","endOffset","nodeIndex","DOM$b","QUEUED","LOADING","LOADED","FAILED","ScriptLoader","states","queue","scriptLoadedCallbacks","queueLoadedCallbacks","loading","loadScript","cleanup","done","isDone","markDone","loadQueue","loadScripts","scripts","execCallbacks","processResults","failures","processQueue","nextQueuedItem","shift","uniqueScripts","firstIndex","isRaw","isTokenised","currentCode","getLanguageData","getData$1","setCode","newCode","getCode","add$1","code","langData","lcNames","translation","lcName","getLangData","textStr","removeContext","substitued","$1","$2","isRtl$1","dir","hasCode","I18n","getData","isRtl","AddOnManager","_listeners","runListeners","matchedListeners","listener","isLoaded","isAdded","loadLanguagePack","languages","language","wrappedLanguages","requireLangPack","languageLoad","waitFor","addOn","createUrl","baseUrl","dep","resource","addOnUrl","urlString","baseURL","lastIndexOf","PluginManager","ThemeManager","ModelManager","first$1","rate","timer","clearTimeout","throttle","setTimeout","last","ancestor$1","annotation","dataAnnotation","dataAnnotationId","dataAnnotationActive","dataAnnotationClasses","dataAnnotationAttributes","isRoot$1","identify","editor","annotationName","rng","selection","getRng","getBody","an","newStart","closest","uid","findMarkers","isAnnotation","isBogusElement","findAll","markers","directory","m","nodesAlready","setup$y","registry","changeCallbacks","initData","listeners","previous","withCallbacks","updateCallbacks","callbackMap","outputData","fireCallbacks","fireNoAnnotation","toggleActiveAttr","onNodeChange","annotations","getNames","addListener","setup$x","dataAnnotation$1","identifyParserNode","removeDirectAnnotation","customAttrNames","customClasses","newClassList","serializer","addTempAttr","addAttributeFilter","persistent","create$b","register","clamp$2","min","random","crypto","getRandomValues","Uint32Array","unique","generate$1","date","time","getTime","random$1","floor","remove$3","clone$2","original","isDeep","shallow$1","deep$1","shallowAs","mutate","TextWalker","isBoundary","direction","TextSeeker","isBlockBoundary","offset","process","newOffset","backwards","forwards","NodeValue","getOption","nodeValue","api$1","get$3","tableCells","tableSections","textBlocks","listItems$1","lists","wsElements","lazyLookup","isTable$1","isBr$5","isTextBlock$2","isList","isListItem$1","isTableSection","isTableCell$2","isWsPreserveElement","getLastChildren$1","rawNode","removeTrailingBr","allBrs","brs","createPaddingBr","br","fillWithPaddingBr","trimBlockTrailingBr","lastChildPrevSibling","ZWSP$1","isZwsp","trim$2","insert$5","insertContent","preserve_zwsp","isElement$5","isText$9","isCaretContainerBlock$1","isCaretContainerInline","isCaretContainer$2","hasContent","insertInline$1","before","textNode","startsWithCaretContainer$1","splitText","endsWithCaretContainer$1","isBeforeInline","isAtStart","isAfterInline","isAtEnd","insertBlock","blockName","blockNode","trimBogusBr","lastBr","showCaretContainerBlock","caretContainer","isRangeInCaretContainerBlock","round$2","round","clone$1","rect","collapse","toStart","isEqual","rect1","rect2","isValidOverflow","overflowY","isAbove$1","halfHeight","isBelow$1","containsXY","boundingClientRectFromRects","rects","prevRect","distanceToRectEdgeFromXY","cx","cy","sqrt","overlapY","r1","r2","getSelectedNode","getNode$1","safeOffset","getNodeUnsafe","extendingChars","isExtendingChar","ch","and","isContentEditableTrue$2","isContentEditableFalse$a","isBr$4","isText$8","isInvalidTextElement","isAtomicInline","isTable","isCaretContainer$1","isCaretCandidate$3","isNonUiContentEditableFalse","isUnselectable","isInEditable","isAtomicContentEditableFalse","isAtomic$1","isEditableCaretCandidate$1","isElement$4","isCaretCandidate$2","isBlock$2","isFloated","isValidElementCaretCandidate","isNotPre","isText$7","isBr$3","nodeIndex$1","resolveIndex$1","createRange$1","isWhiteSpace$1","isRange","isHiddenWhiteSpaceRange","getBrClientRect","brNode","nbsp$1","clientRect","getBoundingClientRectWebKitText","sc","ec","so","eo","newRng","cloneRange","getBoundingClientRect$1","isZeroRect","clientRects","getClientRects","collapseAndInflateWidth","newClientRect","getCaretPositionClientRects","caretPosition","addUniqueAndValidRect","addCharacterOffset","beforeNode","CaretPosition","toRange","isVisible","getNode","fromRangeStart","fromRangeEnd","after","isAbove","pos1","pos2","isBelow","isTextPosition","isElementPosition","trimEmptyTextNode$1","insertNode","insertFragment","rangeInsertNode","isText$6","isBogus","normalizedParent","getChildNodes","normalizedTextOffset","equal","normalizedNodeIndex","numTextFragments","createPathItem","parentsUntil$1","create$a","outputOffset","resolvePathItem","findTextPosition","targetOffset","dataLen","resolve$1","paths","nodeOffset","isContentEditableFalse$9","getNormalizedTextOffset$1","trimmedOffset","getPoint","point","getLocation","forward","isForward","fakeCaret","isFakeCaret","isCollapsed","findIndex","moveEndPoint$1","normalizeTableCellSelection","findAdjacentContentEditableFalseElm","getOffsetBookmark","getCaretBookmark","getRangeBookmark","createBookmarkSpan","filled","getPersistentBookmark","collapsed","rng2","endBookmarkNode","startBookmarkNode","moveToBookmark","keep","getBookmark$3","getUndoBookmark","value$1","applyHelper","constHelper","outputHelper","output","inner","_onError","onValue","isValue","isError","Result","mapError","toOptional","onError","_onValue","fromOption","optional","err","generate","cases","constructors","adt","acase","keys$1","argLength","branches","branchKeys","allReqd","reqKey","foldArgs","log","label","params","Adt","bothErrors","firstError","secondError","bothValues","partition$1","errors","isInlinePattern","isBlockPattern","hasBlockTrigger","trigger","normalizePattern","formatOrCmd","onFormat","onCommand","format","formats","cmd","command","commandValue","getBlockPatterns","patterns","getInlinePatterns","createPatternSet","dynamicPatternsLookup","inlinePatterns","blockPatterns","filterByTrigger","fromRawPatterns","fromRawPatternsLookup","lookupFn","ctx","rawPatterns","deviceDetection$1","DOM$a","getHash","isRegExp","stringOrObjectProcessor","bodyOptionProcessor","valid","bodyObj","register$7","registerOption","processor","default","documentBaseUrl","isInline$1","hasPlugin","convertURL","_ctx","getElement","getIframeAttrs","getDocType","getDocumentBaseUrl","getBodyId","getBodyClass","getContentSecurityPolicy","shouldPutBrInPre$1","getForcedRootBlock","getForcedRootBlockAttrs","getNewlineBehavior","getBrNewLineSelector","getNoNewLineSelector","shouldKeepStyles","shouldEndContainerOnEmptyBlock","isAutomaticUploadsEnabled","shouldReuseFileName","shouldReplaceBlobUris","getIconPackName","getIconsUrl","getImageUploadUrl","getImageUploadBasePath","getImagesUploadCredentials","getImagesUploadHandler","shouldUseContentCssCors","getReferrerPolicy","getLanguageCode","getLanguageUrl","shouldIndentUseMargin","getIndentation","getContentCss","getContentStyle","getFontCss","getDirectionality","getInlineBoundarySelector","getObjectResizing","getResizeImgProportional","getPlaceholder","getEventRoot","getServiceMessage","getTheme","getThemeUrl","getModel","getModelUrl","isInlineBoundariesEnabled","getFormats","getPreviewStyles","canFormatEmptyLines","getFormatNoneditableSelector","getCustomUiSelector","hasHiddenInput","shouldPatchSubmit","shouldAddFormSubmitTrigger","shouldAddUnloadTrigger","getCustomUndoRedoLevels","shouldDisableNodeChange","isReadOnly$1","hasEditableRoot$1","hasContentCssCors","getPlugins","getExternalPlugins$1","shouldBlockUnsupportedDrop","isVisualAidsEnabled","getVisualAidsTableClass","getVisualAidsAnchorClass","getIframeAriaText","getSetupCallback","getInitInstanceCallback","getUrlConverterCallback","getAutoFocus","shouldBrowserSpellcheck","getProtect","shouldPasteBlockDrop","shouldPasteDataImages","getPastePreProcess","getPastePostProcess","getNewDocumentContent","getPasteWebkitStyles","shouldPasteRemoveWebKitStyles","shouldPasteMergeFormats","isSmartPasteEnabled","isPasteAsTextEnabled","getPasteTabSpaces","shouldAllowHtmlDataUrls","getTextPatterns","getTextPatternsLookup","getNonEditableClass","getEditableClass","getNonEditableRegExps","shouldPreserveCData","shouldHighlightOnFocus","shouldSanitizeXss","shouldUseDocumentWrite","hasTextPatternsLookup","getFontStyleValues","getFontSizeClasses","isEncodingXml","getAllowedImageFileTypes","hasTableTabNavigation","getDetailsInitialState","getDetailsSerializedState","shouldSandboxIframes","getSandboxIframesExclusions","shouldConvertUnsafeEmbeds","getLicenseKey","getApiKey","isElement$3","isText$5","removeNode$1","trimCount","trimmedText","deleteZwspChars","deleteData","removeUnchanged","remove$2","removeTextAndReposition","removeElementAndReposition","newPosition","removeTextCaretContainer","removeElementCaretContainer","removeAndReposition","caretContainerNode","isContentEditableFalse$8","isMedia$1","isTableCell$1","inlineFakeCaretSelector","getAbsoluteClientRect","scrollX","scrollY","rootRect","margin","trimInlineCaretContainers","fakeCaretTargetNodes","FakeCaret","hasFocus","lastVisualCaret","cursorInterval","caretBlock","caret","startBlink","isInlineFakeCaretTarget","caretState","reposition","getCss","isFakeCaretTableBrowser","isFakeCaretTarget","isTarget","isContentEditableTrue$1","isContentEditableFalse$7","isMedia","isBlockLike","isCaretContainer","isCaretContainerBlock","isElement$2","isText$4","isCaretCandidate$1","isForwards","isBackwards","skipCaretContainers","findNode","predicateFn","isCefOrCaretContainer","getEditingHost","isCETrue","getParentBlock$3","isInSameBlock","caretPosition1","caretPosition2","getChildNodeAtRelativeOffset","relativeOffset","beforeAfter","isNodesInSameBlock","node1","node2","lean","before$2","after$2","normalizeRange","leanLeft","leanRight","location","getRelativeCefElm","getNormalizedRangeEndPoint","normalizedRange","getElementFromPosition","getElementFromPrevPosition","getVisualCaretPosition","walkFn","isMoveInsideSameBlock","inSameBlock","HDirection","isContentEditableFalse$6","isText$3","isElement$1","isBr$2","isCaretCandidate","isAtomic","isEditableCaretCandidate","getParents$3","nodeAtIndex","getCaretCandidatePosition","moveForwardFromBr","nextNode","findCaretPosition$1","Forwards","startPos","innerNode","rootContentEditableFalseElm","CaretWalker","Backwards","walkToPositionIn","position","fromPosition","afterElement","isBeforeOrStart","isAfterOrEnd","isBeforeAfterSameElement","isAtBr","shouldSkipPosition","navigate","navigateIgnore","ignoreFilter","positionIn","nextPosition","prevPosition","firstPositionIn","lastPositionIn","CARET_ID","isCaretNode","getParentCaretContainer","currentNode","isStringPathBookmark","bookmark","isRangeBookmark","isIdBookmark","isIndexBookmark","isPathBookmark","isForwardBookmark","addBogus","resolveCaretPositionBookmark","endPos","insertZwsp","isEmpty$1","tryFindRangePosition","padEmptyCaretContainer","setEndPoint","isValidTextNode","restoreEndPoint","markerParent","otherMarker","appendData","resolvePaths","resolveId","spos","epos","resolveIndex","selectNode","getBookmark$2","setRng","isBookmarkNode$1","expected","isNbsp","isWhiteSpace","getRanges$1","ranges","rangeCount","getRangeAt","getSelectedNodes","hasMultipleRanges","getCellsFromRanges","getCellsFromElement","getCellsFromElementOrRanges","selectedCells","getCellsFromEditor","getSel","getClosestTable","cell","getStartNode","getEndNode","getFirstChildren","getLastChildren","hasAllContentsSelected","endNode","moveEndPoint","hasAnyRanges","sel","runOnRanges","executor","fakeSelectionNodes","fakeNodeRng","preserve","fillBookmark","isNode","isElementNode$1","isElementDirectlySelected","selectedAttr","preserveSelection","action","shouldMoveStart","selectedNodeBeforeAction","isSelectedBeforeNodeNoneditable","isBeforeNodeStillNoneditable","getStart","moveStartToNearestText","selectedNode","isWhiteSpaceNode$1","getNonWhiteSpaceSibling","inc","nextName","isTextBlock$1","ed","allowSpaces","isEmptyTextNode$1","isWrapNoneditableTarget","baseDataSelector","formatNoneditableSelector","isWrappableNoneditable","replaceVars","vars","isEq$5","str1","normalizeStyleValue","strValue","getTextDecoration","decoration","getParents$2","isFormatPredicate","formatName","formatter","isVariableFormatName","hasVariableValues","isVariableValue","field","fieldValues","areSimilarFormats","otherFormatName","validKeys","filterObj","validKey","fmt1","filteredFmt1","fmt2","filteredFmt2","isBlockFormat","isWrappingBlockFormat","isNonWrappingBlockFormat","isSelectorFormat","isInlineFormat","isMixedFormat","shouldExpandToSelector","expand","getEmptyCaretContainers","isCaretContainerEmpty","isEmptyCaretFormatElement","isBookmarkNode","getParents$1","isWhiteSpaceNode","isTextBlock","isBogusBr","findParentContentEditable","walkText","findSpace","findContent","findWordEndPoint","includeTrailingSpaces","lastTextNode","textSeeker","textOffset","spaceResult","findSelectorEndPoint","formatList","curFormat","findBlockEndPoint","scopeRoot","isAtBlockBoundary$1","findParentContainer","block_expand","isSelfOrParentBookmark","expandRng","includeTrailingSpace","startPoint","endPoint","walk$3","exclude","firstNode","lastNode","collectSiblings","findEndPoint","walkBoundary","validBlocks","isZeroWidth","wrapName","applyWordGrab","applyAnnotation","masterUId","decorate","directAnnotation","otherData","attributeNames","makeAnnotation","eDoc","master","annotate","newWrappers","getDoc","finishWrapper","getOrOpenWrapper","processElements","elems","processElement","processNodes","annotateWithBookmark","undoManager","transact","initialRng","hasFakeSelection","masterUid","selectionRng","Annotator","changes","removeAnnotations","annotationChanged","getBookmark","removeAll","getAll","BookmarkManager","isXYWithinRange","firePreProcess","firePostProcess","fireRemove","fireDetach","fireSwitchMode","fireObjectResizeStart","origin","fireObjectResized","firePreInit","firePostRender","fireInit","firePlaceholderToggle","fireError","errorType","fireFormatApply","fireFormatRemove","fireBeforeSetContent","fireSetContent","fireBeforeGetContent","fireGetContent","fireAutocompleterStart","fireAutocompleterUpdate","fireAutocompleterUpdateActiveRange","fireAutocompleterEnd","firePastePreProcess","internal","firePastePostProcess","firePastePlainTextToggle","fireEditableRootStateChange","VK","BACKSPACE","DELETE","DOWN","ENTER","ESC","LEFT","RIGHT","SPACEBAR","TAB","UP","PAGE_UP","PAGE_DOWN","END","HOME","modifierPressed","shiftKey","ctrlKey","altKey","metaKeyPressed","metaKey","elementSelectionAttr","controlElmSelector","abs","round$1","resizeHandles","nw","ne","se","sw","isTouchEvent","ControlSelection","editableDoc","rootDocument","selectedElm","selectedElmGhost","resizeHelper","selectedHandle","resizeBackdrop","startX","startY","selectedElmX","selectedElmY","startW","startH","ratio","resizeStarted","startScrollWidth","startScrollHeight","isImage","isEventOnImageOutsideRange","touch","touches","contextMenuSelectImage","getResizeTargets","firstElementChild","isResizable","isReadOnly","createGhostElement","isNorth","rowSelect","tableElm","cells","setSizeProp","targets","setGhostElmSize","ghostElm","resizeGhostElement","deltaX","deltaY","proportional","resizeHelperX","resizeHelperY","screenX","screenY","display","scrollWidth","scrollHeight","endGhostResize","wasResizeStarted","showResizeRect","nodeChanged","targetElm","unbindResizeHandleEvents","targetWidth","targetHeight","hideResizeRect","handle","startDrag","handleElm","throttledShowResizeRect","removeSelected","isChildOrEqual","updateResizeRect","removed","composing","controlElm","selectedValue","img","disableGeckoResize","startElm","getEnd","execCommand","situ","setFinish","relativeToNative","startSitu","finishSitu","exactToNative","soffset","finish","foffset","adt$3","ltr","rtl","fromRange","getRanges","domRange","relative","exact","doDiagnose","reversed","rev","diagnose","create$9","SimRange","caretPositionFromPoint","offsetNode","caretRangeFromPoint","availableSearch","fromPoint$1","adt$2","cata","onBefore","onOn","onAfter","getStart$2","before$1","after$1","Situ","adt$1","exactFromRange","simRange","getStart$1","_finishSitu","_soffset","_finish","_foffset","getWin","SimSelection","beforeSpecial","name$1","preprocessRelative","preprocessExact","preprocess","fromElements","toNative","getDomRange","filtered","getAtPoint","isEq$4","rng1","findParent","hasParent$1","hasParentWithName","isCeFalseCaretContainer","hasBrBeforeAfter","isPrevNode","hasContentEditableFalseParent$1","findTextNodeRelative","isAfterNode","lastInlineElement","parentBlockContainer","normalizeEndPoint","directionLeft","normalize$2","normRng","newContainer","RangeUtils","normalize","normalizedRng","rangeLike","newRange","compareRanges","getCaretRangeFromPoint","Dimension","getOffset","aggregate","properties","cumulativeInclusions","absoluteMax","api","get$2","getDocument","walkUp","navigation","frame","view","rest","pathTo","frameElement","Navigation","__proto__","find","frames","loc","excludeFromDescend","fireScrollIntoViewEvent","scrollEvent","fireAfterScrollIntoViewEvent","markerInfo","cleanupFun","createMarker$1","span","elementMarker","withMarker","preserveWith","_s","_e","applyWithMarker","withScrollEvents","withElement","startElement","endElement","scrollToMarker","viewHeight","intoWindowIfNeeded","viewportBottom","markerTop","markerBottom","largerThanViewport","align","intoWindow","innerHeight","intoFrame","frameViewHeight","op","viewportBounds","rangeIntoWindow","elementIntoWindow","rangeIntoFrame","elementIntoFrame","scrollElementIntoView","scroller","scrollRangeIntoView","focus$1","preventScroll","focus","hasFocus$1","activeElement","active$1","clamp$1","normalizeRng","isOrContains","isRngInRoot","shouldStore","nativeRangeToSelectionRange","readRange","getSelection","getBookmark$1","validate","bookmarkToNativeRng","store","newBookmark","restore","isEditorUIElement$1","className","FocusManager","isEditorUIElement","wrappedSetTimeout","wrappedSetInterval","Delay","setEditorTimeout","setEditorInterval","isManualNodeChange","selectionChange","registerPageMouseUp","throttledStore","mouseUpPage","registerMouseUp","registerEditorEvents","register$6","documentFocusInHandler","DOM$9","isEditorContentAreaElement","isUIElement","customSelector","getActiveElement","registerEvents$1","editorManager","toggleContentAreaOnFocus","contentArea","getContainer","focusedEditor","setActive","blurredEditor","activeEditor","unregisterDocumentEvents","setup$w","getContentEditableHost","hasContentEditableFalseParent","getCollapsedNode","getFocusInElement","normalizeSelection","caretPos","focusBody","hasElementFocus","hasIframeFocus","iframeElement","hasInlineFocus","rawBody","hasUiFocus","hasEditorOrUiFocus","focusEditor","quirks","refreshContentEditable","restoreBookmark","bookmarkRng","hasEditableRoot","contentEditableHost","activateEditor","skipFocus","isEditableRange","getEndpointElement","real","skipEmptyTextNodes","orig","commonAncestorContainer","getSelectedBlocks","endElm","selectedBlocks","processRanges","typeLookup","walk$2","isEmptyTextNode","isNonEmptyElement","AstNode","insert","selfAttrs","cloneAttrs","selfAttr","wrap","refNode","whitespace","unescapedTextParents","containsZwsp","includes","getTemporaryNodeSelector","tempAttrs","getTemporaryNodes","createZwspCommentWalker","createTreeWalker","NodeFilter","SHOW_COMMENT","FILTER_ACCEPT","FILTER_SKIP","createUnescapedZwspTextWalker","SHOW_TEXT","hasZwspComment","hasUnescapedZwspText","hasTemporaryNode","trimTemporaryNodes","emptyAllNodeValuesInWalker","curr","emptyZwspComments","emptyUnescapedZwspTexts","trim$1","conditionalTrims","condition","trimmed","cloned","cleanupBogusElements","bogusElements","cleanupInputNames","inputs","input","trimEmptyContents","emptyRegExp","getPlainTextContent","offscreenDiv","getContentFromBody","getTempAttrs","shouldTrim","getContentInternal","makeMap$1","Writer","indent","indentBefore","indent_before","indentAfter","indent_after","entity_encoding","htmlOutput","element_format","cdata","comment","pi","doctype","getContent","HtmlSerializer","writer","handlers","sortedAttrs","elementRule","nonInheritableStyles","Set","nonInheritableStylesArr","conditionalNonInheritableStyles","conditionalNonInheritableStylesArr","shorthandStyleProps","getStyles$1","getStyleProps","isNonInheritableStyle","isConditionalNonInheritableStyle","hasNonInheritableStyles","hasConditionalNonInheritableStyles","getLonghandStyleProps","prop","hasStyleConflict","nodeStyleProps","parentNodeStyleProps","valueMismatch","parentValue","nodeStyleProp","propExists","longhandProps","isChar","delta","isBeforeSpace","isAfterSpace","isEmptyText","matchesElementPosition","isImageBlock","isCefNode","isBeforeImageBlock","isAfterImageBlock","isBeforeMedia","isAfterMedia","isBeforeTable","isAfterTable","isBeforeContentEditableFalse","isAfterContentEditableFalse","dropLast","parentsUntil","parentsAndSelf","navigateIgnoreEmptyTextNodes","isBlock$1","getClosestBlock$1","isAtBeforeAfterBlockBoundary","newPos","fromBlock","isAtBlockBoundary","isAtStartOfBlock","isAtEndOfBlock","isBeforeBlock","isAfterBlock","isBr$1","findBr","parentBlocks","isBeforeBr$1","isAfterBr","findPreviousBr","findNextBr","isInMiddleOfText","getClosestBlock","hasSpaceBefore","hasSpaceAfter","isPreValue","isInPre","isAtBeginningOfBody","isAtEndOfBody","isAtLineBoundary","isCefBlock","isSiblingCefBlock","isBeforeCefBlock","nextPos","isNextCefBlock","isAfterCefBlock","prevPos","isPrevCefBlock","needsToHaveNbsp","needsToBeNbspLeft","needsToBeNbspRight","needsToBeNbsp","isNbspAt","isWhiteSpaceAt","hasNbsp","normalizeNbspMiddle","chars","normalizeNbspAtStart","makeNbsp","firstPos","normalizeNbspInMiddleOfTextNode","newText","normalizeNbspAtEnd","lastPos","normalizeNbsps$1","normalizeNbspsInEditor","normalize$1","replaceData","normalizeWhitespaceAfter","whitespaceCount","normalizeWhitespaceBefore","mergeTextNodes","prevNode","normalizeWhitespace","mergeToPrev","whitespaceOffset","newNode","removeNode","insertData","needsReposition","beforeOrStartOf","afterOrEndOf","getPreviousSiblingCaretPosition","getNextSiblingCaretPosition","findCaretPositionBackwardsFromElm","findCaretPositionForwardsFromElm","findCaretPositionBackwards","findCaretPositionForward","findCaretPosition","findCaretPosOutsideElmAfterDelete","setSelection$1","eqRawNode","paddEmptyBlock","preserveEmptyCaret","deleteNormalized","afterDeletePosOpt","prevTextOpt","nextTextOpt","isInlineElement","deleteElement$2","moveCaret","afterDeletePos","normalizedAfterDeletePos","setContent","setCursorLocation","paddPos","strongRtl","hasStrongRtl","isInlineTarget","findInlineParents","findRootInline","hasSameParentBlock","block1","block2","isAtZwsp","normalizePosition","normalizeForwards","normalizeBackwards","execCommandIgnoreInputEvents","inputBlocker","off","execEditorDeleteCommand","execNativeDeleteCommand","execNativeForwardDeleteCommand","isBeforeRoot","isTextBlockOrListItem","getParentBlock$2","paddEmptyBody","moveSelection","no_selection","willDeleteLastPositionInElement","fromPos","normalizedFirstPos","normalizedLastPos","normalizedFromPos","freefallRtl","deleteRangeContents","deleteContents","lastBlock","additionalCleanupNodes","isRootFromElement","getTableCells","getTable$1","selectionInTableWithNestedTable","details","startTable","endTable","isStartTableParentOfEndTable","isEndTableParentOfStartTable","isSameTable","isMultiTable","adjustQuirksInDetails","getTableDetailsFromRange","isStartInTable","isEndInTable","tableCellRng","tableSelection","deleteAction","singleCellTable","fullTable","partialTable","multiTable","getClosestCell$1","isExpandedCellRng","cellRng","getTableFromCellRng","startParentTable","endParentTable","isSingleCellTable","rows","getCellRng","startCell","endCell","getCellRangeFromStartTable","getCellRangeFromEndTable","getTableSelectionFromCellRng","getTableSelections","selectionDetails","sameTableSelection","startTableSelection","endTableSelection","getCellIndex","getSelectedCells","startIndex","endIndex","isSingleCellTableContentSelected","optCellRng","unselectCells","otherContentRng","handleSingleTable","handleMultiTable","startTableSelectedCells","endTableSelectedCells","getActionFromRange","cleanCells","getOutsideBlock","handleEmptyBlock","startInTable","emptyBlock","deleteContentInsideCell","isFirstCellInSelection","insideTableRng","deleteCellContents","collapseAndRestoreCellSelection","emptySingleTableCells","outsideDetails","editorRng","cellsToClean","outsideBlock","endPointCell","emptyMultiTableCells","startTableCells","endTableCells","betweenRng","startTableCellsToClean","endTableCellsToClean","deleteTableElement","deleteCellRange","deleteCaptionRange","emptyElement","deleteTableRange","getParentCaption","deleteRange$3","getParentCell","deleteBetweenCells","fromCell","toCell","isDeleteOfLastCharPos","fromCaption","first","emptyCaretCaption","validateCaretCaption","toCaption","deleteCaretInsideCaption","deleteCaretCells","deleteCaretCaption","isNearTable","isBeforeOrAfterTable","deleteCaret$3","backspaceDelete$b","getContentEditableRoot$1","internalAttributesPrefixes","each$9","ElementUtils","internalAttributes","compare","attribs","isAttributeInternal","compareObjects","obj1","obj2","attributeName","isHeading","isSummary","traverse","matchNode$1","nodeFilters","attributeFilters","nl","ai","al","findMatchingNodes","childNode","runFilters","matchRecord","filteringAttributes","valueMatches","filter$2","paddEmptyNode","brPreferred","pad_empty_with_br","astNode","isPaddedWithNbsp","hasOnlyChild","isPadded","nonEmptyElements","isLineBreakNode","findClosestEditingHost","editableNode","removeOrUnwrapInvalidNode","originalNodeParent","cleanInvalidNodes","onCreate","textBlockElements","nonSplittableElements","fixed","isSplittableElement","newParent","isInvalid","hasClosest","parentName","normalizeBlockSelectionRange","newEndPos","hasOnlyOneChild$1","isPaddingNode","isPaddedEmptyBlock","blockElements","isEmptyFragmentElement","isListFragment","cleanupDomFragment","domFragment","toDomFragment","listItems","isPadding","isListItemPadded","isEmptyOrPadded","trimListItems","getParentLi","isParentBlockLi","getSplit","beforeRng","afterRng","cloneContents","findFirstIn","caretWalker","newCaretPos","findLastOf","insertMiddle","insertBefore$2","insertAfter$2","insertAtCaret$1","liTarget","liElms","BEGINNING","isAt","newPosNode","mergeableWrappedElements","shouldPasteContentOnly","isPastingSingleElement","isWrappedElement","isPastingInTheSameBlockTag","isPastingInContentEditable","isTableCell","isTableCellContentSelected","validInsertion","no_events","trimBrsFromTableCell","reduceInlineTextElements","merge","textInlineElements","elementUtils","fragmentSelector","fragments","hasOneChild","hasNoNonInheritableStyles","isOverridden","oldStyles","newStyles","overriddenByAllChildren","identicalToParent","conflictWithInsertedParent","markFragmentElements","unmarkFragmentElements","isPartOfFragment","canHaveChildren","moveSelectionToMarker","_c","nextRng","parentEditableElm","findNextCaretRng","isCell","deleteSelectedContent","findMarkerNode","markerNode","notHeadingsInSummary","insertHtmlAtCaret","parser","bookmarkHtml","caretElement","parserArgs","paste","_selectionOverrides","showBlockCaretContainer","invalid","editingHost","toExtract","getNodeFilters","getAttributeFilters","isTreeNode","setEditorHtml","noSelection","setContentString","padd","forcedRootBlockName","isRootContent","trimmedHtml","setContentTree","setContentInternal","ensureIsRoot","transform","transformed","closest$1","isEq$3","matchesUnInheritedFormatSelector","inherit","matchParents","similar","matchedNode","matchNode","matchName","matchItems","itemName","matchAttributes","onmatch","expectedValue","isEmptyValue","match$2","matchAll","matchedFormatNames","checkedMap","rawElm","canApply","matchAllOnNode","formatNames","matchSimilar","ZWSP","importNode","findFirstTextNode","createCaretContainer","fill","trimZwspFromCaretContainer","removeCaretContainerNode","removeCaretContainer","insertCaretContainerNode","formatNode","appendNode","insertFormatNodesIntoCaretContainer","formatNodes","innerMostFormatNode","cleanFormatNode","validFormats","matchedFormats","uniqueFormats","fmtName","clonedFormatNode","normalizeNbsps","normalizeNbspsBetween","once","isComposing","applyCaretFormat","wordcharRegex","removeCaretFormat","hasContentAfter","expandedRng","parentsAfter","newCaretContainer","cleanedFormatNode","caretTextNode","disableCaretContainer","keyCode","endsWithNbsp","setup$v","createCaretFormat","innerMost","replaceWithCaretFormat","createCaretFormatAtStart$1","isFormatElement","inlineElements","postProcessHooks","isPre","addPostProcessHook","hooks","postProcess$1","hasPreSibling","blocks","pre","joinPre","pre1","pre2","sPre2","preBlocks","listItemStyles","hasListStyles","fmt","findExpandedListItemFormat","getExpandedListItemFormat","isRngStartAtStartOfElement","isRngEndAtEndOfElement","isEditableListItem","getFullySelectedBlocks","middle","getFullySelectedListItems","getPartiallySelectedListItems","each$8","isElementNode","findElementSibling","mergeSiblingsNodes","isPrevEditable","isNextEditable","tmpSibling","mergeSiblings","merge_siblings","clearChildStyles","clear_child_styles","links","_value","processChildElements","unwrapEmptySpan","hasStyle","applyStyle","removeResult","MCE_ATTR_RE","each$7","isEq$2","isTableCellOrRow","isChildOfInlineParent","lastIdx","normalizeTableSelection","wrap$1","wrapWithSiblings","isColorFormatAndAnchor","rootBlockElm","forcedRootBlock","list_block","processFormatAttrOrStyle","removeEmptyStyleAttributeIfNeeded","removeStyles","compareNode","stylesModified","styleName","styleValue","normalizedStyleValue","remove_similar","removeListStyleFormats","liFmt","removeNodeFormatInternal","ceFalseOverride","preserveAttributes","preserve_attributes","attrsToPreserve","currentValue","valueOut","findFormatRoot","formatRoot","removeNodeFormatFromClone","newName","wrapAndSplit","lastClone","firstClone","formatRootParent","mixed","removeFormatInternal","splitToFormatRoot","isRemoveBookmarkNode","removeFormatOnNode","removeNodeFormat","currentNodeMatches","textDecorations","textDecoration","removeRngStyle","removeFormat$1","each$6","mergeTextDecorationsAndColor","processTextDecorationsAndColor","parentTextDecoration","mergeBackgroundColorAndFontSize","backgroundColor","hasFontSize","mergeSubSup","inverseTagDescendants","mergeWithChildren","mergeWithParents","merge_with_parents","each$5","canFormatBR","validBRParentElements","hasCaretNodeSibling","applyStyles","styleVal","applyFormatAction","setElementFormat","onformat","applyNodeStyle","found","createWrapElement","wrapElm","applyRngStyle","nodeSpecific","isMatchingWrappingBlock","canRenameBlock","isEditableDescendant","isValidBlockFormatForNode","canWrapNode","isWrappableNoneditableElm","isValidWrapNode","isCaret","isCorrectFormatForNode","currentWrapElm","lastContentEditable","contentEditableValue","getChildCount","mergeStyles","childElement","childCount","fake","applyFormat$1","hasVars","setup$u","registeredFormatListeners","updateAndFireChangeCallbacks","nodeOrRange","fallbackElement","matchingNode","isMatchingNode","matchingFormat","isUnableToMatch","registeredCallbacks","runIfChanged","withSimilar","withoutSimilar","withVars","addListeners","formatChangeItems","getCurrent","toAppendTo","removeListeners","formatChangedInternal","explode$1","create$8","filters","addFilter","getFilters","removeFilter","newCallbacks","removeAttrs","addFontToSpansFilter","domParser","fontSizes","addNodeFilter","face","addStrikeFilter","convertToSTag","addFilters","convert_fonts_to_spans","font_size_legacy_values","register$5","inline_styles","blobUriToBlob","fetch","ok","blob","uriType","extractBase64Data","parseDataUri","uri","base64Encoded","extractedData","decodeURIComponent","buildBlob","atob","Uint8Array","Blob","dataUriToBlob","uriToBlob","blobToDataUri","reader","FileReader","onloadend","readAsDataURL","count$1","uniqueId$1","processDataUri","dataUri","base64Only","generateBlobInfo","base64","btoa","createBlobInfo$1","blobCache","blobInfo","dataUriToBlobInfo","getByData","imageToBlobInfo","imageSrc","invalidDataUri","getByUri","hostCaptureRegex","extractHost","ms","sandboxIframe","iframeNode","exclusions","isMimeType","mime","getEmbedType","createSafeEmbed","sandboxIframes","sandboxIframesExclusions","embed","isBogusImage","isInternalImageSource","registerBase64ImageFilter","blob_cache","processImage","inputSrc","blobUri","register$4","appendRel","addNoOpener","newRel","allow_unsafe_link_target","allow_html_in_named_anchor","fix_list_elements","classValue","validClassesMap","sandbox_iframes","sandbox_iframes_exclusions","convert_unsafe_embeds","entries","setPrototypeOf","isFrozen","getOwnPropertyDescriptor","create$7","construct","Reflect","fun","thisValue","Func","arrayForEach","unapply","forEach","arrayPop","pop","arrayPush","stringToLowerCase","stringToString","stringMatch","stringReplace","stringIndexOf","stringTrim","objectHasOwnProperty","regExpTest","typeErrorCreate","unconstruct","TypeError","_len","arguments","_key","_len2","_key2","addToSet","transformCaseFunc","lcElement","cleanArray","isPropertyExist","object","newObject","lookupGetter","desc","fallbackValue","html$1","svg$1","svgFilters","svgDisallowed","mathMl$1","mathMlDisallowed","mathMl","xml","MUSTACHE_EXPR","ERB_EXPR","TMPLIT_EXPR","DATA_ATTR","ARIA_ATTR","IS_ALLOWED_URI","IS_SCRIPT_OR_DATA","ATTR_WHITESPACE","DOCTYPE_NAME","CUSTOM_ELEMENT","EXPRESSIONS","NODE_TYPE","attribute","cdataSection","entityReference","entityNode","progressingInstruction","documentType","documentFragment","notation","getGlobal","_createTrustedTypesPolicy","trustedTypes","purifyHostElement","createPolicy","ATTR_NAME","policyName","createScriptURL","warn","createDOMPurify","DOMPurify","originalDocument","currentScript","DocumentFragment","HTMLTemplateElement","Node","Element","NamedNodeMap","MozNamedAttrMap","HTMLFormElement","DOMParser","ElementPrototype","getNextSibling","getParentNode","template","trustedTypesPolicy","emptyHTML","implementation","createNodeIterator","createHTMLDocument","IS_ALLOWED_URI$1","ALLOWED_TAGS","DEFAULT_ALLOWED_TAGS","ALLOWED_ATTR","DEFAULT_ALLOWED_ATTR","CUSTOM_ELEMENT_HANDLING","tagNameCheck","writable","configurable","enumerable","attributeNameCheck","allowCustomizedBuiltInElements","FORBID_TAGS","FORBID_ATTR","ALLOW_ARIA_ATTR","ALLOW_DATA_ATTR","ALLOW_UNKNOWN_PROTOCOLS","ALLOW_SELF_CLOSE_IN_ATTR","SAFE_FOR_TEMPLATES","SAFE_FOR_XML","WHOLE_DOCUMENT","SET_CONFIG","FORCE_BODY","RETURN_DOM","RETURN_DOM_FRAGMENT","RETURN_TRUSTED_TYPE","SANITIZE_DOM","SANITIZE_NAMED_PROPS","SANITIZE_NAMED_PROPS_PREFIX","KEEP_CONTENT","IN_PLACE","USE_PROFILES","FORBID_CONTENTS","DEFAULT_FORBID_CONTENTS","DATA_URI_TAGS","DEFAULT_DATA_URI_TAGS","URI_SAFE_ATTRIBUTES","DEFAULT_URI_SAFE_ATTRIBUTES","MATHML_NAMESPACE","SVG_NAMESPACE","HTML_NAMESPACE","NAMESPACE","IS_EMPTY_INPUT","ALLOWED_NAMESPACES","DEFAULT_ALLOWED_NAMESPACES","PARSER_MEDIA_TYPE","SUPPORTED_PARSER_MEDIA_TYPES","DEFAULT_PARSER_MEDIA_TYPE","CONFIG","formElement","isRegexOrFunction","testValue","_parseConfig","cfg","ADD_URI_SAFE_ATTR","ADD_DATA_URI_TAGS","ALLOWED_URI_REGEXP","ADD_TAGS","ADD_ATTR","TRUSTED_TYPES_POLICY","MATHML_TEXT_INTEGRATION_POINTS","HTML_INTEGRATION_POINTS","COMMON_SVG_AND_HTML_ELEMENTS","ALL_SVG_TAGS","ALL_MATHML_TAGS","_checkValidNamespace","parentTagName","_forceRemove","_removeAttribute","getAttributeNode","_initDocument","dirty","leadingWhitespace","dirtyPayload","parseFromString","createDocument","_createNodeIterator","SHOW_ELEMENT","SHOW_PROCESSING_INSTRUCTION","SHOW_CDATA_SECTION","_isClobbered","_isNode","_executeHook","entryPoint","_sanitizeElements","allowedTags","_isBasicCustomElement","childClone","__removalCount","expr","_isValidAttribute","lcTag","_sanitizeAttributes","hookEvent","keepAttr","allowedAttributes","initValue","forceKeepAttr","getAttributeType","setAttributeNS","_sanitizeShadowDOM","shadowNode","shadowIterator","sanitize","importedNode","returnNode","nodeIterator","shadowroot","shadowrootmode","serializedHTML","setConfig","clearConfig","isValidAttribute","addHook","hookFunction","removeHook","removeHooks","removeAllHooks","purify","each$4","queryParts","DEFAULT_PORTS","ftp","http","https","mailto","safeSvgDataUrlElements","blockSvgDataUris","allowSvgDataUrls","decodeUri","encodedUri","unescape","isInvalidUri","decodedUri","allow_html_data_urls","URI","uriComponents","isDomSafe","protocol","pathname","baseUri","base_uri","isProtocolRelative","toAbsPath","urlMatch","part","userInfo","port","setPath","pathMatch","file","getURI","toRelative","relativeUri","tu","uu","toRelPath","anchor","toAbsolute","noHost","absoluteUri","isSameOrigin","defaultPort","breakPoint","normalizedBase","nb","normalizedPath","baseParts","pathParts","outPath","noProtoHost","filteredUrlAttrs","internalElementAttr","processNode","_d","allow_conditional_comments","lcTagName","isInternalElement","bogus","processAttr","ele","shouldKeepAttribute","isBooleanAttribute","isRequiredAttributeOfInternalElement","filterAttributes","setupPurify","namespaceTracker","purify$1","getPurifyConfig","mimeType","basePurifyConfig","config","sanitizeSvgElement","xlinkAttrs","sanitizeMathmlElement","allowedEncodings","allow_mathml_annotation_encodings","encoding","mkSanitizeNamespaceElement","namespaceType","getSanitizer","sanitizeHtmlElement","sanitizeNamespaceElement","_mimeType","extend$1","transferChildren","nativeParent","nsSanitizer","isSpecial","nativeChild","walkTree","preprocessors","postprocessors","traverseOrder","postprocess","whitespaceCleaner","textRootBlockElements","allWhiteSpaceRegExp","startWhiteSpaceRegExp","endWhiteSpaceRegExp","hasWhitespaceParent","isTextRootBlockEmpty","isAtEdgeOfBlock","neighbour","isNodeEmpty","getRootBlockName","forced_root_block","DomParser","nodeFilterRegistry","attributeFilterRegistry","defaultedSettings","root_name","sanitizer","parseAndSanitizeWithContext","rootName","isSpecialRoot","makeWrap","removeNodeFilter","removeAttributeFilter","findInvalidChildren","isWrappableNode","addRootBlocks","rootBlockName","rootBlockNode","rootBlock","forced_root_block_attrs","whitespacePre","whitespacePost","invalidFinder","matchFinder","topLevelChildren","otherChildren","exports","serializeContent","withSerializedContent","fireEvent","parserSettings","serializedContent","eventArgs","makeParserSettings","preProcessGetContent","postProcessGetContent","processedEventArgs","preProcessSetContent","postProcessSetContent","tableModel","tableRow","cellPosition","getSpan","fillout","rowspan","colspan","y2","x2","cellExists","skipCellsX","getWidth","row","findElementPos","extractRows","sx","sy","ey","newRows","subTable","createDomTable","tableElement","tableBody","modelRowsToDomRows","toDom","subsection","findParentListContainer","getFullySelectedListWrappers","_li","listCont","listElm","listStyles","_style","innerElm","directListWrappers","commonAnchorContainer","getWrapElements","wrapElements","listWrappers","allWrappers","emptyFragment","getFragmentFromRange","getParentTable","getTableFragment","selectedTableCells","firstCell","lastCell","fullTableModel","sectionedTableModel","getSelectionFragment","read$3","isCollapsibleWhitespace","getInnerText","bin","getContextNodeName","parentBlockOpt","getTextContent","contextNodeName","rangeContentClone","nonRenderedText","parentBlockText","textIndex","hasProceedingSpace","hasTrailingSpace","getSerializedContent","tmpElm","contextual","extractSelectedContent","setupArgs$3","getInner","getSelectedContentInternal","defaultedArgs","updatedArgs","KEEP","INSERT","diff","vDown","vUp","snake","diag","buildScript","start1","end1","start2","end2","getMiddleSnake","j","i2","buildSnake","sum","getOuterHtml","insertAt","removeAt","applyDiff","read$2","trimZwsp","write","currentFragments","lazyTempDocument","hasIframes","createFragmentedLevel","beforeBookmark","createCompleteLevel","createFromEditor","applyToEditor","level","getLevelContent","getCleanLevelContent","hasEqualContent","level1","level2","hasEqualCleanedContent","isEq$1","isUnlocked","locks","setTyping","typing","endTyping","endTypingLevelIgnoreLocks","beforeChange$1","addUndoLevel$1","currentLevel","newLevel","lastLevel","bm","customUndoRedoLevels","setDirty","clear$1","extra$1","callback1","callback2","redo$1","undo$1","reset$1","hasUndo$1","hasRedo$1","transact$1","beforeChange","ignore","ignore$1","addVisualInternal","matchedElm","hasVisual","makePlainAdaptor","init","bindEvents","undo","redo","hasUndo","hasRedo","extra","formatChanged","addVisual","autocompleter","addDecoration","removeDecoration","makeRtcAdaptor","rtcEditor","defaultVars","_undoManager","_locks","_index","_node","_similar","_rfl","_details","_format","getRawModel","makeNoopAdaptor","nul","isRtc","plugins","getRtcSetup","rtcPlugin","setup$t","editorCast","rtcInstance","rtc","isRemote","getRtcInstanceWithFallback","getRtcInstanceWithError","addUndoLevel","matchFormat","matchAllFormats","matchNodeFormat","canApplyFormat","closestFormat","applyFormat","removeFormat","toggleFormat","getContent$2","setContent$2","insertContent$1","getSelectedContent","addVisual$1","getContent$1","walkPastBookmark","merge$1","outer","outerElm","oldLength","normalizeTextIfRequired","mergeAndNormalizeText","outerNode","normalizer","innerTextNode","rngSetContent","prevText","nextText","setupArgs$2","cleanContent","contextBlock","contextArgs","setContent$1","cleanedContent","createContextualFragment","deleteFromCallbackMap","SelectorChanged","selectorChangedData","currentSelectors","findMatchingNode","matchedSelectors","selectorChangedWithUnbind","isAttachedToDom","isValidRange","EditorSelection","selectedRange","explicitRange","getRng$1","getEnd$1","bookmarkManager","select$1","compareEndPoints","fakeSelectedElements","tryCompareBoundaryPoints","how","sourceRange","destinationRange","compareBoundaryPoints","anchorNode","START_TO_START","END_TO_END","removeAllRanges","addRange","setBaseAndExtent","focusNode","setNode","getSelectedBlocks$1","anchorRange","focusRange","anchorOffset","focusOffset","selectorChanged","getScrollContainer","scrollContainer","placeCaretAt","controlSelection","htmlParser","prevName","lastParent","register$3","hasChildren","preserve_cdata","remove_trailing_brs","trimTrailingBr","isBr","brNode1","brNode2","preProcess$1","oldDoc","clonedNode","impl","shouldFireEvent","hasEventListeners","process$1","postProcess","outArgs","getHtmlFromNode","parseHtml","serializeNode","htmlSerializer","toHtml","DomSerializerImpl","addRules","setRules","DomSerializer","domSerializer","defaultFormat$1","setupArgs$1","defaultFormat","setupArgs","removedOptions","deprecatedOptions","removedPlugins","deprecatedPlugins","getMatchingOptions","searchingFor","settingNames","setting","getRemovedOptions","getDeprecatedOptions","getMatchingPlugins","plugin","pluginNames","getRemovedPlugins","getDeprecatedPlugins","entry","logRemovedWarnings","rawOptions","normalizedOptions","hasRemovedPlugins","hasRemovedOptions","isLegacyMobileTheme","theme","listJoiner","themesMessage","pluginsMessage","optionsMessage","getPluginDescription","replacedWith","logDeprecatedWarnings","hasDeprecatedPlugins","hasDeprecatedOptions","logWarnings","DOM$8","restoreOriginalStyles","orgDisplay","safeDestroy","clearDomReferences","contentAreaContainer","editorContainer","bodyElement","contentDocument","contentWindow","restoreForm","form","_mceOldSubmit","submit","formEventDelegate","remove$1","editorUpload","save","is_removing","unbindAllNativeEvents","automatic","destroyed","_beforeUnload","CreateIconManager","iconPack","icons","IconManager","getProp","propName","getComputedSizeProp","getClientWidth","getClientHeight","getMarginTop","getMarginLeft","isInsideElementContentArea","bodyElm","transpose","isXYInContentArea","transposedPoint","fromDomSafe","isEditorAttachedToDom","rawContainer","getContentAreaContainer","NotificationManagerImpl","unimplemented","open","close","getArgs","NotificationManager","notifications","getImplementation","getNotificationManagerImpl","getTopNotification","progressBar","timeout","notification","addNotification","closeNotification","otherNotification","getNotifications","registerEvents","serviceMessage","requestAnimationFrame","isF12","notificationApi","getEl","WindowManagerImpl","openUrl","alert","confirm","WindowManager","dialogs","getWindowManagerImpl","funcBind","fireOpenEvent","dialog","fireCloseEvent","addDialog","closeDialog","otherDialog","getTopDialog","storeSelectionAndOpenDialog","openDialog","ui","windowManagerImpl","displayNotification","notificationManager","displayError","_skinLoaded","uploadError","logError","createLoadError","pluginLoadError","iconsLoadError","languageLoadError","themeLoadError","modelLoadError","pluginInitError","initError","isContentCssSkinName","toContentSkinResourceName","isBundledCssSkinName","tinymce","Resource","getContentCssUrls","transformToUrls","getFontCssUrls","cssLinks","skinUrl","contentCssFile","documentBaseURI","appendContentCssFromSettings","contentCSS","getAllImages","ImageScanner","uploadStatus","cachedPromises","images","isUploaded","promises","imageInfo","image","newPromise","UploadStatus","PENDING","UPLOADED","blobUriStatuses","createStatus","resultUri","hasBlobUri","getResultUri","isPending","markPending","markUploaded","removeFailed","seed","rnd","now","uuid","BlobCache","cache","mimeToExt","mimes","filename","toBlobInfo","URL","createObjectURL","findFirst","cachedBlobInfo","removeByUri","revokeObjectURL","Uploader","pendingPromises","pathJoin","path1","path2","defaultHandler","progress","xhr","XMLHttpRequest","withCredentials","credentials","upload","onprogress","loaded","total","json","JSON","responseText","basePath","formData","FormData","send","uploadHandler","noUpload","handlerSuccess","handlerFailure","resolvePending","uploadBlobInfo","openNotification","percent","isDefaultHandler","pendingUploadBlobInfo","uploadBlobs","blobInfos","createUploader","ImageUploader","uploader","showNotification","isEmptyForPadding","addPaddingToEmpty","EditorUpload","imageScanner","urlFilters","aliveGuard","cacheInvalidator","replaceString","replaceImageUrl","targetUrl","replacementUrl","replacementString","replaceUrlInUndoStack","replaceImageUriInView","uploadImages","scanForImages","imageInfos","imagesToRemove","shouldDispatchChange","filteredResult","uploadInfo","uploadUri","sugarElement","parentOpt","dispatchChange","uploadImagesAuto","isValidDataUriImage","imgElm","resultItem","replaceBlobUris","source_view","get$1","valigntop","verticalAlign","valignmiddle","valignbottom","alignleft","preview","textAlign","float","marginLeft","marginRight","aligncenter","alignright","alignjustify","bold","fontWeight","italic","fontStyle","underline","strikethrough","strike","forecolor","hilitecolor","fontname","fontFamily","fontsize","fontSize","lineheight","lineHeight","fontsize_class","class","blockquote","subscript","superscript","_fmt","_itemName","lang","customValue","removeformat","genericBase","cellBase","cellFormats","tablecellbackgroundcolor","tablecellverticalalign","tablecellbordercolor","borderColor","tablecellclass","tableclass","tablecellborderstyle","borderStyle","tablecellborderwidth","borderWidth","FormatRegistry","unregister","each$3","isPreviewItem","parsedSelectorToHtml","ancestry","sItem","getRequiredParent","elmRule","wrapInHtml","ancestors","parentCandidate","ancestorName","parentRequired","siblingElm","parentSiblings","parseSelectorItem","$0","$3","$4","parseSelector","getCssText","previewCss","previewStyles","removeVars","previewFrag","previewElm","rawParentFontSize","parentFontSize","numValue","setup$s","addShortcut","Formatter","formatChangeState","shouldIgnoreCommand","isFirstTypedCharacter","addNonTypingUndoLevel","isMeta","isDirty","modKey","hasOnlyMetaOrCtrlModifier","isInsertReplacementText","inputType","isInsertTextDataNull","isInsertFromPasteOrDrop","addKeyboardShortcuts","UndoManager","nonTypingKeycodes","placeholderAttr","isKeyboardEvent","isDeleteEvent","isNonTypingKeyboardEvent","isTypingKeyboardEvent","isVisuallyEmpty","setup$r","placeholder","updatePlaceholder","showPlaceholder","isPlaceholderShown","blockPosition","blockBoundary","getBlockPosition","containerElm","isNotAncestorial","isDifferentBlocks","getClosestHost","isHost","hasSameHost","isEditable$1","hasValidBlocks","isValidBlock","skipLastBr","lastPositionInBlock","readFromRange","fromBlockPos","toBlockPos","blockPos","read$1","getChildrenUntilBlockBoundary","extractChildren","removeEmptyRoot","isEmptyBefore","nestedBlockMerge","toBlock","insertionPoint","sidelongBlockMerge","getInlineToBlockDescendants","newFromBlockDescendants","findInsertionPoint","parentsAndSelf$1","getInsertionPoint","trimBr","mergeBlockInto","mergeBlocks","backspaceDelete$a","deleteRangeMergeBlocks","isRawNodeInTable","isSelectionInTable","isEverythingSelected","noPrevious","noNext","emptyEditor","deleteRange$2","backspaceDelete$9","_forward","showCaret","getNodeRange","renderCaretAtRange","caretPositionNode","caretPositionBeforeNode","ceRoot","renderRangeCaret","isBeforeBoundary","isAfterBoundary","trimEmptyTextNode","deleteContentAndShowCaret","peekCaretPosition","caretRange","deleteRange","deleteBoundaryText","getNextPosFn","isBeforeFn","nextCaretPosition","normalizedNextCaretPosition","backspaceDelete$8","getEdgeCefPosition","atStart","isCefAtEdgeSelected","isCompoundElement","DeleteAction","moveToElement","moveToPosition","isAtContentEditableBlockCaret","caretLocation","isDeleteFromCefDifferentBlocks","deleteEmptyBlockOrMoveToCef","toCefElm","blockElm","findCefPosition","getContentEditableBlockAction","skipMoveToActionFromInlineCefToContent","getContentEditableAction","read","deleteElement$1","hideFakeCaret","getAncestorCe","backspaceDeleteCaret","deleteOffscreenSelection","backspaceDeleteRange","hasCefAncestor","paddEmptyElement","backspaceDelete$7","isTextEndpoint","endpoint","isElementEndpoint","createMarker","getEndpoint","resolveBookmark","Range","backspaceDelete$6","startBlock","endBlock","startBlockName","deleteCaret$2","backspaceDelete$5","isText$2","startsWithCaretContainer","endsWithCaretContainer","createZwsp","insertBefore$1","insertAfter$1","insertInline","insertInlineBefore","insertInlineAfter","insertInlinePos","isPosCaretContainer","caretNode","renderCaret","evaluateUntil","fns","Location","rescope$1","nPos","isNotInsideFormatCaretContainer","findInsideRootInline","start$1","isValidLocation","readLocation","getName","outside","inside","isEq","location1","location2","betweenInlines","fromInline","toInline","skipNoMovement","fromLocation","toLocation","findLocationTraverse","findLocationSimple","findLocation$1","hasSelectionModifyApi","modify","moveRel","moveByWord","BreakType","flip","positions","walk$1","getBreakType","currentPos","Br","Block","Wrap","getPositionsUntil","breakType","breakAt","Eol","getAdjacentLinePositions","getPositionsUntilBreak","findClosestHorizontalPositionFromPoint","lastRect","newRect","lastDist","newDist","findClosestHorizontalPosition","targetRect","getPositionsUntilPreviousLine","getPositionsUntilNextLine","getPositionsAbove","getPositionsBelow","isAtFirstLine","isAtLastLine","getFirstLinePositions","getLastLinePositions","getClosestPositionAbove","getClosestPositionBelow","isContentEditableFalse$5","distanceToRectLeft$1","distanceToRectRight$1","isNodeClientRect","findClosestClientRect","oldClientRect","oldDistance","newDistance","getNodeClientRects","toArrayWithNode","VDirection","findUntil","walkUntil","isAboveFn","isBeflowFn","line","targetClientRect","aboveLineNumber","lineNumber","isLineNumber","upUntil","Up","downUntil","Down","getLastClientRect","positionsUntil","isBelowFn","isAboveLine","isLine","moveToRange","renderRangeCaretOpt","moveHorizontally","isBefore","isAfter","isElement","rangeIsInContainerBlock","moveVertically","caretClientRect","getClosestFn","walkerFn","linePositions","nextLinePositions","nextLineRect","dist1","dist2","caretPositions","closestNextLineRect","getLineEndPoint","lineInfo","moveToLineEndPoint$3","setCaretPosition","setSelected","renderCaretLocation","getPositionFromRange","findLocation","isInlineTarget$1","toggleInlines","inlineBoundaries","selectedInlines","targetInlines","safeRemoveCaretContainer","caretValue","renderInsideInlineCaret","inlines","_inline","move$3","moveWord","_caret","setupSelectedState","moveNextWord","movePrevWord","moveToLineEndPoint$2","linePoint","outsideLoc","rangeFromPositions","hasOnlyTwoOrLessPositionsLeft","setCaretLocation","deleteFromTo","rescope","backspaceDeleteCollapsed","toPosition","backspaceDelete$4","hasMultipleChildren","getParentsUntil","hasOnlyOneChild","getParentInlinesUntilMultichildInline","getParentInlines","getFormatNodes","parentInlines","isFormatElement$1","getFormatNodesAtStart","deleteLastPosition","deleteCaret$1","isBrInEmptyElement","isEmptyCaret","createCaretFormatAtStart","updateCaretFormat","updateFormats","missingFormats","rangeStartsAtTextContainer","rangeStartsAtStartOfTextContainer","rangeStartParentIsFormatElement","startParent","rangeStartAndEndHaveSameParent","endParent","isEqualNode","rangeEndsAtEndOfEndContainer","rangeEndsAtEndOfStartContainer","rangeEndsAfterEndOfStartContainer","rangeEndsAtOrAfterEndOfStartContainer","requiresDeleteRangeOverride","deleteRange$1","backspaceDelete$3","hasAncestorInlineCaret","hasAncestorInlineCaretAtStart","requiresRefreshCaretOverride","refreshCaret","deleteElement","deleteCaret","isNearMedia","backspaceDelete$2","parseIndentValue","getIndentStyleName","useMargin","indentStyleName","indentElement","unit","parsedValue","validateBlocks","intentValue","canOutdent","getBlocksToIndent","isListComponent","parentIsListComponent","indentation","indentUnit","indentValue","outdent","backspaceDelete$1","findAction","deleteCommand","forwardDeleteCommand","setup$q","addCommand","SIGNIFICANT_MOVE","LONGPRESS_DELAY","getTouch","isFarEnough","distX","distY","setup$p","startData","longpressFired","debounceLongpress","isBlockElement","isValidTarget","hasBlockParent","shouldRemoveTextNode","createRootBlock","rootNodeName","insertEmptyLine","setup$o","checkClassName","replaceMatchWithSpan","prevChar","findStartTagIndex","tagHtml","convertRegExpsToNonEditable","nonEditableRegExps","isValidContent","re","setup$n","contentEditableAttrName","editClass","nonEditClass","hasEditClass","hasNonEditClass","findBlockCaretContainer","blockCaretContainer","handleBlockContainer","setup$m","isContentEditableFalse$4","moveToCeFalseHorizontally","moveToCeFalseVertically","createTextBlock","textBlock","exitPreBlock","getVisualCaretPosition$1","newBlock","getHorizontalRange","getVerticalRange","down","flipDirection","moveH$2","moveV$4","moveToLineEndPoint$1","isCefPosition","selectToEndPoint","curRng","getClosestTargetBlock","isAtFirstOrLastLine","moveCaretToNewEmptyLine","insertFn","moveV$3","moveUp","summary","moveDown","move$2","moveV$2","baseKeyPattern","defaultPatterns","defaultDelayedPatterns","matchesEvent","match$1","matchDelayed","execute","executeWithDelayedAction","moveH$1","moveV$1","moveToLineEndPoint","CellLocation","firstLayer","filterFirstLayer","lookup$1","tags","isRootOrUpperTable","isEligible","newIndex","detection","isTextNodeWithCursorPosition","isContentEditableFalse$3","elementsWithCursorPosition","isCursorPosition","hasCursorPosition","deflate","getCorners","getYAxisValue","tds","findClosestCorner","corners","newCorner","oldCorner","oldDist","getClosestCell","isTargetCorner","corner","getBottomValue","getTopValue","getClosestCellAbove","getClosestCellBelow","findClosestPositionInAboveCell","findClosestPositionInBelowCell","hasNextBreak","breakPos","startsWithWrapBreak","startsWithBrBreak","isAtTableCellLine","isAtFirstTableCellLine","isAtLastTableCellLine","isCaretAtStartOrEndOfTable","navigateHorizontally","_td","getClosestAbovePosition","getClosestBelowPosition","getTable","renderBlock","navigateVertically","move$1","mover","moveH","moveV","getCellFirstCursorPosition","tabGo","_current","tabForward","tabBackward","handleTab","rootElements","model","clearSelectedCells","executeKeydownOverride$4","isMac","setup$l","DOM$7","alwaysNext","textBefore","textAfter","scanLeft","scanRight","repeatLeft","isValidTextRange","getText","isWhitespace","stripTrigger","findTrigger","includeWhitespace","firstChar","initRange","buffer","findTriggerIndex","spot","triggerIndex","isText$1","toLast","toLeaf","isPreviousCharContent","leaf","_element","isStartOfWord","getTriggerContext","database","triggers","getDatabase","lookupWithContext","fetchOptions","startText","autocompleters","lookupByTrigger","minChars","lookupData","ac","fetchResult","maxResults","matchText","columns","onAction","highlightOn","SimpleResultType","fold$1","stype","serror","svalue","partition","Value","bind$1","bindError","toResult","fromResult","SimpleResult","formatObj","stringify","formatErrors","es","getErrorInfo","missingRequired","missingKey","missingBranch","branch","custom","chooseFrom","fields","extract","choose$1","choice","chosen","bothObjects","deepMerge","baseMerge","merger","objects","curObject","defaultedThunk","fallbackThunk","defaulted$1","fallback","asOption","mergeValues","mergeErrors","consolidateObj","consolidateArr","partitions","ResultCombine","field$1","newKey","presence","customField$1","instantiator","ifField","ifCustom","validator","anyValue$1","requiredAccess","bundle","fallbackAccess","optionAccess","optionDefaultedAccess","opt","extractField","av","bundleAsOption","optValue","ov","extractFields","objOf","fieldStrings","_okey","_presence","_instantiator","arrOf","valueOf","extractValue","errs","asRaw","formatError","errInfo","choose","anyValue","typedValue","expectedType","actualType","number","string","boolean","functionProcessor","customField","validateEnum","requiredOf","requiredString","requiredFunction","requiredArrayOf","optionOf","optionString","optionFunction","defaulted","defaultedOf","defaultedNumber","defaultedString","defaultedStringEnum","defaultedBoolean","defaultedFunction","defaultedArrayOf","fetch$1","onSetup","optionalText","optionalIcon","optionalTooltip","optionalLabel","active","enabled","primary","defaultedColumns","defaultedType","autocompleterSchema","createAutocompleter","baseToolbarButtonFields","baseToolbarToggleButtonFields","contextBarFields","contextButtonFields","contextToggleButtonFields","launchButtonFields","launchToggleButtonFields","toggleOrNormal","contextformbutton","contextformtogglebutton","register$2","popups","dataset","popup","datasetValues","dv","setupEditorInput","update","which","cancelIfNecessary","setup$k","activeAutocompleter","uiActive","isActive","commenceIfNecessary","matchLength","getAutocompleters","doLookup","newContext","lookupInfo","isRangeInsideOrEqual","innerRange","outerRange","startComparison","endComparison","readActiveRange","selRange","_ui","editorCommands","addQueryStateHandler","browser$1","emptyNodeContents","isEntireNodeSelected","getParentDetailsElementAtPos","isInDetailsElement","getDetailsElements","startDetails","endDetails","startSummary","isCaretInTheBeginningOf","isCaretInTheEndOf","isCaretAtStartOfSummary","detailsElements","isCaretAtEndOfSummary","isCaretInFirstPositionInBody","isCaretInLastPositionInBody","setCaretToPosition","moveCaretToDetailsPos","isPartialDelete","containsStart","containsEnd","startInSummary","endInSummary","isPartiallySelectedDetailsElements","isInPartiallySelectedSummary","shouldPreventDeleteIntoDetails","granularity","parentDetailsAtCaret","inEmptyParentBlock","isFirstBlock","isLastBlock","firstOrLast","isBeforeAfterDetails","parentDetailsAtNewPos","shouldPreventDeleteSummaryAction","detailElements","shouldPreventDeleteAction","handleDeleteActionSafari","applySelection","updateSelection","appendAllChildNodes","backspaceDelete","createAndFireInputEvent","eventType","specifics","overrides","bubbles","detail","currentTarget","eventPhase","AT_TARGET","originalTarget","explicitOriginalTarget","isTrusted","cancelable","InputEvent","fireInputEvent","fireBeforeInputEvent","platform$2","isMacOSOriOS","executeKeydownOverride$3","unmodifiedGranularity","getModifiedGranularity","isWord","applyAction","beforeInput","executeKeyupOverride","isBackspaceKeydown","setup$j","firstNonWhiteSpaceNodeSibling","moveToCaretPosition","getEditableRoot","editableRoot","getParentBlock$1","getParentBlockName","isListItemParentBlock","applyAttributes","forcedRootBlockAttrs","attrStyles","currentStyles","attrClassesOpt","attrClasses","currentClassesOpt","currentClasses","filteredClasses","newClasses","appliedAttrs","remainingAttrs","setForcedBlockAttrs","createNewBlock","keepStyles","newBlockName","parentBlockName","getDetailsRoot","isAtDetailsEdge","isLastEmptyBlockInDetails","insertNewLine","hasFirstChild","isFirstChild","hasParent","isListBlock","isListItem","isNestedList","getContainerBlock","containerBlock","containerBlockParent","isFirstOrLastLi","getStyles","insert$4","containerParent","parentBlockStyles","tmpRng","previousChildren","isWithinNonEditableList","parentList","isEmptyAnchor","containerAndPreviousSiblingName","containerAndNextSiblingName","canSplitBlock","trimInlineElementsOnLeftSideOfBlock","firstChilds","normalizeZwspOffset","includeZwspInRange","trimLeadingLineBreaks","wrapSelfAndSiblingsInDefaultBlock","startNodeName","startNodeParent","addBrToBlockIfNeeded","shouldEndContainer","optionValue","insert$3","isAfterLastNodeInContainer","isCef","collapsedAndCef","createNewBlock$1","isCaretAtStartOrEndOfBlock","normalizedOffset","insertNewBlockAfter","containerBlockName","liBlock","parentBlockParent","afterTable","parentBlockSugar","afterBr","prevBrOpt","fakeEventName$1","blockbreak","fakeEventName","hasRightSideContent","moveSelectionToBr","brElm","extraBr","insertBrAtCaret","isControlKey","insertBrBefore","insertBrAfter","hasBrAfter","isBeforeBr","isAnchorLink","isInsideAnchor","readInlineAnchorLocation","insertBrOutsideAnchor","insert$2","anchorLocation","linebreak","matchesSelector","shouldInsertBr","shouldBlockNewLine$1","newLineAction","shouldBlockNewLine","_shiftKey","inListBlock","requiredState","inBlock","inCefBlock","inPreBlock","inSummaryBlock","shouldPutBrInPre","inBrContext","hasShiftKey","_editor","canInsertIntoEditableRoot","rootEditable","isInRootWithEmptyOrCEF","isCefOpt","predicates","isMatch","getAction","insertBreak","insert$1","logicalAction","platform$1","isIOSSafari","handleEnterKeyEvent","isCaretAfterKoreanCharacter","koreanCharRegex","setup$i","iOSSafariKeydownBookmark","iOSSafariKeydownOverride","iOSSafariKeyupOverride","executeKeydownOverride$2","setup$h","setup$g","platform","executeKeyupAction","isPageUpDown","setNodeChangeBlocker","blocked","setup$f","setup$e","insertTextAtPosition","insertNbspAtPosition","insertSpaceAtPosition","insertSpaceOrNbspAtPosition","locationToCaretPosition","insertInlineBoundarySpaceOrNbsp","checkPos","setSelection","isInsideSummary","domUtils","insertSpaceOrNbspAtSelection","insertSpaceInSummaryAtSelectionOnFirefox","insertSpaceThunk","executeKeydownOverride$1","setup$d","tableTabNavigation","executeKeydownOverride","setup$c","setup$b","NodeChange","lastPath","lastRng","nativeRng","fakeRng","isSameElementPath","initialized","currentPath","imageId","getDragImage","transfer","setDragImage","imageData","eventId","getEvent","mkSetEventFn","setEvent","setDragstartEvent","setDropEvent","setDragendEvent","checkEvent","isInDragStartEvent","createEmptyFileList","modeId","getMode","mkSetModeFn","setMode$1","setReadWriteMode","setReadOnlyMode","setProtectedMode","checkMode","expectedMode","isInReadWriteMode","isInProtectedMode","normalizeItems","dataTransfer","itemsImpl","validDropEffects","validEffectAlloweds","createDataTransfer","dataTransferImpl","DataTransfer","dropEffect","effectAllowed","effect","allowed","types","setData","clearData","cloneDataTransfer","originalMode","getHtmlData","setHtmlData","internalMimeType","internalHtmlMime","internalMark","mark","unmark","isMarked","isPlainText","openContainer","rootTag","rootAttrs","toBlockElements","tagOpen","tagClose","paragraphs","stitch","pasteBinDefaultContent","create$6","lastRngCell","pasteBinElm","pasteBinClone","isPasteBin","getHtml","copyAndRemove","toElm","fromElm","pasteBinClones","dirtyWrappers","cleanWrapper","isDefaultPasteBinContent","PasteBin","getLastRng","filter$1","voidElements","ignoreElements","trimHtml","trimSpaces","s1","s2","createIdGenerator","getImageMimeType","lowerExt","mimeOverrides","jpg","jpe","jfi","jif","jfif","pjpeg","pjp","preProcess","processResult","cancelled","postProcessFilter","tempBody","postProcessArgs","filterContent","preProcessArgs","filteredContent","pasteHtml$1","isAbsoluteUrl","isImageUrl","createImage","pasteHtmlFn","createLink","linkSelection","insertImage","smartInsertContent","pasteAsText","createPasteDataTransfer","doPaste","shouldSimulateInputEvent","doPasteAction","pasteHtml","internalFlag","pasteText","encodedText","getDataTransferItems","contentType","hasContentType","clipboardContent","hasHtmlOrText","extractFilename","createBlobInfo","useFileName","pasteImage","imageItem","existingBlobInfo","isClipboardEvent","readFilesAsDataUris","allowedExtensions","extension","getImagesFromDataTransfer","kind","getAsFile","pasteImageData","clipboardData","fileResults","isBrokenAndroidClipboardEvent","isKeyboardPasteEvent","insertClipboardContent","plainTextMode","isInternal","isPlainTextHtml","isAbsoluteUrl$1","registerEventHandlers","pasteBin","pasteFormat","keyboardPastePlainTextState","registerDataImageFilter","isWebKitFakeUrl","isDataUri","isPasteInsert","registerEventsAndFilters","togglePlainTextPaste","register$1","setHtml5Clipboard","setClipboardData","contenteditable","overflow","offscreenRange","selectNodeContents","isTableSelection","hasSelectedContent","cut","getCaretRangeFromEvent","isPlainTextFileUrl","plainTextContent","setFocusedRange","hasImage","needsCustomInternalDrop","dropContent","parentTransparent","inSummary","setupSummaryDeleteByDragFix","hasNoSummary","brokenDetailElements","setup$a","draggingInternallyState","internalContent","needsInternalDrop","isInternalDrop","trimmedContent","setup$9","processEvent","addPreProcessFilter","filterFunc","rgbRegExp","rgbToHex","removeWebKitStyles","webKitStylesOption","webKitStyles","inputStyles","outputStyles","inputValue","compareInput","outputStyle","setup$8","setup$7","preventSummaryToggle","filterDetails","initialStateOption","serializedStateOption","setup$6","isText","isContentEditableFalse$2","isContentEditableTrue","getClosestScope","getClosestCef","findEdgeCaretCandidate","findClosestBlockRange","startRng","clickNode","cef","onTripleClickSelect","setup$5","FakeCaretPosition","distanceToRectLeft","distanceToRectRight","isInsideY","collidesY","isOverlapping","overlap","splitRectsPerAxis","intersectingRects","boundingRect","horizontal","vertical","clientInfo","Before","After","horizontalDistance","_y","closestChildCaretCandidateNodeRect","findCloserTextNode","caretCandidateRect","tryFindSecondBestTextNode","sndClosest","distance","deltaDistance","findClosestCaretCandidateNodeRect","sortedRects","horizontalRects","verticalRects","above","below","traverseUp","prevScope","isDragGhostContainer","childNodesWithoutGhost","uncheckedChildren","newScope","closestCaretCandidateNodeRect","ownerDoc","elementAtPoint","closestFakeCaretCandidate","getAbsolutePosition","docElem","getBodyPosition","getScrollPosition","getBodyScroll","inlineScroll","iframeScroll","getMousePosition","iframePosition","scrollPosition","calculatePosition","bodyPosition","mousePosition","calc","getTargetProps","makeDndEventFromMouseEvent","makeDndEvent","timeStamp","BUBBLING_PHASE","CAPTURING_PHASE","NONE","button","buttons","movementX","movementY","offsetX","offsetY","relatedTarget","initUIEvent","initMouseEvent","makeDataTransferCopyForDragEvent","makeDragEvent","dataTransferForDispatch","scrollPixelsPerInterval","scrollIntervalValue","mouseRangeToTriggerScrollInsideEditor","mouseRangeToTriggerScrollOutsideEditor","isContentEditableFalse$1","isDraggable","isValidDropTarget","dragElement","createGhost","clonedElm","opacity","padding","boxSizing","appendGhostToBody","scrollEditor","amount","behavior","scrollRight","scrollUp","scrollDown","moveGhost","maxX","maxY","mouseY","mouseX","mouseEventOriginatedFromWithinTheEditor","overflowX","outerMouseY","outerMouseX","dragging","innerWidth","removeElement","removeElementWithPadding","isLeftMouseButtonPressed","applyRelPos","relX","ceElm","elmPos","relY","ghost","caretInfo","dispatchDragEvent","move","throttledPlaceCaretAt","state_","movement","targetPos","getRawTarget","drop","dropTarget","removeDragState","stopDragging","bindFakeDragEvents","pageDom","dragStartHandler","dragHandler","dropHandler","dragEndHandler","blockUnsupportedFileDrop","preventFileDrop","preventFileDropIfUIElement","editorRoot","eventNames","init$2","setup$4","renderFocusCaret","setup$3","isContentEditableFalse","getContentEditableRoot","SelectionOverrides","realSelectionId","selectedElement","isFakeSelectionElement","isFakeSelectionTargetElement","setRange","removeElementSelection","contentEditableRoot","setElementSelection","closestContentEditable","normalizeVoidElementSelection","isRangeInCaretContainer","isWithinCaretContainer","setupOffscreenSelection","targetClone","realSelectionContainer","selectElement","nodeElm","afterNode","getNormalizedTextOffset","generatePath","generatePathRange","resolvePath","nodePath","resolvedNode","optNode","resolvePathRange","generatePathRangeFromRange","cleanEmptyNodes","deleteRng","getParentBlock","resolveFromDynamicPatterns","patternSet","beforeText","dynamicPatterns","getBeforeText","newMarker","rangeFromMarker","markerPrefix","pathRange","textEnd","textStart","startParentNode","endParentNode","removeMarker","isReplacementPattern","matchesPattern","patternContent","searchText","startEndIndex","findPatternStartFromSpot","startPattern","startSpot","startPatternIndex","isCompleteMatch","nextSpot","findPatternStart","requireGap","startRange","findPattern$3","normalizedMatches","endPathRng","endRng","resultsOpt","findPatternsRec","remainingPatterns","startPathRng","endSpot","patternsWithoutCurrent","applyPattern$2","patternRange","applyReplacementPattern","markerRange","applyPatternWithContent","startMarker","endMarker","markerEndRange","markerStartRange","patternMarker","addMarkers","matchesWithEnds","sortPatterns$1","getBestMatches","matchesWithSortedPatterns","hasSameMatches","sortedMatch","findPatterns$2","applyMatches$2","matchesWithMarkers","stripPattern$1","createApplyPattern","stripPattern","isBlockFormatName","formatSet","sortPatterns","findPattern$2","sortedPatterns","nuText","createFindPatterns","findPattern","skipFullMatch","startsWithSingleSpace","applyPattern$1","findPattern$1","findPatterns$1","getMatches$1","dynamicPatternSet","inlineMatches","blockMatches","applyMatches$1","applyPattern","findPatterns","getMatches","applyMatches","handleEnter","handleInlineKey","handleBlockPatternOnSpace","checkKeyEvent","codes","checkKeyCode","checkCharCode","charCode","setup$2","charCodes","keyCodes","getPatternSet","queryCommandSupported","hasDynamicPatterns","hasPatterns","handleInlineTrigger","setup$1","Quirks","isGecko","isWebKit","setEditorCommandState","emptyEditorWhenDeleting","serializeRng","contents","allContentsSelected","allRng","allSelection","selectAll","shortcuts","documentElementEditingFocus","removeHrOnBackspace","blur","selectControlElements","visualAidsAnchorClass","removeStylesWhenDeletingAcrossBlockElements","getAttributeApplyFunction","setAttributeNode","isSelectionAcrossElements","disableBackspaceIntoATable","removeBlockQuoteOnBackSpace","setGeckoEditingOptions","setOpts","addBrAfterLastLinks","fixLinks","setDefaultBlockType","isAllContentSelected","showBrokenImageIcon","contentStyles","restoreFocusOnKeyDown","bodyHeight","blockCmdArrowNavigation","tapLinksAndImages","blockFormSubmitInsideEditor","removeAppleInterchangeBrs","setupRtc","isGplKey","isValidGeneratedKey","validateLicenseKey","validateEditorLicenseKey","licenseKey","hasApiKey","DOM$6","appendStyle","getRootName","removeUndefined","mkParserSettings","mkSchemaSettings","mkSerializerSettings","createParser","autoFocus","moveSelectionToFirstCaretPosition","initEditor","bindPendingEventDelegates","initInstanceCallback","getStyleSheetLoader$1","makeStylesheetLoadingPromises","framedFonts","bundledCss","normalCss","bundledPromises","loadContentCss","fontCss","removeCss","contentCssText","allStylesheets","contentStyle","preInit","spellcheck","directionality","protect","loadInitialContent","startContent","initEditorWithInitialContent","startProgress","canceled","progressTimeout","setProgressState","contentBodyLoaded","disabled","readonly","_editableRoot","annotator","_nodeChangeDispatcher","setupRtcThunk","cancelProgress","_rtcMode","DOM$5","createIframeElement","title","customAttrs","tabindex","iframe","frameBorder","allowTransparency","getIframeHtml","iframeHTML","bodyId","bodyClass","translatedAriaText","createIframe","boxInfo","iframeTitle","translatedTitle","ifr","iframeContainer","setupIframeBody","ready","srcdoc","init$1","hidden","visibility","orgVisibility","DOM$4","initPlugin","initializedPlugins","Plugin","pluginUrl","pluginInstance","trimLegacyPrefix","initPlugins","initIcons","iconPackName","currentIcons","loadIcons","svgData","icon","addIcon","initTheme","Theme","initModel","Model","renderFromLoadedTheme","render","renderUI","renderThemeFalse","renderFromThemeFunc","iframeHeight","createThemeFalseResult","renderThemeFalseIframe","renderThemeUi","augmentEditorUiApi","uiApiFacade","isEnabled","setEnabled","shouldSkip","renderInfo","DOM$3","hasSkipLoadPrefix","loadLanguage","scriptLoader","languageCode","languageUrl","loadTheme","themeUrl","loadModel","modelUrl","getIconsUrlMetaFromUrl","getIconsUrlMetaFromName","defaultIconsUrl","customIconsUrl","urlMeta","loadPlugins","loadPlugin","isThemeLoaded","isModelLoaded","getStyleSheetLoader","snapshot","resetContent","triggerSave","windowManager","set_dirty","setEditableRoot","sectionResult","sections","deviceDetection","normalizePlugins","trimmedPlugins","extractSections","getSection","defaults","sectionOptions","hasSection","getSectionConfig","getMobileOverrideOptions","mobileOptions","defaultMobileOptions","table_grid","object_resizing","resize","toolbar_mode","toolbar_sticky","defaultPhoneOptions","menubar","getExternalPlugins","overrideOptions","userDefinedExternalPlugins","external_plugins","combinePlugins","forcedPlugins","getPlatformPlugins","isMobileDevice","desktopPlugins","mobilePlugins","processPlugins","defaultOverrideOptions","forced_plugins","mobileConfig","platformPlugins","combinedPlugins","isOnMobile","combineOptions","defaultOptions","deviceOverrideOptions","mobile","extendedOptions","normalizeOptions","copiedOptions","registerExecCommands$2","toggleAlign","addCommands","JustifyLeft","JustifyCenter","JustifyRight","JustifyFull","JustifyNone","registerQueryStateCommands","alignStates","registerCommands$a","registerCommands$9","queryCommandEnabled","trimOrPadLeftRight","processValue$1","trimOrPad","insertAtCaret","insertedContent","registerCommands$8","mceCleanup","_command","insertHorizontalRule","insertText","insertHTML","mceInsertContent","mceSetContent","mceReplaceContent","mceNewDocument","legacyPropNames","isFont","getSpecifiedFontProp","getProperty","legacyPropName","normalizeFontFamily","getComputedFontProp","getFontProp","getFontSize","getFontFamily","findFirstCaretElement","getCaretElement","atStartOfNode","bindRange","mapRange","fromFontSizeNumber","fontSizeNumber","fontClasses","normalizeFontNames","font","fonts","fontNameAction","fontNameQuery","fontSizeAction","fontSizeQuery","lineHeightQuery","specifiedStyle","computedStyle","lineHeightAction","registerExecCommands$1","ForeColor,HiliteColor","BackColor","FontName","FontSize","LineHeight","Lang","customCode","mceBlockQuote","FormatBlock","mceToggleFormat","registerQueryValueCommands","isFormatMatch","addQueryValueHandler","registerCommands$7","registerCommands$6","mceAddUndoLevel","mceEndUndoLevel","Undo","Redo","registerCommands$5","Indent","Outdent","registerCommands$4","applyLinkToSelection","linkDetails","unlink","mceInsertLink","getTopParentBlock","topParentBlock","registerCommands$3","InsertNewBlockBefore","InsertNewBlockAfter","registerCommands$2","insertParagraph","mceInsertNewLine","InsertLineBreak","registerCommands$1","mceSelectNodeDepth","mceSelectNode","registerExecCommands","mceRemoveNode","mcePrint","print","mceFocus","mceToggleVisualAid","registerCommands","selectionSafeCommands","isSelectionSafeCommand","EditorCommands","commands","lowerCaseCommand","skip_focus","queryCommandState","queryCommandValue","commandList","setContentEditable","removeFakeSelection","restoreFakeSelection","setCommonEditorCommands","setEditorReadonly","unsetEditorReadonly","toggleReadOnly","isClickEvent","allowedEvents","isReadOnlyAllowedEvent","getAnchorHrefOpt","processReadonlyEvents","targetEl","registerReadOnlySelectionBlockers","undoLevel","nativeEvents","EventDispatcher","isNative","bindings","toggleEvent","beforeFire","wrappedCallback","currentName","bindingName","filteredHandlers","binding","getEventDispatcher","_eventDispatcher","toggleNativeEvent","Observable","bubble","dispatcherArgs","DOM$2","customEventRootDelegates","getEventTarget","eventName","eventRoot","isListening","bindEventDelegate","delegates","eventRootElm","delegate","editors","EditorObservable","_pendingNativeEvents","stringListProcessor","getBuiltInProcessor","processValue","isBuiltInSpec","getErrorMessage","additionalText","isValidResult","processDefaultValue","create$5","initialOptions","rawInitialOptions","setValue","isRegistered","immutable","unset","registered","debug","defaultModes","switchToMode","activeMode","availableModes","oldMode","newMode","activate","deactivate","editorReadOnly","setMode","registerMode","create$4","design","each$2","keyCodeLookup","f1","f2","f3","f4","f5","f6","f7","f8","f9","f10","f11","f12","modifierNames","isModifier","parseShortcut","shortcut","access","alt","ctrl","meta","Shortcuts","pendingPatterns","hasModifier","isFunctionKey","matchShortcut","subpatterns","executeShortcutAction","cmdFunc","normalizeCommandFunc","createShortcut","create$3","menuItems","contextMenus","contextToolbars","contexts","sidebars","views","addContext","addButton","addGroupToolbarButton","addToggleButton","addMenuButton","addSplitButton","addMenuItem","addNestedMenuItem","addToggleMenuItem","addAutocompleter","addContextMenu","addContextToolbar","addContextForm","addSidebar","addView","bridge","DOM$1","each$1","Editor","loadedCSS","isNotDirty","documentBaseURL","_setBaseUrl","baseURI","setupCallback","getParam","loadArgs","saveArgs","initialContent","oldState","urlConverterCallback","urlObject","_scanForImages","boundGlobalEvents","beforeUnloadDelegate","globalEventDelegate","EditorManager","toggleGlobalEvents","removeEditorFromList","targetEditor","oldEditors","purgeDestroyedEditor","isQuirksMode","compatMode","majorVersion","minorVersion","releaseDate","i18n","tinyMCEPreInit","srcScript","overrideDefaults","base_url","pluginBaseUrls","plugin_base_urls","pluginBaseUrl","pluginName","invalidInlineTargets","isInvalidInlineTarget","createId","execCallback","findTargets","provideResults","initEditors","initCount","createEditor","existingEditor","editorId","editorOptions","addI18n","dataValue","FakeClipboardItem","getType","FakeClipboard","relativePosition","targetW","targetH","relChars","create$2","findBestRelativePosition","constrainRect","rels","inflate","intersect","cropRect","x1","y1","clamp","clampRect","fixedSize","cx2","cy2","underflowX1","underflowY1","overflowX2","overflowY2","fromClientRect","Rect","awaiter","resolveCb","rejectCb","complete","completer","create$1","tasks","resultFns","resources","loadErrMsg","runErrMsg","task","waiter","storage","getItem","setItem","removeItem","defineProperty","localStorage","LocalStorage","publicApi","geom","util","TreeWalker","Serializer","Selection","tinymce$1","exportToModuleLoaders","module","exportToWindowGlobal","tinyMCE"],"sources":["C:/Users/alanp/Desktop/Dev_GitHub/Smart-Residential-Energy-Consumption-Monitoring-System--SMCERI-/smceri/node_modules/tinymce/tinymce.js"],"sourcesContent":["/**\n * TinyMCE version 7.5.1 (TBD)\n */\n\n(function () {\n    'use strict';\n\n    var typeOf$1 = function (x) {\n      if (x === null) {\n        return 'null';\n      }\n      if (x === undefined) {\n        return 'undefined';\n      }\n      var t = typeof x;\n      if (t === 'object' && (Array.prototype.isPrototypeOf(x) || x.constructor && x.constructor.name === 'Array')) {\n        return 'array';\n      }\n      if (t === 'object' && (String.prototype.isPrototypeOf(x) || x.constructor && x.constructor.name === 'String')) {\n        return 'string';\n      }\n      return t;\n    };\n    var isEquatableType = function (x) {\n      return [\n        'undefined',\n        'boolean',\n        'number',\n        'string',\n        'function',\n        'xml',\n        'null'\n      ].indexOf(x) !== -1;\n    };\n\n    var sort$1 = function (xs, compareFn) {\n      var clone = Array.prototype.slice.call(xs);\n      return clone.sort(compareFn);\n    };\n\n    var contramap = function (eqa, f) {\n      return eq$2(function (x, y) {\n        return eqa.eq(f(x), f(y));\n      });\n    };\n    var eq$2 = function (f) {\n      return { eq: f };\n    };\n    var tripleEq = eq$2(function (x, y) {\n      return x === y;\n    });\n    var eqString = tripleEq;\n    var eqArray = function (eqa) {\n      return eq$2(function (x, y) {\n        if (x.length !== y.length) {\n          return false;\n        }\n        var len = x.length;\n        for (var i = 0; i < len; i++) {\n          if (!eqa.eq(x[i], y[i])) {\n            return false;\n          }\n        }\n        return true;\n      });\n    };\n    var eqSortedArray = function (eqa, compareFn) {\n      return contramap(eqArray(eqa), function (xs) {\n        return sort$1(xs, compareFn);\n      });\n    };\n    var eqRecord = function (eqa) {\n      return eq$2(function (x, y) {\n        var kx = Object.keys(x);\n        var ky = Object.keys(y);\n        if (!eqSortedArray(eqString).eq(kx, ky)) {\n          return false;\n        }\n        var len = kx.length;\n        for (var i = 0; i < len; i++) {\n          var q = kx[i];\n          if (!eqa.eq(x[q], y[q])) {\n            return false;\n          }\n        }\n        return true;\n      });\n    };\n    var eqAny = eq$2(function (x, y) {\n      if (x === y) {\n        return true;\n      }\n      var tx = typeOf$1(x);\n      var ty = typeOf$1(y);\n      if (tx !== ty) {\n        return false;\n      }\n      if (isEquatableType(tx)) {\n        return x === y;\n      } else if (tx === 'array') {\n        return eqArray(eqAny).eq(x, y);\n      } else if (tx === 'object') {\n        return eqRecord(eqAny).eq(x, y);\n      }\n      return false;\n    });\n\n    const getPrototypeOf$2 = Object.getPrototypeOf;\n    const hasProto = (v, constructor, predicate) => {\n      var _a;\n      if (predicate(v, constructor.prototype)) {\n        return true;\n      } else {\n        return ((_a = v.constructor) === null || _a === void 0 ? void 0 : _a.name) === constructor.name;\n      }\n    };\n    const typeOf = x => {\n      const t = typeof x;\n      if (x === null) {\n        return 'null';\n      } else if (t === 'object' && Array.isArray(x)) {\n        return 'array';\n      } else if (t === 'object' && hasProto(x, String, (o, proto) => proto.isPrototypeOf(o))) {\n        return 'string';\n      } else {\n        return t;\n      }\n    };\n    const isType$1 = type => value => typeOf(value) === type;\n    const isSimpleType = type => value => typeof value === type;\n    const eq$1 = t => a => t === a;\n    const is$4 = (value, constructor) => isObject(value) && hasProto(value, constructor, (o, proto) => getPrototypeOf$2(o) === proto);\n    const isString = isType$1('string');\n    const isObject = isType$1('object');\n    const isPlainObject = value => is$4(value, Object);\n    const isArray$1 = isType$1('array');\n    const isNull = eq$1(null);\n    const isBoolean = isSimpleType('boolean');\n    const isUndefined = eq$1(undefined);\n    const isNullable = a => a === null || a === undefined;\n    const isNonNullable = a => !isNullable(a);\n    const isFunction = isSimpleType('function');\n    const isNumber = isSimpleType('number');\n    const isArrayOf = (value, pred) => {\n      if (isArray$1(value)) {\n        for (let i = 0, len = value.length; i < len; ++i) {\n          if (!pred(value[i])) {\n            return false;\n          }\n        }\n        return true;\n      }\n      return false;\n    };\n\n    const noop = () => {\n    };\n    const compose = (fa, fb) => {\n      return (...args) => {\n        return fa(fb.apply(null, args));\n      };\n    };\n    const compose1 = (fbc, fab) => a => fbc(fab(a));\n    const constant = value => {\n      return () => {\n        return value;\n      };\n    };\n    const identity = x => {\n      return x;\n    };\n    const tripleEquals = (a, b) => {\n      return a === b;\n    };\n    function curry(fn, ...initialArgs) {\n      return (...restArgs) => {\n        const all = initialArgs.concat(restArgs);\n        return fn.apply(null, all);\n      };\n    }\n    const not = f => t => !f(t);\n    const die = msg => {\n      return () => {\n        throw new Error(msg);\n      };\n    };\n    const apply$1 = f => {\n      return f();\n    };\n    const call = f => {\n      f();\n    };\n    const never = constant(false);\n    const always = constant(true);\n\n    class Optional {\n      constructor(tag, value) {\n        this.tag = tag;\n        this.value = value;\n      }\n      static some(value) {\n        return new Optional(true, value);\n      }\n      static none() {\n        return Optional.singletonNone;\n      }\n      fold(onNone, onSome) {\n        if (this.tag) {\n          return onSome(this.value);\n        } else {\n          return onNone();\n        }\n      }\n      isSome() {\n        return this.tag;\n      }\n      isNone() {\n        return !this.tag;\n      }\n      map(mapper) {\n        if (this.tag) {\n          return Optional.some(mapper(this.value));\n        } else {\n          return Optional.none();\n        }\n      }\n      bind(binder) {\n        if (this.tag) {\n          return binder(this.value);\n        } else {\n          return Optional.none();\n        }\n      }\n      exists(predicate) {\n        return this.tag && predicate(this.value);\n      }\n      forall(predicate) {\n        return !this.tag || predicate(this.value);\n      }\n      filter(predicate) {\n        if (!this.tag || predicate(this.value)) {\n          return this;\n        } else {\n          return Optional.none();\n        }\n      }\n      getOr(replacement) {\n        return this.tag ? this.value : replacement;\n      }\n      or(replacement) {\n        return this.tag ? this : replacement;\n      }\n      getOrThunk(thunk) {\n        return this.tag ? this.value : thunk();\n      }\n      orThunk(thunk) {\n        return this.tag ? this : thunk();\n      }\n      getOrDie(message) {\n        if (!this.tag) {\n          throw new Error(message !== null && message !== void 0 ? message : 'Called getOrDie on None');\n        } else {\n          return this.value;\n        }\n      }\n      static from(value) {\n        return isNonNullable(value) ? Optional.some(value) : Optional.none();\n      }\n      getOrNull() {\n        return this.tag ? this.value : null;\n      }\n      getOrUndefined() {\n        return this.value;\n      }\n      each(worker) {\n        if (this.tag) {\n          worker(this.value);\n        }\n      }\n      toArray() {\n        return this.tag ? [this.value] : [];\n      }\n      toString() {\n        return this.tag ? `some(${ this.value })` : 'none()';\n      }\n    }\n    Optional.singletonNone = new Optional(false);\n\n    const nativeSlice = Array.prototype.slice;\n    const nativeIndexOf = Array.prototype.indexOf;\n    const nativePush = Array.prototype.push;\n    const rawIndexOf = (ts, t) => nativeIndexOf.call(ts, t);\n    const indexOf$1 = (xs, x) => {\n      const r = rawIndexOf(xs, x);\n      return r === -1 ? Optional.none() : Optional.some(r);\n    };\n    const contains$2 = (xs, x) => rawIndexOf(xs, x) > -1;\n    const exists = (xs, pred) => {\n      for (let i = 0, len = xs.length; i < len; i++) {\n        const x = xs[i];\n        if (pred(x, i)) {\n          return true;\n        }\n      }\n      return false;\n    };\n    const map$3 = (xs, f) => {\n      const len = xs.length;\n      const r = new Array(len);\n      for (let i = 0; i < len; i++) {\n        const x = xs[i];\n        r[i] = f(x, i);\n      }\n      return r;\n    };\n    const each$e = (xs, f) => {\n      for (let i = 0, len = xs.length; i < len; i++) {\n        const x = xs[i];\n        f(x, i);\n      }\n    };\n    const eachr = (xs, f) => {\n      for (let i = xs.length - 1; i >= 0; i--) {\n        const x = xs[i];\n        f(x, i);\n      }\n    };\n    const partition$2 = (xs, pred) => {\n      const pass = [];\n      const fail = [];\n      for (let i = 0, len = xs.length; i < len; i++) {\n        const x = xs[i];\n        const arr = pred(x, i) ? pass : fail;\n        arr.push(x);\n      }\n      return {\n        pass,\n        fail\n      };\n    };\n    const filter$5 = (xs, pred) => {\n      const r = [];\n      for (let i = 0, len = xs.length; i < len; i++) {\n        const x = xs[i];\n        if (pred(x, i)) {\n          r.push(x);\n        }\n      }\n      return r;\n    };\n    const foldr = (xs, f, acc) => {\n      eachr(xs, (x, i) => {\n        acc = f(acc, x, i);\n      });\n      return acc;\n    };\n    const foldl = (xs, f, acc) => {\n      each$e(xs, (x, i) => {\n        acc = f(acc, x, i);\n      });\n      return acc;\n    };\n    const findUntil$1 = (xs, pred, until) => {\n      for (let i = 0, len = xs.length; i < len; i++) {\n        const x = xs[i];\n        if (pred(x, i)) {\n          return Optional.some(x);\n        } else if (until(x, i)) {\n          break;\n        }\n      }\n      return Optional.none();\n    };\n    const find$2 = (xs, pred) => {\n      return findUntil$1(xs, pred, never);\n    };\n    const findIndex$2 = (xs, pred) => {\n      for (let i = 0, len = xs.length; i < len; i++) {\n        const x = xs[i];\n        if (pred(x, i)) {\n          return Optional.some(i);\n        }\n      }\n      return Optional.none();\n    };\n    const flatten = xs => {\n      const r = [];\n      for (let i = 0, len = xs.length; i < len; ++i) {\n        if (!isArray$1(xs[i])) {\n          throw new Error('Arr.flatten item ' + i + ' was not an array, input: ' + xs);\n        }\n        nativePush.apply(r, xs[i]);\n      }\n      return r;\n    };\n    const bind$3 = (xs, f) => flatten(map$3(xs, f));\n    const forall = (xs, pred) => {\n      for (let i = 0, len = xs.length; i < len; ++i) {\n        const x = xs[i];\n        if (pred(x, i) !== true) {\n          return false;\n        }\n      }\n      return true;\n    };\n    const reverse = xs => {\n      const r = nativeSlice.call(xs, 0);\n      r.reverse();\n      return r;\n    };\n    const difference = (a1, a2) => filter$5(a1, x => !contains$2(a2, x));\n    const mapToObject = (xs, f) => {\n      const r = {};\n      for (let i = 0, len = xs.length; i < len; i++) {\n        const x = xs[i];\n        r[String(x)] = f(x, i);\n      }\n      return r;\n    };\n    const sort = (xs, comparator) => {\n      const copy = nativeSlice.call(xs, 0);\n      copy.sort(comparator);\n      return copy;\n    };\n    const get$b = (xs, i) => i >= 0 && i < xs.length ? Optional.some(xs[i]) : Optional.none();\n    const head = xs => get$b(xs, 0);\n    const last$2 = xs => get$b(xs, xs.length - 1);\n    const from = isFunction(Array.from) ? Array.from : x => nativeSlice.call(x);\n    const findMap = (arr, f) => {\n      for (let i = 0; i < arr.length; i++) {\n        const r = f(arr[i], i);\n        if (r.isSome()) {\n          return r;\n        }\n      }\n      return Optional.none();\n    };\n    const unique$1 = (xs, comparator) => {\n      const r = [];\n      const isDuplicated = isFunction(comparator) ? x => exists(r, i => comparator(i, x)) : x => contains$2(r, x);\n      for (let i = 0, len = xs.length; i < len; i++) {\n        const x = xs[i];\n        if (!isDuplicated(x)) {\n          r.push(x);\n        }\n      }\n      return r;\n    };\n\n    const keys = Object.keys;\n    const hasOwnProperty$1 = Object.hasOwnProperty;\n    const each$d = (obj, f) => {\n      const props = keys(obj);\n      for (let k = 0, len = props.length; k < len; k++) {\n        const i = props[k];\n        const x = obj[i];\n        f(x, i);\n      }\n    };\n    const map$2 = (obj, f) => {\n      return tupleMap(obj, (x, i) => ({\n        k: i,\n        v: f(x, i)\n      }));\n    };\n    const tupleMap = (obj, f) => {\n      const r = {};\n      each$d(obj, (x, i) => {\n        const tuple = f(x, i);\n        r[tuple.k] = tuple.v;\n      });\n      return r;\n    };\n    const objAcc = r => (x, i) => {\n      r[i] = x;\n    };\n    const internalFilter = (obj, pred, onTrue, onFalse) => {\n      each$d(obj, (x, i) => {\n        (pred(x, i) ? onTrue : onFalse)(x, i);\n      });\n    };\n    const bifilter = (obj, pred) => {\n      const t = {};\n      const f = {};\n      internalFilter(obj, pred, objAcc(t), objAcc(f));\n      return {\n        t,\n        f\n      };\n    };\n    const filter$4 = (obj, pred) => {\n      const t = {};\n      internalFilter(obj, pred, objAcc(t), noop);\n      return t;\n    };\n    const mapToArray = (obj, f) => {\n      const r = [];\n      each$d(obj, (value, name) => {\n        r.push(f(value, name));\n      });\n      return r;\n    };\n    const values = obj => {\n      return mapToArray(obj, identity);\n    };\n    const get$a = (obj, key) => {\n      return has$2(obj, key) ? Optional.from(obj[key]) : Optional.none();\n    };\n    const has$2 = (obj, key) => hasOwnProperty$1.call(obj, key);\n    const hasNonNullableKey = (obj, key) => has$2(obj, key) && obj[key] !== undefined && obj[key] !== null;\n    const equal$1 = (a1, a2, eq = eqAny) => eqRecord(eq).eq(a1, a2);\n\n    const stringArray = a => {\n      const all = {};\n      each$e(a, key => {\n        all[key] = {};\n      });\n      return keys(all);\n    };\n\n    const isArrayLike = o => o.length !== undefined;\n    const isArray = Array.isArray;\n    const toArray$1 = obj => {\n      if (!isArray(obj)) {\n        const array = [];\n        for (let i = 0, l = obj.length; i < l; i++) {\n          array[i] = obj[i];\n        }\n        return array;\n      } else {\n        return obj;\n      }\n    };\n    const each$c = (o, cb, s) => {\n      if (!o) {\n        return false;\n      }\n      s = s || o;\n      if (isArrayLike(o)) {\n        for (let n = 0, l = o.length; n < l; n++) {\n          if (cb.call(s, o[n], n, o) === false) {\n            return false;\n          }\n        }\n      } else {\n        for (const n in o) {\n          if (has$2(o, n)) {\n            if (cb.call(s, o[n], n, o) === false) {\n              return false;\n            }\n          }\n        }\n      }\n      return true;\n    };\n    const map$1 = (array, callback) => {\n      const out = [];\n      each$c(array, (item, index) => {\n        out.push(callback(item, index, array));\n      });\n      return out;\n    };\n    const filter$3 = (a, f) => {\n      const o = [];\n      each$c(a, (v, index) => {\n        if (!f || f(v, index, a)) {\n          o.push(v);\n        }\n      });\n      return o;\n    };\n    const indexOf = (a, v) => {\n      if (a) {\n        for (let i = 0, l = a.length; i < l; i++) {\n          if (a[i] === v) {\n            return i;\n          }\n        }\n      }\n      return -1;\n    };\n    const reduce = (collection, iteratee, accumulator, thisArg) => {\n      let acc = isUndefined(accumulator) ? collection[0] : accumulator;\n      for (let i = 0; i < collection.length; i++) {\n        acc = iteratee.call(thisArg, acc, collection[i], i);\n      }\n      return acc;\n    };\n    const findIndex$1 = (array, predicate, thisArg) => {\n      for (let i = 0, l = array.length; i < l; i++) {\n        if (predicate.call(thisArg, array[i], i, array)) {\n          return i;\n        }\n      }\n      return -1;\n    };\n    const last$1 = collection => collection[collection.length - 1];\n\n    const cached = f => {\n      let called = false;\n      let r;\n      return (...args) => {\n        if (!called) {\n          called = true;\n          r = f.apply(null, args);\n        }\n        return r;\n      };\n    };\n\n    const DeviceType = (os, browser, userAgent, mediaMatch) => {\n      const isiPad = os.isiOS() && /ipad/i.test(userAgent) === true;\n      const isiPhone = os.isiOS() && !isiPad;\n      const isMobile = os.isiOS() || os.isAndroid();\n      const isTouch = isMobile || mediaMatch('(pointer:coarse)');\n      const isTablet = isiPad || !isiPhone && isMobile && mediaMatch('(min-device-width:768px)');\n      const isPhone = isiPhone || isMobile && !isTablet;\n      const iOSwebview = browser.isSafari() && os.isiOS() && /safari/i.test(userAgent) === false;\n      const isDesktop = !isPhone && !isTablet && !iOSwebview;\n      return {\n        isiPad: constant(isiPad),\n        isiPhone: constant(isiPhone),\n        isTablet: constant(isTablet),\n        isPhone: constant(isPhone),\n        isTouch: constant(isTouch),\n        isAndroid: os.isAndroid,\n        isiOS: os.isiOS,\n        isWebView: constant(iOSwebview),\n        isDesktop: constant(isDesktop)\n      };\n    };\n\n    const firstMatch = (regexes, s) => {\n      for (let i = 0; i < regexes.length; i++) {\n        const x = regexes[i];\n        if (x.test(s)) {\n          return x;\n        }\n      }\n      return undefined;\n    };\n    const find$1 = (regexes, agent) => {\n      const r = firstMatch(regexes, agent);\n      if (!r) {\n        return {\n          major: 0,\n          minor: 0\n        };\n      }\n      const group = i => {\n        return Number(agent.replace(r, '$' + i));\n      };\n      return nu$3(group(1), group(2));\n    };\n    const detect$4 = (versionRegexes, agent) => {\n      const cleanedAgent = String(agent).toLowerCase();\n      if (versionRegexes.length === 0) {\n        return unknown$2();\n      }\n      return find$1(versionRegexes, cleanedAgent);\n    };\n    const unknown$2 = () => {\n      return nu$3(0, 0);\n    };\n    const nu$3 = (major, minor) => {\n      return {\n        major,\n        minor\n      };\n    };\n    const Version = {\n      nu: nu$3,\n      detect: detect$4,\n      unknown: unknown$2\n    };\n\n    const detectBrowser$1 = (browsers, userAgentData) => {\n      return findMap(userAgentData.brands, uaBrand => {\n        const lcBrand = uaBrand.brand.toLowerCase();\n        return find$2(browsers, browser => {\n          var _a;\n          return lcBrand === ((_a = browser.brand) === null || _a === void 0 ? void 0 : _a.toLowerCase());\n        }).map(info => ({\n          current: info.name,\n          version: Version.nu(parseInt(uaBrand.version, 10), 0)\n        }));\n      });\n    };\n\n    const detect$3 = (candidates, userAgent) => {\n      const agent = String(userAgent).toLowerCase();\n      return find$2(candidates, candidate => {\n        return candidate.search(agent);\n      });\n    };\n    const detectBrowser = (browsers, userAgent) => {\n      return detect$3(browsers, userAgent).map(browser => {\n        const version = Version.detect(browser.versionRegexes, userAgent);\n        return {\n          current: browser.name,\n          version\n        };\n      });\n    };\n    const detectOs = (oses, userAgent) => {\n      return detect$3(oses, userAgent).map(os => {\n        const version = Version.detect(os.versionRegexes, userAgent);\n        return {\n          current: os.name,\n          version\n        };\n      });\n    };\n\n    const removeFromStart = (str, numChars) => {\n      return str.substring(numChars);\n    };\n\n    const checkRange = (str, substr, start) => substr === '' || str.length >= substr.length && str.substr(start, start + substr.length) === substr;\n    const removeLeading = (str, prefix) => {\n      return startsWith(str, prefix) ? removeFromStart(str, prefix.length) : str;\n    };\n    const contains$1 = (str, substr, start = 0, end) => {\n      const idx = str.indexOf(substr, start);\n      if (idx !== -1) {\n        return isUndefined(end) ? true : idx + substr.length <= end;\n      } else {\n        return false;\n      }\n    };\n    const startsWith = (str, prefix) => {\n      return checkRange(str, prefix, 0);\n    };\n    const endsWith = (str, suffix) => {\n      return checkRange(str, suffix, str.length - suffix.length);\n    };\n    const blank = r => s => s.replace(r, '');\n    const trim$4 = blank(/^\\s+|\\s+$/g);\n    const lTrim = blank(/^\\s+/g);\n    const rTrim = blank(/\\s+$/g);\n    const isNotEmpty = s => s.length > 0;\n    const isEmpty$3 = s => !isNotEmpty(s);\n    const repeat = (s, count) => count <= 0 ? '' : new Array(count + 1).join(s);\n    const toInt = (value, radix = 10) => {\n      const num = parseInt(value, radix);\n      return isNaN(num) ? Optional.none() : Optional.some(num);\n    };\n\n    const normalVersionRegex = /.*?version\\/\\ ?([0-9]+)\\.([0-9]+).*/;\n    const checkContains = target => {\n      return uastring => {\n        return contains$1(uastring, target);\n      };\n    };\n    const browsers = [\n      {\n        name: 'Edge',\n        versionRegexes: [/.*?edge\\/ ?([0-9]+)\\.([0-9]+)$/],\n        search: uastring => {\n          return contains$1(uastring, 'edge/') && contains$1(uastring, 'chrome') && contains$1(uastring, 'safari') && contains$1(uastring, 'applewebkit');\n        }\n      },\n      {\n        name: 'Chromium',\n        brand: 'Chromium',\n        versionRegexes: [\n          /.*?chrome\\/([0-9]+)\\.([0-9]+).*/,\n          normalVersionRegex\n        ],\n        search: uastring => {\n          return contains$1(uastring, 'chrome') && !contains$1(uastring, 'chromeframe');\n        }\n      },\n      {\n        name: 'IE',\n        versionRegexes: [\n          /.*?msie\\ ?([0-9]+)\\.([0-9]+).*/,\n          /.*?rv:([0-9]+)\\.([0-9]+).*/\n        ],\n        search: uastring => {\n          return contains$1(uastring, 'msie') || contains$1(uastring, 'trident');\n        }\n      },\n      {\n        name: 'Opera',\n        versionRegexes: [\n          normalVersionRegex,\n          /.*?opera\\/([0-9]+)\\.([0-9]+).*/\n        ],\n        search: checkContains('opera')\n      },\n      {\n        name: 'Firefox',\n        versionRegexes: [/.*?firefox\\/\\ ?([0-9]+)\\.([0-9]+).*/],\n        search: checkContains('firefox')\n      },\n      {\n        name: 'Safari',\n        versionRegexes: [\n          normalVersionRegex,\n          /.*?cpu os ([0-9]+)_([0-9]+).*/\n        ],\n        search: uastring => {\n          return (contains$1(uastring, 'safari') || contains$1(uastring, 'mobile/')) && contains$1(uastring, 'applewebkit');\n        }\n      }\n    ];\n    const oses = [\n      {\n        name: 'Windows',\n        search: checkContains('win'),\n        versionRegexes: [/.*?windows\\ nt\\ ?([0-9]+)\\.([0-9]+).*/]\n      },\n      {\n        name: 'iOS',\n        search: uastring => {\n          return contains$1(uastring, 'iphone') || contains$1(uastring, 'ipad');\n        },\n        versionRegexes: [\n          /.*?version\\/\\ ?([0-9]+)\\.([0-9]+).*/,\n          /.*cpu os ([0-9]+)_([0-9]+).*/,\n          /.*cpu iphone os ([0-9]+)_([0-9]+).*/\n        ]\n      },\n      {\n        name: 'Android',\n        search: checkContains('android'),\n        versionRegexes: [/.*?android\\ ?([0-9]+)\\.([0-9]+).*/]\n      },\n      {\n        name: 'macOS',\n        search: checkContains('mac os x'),\n        versionRegexes: [/.*?mac\\ os\\ x\\ ?([0-9]+)_([0-9]+).*/]\n      },\n      {\n        name: 'Linux',\n        search: checkContains('linux'),\n        versionRegexes: []\n      },\n      {\n        name: 'Solaris',\n        search: checkContains('sunos'),\n        versionRegexes: []\n      },\n      {\n        name: 'FreeBSD',\n        search: checkContains('freebsd'),\n        versionRegexes: []\n      },\n      {\n        name: 'ChromeOS',\n        search: checkContains('cros'),\n        versionRegexes: [/.*?chrome\\/([0-9]+)\\.([0-9]+).*/]\n      }\n    ];\n    const PlatformInfo = {\n      browsers: constant(browsers),\n      oses: constant(oses)\n    };\n\n    const edge = 'Edge';\n    const chromium = 'Chromium';\n    const ie = 'IE';\n    const opera = 'Opera';\n    const firefox = 'Firefox';\n    const safari = 'Safari';\n    const unknown$1 = () => {\n      return nu$2({\n        current: undefined,\n        version: Version.unknown()\n      });\n    };\n    const nu$2 = info => {\n      const current = info.current;\n      const version = info.version;\n      const isBrowser = name => () => current === name;\n      return {\n        current,\n        version,\n        isEdge: isBrowser(edge),\n        isChromium: isBrowser(chromium),\n        isIE: isBrowser(ie),\n        isOpera: isBrowser(opera),\n        isFirefox: isBrowser(firefox),\n        isSafari: isBrowser(safari)\n      };\n    };\n    const Browser = {\n      unknown: unknown$1,\n      nu: nu$2,\n      edge: constant(edge),\n      chromium: constant(chromium),\n      ie: constant(ie),\n      opera: constant(opera),\n      firefox: constant(firefox),\n      safari: constant(safari)\n    };\n\n    const windows = 'Windows';\n    const ios = 'iOS';\n    const android = 'Android';\n    const linux = 'Linux';\n    const macos = 'macOS';\n    const solaris = 'Solaris';\n    const freebsd = 'FreeBSD';\n    const chromeos = 'ChromeOS';\n    const unknown = () => {\n      return nu$1({\n        current: undefined,\n        version: Version.unknown()\n      });\n    };\n    const nu$1 = info => {\n      const current = info.current;\n      const version = info.version;\n      const isOS = name => () => current === name;\n      return {\n        current,\n        version,\n        isWindows: isOS(windows),\n        isiOS: isOS(ios),\n        isAndroid: isOS(android),\n        isMacOS: isOS(macos),\n        isLinux: isOS(linux),\n        isSolaris: isOS(solaris),\n        isFreeBSD: isOS(freebsd),\n        isChromeOS: isOS(chromeos)\n      };\n    };\n    const OperatingSystem = {\n      unknown,\n      nu: nu$1,\n      windows: constant(windows),\n      ios: constant(ios),\n      android: constant(android),\n      linux: constant(linux),\n      macos: constant(macos),\n      solaris: constant(solaris),\n      freebsd: constant(freebsd),\n      chromeos: constant(chromeos)\n    };\n\n    const detect$2 = (userAgent, userAgentDataOpt, mediaMatch) => {\n      const browsers = PlatformInfo.browsers();\n      const oses = PlatformInfo.oses();\n      const browser = userAgentDataOpt.bind(userAgentData => detectBrowser$1(browsers, userAgentData)).orThunk(() => detectBrowser(browsers, userAgent)).fold(Browser.unknown, Browser.nu);\n      const os = detectOs(oses, userAgent).fold(OperatingSystem.unknown, OperatingSystem.nu);\n      const deviceType = DeviceType(os, browser, userAgent, mediaMatch);\n      return {\n        browser,\n        os,\n        deviceType\n      };\n    };\n    const PlatformDetection = { detect: detect$2 };\n\n    const mediaMatch = query => window.matchMedia(query).matches;\n    let platform$4 = cached(() => PlatformDetection.detect(window.navigator.userAgent, Optional.from(window.navigator.userAgentData), mediaMatch));\n    const detect$1 = () => platform$4();\n\n    const userAgent = window.navigator.userAgent;\n    const platform$3 = detect$1();\n    const browser$3 = platform$3.browser;\n    const os$1 = platform$3.os;\n    const deviceType = platform$3.deviceType;\n    const windowsPhone = userAgent.indexOf('Windows Phone') !== -1;\n    const Env = {\n      transparentSrc: 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7',\n      documentMode: browser$3.isIE() ? document.documentMode || 7 : 10,\n      cacheSuffix: null,\n      container: null,\n      canHaveCSP: !browser$3.isIE(),\n      windowsPhone,\n      browser: {\n        current: browser$3.current,\n        version: browser$3.version,\n        isChromium: browser$3.isChromium,\n        isEdge: browser$3.isEdge,\n        isFirefox: browser$3.isFirefox,\n        isIE: browser$3.isIE,\n        isOpera: browser$3.isOpera,\n        isSafari: browser$3.isSafari\n      },\n      os: {\n        current: os$1.current,\n        version: os$1.version,\n        isAndroid: os$1.isAndroid,\n        isChromeOS: os$1.isChromeOS,\n        isFreeBSD: os$1.isFreeBSD,\n        isiOS: os$1.isiOS,\n        isLinux: os$1.isLinux,\n        isMacOS: os$1.isMacOS,\n        isSolaris: os$1.isSolaris,\n        isWindows: os$1.isWindows\n      },\n      deviceType: {\n        isDesktop: deviceType.isDesktop,\n        isiPad: deviceType.isiPad,\n        isiPhone: deviceType.isiPhone,\n        isPhone: deviceType.isPhone,\n        isTablet: deviceType.isTablet,\n        isTouch: deviceType.isTouch,\n        isWebView: deviceType.isWebView\n      }\n    };\n\n    const whiteSpaceRegExp$1 = /^\\s*|\\s*$/g;\n    const trim$3 = str => {\n      return isNullable(str) ? '' : ('' + str).replace(whiteSpaceRegExp$1, '');\n    };\n    const is$3 = (obj, type) => {\n      if (!type) {\n        return obj !== undefined;\n      }\n      if (type === 'array' && isArray(obj)) {\n        return true;\n      }\n      return typeof obj === type;\n    };\n    const makeMap$4 = (items, delim, map = {}) => {\n      const resolvedItems = isString(items) ? items.split(delim || ',') : items || [];\n      let i = resolvedItems.length;\n      while (i--) {\n        map[resolvedItems[i]] = {};\n      }\n      return map;\n    };\n    const hasOwnProperty = has$2;\n    const extend$3 = (obj, ...exts) => {\n      for (let i = 0; i < exts.length; i++) {\n        const ext = exts[i];\n        for (const name in ext) {\n          if (has$2(ext, name)) {\n            const value = ext[name];\n            if (value !== undefined) {\n              obj[name] = value;\n            }\n          }\n        }\n      }\n      return obj;\n    };\n    const walk$4 = function (o, f, n, s) {\n      s = s || this;\n      if (o) {\n        if (n) {\n          o = o[n];\n        }\n        each$c(o, (o, i) => {\n          if (f.call(s, o, i, n) === false) {\n            return false;\n          } else {\n            walk$4(o, f, n, s);\n            return true;\n          }\n        });\n      }\n    };\n    const resolve$3 = (n, o = window) => {\n      const path = n.split('.');\n      for (let i = 0, l = path.length; i < l; i++) {\n        o = o[path[i]];\n        if (!o) {\n          break;\n        }\n      }\n      return o;\n    };\n    const explode$3 = (s, d) => {\n      if (isArray$1(s)) {\n        return s;\n      } else if (s === '') {\n        return [];\n      } else {\n        return map$1(s.split(d || ','), trim$3);\n      }\n    };\n    const _addCacheSuffix = url => {\n      const cacheSuffix = Env.cacheSuffix;\n      if (cacheSuffix) {\n        url += (url.indexOf('?') === -1 ? '?' : '&') + cacheSuffix;\n      }\n      return url;\n    };\n    const Tools = {\n      trim: trim$3,\n      isArray: isArray,\n      is: is$3,\n      toArray: toArray$1,\n      makeMap: makeMap$4,\n      each: each$c,\n      map: map$1,\n      grep: filter$3,\n      inArray: indexOf,\n      hasOwn: hasOwnProperty,\n      extend: extend$3,\n      walk: walk$4,\n      resolve: resolve$3,\n      explode: explode$3,\n      _addCacheSuffix\n    };\n\n    const is$2 = (lhs, rhs, comparator = tripleEquals) => lhs.exists(left => comparator(left, rhs));\n    const equals = (lhs, rhs, comparator = tripleEquals) => lift2(lhs, rhs, comparator).getOr(lhs.isNone() && rhs.isNone());\n    const cat = arr => {\n      const r = [];\n      const push = x => {\n        r.push(x);\n      };\n      for (let i = 0; i < arr.length; i++) {\n        arr[i].each(push);\n      }\n      return r;\n    };\n    const lift2 = (oa, ob, f) => oa.isSome() && ob.isSome() ? Optional.some(f(oa.getOrDie(), ob.getOrDie())) : Optional.none();\n    const lift3 = (oa, ob, oc, f) => oa.isSome() && ob.isSome() && oc.isSome() ? Optional.some(f(oa.getOrDie(), ob.getOrDie(), oc.getOrDie())) : Optional.none();\n    const someIf = (b, a) => b ? Optional.some(a) : Optional.none();\n\n    const Global = typeof window !== 'undefined' ? window : Function('return this;')();\n\n    const path = (parts, scope) => {\n      let o = scope !== undefined && scope !== null ? scope : Global;\n      for (let i = 0; i < parts.length && o !== undefined && o !== null; ++i) {\n        o = o[parts[i]];\n      }\n      return o;\n    };\n    const resolve$2 = (p, scope) => {\n      const parts = p.split('.');\n      return path(parts, scope);\n    };\n\n    const unsafe = (name, scope) => {\n      return resolve$2(name, scope);\n    };\n    const getOrDie = (name, scope) => {\n      const actual = unsafe(name, scope);\n      if (actual === undefined || actual === null) {\n        throw new Error(name + ' not available on this browser');\n      }\n      return actual;\n    };\n\n    const getPrototypeOf$1 = Object.getPrototypeOf;\n    const sandHTMLElement = scope => {\n      return getOrDie('HTMLElement', scope);\n    };\n    const isPrototypeOf = x => {\n      const scope = resolve$2('ownerDocument.defaultView', x);\n      return isObject(x) && (sandHTMLElement(scope).prototype.isPrototypeOf(x) || /^HTML\\w*Element$/.test(getPrototypeOf$1(x).constructor.name));\n    };\n\n    const COMMENT = 8;\n    const DOCUMENT = 9;\n    const DOCUMENT_FRAGMENT = 11;\n    const ELEMENT = 1;\n    const TEXT = 3;\n\n    const name = element => {\n      const r = element.dom.nodeName;\n      return r.toLowerCase();\n    };\n    const type$1 = element => element.dom.nodeType;\n    const isType = t => element => type$1(element) === t;\n    const isComment$1 = element => type$1(element) === COMMENT || name(element) === '#comment';\n    const isHTMLElement$1 = element => isElement$7(element) && isPrototypeOf(element.dom);\n    const isElement$7 = isType(ELEMENT);\n    const isText$c = isType(TEXT);\n    const isDocument$2 = isType(DOCUMENT);\n    const isDocumentFragment$1 = isType(DOCUMENT_FRAGMENT);\n    const isTag = tag => e => isElement$7(e) && name(e) === tag;\n\n    const rawSet = (dom, key, value) => {\n      if (isString(value) || isBoolean(value) || isNumber(value)) {\n        dom.setAttribute(key, value + '');\n      } else {\n        console.error('Invalid call to Attribute.set. Key ', key, ':: Value ', value, ':: Element ', dom);\n        throw new Error('Attribute value was not simple');\n      }\n    };\n    const set$3 = (element, key, value) => {\n      rawSet(element.dom, key, value);\n    };\n    const setAll$1 = (element, attrs) => {\n      const dom = element.dom;\n      each$d(attrs, (v, k) => {\n        rawSet(dom, k, v);\n      });\n    };\n    const get$9 = (element, key) => {\n      const v = element.dom.getAttribute(key);\n      return v === null ? undefined : v;\n    };\n    const getOpt = (element, key) => Optional.from(get$9(element, key));\n    const has$1 = (element, key) => {\n      const dom = element.dom;\n      return dom && dom.hasAttribute ? dom.hasAttribute(key) : false;\n    };\n    const remove$9 = (element, key) => {\n      element.dom.removeAttribute(key);\n    };\n    const hasNone = element => {\n      const attrs = element.dom.attributes;\n      return attrs === undefined || attrs === null || attrs.length === 0;\n    };\n    const clone$4 = element => foldl(element.dom.attributes, (acc, attr) => {\n      acc[attr.name] = attr.value;\n      return acc;\n    }, {});\n\n    const read$4 = (element, attr) => {\n      const value = get$9(element, attr);\n      return value === undefined || value === '' ? [] : value.split(' ');\n    };\n    const add$4 = (element, attr, id) => {\n      const old = read$4(element, attr);\n      const nu = old.concat([id]);\n      set$3(element, attr, nu.join(' '));\n      return true;\n    };\n    const remove$8 = (element, attr, id) => {\n      const nu = filter$5(read$4(element, attr), v => v !== id);\n      if (nu.length > 0) {\n        set$3(element, attr, nu.join(' '));\n      } else {\n        remove$9(element, attr);\n      }\n      return false;\n    };\n\n    const supports = element => element.dom.classList !== undefined;\n    const get$8 = element => read$4(element, 'class');\n    const add$3 = (element, clazz) => add$4(element, 'class', clazz);\n    const remove$7 = (element, clazz) => remove$8(element, 'class', clazz);\n    const toggle$2 = (element, clazz) => {\n      if (contains$2(get$8(element), clazz)) {\n        return remove$7(element, clazz);\n      } else {\n        return add$3(element, clazz);\n      }\n    };\n\n    const add$2 = (element, clazz) => {\n      if (supports(element)) {\n        element.dom.classList.add(clazz);\n      } else {\n        add$3(element, clazz);\n      }\n    };\n    const cleanClass = element => {\n      const classList = supports(element) ? element.dom.classList : get$8(element);\n      if (classList.length === 0) {\n        remove$9(element, 'class');\n      }\n    };\n    const remove$6 = (element, clazz) => {\n      if (supports(element)) {\n        const classList = element.dom.classList;\n        classList.remove(clazz);\n      } else {\n        remove$7(element, clazz);\n      }\n      cleanClass(element);\n    };\n    const toggle$1 = (element, clazz) => {\n      const result = supports(element) ? element.dom.classList.toggle(clazz) : toggle$2(element, clazz);\n      cleanClass(element);\n      return result;\n    };\n    const has = (element, clazz) => supports(element) && element.dom.classList.contains(clazz);\n\n    const fromHtml$1 = (html, scope) => {\n      const doc = scope || document;\n      const div = doc.createElement('div');\n      div.innerHTML = html;\n      if (!div.hasChildNodes() || div.childNodes.length > 1) {\n        const message = 'HTML does not have a single root node';\n        console.error(message, html);\n        throw new Error(message);\n      }\n      return fromDom$2(div.childNodes[0]);\n    };\n    const fromTag = (tag, scope) => {\n      const doc = scope || document;\n      const node = doc.createElement(tag);\n      return fromDom$2(node);\n    };\n    const fromText = (text, scope) => {\n      const doc = scope || document;\n      const node = doc.createTextNode(text);\n      return fromDom$2(node);\n    };\n    const fromDom$2 = node => {\n      if (node === null || node === undefined) {\n        throw new Error('Node cannot be null or undefined');\n      }\n      return { dom: node };\n    };\n    const fromPoint$2 = (docElm, x, y) => Optional.from(docElm.dom.elementFromPoint(x, y)).map(fromDom$2);\n    const SugarElement = {\n      fromHtml: fromHtml$1,\n      fromTag,\n      fromText,\n      fromDom: fromDom$2,\n      fromPoint: fromPoint$2\n    };\n\n    const toArray = (target, f) => {\n      const r = [];\n      const recurse = e => {\n        r.push(e);\n        return f(e);\n      };\n      let cur = f(target);\n      do {\n        cur = cur.bind(recurse);\n      } while (cur.isSome());\n      return r;\n    };\n\n    const is$1 = (element, selector) => {\n      const dom = element.dom;\n      if (dom.nodeType !== ELEMENT) {\n        return false;\n      } else {\n        const elem = dom;\n        if (elem.matches !== undefined) {\n          return elem.matches(selector);\n        } else if (elem.msMatchesSelector !== undefined) {\n          return elem.msMatchesSelector(selector);\n        } else if (elem.webkitMatchesSelector !== undefined) {\n          return elem.webkitMatchesSelector(selector);\n        } else if (elem.mozMatchesSelector !== undefined) {\n          return elem.mozMatchesSelector(selector);\n        } else {\n          throw new Error('Browser lacks native selectors');\n        }\n      }\n    };\n    const bypassSelector = dom => dom.nodeType !== ELEMENT && dom.nodeType !== DOCUMENT && dom.nodeType !== DOCUMENT_FRAGMENT || dom.childElementCount === 0;\n    const all = (selector, scope) => {\n      const base = scope === undefined ? document : scope.dom;\n      return bypassSelector(base) ? [] : map$3(base.querySelectorAll(selector), SugarElement.fromDom);\n    };\n    const one = (selector, scope) => {\n      const base = scope === undefined ? document : scope.dom;\n      return bypassSelector(base) ? Optional.none() : Optional.from(base.querySelector(selector)).map(SugarElement.fromDom);\n    };\n\n    const eq = (e1, e2) => e1.dom === e2.dom;\n    const contains = (e1, e2) => {\n      const d1 = e1.dom;\n      const d2 = e2.dom;\n      return d1 === d2 ? false : d1.contains(d2);\n    };\n\n    const owner$1 = element => SugarElement.fromDom(element.dom.ownerDocument);\n    const documentOrOwner = dos => isDocument$2(dos) ? dos : owner$1(dos);\n    const documentElement = element => SugarElement.fromDom(documentOrOwner(element).dom.documentElement);\n    const defaultView = element => SugarElement.fromDom(documentOrOwner(element).dom.defaultView);\n    const parent = element => Optional.from(element.dom.parentNode).map(SugarElement.fromDom);\n    const parentElement = element => Optional.from(element.dom.parentElement).map(SugarElement.fromDom);\n    const parents$1 = (element, isRoot) => {\n      const stop = isFunction(isRoot) ? isRoot : never;\n      let dom = element.dom;\n      const ret = [];\n      while (dom.parentNode !== null && dom.parentNode !== undefined) {\n        const rawParent = dom.parentNode;\n        const p = SugarElement.fromDom(rawParent);\n        ret.push(p);\n        if (stop(p) === true) {\n          break;\n        } else {\n          dom = rawParent;\n        }\n      }\n      return ret;\n    };\n    const siblings = element => {\n      const filterSelf = elements => filter$5(elements, x => !eq(element, x));\n      return parent(element).map(children$1).map(filterSelf).getOr([]);\n    };\n    const prevSibling = element => Optional.from(element.dom.previousSibling).map(SugarElement.fromDom);\n    const nextSibling = element => Optional.from(element.dom.nextSibling).map(SugarElement.fromDom);\n    const prevSiblings = element => reverse(toArray(element, prevSibling));\n    const nextSiblings = element => toArray(element, nextSibling);\n    const children$1 = element => map$3(element.dom.childNodes, SugarElement.fromDom);\n    const child$1 = (element, index) => {\n      const cs = element.dom.childNodes;\n      return Optional.from(cs[index]).map(SugarElement.fromDom);\n    };\n    const firstChild = element => child$1(element, 0);\n    const lastChild = element => child$1(element, element.dom.childNodes.length - 1);\n    const childNodesCount = element => element.dom.childNodes.length;\n\n    const getHead = doc => {\n      const b = doc.dom.head;\n      if (b === null || b === undefined) {\n        throw new Error('Head is not available yet');\n      }\n      return SugarElement.fromDom(b);\n    };\n\n    const isShadowRoot = dos => isDocumentFragment$1(dos) && isNonNullable(dos.dom.host);\n    const getRootNode = e => SugarElement.fromDom(e.dom.getRootNode());\n    const getStyleContainer = dos => isShadowRoot(dos) ? dos : getHead(documentOrOwner(dos));\n    const getContentContainer = dos => isShadowRoot(dos) ? dos : SugarElement.fromDom(documentOrOwner(dos).dom.body);\n    const getShadowRoot = e => {\n      const r = getRootNode(e);\n      return isShadowRoot(r) ? Optional.some(r) : Optional.none();\n    };\n    const getShadowHost = e => SugarElement.fromDom(e.dom.host);\n    const getOriginalEventTarget = event => {\n      if (isNonNullable(event.target)) {\n        const el = SugarElement.fromDom(event.target);\n        if (isElement$7(el) && isOpenShadowHost(el)) {\n          if (event.composed && event.composedPath) {\n            const composedPath = event.composedPath();\n            if (composedPath) {\n              return head(composedPath);\n            }\n          }\n        }\n      }\n      return Optional.from(event.target);\n    };\n    const isOpenShadowHost = element => isNonNullable(element.dom.shadowRoot);\n\n    const inBody = element => {\n      const dom = isText$c(element) ? element.dom.parentNode : element.dom;\n      if (dom === undefined || dom === null || dom.ownerDocument === null) {\n        return false;\n      }\n      const doc = dom.ownerDocument;\n      return getShadowRoot(SugarElement.fromDom(dom)).fold(() => doc.body.contains(dom), compose1(inBody, getShadowHost));\n    };\n\n    var ClosestOrAncestor = (is, ancestor, scope, a, isRoot) => {\n      if (is(scope, a)) {\n        return Optional.some(scope);\n      } else if (isFunction(isRoot) && isRoot(scope)) {\n        return Optional.none();\n      } else {\n        return ancestor(scope, a, isRoot);\n      }\n    };\n\n    const ancestor$4 = (scope, predicate, isRoot) => {\n      let element = scope.dom;\n      const stop = isFunction(isRoot) ? isRoot : never;\n      while (element.parentNode) {\n        element = element.parentNode;\n        const el = SugarElement.fromDom(element);\n        if (predicate(el)) {\n          return Optional.some(el);\n        } else if (stop(el)) {\n          break;\n        }\n      }\n      return Optional.none();\n    };\n    const closest$4 = (scope, predicate, isRoot) => {\n      const is = (s, test) => test(s);\n      return ClosestOrAncestor(is, ancestor$4, scope, predicate, isRoot);\n    };\n    const sibling$1 = (scope, predicate) => {\n      const element = scope.dom;\n      if (!element.parentNode) {\n        return Optional.none();\n      }\n      return child(SugarElement.fromDom(element.parentNode), x => !eq(scope, x) && predicate(x));\n    };\n    const child = (scope, predicate) => {\n      const pred = node => predicate(SugarElement.fromDom(node));\n      const result = find$2(scope.dom.childNodes, pred);\n      return result.map(SugarElement.fromDom);\n    };\n    const descendant$2 = (scope, predicate) => {\n      const descend = node => {\n        for (let i = 0; i < node.childNodes.length; i++) {\n          const child = SugarElement.fromDom(node.childNodes[i]);\n          if (predicate(child)) {\n            return Optional.some(child);\n          }\n          const res = descend(node.childNodes[i]);\n          if (res.isSome()) {\n            return res;\n          }\n        }\n        return Optional.none();\n      };\n      return descend(scope.dom);\n    };\n\n    const ancestor$3 = (scope, selector, isRoot) => ancestor$4(scope, e => is$1(e, selector), isRoot);\n    const descendant$1 = (scope, selector) => one(selector, scope);\n    const closest$3 = (scope, selector, isRoot) => {\n      const is = (element, selector) => is$1(element, selector);\n      return ClosestOrAncestor(is, ancestor$3, scope, selector, isRoot);\n    };\n\n    const closest$2 = target => closest$3(target, '[contenteditable]');\n    const isEditable$2 = (element, assumeEditable = false) => {\n      if (inBody(element)) {\n        return element.dom.isContentEditable;\n      } else {\n        return closest$2(element).fold(constant(assumeEditable), editable => getRaw$1(editable) === 'true');\n      }\n    };\n    const getRaw$1 = element => element.dom.contentEditable;\n\n    const isSupported = dom => dom.style !== undefined && isFunction(dom.style.getPropertyValue);\n\n    const internalSet = (dom, property, value) => {\n      if (!isString(value)) {\n        console.error('Invalid call to CSS.set. Property ', property, ':: Value ', value, ':: Element ', dom);\n        throw new Error('CSS value must be a string: ' + value);\n      }\n      if (isSupported(dom)) {\n        dom.style.setProperty(property, value);\n      }\n    };\n    const internalRemove = (dom, property) => {\n      if (isSupported(dom)) {\n        dom.style.removeProperty(property);\n      }\n    };\n    const set$2 = (element, property, value) => {\n      const dom = element.dom;\n      internalSet(dom, property, value);\n    };\n    const setAll = (element, css) => {\n      const dom = element.dom;\n      each$d(css, (v, k) => {\n        internalSet(dom, k, v);\n      });\n    };\n    const get$7 = (element, property) => {\n      const dom = element.dom;\n      const styles = window.getComputedStyle(dom);\n      const r = styles.getPropertyValue(property);\n      return r === '' && !inBody(element) ? getUnsafeProperty(dom, property) : r;\n    };\n    const getUnsafeProperty = (dom, property) => isSupported(dom) ? dom.style.getPropertyValue(property) : '';\n    const getRaw = (element, property) => {\n      const dom = element.dom;\n      const raw = getUnsafeProperty(dom, property);\n      return Optional.from(raw).filter(r => r.length > 0);\n    };\n    const getAllRaw = element => {\n      const css = {};\n      const dom = element.dom;\n      if (isSupported(dom)) {\n        for (let i = 0; i < dom.style.length; i++) {\n          const ruleName = dom.style.item(i);\n          css[ruleName] = dom.style[ruleName];\n        }\n      }\n      return css;\n    };\n    const remove$5 = (element, property) => {\n      const dom = element.dom;\n      internalRemove(dom, property);\n      if (is$2(getOpt(element, 'style').map(trim$4), '')) {\n        remove$9(element, 'style');\n      }\n    };\n    const reflow = e => e.dom.offsetWidth;\n\n    const before$3 = (marker, element) => {\n      const parent$1 = parent(marker);\n      parent$1.each(v => {\n        v.dom.insertBefore(element.dom, marker.dom);\n      });\n    };\n    const after$4 = (marker, element) => {\n      const sibling = nextSibling(marker);\n      sibling.fold(() => {\n        const parent$1 = parent(marker);\n        parent$1.each(v => {\n          append$1(v, element);\n        });\n      }, v => {\n        before$3(v, element);\n      });\n    };\n    const prepend = (parent, element) => {\n      const firstChild$1 = firstChild(parent);\n      firstChild$1.fold(() => {\n        append$1(parent, element);\n      }, v => {\n        parent.dom.insertBefore(element.dom, v.dom);\n      });\n    };\n    const append$1 = (parent, element) => {\n      parent.dom.appendChild(element.dom);\n    };\n    const wrap$2 = (element, wrapper) => {\n      before$3(element, wrapper);\n      append$1(wrapper, element);\n    };\n\n    const after$3 = (marker, elements) => {\n      each$e(elements, (x, i) => {\n        const e = i === 0 ? marker : elements[i - 1];\n        after$4(e, x);\n      });\n    };\n    const append = (parent, elements) => {\n      each$e(elements, x => {\n        append$1(parent, x);\n      });\n    };\n\n    const empty = element => {\n      element.dom.textContent = '';\n      each$e(children$1(element), rogue => {\n        remove$4(rogue);\n      });\n    };\n    const remove$4 = element => {\n      const dom = element.dom;\n      if (dom.parentNode !== null) {\n        dom.parentNode.removeChild(dom);\n      }\n    };\n    const unwrap = wrapper => {\n      const children = children$1(wrapper);\n      if (children.length > 0) {\n        after$3(wrapper, children);\n      }\n      remove$4(wrapper);\n    };\n\n    const fromHtml = (html, scope) => {\n      const doc = scope || document;\n      const div = doc.createElement('div');\n      div.innerHTML = html;\n      return children$1(SugarElement.fromDom(div));\n    };\n    const fromDom$1 = nodes => map$3(nodes, SugarElement.fromDom);\n\n    const get$6 = element => element.dom.innerHTML;\n    const set$1 = (element, content) => {\n      const owner = owner$1(element);\n      const docDom = owner.dom;\n      const fragment = SugarElement.fromDom(docDom.createDocumentFragment());\n      const contentElements = fromHtml(content, docDom);\n      append(fragment, contentElements);\n      empty(element);\n      append$1(element, fragment);\n    };\n    const getOuter = element => {\n      const container = SugarElement.fromTag('div');\n      const clone = SugarElement.fromDom(element.dom.cloneNode(true));\n      append$1(container, clone);\n      return get$6(container);\n    };\n\n    const mkEvent = (target, x, y, stop, prevent, kill, raw) => ({\n      target,\n      x,\n      y,\n      stop,\n      prevent,\n      kill,\n      raw\n    });\n    const fromRawEvent = rawEvent => {\n      const target = SugarElement.fromDom(getOriginalEventTarget(rawEvent).getOr(rawEvent.target));\n      const stop = () => rawEvent.stopPropagation();\n      const prevent = () => rawEvent.preventDefault();\n      const kill = compose(prevent, stop);\n      return mkEvent(target, rawEvent.clientX, rawEvent.clientY, stop, prevent, kill, rawEvent);\n    };\n    const handle$1 = (filter, handler) => rawEvent => {\n      if (filter(rawEvent)) {\n        handler(fromRawEvent(rawEvent));\n      }\n    };\n    const binder = (element, event, filter, handler, useCapture) => {\n      const wrapped = handle$1(filter, handler);\n      element.dom.addEventListener(event, wrapped, useCapture);\n      return { unbind: curry(unbind, element, event, wrapped, useCapture) };\n    };\n    const bind$2 = (element, event, filter, handler) => binder(element, event, filter, handler, false);\n    const unbind = (element, event, handler, useCapture) => {\n      element.dom.removeEventListener(event, handler, useCapture);\n    };\n\n    const r = (left, top) => {\n      const translate = (x, y) => r(left + x, top + y);\n      return {\n        left,\n        top,\n        translate\n      };\n    };\n    const SugarPosition = r;\n\n    const boxPosition = dom => {\n      const box = dom.getBoundingClientRect();\n      return SugarPosition(box.left, box.top);\n    };\n    const firstDefinedOrZero = (a, b) => {\n      if (a !== undefined) {\n        return a;\n      } else {\n        return b !== undefined ? b : 0;\n      }\n    };\n    const absolute = element => {\n      const doc = element.dom.ownerDocument;\n      const body = doc.body;\n      const win = doc.defaultView;\n      const html = doc.documentElement;\n      if (body === element.dom) {\n        return SugarPosition(body.offsetLeft, body.offsetTop);\n      }\n      const scrollTop = firstDefinedOrZero(win === null || win === void 0 ? void 0 : win.pageYOffset, html.scrollTop);\n      const scrollLeft = firstDefinedOrZero(win === null || win === void 0 ? void 0 : win.pageXOffset, html.scrollLeft);\n      const clientTop = firstDefinedOrZero(html.clientTop, body.clientTop);\n      const clientLeft = firstDefinedOrZero(html.clientLeft, body.clientLeft);\n      return viewport(element).translate(scrollLeft - clientLeft, scrollTop - clientTop);\n    };\n    const viewport = element => {\n      const dom = element.dom;\n      const doc = dom.ownerDocument;\n      const body = doc.body;\n      if (body === dom) {\n        return SugarPosition(body.offsetLeft, body.offsetTop);\n      }\n      if (!inBody(element)) {\n        return SugarPosition(0, 0);\n      }\n      return boxPosition(dom);\n    };\n\n    const get$5 = _DOC => {\n      const doc = _DOC !== undefined ? _DOC.dom : document;\n      const x = doc.body.scrollLeft || doc.documentElement.scrollLeft;\n      const y = doc.body.scrollTop || doc.documentElement.scrollTop;\n      return SugarPosition(x, y);\n    };\n    const to = (x, y, _DOC) => {\n      const doc = _DOC !== undefined ? _DOC.dom : document;\n      const win = doc.defaultView;\n      if (win) {\n        win.scrollTo(x, y);\n      }\n    };\n    const intoView = (element, alignToTop) => {\n      const isSafari = detect$1().browser.isSafari();\n      if (isSafari && isFunction(element.dom.scrollIntoViewIfNeeded)) {\n        element.dom.scrollIntoViewIfNeeded(false);\n      } else {\n        element.dom.scrollIntoView(alignToTop);\n      }\n    };\n\n    const get$4 = _win => {\n      const win = _win === undefined ? window : _win;\n      if (detect$1().browser.isFirefox()) {\n        return Optional.none();\n      } else {\n        return Optional.from(win.visualViewport);\n      }\n    };\n    const bounds = (x, y, width, height) => ({\n      x,\n      y,\n      width,\n      height,\n      right: x + width,\n      bottom: y + height\n    });\n    const getBounds = _win => {\n      const win = _win === undefined ? window : _win;\n      const doc = win.document;\n      const scroll = get$5(SugarElement.fromDom(doc));\n      return get$4(win).fold(() => {\n        const html = win.document.documentElement;\n        const width = html.clientWidth;\n        const height = html.clientHeight;\n        return bounds(scroll.left, scroll.top, width, height);\n      }, visualViewport => bounds(Math.max(visualViewport.pageLeft, scroll.left), Math.max(visualViewport.pageTop, scroll.top), visualViewport.width, visualViewport.height));\n    };\n\n    const children = (scope, predicate) => filter$5(children$1(scope), predicate);\n    const descendants$1 = (scope, predicate) => {\n      let result = [];\n      each$e(children$1(scope), x => {\n        if (predicate(x)) {\n          result = result.concat([x]);\n        }\n        result = result.concat(descendants$1(x, predicate));\n      });\n      return result;\n    };\n\n    const descendants = (scope, selector) => all(selector, scope);\n\n    const ancestor$2 = (scope, predicate, isRoot) => ancestor$4(scope, predicate, isRoot).isSome();\n    const sibling = (scope, predicate) => sibling$1(scope, predicate).isSome();\n    const descendant = (scope, predicate) => descendant$2(scope, predicate).isSome();\n\n    class DomTreeWalker {\n      constructor(startNode, rootNode) {\n        this.node = startNode;\n        this.rootNode = rootNode;\n        this.current = this.current.bind(this);\n        this.next = this.next.bind(this);\n        this.prev = this.prev.bind(this);\n        this.prev2 = this.prev2.bind(this);\n      }\n      current() {\n        return this.node;\n      }\n      next(shallow) {\n        this.node = this.findSibling(this.node, 'firstChild', 'nextSibling', shallow);\n        return this.node;\n      }\n      prev(shallow) {\n        this.node = this.findSibling(this.node, 'lastChild', 'previousSibling', shallow);\n        return this.node;\n      }\n      prev2(shallow) {\n        this.node = this.findPreviousNode(this.node, shallow);\n        return this.node;\n      }\n      findSibling(node, startName, siblingName, shallow) {\n        if (node) {\n          if (!shallow && node[startName]) {\n            return node[startName];\n          }\n          if (node !== this.rootNode) {\n            let sibling = node[siblingName];\n            if (sibling) {\n              return sibling;\n            }\n            for (let parent = node.parentNode; parent && parent !== this.rootNode; parent = parent.parentNode) {\n              sibling = parent[siblingName];\n              if (sibling) {\n                return sibling;\n              }\n            }\n          }\n        }\n        return undefined;\n      }\n      findPreviousNode(node, shallow) {\n        if (node) {\n          const sibling = node.previousSibling;\n          if (this.rootNode && sibling === this.rootNode) {\n            return;\n          }\n          if (sibling) {\n            if (!shallow) {\n              for (let child = sibling.lastChild; child; child = child.lastChild) {\n                if (!child.lastChild) {\n                  return child;\n                }\n              }\n            }\n            return sibling;\n          }\n          const parent = node.parentNode;\n          if (parent && parent !== this.rootNode) {\n            return parent;\n          }\n        }\n        return undefined;\n      }\n    }\n\n    const zeroWidth = '\\uFEFF';\n    const nbsp = '\\xA0';\n    const isZwsp$2 = char => char === zeroWidth;\n    const removeZwsp = s => s.replace(/\\uFEFF/g, '');\n\n    const whiteSpaceRegExp = /^[ \\t\\r\\n]*$/;\n    const isWhitespaceText = text => whiteSpaceRegExp.test(text);\n    const isZwsp$1 = text => {\n      for (const c of text) {\n        if (!isZwsp$2(c)) {\n          return false;\n        }\n      }\n      return true;\n    };\n    const isCollapsibleWhitespace$1 = c => ' \\f\\t\\x0B'.indexOf(c) !== -1;\n    const isNewLineChar = c => c === '\\n' || c === '\\r';\n    const isNewline = (text, idx) => idx < text.length && idx >= 0 ? isNewLineChar(text[idx]) : false;\n    const normalize$4 = (text, tabSpaces = 4, isStartOfContent = true, isEndOfContent = true) => {\n      const tabSpace = repeat(' ', tabSpaces);\n      const normalizedText = text.replace(/\\t/g, tabSpace);\n      const result = foldl(normalizedText, (acc, c) => {\n        if (isCollapsibleWhitespace$1(c) || c === nbsp) {\n          if (acc.pcIsSpace || acc.str === '' && isStartOfContent || acc.str.length === normalizedText.length - 1 && isEndOfContent || isNewline(normalizedText, acc.str.length + 1)) {\n            return {\n              pcIsSpace: false,\n              str: acc.str + nbsp\n            };\n          } else {\n            return {\n              pcIsSpace: true,\n              str: acc.str + ' '\n            };\n          }\n        } else {\n          return {\n            pcIsSpace: isNewLineChar(c),\n            str: acc.str + c\n          };\n        }\n      }, {\n        pcIsSpace: false,\n        str: ''\n      });\n      return result.str;\n    };\n\n    const isNodeType = type => {\n      return node => {\n        return !!node && node.nodeType === type;\n      };\n    };\n    const isRestrictedNode = node => !!node && !Object.getPrototypeOf(node);\n    const isElement$6 = isNodeType(1);\n    const isHTMLElement = node => isElement$6(node) && isHTMLElement$1(SugarElement.fromDom(node));\n    const isSVGElement = node => isElement$6(node) && node.namespaceURI === 'http://www.w3.org/2000/svg';\n    const matchNodeName = name => {\n      const lowerCasedName = name.toLowerCase();\n      return node => isNonNullable(node) && node.nodeName.toLowerCase() === lowerCasedName;\n    };\n    const matchNodeNames = names => {\n      const lowerCasedNames = names.map(s => s.toLowerCase());\n      return node => {\n        if (node && node.nodeName) {\n          const nodeName = node.nodeName.toLowerCase();\n          return contains$2(lowerCasedNames, nodeName);\n        }\n        return false;\n      };\n    };\n    const matchStyleValues = (name, values) => {\n      const items = values.toLowerCase().split(' ');\n      return node => {\n        if (isElement$6(node)) {\n          const win = node.ownerDocument.defaultView;\n          if (win) {\n            for (let i = 0; i < items.length; i++) {\n              const computed = win.getComputedStyle(node, null);\n              const cssValue = computed ? computed.getPropertyValue(name) : null;\n              if (cssValue === items[i]) {\n                return true;\n              }\n            }\n          }\n        }\n        return false;\n      };\n    };\n    const hasAttribute = attrName => {\n      return node => {\n        return isElement$6(node) && node.hasAttribute(attrName);\n      };\n    };\n    const isBogus$1 = node => isElement$6(node) && node.hasAttribute('data-mce-bogus');\n    const isBogusAll = node => isElement$6(node) && node.getAttribute('data-mce-bogus') === 'all';\n    const isTable$2 = node => isElement$6(node) && node.tagName === 'TABLE';\n    const hasContentEditableState = value => {\n      return node => {\n        if (isHTMLElement(node)) {\n          if (node.contentEditable === value) {\n            return true;\n          }\n          if (node.getAttribute('data-mce-contenteditable') === value) {\n            return true;\n          }\n        }\n        return false;\n      };\n    };\n    const isTextareaOrInput = matchNodeNames([\n      'textarea',\n      'input'\n    ]);\n    const isText$b = isNodeType(3);\n    const isCData = isNodeType(4);\n    const isPi = isNodeType(7);\n    const isComment = isNodeType(8);\n    const isDocument$1 = isNodeType(9);\n    const isDocumentFragment = isNodeType(11);\n    const isBr$6 = matchNodeName('br');\n    const isImg = matchNodeName('img');\n    const isContentEditableTrue$3 = hasContentEditableState('true');\n    const isContentEditableFalse$b = hasContentEditableState('false');\n    const isTableCell$3 = matchNodeNames([\n      'td',\n      'th'\n    ]);\n    const isTableCellOrCaption = matchNodeNames([\n      'td',\n      'th',\n      'caption'\n    ]);\n    const isMedia$2 = matchNodeNames([\n      'video',\n      'audio',\n      'object',\n      'embed'\n    ]);\n    const isListItem$2 = matchNodeName('li');\n    const isDetails = matchNodeName('details');\n    const isSummary$1 = matchNodeName('summary');\n\n    const defaultOptionValues = {\n      skipBogus: true,\n      includeZwsp: false,\n      checkRootAsContent: false\n    };\n    const hasWhitespacePreserveParent = (node, rootNode, schema) => {\n      const rootElement = SugarElement.fromDom(rootNode);\n      const startNode = SugarElement.fromDom(node);\n      const whitespaceElements = schema.getWhitespaceElements();\n      const predicate = node => has$2(whitespaceElements, name(node));\n      return ancestor$2(startNode, predicate, curry(eq, rootElement));\n    };\n    const isNamedAnchor = node => {\n      return isElement$6(node) && node.nodeName === 'A' && !node.hasAttribute('href') && (node.hasAttribute('name') || node.hasAttribute('id'));\n    };\n    const isNonEmptyElement$1 = (node, schema) => {\n      return isElement$6(node) && has$2(schema.getNonEmptyElements(), node.nodeName);\n    };\n    const isBookmark = hasAttribute('data-mce-bookmark');\n    const hasNonEditableParent = node => parentElement(SugarElement.fromDom(node)).exists(parent => !isEditable$2(parent));\n    const isWhitespace$1 = (node, rootNode, schema) => isWhitespaceText(node.data) && !hasWhitespacePreserveParent(node, rootNode, schema);\n    const isText$a = (node, rootNode, schema, options) => isText$b(node) && !isWhitespace$1(node, rootNode, schema) && (!options.includeZwsp || !isZwsp$1(node.data));\n    const isContentNode = (schema, node, rootNode, options) => {\n      return isFunction(options.isContent) && options.isContent(node) || isNonEmptyElement$1(node, schema) || isBookmark(node) || isNamedAnchor(node) || isText$a(node, rootNode, schema, options) || isContentEditableFalse$b(node) || isContentEditableTrue$3(node) && hasNonEditableParent(node);\n    };\n    const isEmptyNode = (schema, targetNode, opts) => {\n      const options = {\n        ...defaultOptionValues,\n        ...opts\n      };\n      if (options.checkRootAsContent) {\n        if (isContentNode(schema, targetNode, targetNode, options)) {\n          return false;\n        }\n      }\n      let node = targetNode.firstChild;\n      let brCount = 0;\n      if (!node) {\n        return true;\n      }\n      const walker = new DomTreeWalker(node, targetNode);\n      do {\n        if (options.skipBogus && isElement$6(node)) {\n          const bogusValue = node.getAttribute('data-mce-bogus');\n          if (bogusValue) {\n            node = walker.next(bogusValue === 'all');\n            continue;\n          }\n        }\n        if (isComment(node)) {\n          node = walker.next(true);\n          continue;\n        }\n        if (isBr$6(node)) {\n          brCount++;\n          node = walker.next();\n          continue;\n        }\n        if (isContentNode(schema, node, targetNode, options)) {\n          return false;\n        }\n        node = walker.next();\n      } while (node);\n      return brCount <= 1;\n    };\n    const isEmpty$2 = (schema, elm, options) => {\n      return isEmptyNode(schema, elm.dom, {\n        checkRootAsContent: true,\n        ...options\n      });\n    };\n    const isContent$1 = (schema, node, options) => {\n      return isContentNode(schema, node, node, {\n        includeZwsp: defaultOptionValues.includeZwsp,\n        ...options\n      });\n    };\n\n    const Cell = initial => {\n      let value = initial;\n      const get = () => {\n        return value;\n      };\n      const set = v => {\n        value = v;\n      };\n      return {\n        get,\n        set\n      };\n    };\n\n    const singleton = doRevoke => {\n      const subject = Cell(Optional.none());\n      const revoke = () => subject.get().each(doRevoke);\n      const clear = () => {\n        revoke();\n        subject.set(Optional.none());\n      };\n      const isSet = () => subject.get().isSome();\n      const get = () => subject.get();\n      const set = s => {\n        revoke();\n        subject.set(Optional.some(s));\n      };\n      return {\n        clear,\n        isSet,\n        get,\n        set\n      };\n    };\n    const repeatable = delay => {\n      const intervalId = Cell(Optional.none());\n      const revoke = () => intervalId.get().each(id => clearInterval(id));\n      const clear = () => {\n        revoke();\n        intervalId.set(Optional.none());\n      };\n      const isSet = () => intervalId.get().isSome();\n      const get = () => intervalId.get();\n      const set = functionToRepeat => {\n        revoke();\n        intervalId.set(Optional.some(setInterval(functionToRepeat, delay)));\n      };\n      return {\n        clear,\n        isSet,\n        get,\n        set\n      };\n    };\n    const value$2 = () => {\n      const subject = singleton(noop);\n      const on = f => subject.get().each(f);\n      return {\n        ...subject,\n        on\n      };\n    };\n\n    const nodeNameToNamespaceType = name => {\n      const lowerCaseName = name.toLowerCase();\n      if (lowerCaseName === 'svg') {\n        return 'svg';\n      } else if (lowerCaseName === 'math') {\n        return 'math';\n      } else {\n        return 'html';\n      }\n    };\n    const isNonHtmlElementRootName = name => nodeNameToNamespaceType(name) !== 'html';\n    const isNonHtmlElementRoot = node => isNonHtmlElementRootName(node.nodeName);\n    const toScopeType = node => nodeNameToNamespaceType(node.nodeName);\n    const namespaceElements = [\n      'svg',\n      'math'\n    ];\n    const createNamespaceTracker = () => {\n      const currentScope = value$2();\n      const current = () => currentScope.get().map(toScopeType).getOr('html');\n      const track = node => {\n        if (isNonHtmlElementRoot(node)) {\n          currentScope.set(node);\n        } else if (currentScope.get().exists(scopeNode => !scopeNode.contains(node))) {\n          currentScope.clear();\n        }\n        return current();\n      };\n      const reset = () => {\n        currentScope.clear();\n      };\n      return {\n        track,\n        current,\n        reset\n      };\n    };\n\n    const transparentBlockAttr = 'data-mce-block';\n    const elementNames = map => filter$5(keys(map), key => !/[A-Z]/.test(key));\n    const makeSelectorFromSchemaMap = map => map$3(elementNames(map), name => {\n      const escapedName = CSS.escape(name);\n      return `${ escapedName }:` + map$3(namespaceElements, ns => `not(${ ns } ${ escapedName })`).join(':');\n    }).join(',');\n    const updateTransparent = (blocksSelector, transparent) => {\n      if (isNonNullable(transparent.querySelector(blocksSelector))) {\n        transparent.setAttribute(transparentBlockAttr, 'true');\n        if (transparent.getAttribute('data-mce-selected') === 'inline-boundary') {\n          transparent.removeAttribute('data-mce-selected');\n        }\n        return true;\n      } else {\n        transparent.removeAttribute(transparentBlockAttr);\n        return false;\n      }\n    };\n    const updateBlockStateOnChildren = (schema, scope) => {\n      const transparentSelector = makeSelectorFromSchemaMap(schema.getTransparentElements());\n      const blocksSelector = makeSelectorFromSchemaMap(schema.getBlockElements());\n      return filter$5(scope.querySelectorAll(transparentSelector), transparent => updateTransparent(blocksSelector, transparent));\n    };\n    const trimEdge = (schema, el, leftSide) => {\n      var _a;\n      const childPropertyName = leftSide ? 'lastChild' : 'firstChild';\n      for (let child = el[childPropertyName]; child; child = child[childPropertyName]) {\n        if (isEmptyNode(schema, child, { checkRootAsContent: true })) {\n          (_a = child.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(child);\n          return;\n        }\n      }\n    };\n    const split$2 = (schema, parentElm, splitElm) => {\n      const range = document.createRange();\n      const parentNode = parentElm.parentNode;\n      if (parentNode) {\n        range.setStartBefore(parentElm);\n        range.setEndBefore(splitElm);\n        const beforeFragment = range.extractContents();\n        trimEdge(schema, beforeFragment, true);\n        range.setStartAfter(splitElm);\n        range.setEndAfter(parentElm);\n        const afterFragment = range.extractContents();\n        trimEdge(schema, afterFragment, false);\n        if (!isEmptyNode(schema, beforeFragment, { checkRootAsContent: true })) {\n          parentNode.insertBefore(beforeFragment, parentElm);\n        }\n        if (!isEmptyNode(schema, splitElm, { checkRootAsContent: true })) {\n          parentNode.insertBefore(splitElm, parentElm);\n        }\n        if (!isEmptyNode(schema, afterFragment, { checkRootAsContent: true })) {\n          parentNode.insertBefore(afterFragment, parentElm);\n        }\n        parentNode.removeChild(parentElm);\n      }\n    };\n    const splitInvalidChildren = (schema, scope, transparentBlocks) => {\n      const blocksElements = schema.getBlockElements();\n      const rootNode = SugarElement.fromDom(scope);\n      const isBlock = el => name(el) in blocksElements;\n      const isRoot = el => eq(el, rootNode);\n      each$e(fromDom$1(transparentBlocks), transparentBlock => {\n        ancestor$4(transparentBlock, isBlock, isRoot).each(parentBlock => {\n          const invalidChildren = children(transparentBlock, el => isBlock(el) && !schema.isValidChild(name(parentBlock), name(el)));\n          if (invalidChildren.length > 0) {\n            const stateScope = parentElement(parentBlock);\n            each$e(invalidChildren, child => {\n              ancestor$4(child, isBlock, isRoot).each(parentBlock => {\n                split$2(schema, parentBlock.dom, child.dom);\n              });\n            });\n            stateScope.each(scope => updateBlockStateOnChildren(schema, scope.dom));\n          }\n        });\n      });\n    };\n    const unwrapInvalidChildren = (schema, scope, transparentBlocks) => {\n      each$e([\n        ...transparentBlocks,\n        ...isTransparentBlock(schema, scope) ? [scope] : []\n      ], block => each$e(descendants(SugarElement.fromDom(block), block.nodeName.toLowerCase()), elm => {\n        if (isTransparentInline(schema, elm.dom)) {\n          unwrap(elm);\n        }\n      }));\n    };\n    const updateChildren = (schema, scope) => {\n      const transparentBlocks = updateBlockStateOnChildren(schema, scope);\n      splitInvalidChildren(schema, scope, transparentBlocks);\n      unwrapInvalidChildren(schema, scope, transparentBlocks);\n    };\n    const updateElement = (schema, target) => {\n      if (isTransparentElement(schema, target)) {\n        const blocksSelector = makeSelectorFromSchemaMap(schema.getBlockElements());\n        updateTransparent(blocksSelector, target);\n      }\n    };\n    const updateCaret = (schema, root, caretParent) => {\n      const isRoot = el => eq(el, SugarElement.fromDom(root));\n      const parents = parents$1(SugarElement.fromDom(caretParent), isRoot);\n      get$b(parents, parents.length - 2).filter(isElement$7).fold(() => updateChildren(schema, root), scope => updateChildren(schema, scope.dom));\n    };\n    const hasBlockAttr = el => el.hasAttribute(transparentBlockAttr);\n    const isTransparentElementName = (schema, name) => has$2(schema.getTransparentElements(), name);\n    const isTransparentElement = (schema, node) => isElement$6(node) && isTransparentElementName(schema, node.nodeName);\n    const isTransparentBlock = (schema, node) => isTransparentElement(schema, node) && hasBlockAttr(node);\n    const isTransparentInline = (schema, node) => isTransparentElement(schema, node) && !hasBlockAttr(node);\n    const isTransparentAstBlock = (schema, node) => node.type === 1 && isTransparentElementName(schema, node.name) && isString(node.attr(transparentBlockAttr));\n\n    const browser$2 = detect$1().browser;\n    const firstElement = nodes => find$2(nodes, isElement$7);\n    const getTableCaptionDeltaY = elm => {\n      if (browser$2.isFirefox() && name(elm) === 'table') {\n        return firstElement(children$1(elm)).filter(elm => {\n          return name(elm) === 'caption';\n        }).bind(caption => {\n          return firstElement(nextSiblings(caption)).map(body => {\n            const bodyTop = body.dom.offsetTop;\n            const captionTop = caption.dom.offsetTop;\n            const captionHeight = caption.dom.offsetHeight;\n            return bodyTop <= captionTop ? -captionHeight : 0;\n          });\n        }).getOr(0);\n      } else {\n        return 0;\n      }\n    };\n    const hasChild = (elm, child) => elm.children && contains$2(elm.children, child);\n    const getPos = (body, elm, rootElm) => {\n      let x = 0, y = 0;\n      const doc = body.ownerDocument;\n      rootElm = rootElm ? rootElm : body;\n      if (elm) {\n        if (rootElm === body && elm.getBoundingClientRect && get$7(SugarElement.fromDom(body), 'position') === 'static') {\n          const pos = elm.getBoundingClientRect();\n          x = pos.left + (doc.documentElement.scrollLeft || body.scrollLeft) - doc.documentElement.clientLeft;\n          y = pos.top + (doc.documentElement.scrollTop || body.scrollTop) - doc.documentElement.clientTop;\n          return {\n            x,\n            y\n          };\n        }\n        let offsetParent = elm;\n        while (offsetParent && offsetParent !== rootElm && offsetParent.nodeType && !hasChild(offsetParent, rootElm)) {\n          const castOffsetParent = offsetParent;\n          x += castOffsetParent.offsetLeft || 0;\n          y += castOffsetParent.offsetTop || 0;\n          offsetParent = castOffsetParent.offsetParent;\n        }\n        offsetParent = elm.parentNode;\n        while (offsetParent && offsetParent !== rootElm && offsetParent.nodeType && !hasChild(offsetParent, rootElm)) {\n          x -= offsetParent.scrollLeft || 0;\n          y -= offsetParent.scrollTop || 0;\n          offsetParent = offsetParent.parentNode;\n        }\n        y += getTableCaptionDeltaY(SugarElement.fromDom(elm));\n      }\n      return {\n        x,\n        y\n      };\n    };\n\n    const StyleSheetLoader = (documentOrShadowRoot, settings = {}) => {\n      let idCount = 0;\n      const loadedStates = {};\n      const edos = SugarElement.fromDom(documentOrShadowRoot);\n      const doc = documentOrOwner(edos);\n      const _setReferrerPolicy = referrerPolicy => {\n        settings.referrerPolicy = referrerPolicy;\n      };\n      const _setContentCssCors = contentCssCors => {\n        settings.contentCssCors = contentCssCors;\n      };\n      const addStyle = element => {\n        append$1(getStyleContainer(edos), element);\n      };\n      const removeStyle = id => {\n        const styleContainer = getStyleContainer(edos);\n        descendant$1(styleContainer, '#' + id).each(remove$4);\n      };\n      const getOrCreateState = url => get$a(loadedStates, url).getOrThunk(() => ({\n        id: 'mce-u' + idCount++,\n        passed: [],\n        failed: [],\n        count: 0\n      }));\n      const load = url => new Promise((success, failure) => {\n        let link;\n        const urlWithSuffix = Tools._addCacheSuffix(url);\n        const state = getOrCreateState(urlWithSuffix);\n        loadedStates[urlWithSuffix] = state;\n        state.count++;\n        const resolve = (callbacks, status) => {\n          each$e(callbacks, call);\n          state.status = status;\n          state.passed = [];\n          state.failed = [];\n          if (link) {\n            link.onload = null;\n            link.onerror = null;\n            link = null;\n          }\n        };\n        const passed = () => resolve(state.passed, 2);\n        const failed = () => resolve(state.failed, 3);\n        if (success) {\n          state.passed.push(success);\n        }\n        if (failure) {\n          state.failed.push(failure);\n        }\n        if (state.status === 1) {\n          return;\n        }\n        if (state.status === 2) {\n          passed();\n          return;\n        }\n        if (state.status === 3) {\n          failed();\n          return;\n        }\n        state.status = 1;\n        const linkElem = SugarElement.fromTag('link', doc.dom);\n        setAll$1(linkElem, {\n          rel: 'stylesheet',\n          type: 'text/css',\n          id: state.id\n        });\n        if (settings.contentCssCors) {\n          set$3(linkElem, 'crossOrigin', 'anonymous');\n        }\n        if (settings.referrerPolicy) {\n          set$3(linkElem, 'referrerpolicy', settings.referrerPolicy);\n        }\n        link = linkElem.dom;\n        link.onload = passed;\n        link.onerror = failed;\n        addStyle(linkElem);\n        set$3(linkElem, 'href', urlWithSuffix);\n      });\n      const loadRawCss = (key, css) => {\n        const state = getOrCreateState(key);\n        loadedStates[key] = state;\n        state.count++;\n        const styleElem = SugarElement.fromTag('style', doc.dom);\n        setAll$1(styleElem, {\n          rel: 'stylesheet',\n          type: 'text/css',\n          id: state.id\n        });\n        styleElem.dom.innerHTML = css;\n        addStyle(styleElem);\n      };\n      const loadAll = urls => {\n        const loadedUrls = Promise.allSettled(map$3(urls, url => load(url).then(constant(url))));\n        return loadedUrls.then(results => {\n          const parts = partition$2(results, r => r.status === 'fulfilled');\n          if (parts.fail.length > 0) {\n            return Promise.reject(map$3(parts.fail, result => result.reason));\n          } else {\n            return map$3(parts.pass, result => result.value);\n          }\n        });\n      };\n      const unload = url => {\n        const urlWithSuffix = Tools._addCacheSuffix(url);\n        get$a(loadedStates, urlWithSuffix).each(state => {\n          const count = --state.count;\n          if (count === 0) {\n            delete loadedStates[urlWithSuffix];\n            removeStyle(state.id);\n          }\n        });\n      };\n      const unloadRawCss = key => {\n        get$a(loadedStates, key).each(state => {\n          const count = --state.count;\n          if (count === 0) {\n            delete loadedStates[key];\n            removeStyle(state.id);\n          }\n        });\n      };\n      const unloadAll = urls => {\n        each$e(urls, url => {\n          unload(url);\n        });\n      };\n      return {\n        load,\n        loadRawCss,\n        loadAll,\n        unload,\n        unloadRawCss,\n        unloadAll,\n        _setReferrerPolicy,\n        _setContentCssCors\n      };\n    };\n\n    const create$c = () => {\n      const map = new WeakMap();\n      const forElement = (referenceElement, settings) => {\n        const root = getRootNode(referenceElement);\n        const rootDom = root.dom;\n        return Optional.from(map.get(rootDom)).getOrThunk(() => {\n          const sl = StyleSheetLoader(rootDom, settings);\n          map.set(rootDom, sl);\n          return sl;\n        });\n      };\n      return { forElement };\n    };\n    const instance = create$c();\n\n    const isSpan = node => node.nodeName.toLowerCase() === 'span';\n    const isInlineContent = (node, schema) => isNonNullable(node) && (isContent$1(schema, node) || schema.isInline(node.nodeName.toLowerCase()));\n    const surroundedByInlineContent = (node, root, schema) => {\n      const prev = new DomTreeWalker(node, root).prev(false);\n      const next = new DomTreeWalker(node, root).next(false);\n      const prevIsInline = isUndefined(prev) || isInlineContent(prev, schema);\n      const nextIsInline = isUndefined(next) || isInlineContent(next, schema);\n      return prevIsInline && nextIsInline;\n    };\n    const isBookmarkNode$2 = node => isSpan(node) && node.getAttribute('data-mce-type') === 'bookmark';\n    const isKeepTextNode = (node, root, schema) => isText$b(node) && node.data.length > 0 && surroundedByInlineContent(node, root, schema);\n    const isKeepElement = node => isElement$6(node) ? node.childNodes.length > 0 : false;\n    const isDocument = node => isDocumentFragment(node) || isDocument$1(node);\n    const trimNode = (dom, node, schema, root) => {\n      var _a;\n      const rootNode = root || node;\n      if (isElement$6(node) && isBookmarkNode$2(node)) {\n        return node;\n      }\n      const children = node.childNodes;\n      for (let i = children.length - 1; i >= 0; i--) {\n        trimNode(dom, children[i], schema, rootNode);\n      }\n      if (isElement$6(node)) {\n        const currentChildren = node.childNodes;\n        if (currentChildren.length === 1 && isBookmarkNode$2(currentChildren[0])) {\n          (_a = node.parentNode) === null || _a === void 0 ? void 0 : _a.insertBefore(currentChildren[0], node);\n        }\n      }\n      if (!isDocument(node) && !isContent$1(schema, node) && !isKeepElement(node) && !isKeepTextNode(node, rootNode, schema)) {\n        dom.remove(node);\n      }\n      return node;\n    };\n\n    const makeMap$3 = Tools.makeMap;\n    const attrsCharsRegExp = /[&<>\\\"\\u0060\\u007E-\\uD7FF\\uE000-\\uFFEF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g;\n    const textCharsRegExp = /[<>&\\u007E-\\uD7FF\\uE000-\\uFFEF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g;\n    const rawCharsRegExp = /[<>&\\\"\\']/g;\n    const entityRegExp = /&#([a-z0-9]+);?|&([a-z0-9]+);/gi;\n    const asciiMap = {\n      128: '\\u20AC',\n      130: '\\u201A',\n      131: '\\u0192',\n      132: '\\u201E',\n      133: '\\u2026',\n      134: '\\u2020',\n      135: '\\u2021',\n      136: '\\u02c6',\n      137: '\\u2030',\n      138: '\\u0160',\n      139: '\\u2039',\n      140: '\\u0152',\n      142: '\\u017d',\n      145: '\\u2018',\n      146: '\\u2019',\n      147: '\\u201C',\n      148: '\\u201D',\n      149: '\\u2022',\n      150: '\\u2013',\n      151: '\\u2014',\n      152: '\\u02DC',\n      153: '\\u2122',\n      154: '\\u0161',\n      155: '\\u203A',\n      156: '\\u0153',\n      158: '\\u017e',\n      159: '\\u0178'\n    };\n    const baseEntities = {\n      '\"': '&quot;',\n      '\\'': '&#39;',\n      '<': '&lt;',\n      '>': '&gt;',\n      '&': '&amp;',\n      '`': '&#96;'\n    };\n    const reverseEntities = {\n      '&lt;': '<',\n      '&gt;': '>',\n      '&amp;': '&',\n      '&quot;': '\"',\n      '&apos;': `'`\n    };\n    const nativeDecode = text => {\n      const elm = SugarElement.fromTag('div').dom;\n      elm.innerHTML = text;\n      return elm.textContent || elm.innerText || text;\n    };\n    const buildEntitiesLookup = (items, radix) => {\n      const lookup = {};\n      if (items) {\n        const itemList = items.split(',');\n        radix = radix || 10;\n        for (let i = 0; i < itemList.length; i += 2) {\n          const chr = String.fromCharCode(parseInt(itemList[i], radix));\n          if (!baseEntities[chr]) {\n            const entity = '&' + itemList[i + 1] + ';';\n            lookup[chr] = entity;\n            lookup[entity] = chr;\n          }\n        }\n        return lookup;\n      } else {\n        return undefined;\n      }\n    };\n    const namedEntities = buildEntitiesLookup('50,nbsp,51,iexcl,52,cent,53,pound,54,curren,55,yen,56,brvbar,57,sect,58,uml,59,copy,' + '5a,ordf,5b,laquo,5c,not,5d,shy,5e,reg,5f,macr,5g,deg,5h,plusmn,5i,sup2,5j,sup3,5k,acute,' + '5l,micro,5m,para,5n,middot,5o,cedil,5p,sup1,5q,ordm,5r,raquo,5s,frac14,5t,frac12,5u,frac34,' + '5v,iquest,60,Agrave,61,Aacute,62,Acirc,63,Atilde,64,Auml,65,Aring,66,AElig,67,Ccedil,' + '68,Egrave,69,Eacute,6a,Ecirc,6b,Euml,6c,Igrave,6d,Iacute,6e,Icirc,6f,Iuml,6g,ETH,6h,Ntilde,' + '6i,Ograve,6j,Oacute,6k,Ocirc,6l,Otilde,6m,Ouml,6n,times,6o,Oslash,6p,Ugrave,6q,Uacute,' + '6r,Ucirc,6s,Uuml,6t,Yacute,6u,THORN,6v,szlig,70,agrave,71,aacute,72,acirc,73,atilde,74,auml,' + '75,aring,76,aelig,77,ccedil,78,egrave,79,eacute,7a,ecirc,7b,euml,7c,igrave,7d,iacute,7e,icirc,' + '7f,iuml,7g,eth,7h,ntilde,7i,ograve,7j,oacute,7k,ocirc,7l,otilde,7m,ouml,7n,divide,7o,oslash,' + '7p,ugrave,7q,uacute,7r,ucirc,7s,uuml,7t,yacute,7u,thorn,7v,yuml,ci,fnof,sh,Alpha,si,Beta,' + 'sj,Gamma,sk,Delta,sl,Epsilon,sm,Zeta,sn,Eta,so,Theta,sp,Iota,sq,Kappa,sr,Lambda,ss,Mu,' + 'st,Nu,su,Xi,sv,Omicron,t0,Pi,t1,Rho,t3,Sigma,t4,Tau,t5,Upsilon,t6,Phi,t7,Chi,t8,Psi,' + 't9,Omega,th,alpha,ti,beta,tj,gamma,tk,delta,tl,epsilon,tm,zeta,tn,eta,to,theta,tp,iota,' + 'tq,kappa,tr,lambda,ts,mu,tt,nu,tu,xi,tv,omicron,u0,pi,u1,rho,u2,sigmaf,u3,sigma,u4,tau,' + 'u5,upsilon,u6,phi,u7,chi,u8,psi,u9,omega,uh,thetasym,ui,upsih,um,piv,812,bull,816,hellip,' + '81i,prime,81j,Prime,81u,oline,824,frasl,88o,weierp,88h,image,88s,real,892,trade,89l,alefsym,' + '8cg,larr,8ch,uarr,8ci,rarr,8cj,darr,8ck,harr,8dl,crarr,8eg,lArr,8eh,uArr,8ei,rArr,8ej,dArr,' + '8ek,hArr,8g0,forall,8g2,part,8g3,exist,8g5,empty,8g7,nabla,8g8,isin,8g9,notin,8gb,ni,8gf,prod,' + '8gh,sum,8gi,minus,8gn,lowast,8gq,radic,8gt,prop,8gu,infin,8h0,ang,8h7,and,8h8,or,8h9,cap,8ha,cup,' + '8hb,int,8hk,there4,8hs,sim,8i5,cong,8i8,asymp,8j0,ne,8j1,equiv,8j4,le,8j5,ge,8k2,sub,8k3,sup,8k4,' + 'nsub,8k6,sube,8k7,supe,8kl,oplus,8kn,otimes,8l5,perp,8m5,sdot,8o8,lceil,8o9,rceil,8oa,lfloor,8ob,' + 'rfloor,8p9,lang,8pa,rang,9ea,loz,9j0,spades,9j3,clubs,9j5,hearts,9j6,diams,ai,OElig,aj,oelig,b0,' + 'Scaron,b1,scaron,bo,Yuml,m6,circ,ms,tilde,802,ensp,803,emsp,809,thinsp,80c,zwnj,80d,zwj,80e,lrm,' + '80f,rlm,80j,ndash,80k,mdash,80o,lsquo,80p,rsquo,80q,sbquo,80s,ldquo,80t,rdquo,80u,bdquo,810,dagger,' + '811,Dagger,81g,permil,81p,lsaquo,81q,rsaquo,85c,euro', 32);\n    const encodeRaw = (text, attr) => text.replace(attr ? attrsCharsRegExp : textCharsRegExp, chr => {\n      return baseEntities[chr] || chr;\n    });\n    const encodeAllRaw = text => ('' + text).replace(rawCharsRegExp, chr => {\n      return baseEntities[chr] || chr;\n    });\n    const encodeNumeric = (text, attr) => text.replace(attr ? attrsCharsRegExp : textCharsRegExp, chr => {\n      if (chr.length > 1) {\n        return '&#' + ((chr.charCodeAt(0) - 55296) * 1024 + (chr.charCodeAt(1) - 56320) + 65536) + ';';\n      }\n      return baseEntities[chr] || '&#' + chr.charCodeAt(0) + ';';\n    });\n    const encodeNamed = (text, attr, entities) => {\n      const resolveEntities = entities || namedEntities;\n      return text.replace(attr ? attrsCharsRegExp : textCharsRegExp, chr => {\n        return baseEntities[chr] || resolveEntities[chr] || chr;\n      });\n    };\n    const getEncodeFunc = (name, entities) => {\n      const entitiesMap = buildEntitiesLookup(entities) || namedEntities;\n      const encodeNamedAndNumeric = (text, attr) => text.replace(attr ? attrsCharsRegExp : textCharsRegExp, chr => {\n        if (baseEntities[chr] !== undefined) {\n          return baseEntities[chr];\n        }\n        if (entitiesMap[chr] !== undefined) {\n          return entitiesMap[chr];\n        }\n        if (chr.length > 1) {\n          return '&#' + ((chr.charCodeAt(0) - 55296) * 1024 + (chr.charCodeAt(1) - 56320) + 65536) + ';';\n        }\n        return '&#' + chr.charCodeAt(0) + ';';\n      });\n      const encodeCustomNamed = (text, attr) => {\n        return encodeNamed(text, attr, entitiesMap);\n      };\n      const nameMap = makeMap$3(name.replace(/\\+/g, ','));\n      if (nameMap.named && nameMap.numeric) {\n        return encodeNamedAndNumeric;\n      }\n      if (nameMap.named) {\n        if (entities) {\n          return encodeCustomNamed;\n        }\n        return encodeNamed;\n      }\n      if (nameMap.numeric) {\n        return encodeNumeric;\n      }\n      return encodeRaw;\n    };\n    const decode = text => text.replace(entityRegExp, (all, numeric) => {\n      if (numeric) {\n        if (numeric.charAt(0).toLowerCase() === 'x') {\n          numeric = parseInt(numeric.substr(1), 16);\n        } else {\n          numeric = parseInt(numeric, 10);\n        }\n        if (numeric > 65535) {\n          numeric -= 65536;\n          return String.fromCharCode(55296 + (numeric >> 10), 56320 + (numeric & 1023));\n        }\n        return asciiMap[numeric] || String.fromCharCode(numeric);\n      }\n      return reverseEntities[all] || namedEntities[all] || nativeDecode(all);\n    });\n    const Entities = {\n      encodeRaw,\n      encodeAllRaw,\n      encodeNumeric,\n      encodeNamed,\n      getEncodeFunc,\n      decode\n    };\n\n    const split$1 = (items, delim) => {\n      items = Tools.trim(items);\n      return items ? items.split(delim || ' ') : [];\n    };\n    const patternToRegExp = str => new RegExp('^' + str.replace(/([?+*])/g, '.$1') + '$');\n    const isRegExp$1 = obj => isObject(obj) && obj.source && Object.prototype.toString.call(obj) === '[object RegExp]';\n    const deepCloneElementRule = obj => {\n      const helper = value => {\n        if (isArray$1(value)) {\n          return map$3(value, helper);\n        } else if (isRegExp$1(value)) {\n          return new RegExp(value.source, value.flags);\n        } else if (isObject(value)) {\n          return map$2(value, helper);\n        } else {\n          return value;\n        }\n      };\n      return helper(obj);\n    };\n\n    const parseCustomElementsRules = value => {\n      const customElementRegExp = /^(~)?(.+)$/;\n      return bind$3(split$1(value, ','), rule => {\n        const matches = customElementRegExp.exec(rule);\n        if (matches) {\n          const inline = matches[1] === '~';\n          const cloneName = inline ? 'span' : 'div';\n          const name = matches[2];\n          return [{\n              cloneName,\n              name\n            }];\n        } else {\n          return [];\n        }\n      });\n    };\n\n    const getGlobalAttributeSet = type => {\n      return Object.freeze([\n        'id',\n        'accesskey',\n        'class',\n        'dir',\n        'lang',\n        'style',\n        'tabindex',\n        'title',\n        'role',\n        ...type !== 'html4' ? [\n          'contenteditable',\n          'contextmenu',\n          'draggable',\n          'dropzone',\n          'hidden',\n          'spellcheck',\n          'translate',\n          'itemprop',\n          'itemscope',\n          'itemtype'\n        ] : [],\n        ...type !== 'html5-strict' ? ['xml:lang'] : []\n      ]);\n    };\n\n    const getElementSetsAsStrings = type => {\n      let blockContent;\n      let phrasingContent;\n      blockContent = 'address blockquote div dl fieldset form h1 h2 h3 h4 h5 h6 hr menu ol p pre table ul';\n      phrasingContent = 'a abbr b bdo br button cite code del dfn em embed i iframe img input ins kbd ' + 'label map noscript object q s samp script select small span strong sub sup ' + 'textarea u var #text #comment';\n      if (type !== 'html4') {\n        const transparentContent = 'a ins del canvas map';\n        blockContent += ' article aside details dialog figure main header footer hgroup section nav ' + transparentContent;\n        phrasingContent += ' audio canvas command data datalist mark meter output picture ' + 'progress time wbr video ruby bdi keygen svg';\n      }\n      if (type !== 'html5-strict') {\n        const html4PhrasingContent = 'acronym applet basefont big font strike tt';\n        phrasingContent = [\n          phrasingContent,\n          html4PhrasingContent\n        ].join(' ');\n        const html4BlockContent = 'center dir isindex noframes';\n        blockContent = [\n          blockContent,\n          html4BlockContent\n        ].join(' ');\n      }\n      const flowContent = [\n        blockContent,\n        phrasingContent\n      ].join(' ');\n      return {\n        blockContent,\n        phrasingContent,\n        flowContent\n      };\n    };\n    const getElementSets = type => {\n      const {blockContent, phrasingContent, flowContent} = getElementSetsAsStrings(type);\n      const toArr = value => {\n        return Object.freeze(value.split(' '));\n      };\n      return Object.freeze({\n        blockContent: toArr(blockContent),\n        phrasingContent: toArr(phrasingContent),\n        flowContent: toArr(flowContent)\n      });\n    };\n\n    const cachedSets = {\n      'html4': cached(() => getElementSets('html4')),\n      'html5': cached(() => getElementSets('html5')),\n      'html5-strict': cached(() => getElementSets('html5-strict'))\n    };\n    const getElementsPreset = (type, name) => {\n      const {blockContent, phrasingContent, flowContent} = cachedSets[type]();\n      if (name === 'blocks') {\n        return Optional.some(blockContent);\n      } else if (name === 'phrasing') {\n        return Optional.some(phrasingContent);\n      } else if (name === 'flow') {\n        return Optional.some(flowContent);\n      } else {\n        return Optional.none();\n      }\n    };\n\n    const makeSchema = type => {\n      const globalAttributes = getGlobalAttributeSet(type);\n      const {phrasingContent, flowContent} = getElementSetsAsStrings(type);\n      const schema = {};\n      const addElement = (name, attributes, children) => {\n        schema[name] = {\n          attributes: mapToObject(attributes, constant({})),\n          attributesOrder: attributes,\n          children: mapToObject(children, constant({}))\n        };\n      };\n      const add = (name, attributes = '', children = '') => {\n        const childNames = split$1(children);\n        const names = split$1(name);\n        let ni = names.length;\n        const allAttributes = [\n          ...globalAttributes,\n          ...split$1(attributes)\n        ];\n        while (ni--) {\n          addElement(names[ni], allAttributes.slice(), childNames);\n        }\n      };\n      const addAttrs = (name, attributes) => {\n        const names = split$1(name);\n        const attrs = split$1(attributes);\n        let ni = names.length;\n        while (ni--) {\n          const schemaItem = schema[names[ni]];\n          for (let i = 0, l = attrs.length; i < l; i++) {\n            schemaItem.attributes[attrs[i]] = {};\n            schemaItem.attributesOrder.push(attrs[i]);\n          }\n        }\n      };\n      if (type !== 'html5-strict') {\n        const html4PhrasingContent = 'acronym applet basefont big font strike tt';\n        each$e(split$1(html4PhrasingContent), name => {\n          add(name, '', phrasingContent);\n        });\n        const html4BlockContent = 'center dir isindex noframes';\n        each$e(split$1(html4BlockContent), name => {\n          add(name, '', flowContent);\n        });\n      }\n      add('html', 'manifest', 'head body');\n      add('head', '', 'base command link meta noscript script style title');\n      add('title hr noscript br');\n      add('base', 'href target');\n      add('link', 'href rel media hreflang type sizes hreflang');\n      add('meta', 'name http-equiv content charset');\n      add('style', 'media type scoped');\n      add('script', 'src async defer type charset');\n      add('body', 'onafterprint onbeforeprint onbeforeunload onblur onerror onfocus ' + 'onhashchange onload onmessage onoffline ononline onpagehide onpageshow ' + 'onpopstate onresize onscroll onstorage onunload', flowContent);\n      add('dd div', '', flowContent);\n      add('address dt caption', '', type === 'html4' ? phrasingContent : flowContent);\n      add('h1 h2 h3 h4 h5 h6 pre p abbr code var samp kbd sub sup i b u bdo span legend em strong small s cite dfn', '', phrasingContent);\n      add('blockquote', 'cite', flowContent);\n      add('ol', 'reversed start type', 'li');\n      add('ul', '', 'li');\n      add('li', 'value', flowContent);\n      add('dl', '', 'dt dd');\n      add('a', 'href target rel media hreflang type', type === 'html4' ? phrasingContent : flowContent);\n      add('q', 'cite', phrasingContent);\n      add('ins del', 'cite datetime', flowContent);\n      add('img', 'src sizes srcset alt usemap ismap width height');\n      add('iframe', 'src name width height', flowContent);\n      add('embed', 'src type width height');\n      add('object', 'data type typemustmatch name usemap form width height', [\n        flowContent,\n        'param'\n      ].join(' '));\n      add('param', 'name value');\n      add('map', 'name', [\n        flowContent,\n        'area'\n      ].join(' '));\n      add('area', 'alt coords shape href target rel media hreflang type');\n      add('table', 'border', 'caption colgroup thead tfoot tbody tr' + (type === 'html4' ? ' col' : ''));\n      add('colgroup', 'span', 'col');\n      add('col', 'span');\n      add('tbody thead tfoot', '', 'tr');\n      add('tr', '', 'td th');\n      add('td', 'colspan rowspan headers', flowContent);\n      add('th', 'colspan rowspan headers scope abbr', flowContent);\n      add('form', 'accept-charset action autocomplete enctype method name novalidate target', flowContent);\n      add('fieldset', 'disabled form name', [\n        flowContent,\n        'legend'\n      ].join(' '));\n      add('label', 'form for', phrasingContent);\n      add('input', 'accept alt autocomplete checked dirname disabled form formaction formenctype formmethod formnovalidate ' + 'formtarget height list max maxlength min multiple name pattern readonly required size src step type value width');\n      add('button', 'disabled form formaction formenctype formmethod formnovalidate formtarget name type value', type === 'html4' ? flowContent : phrasingContent);\n      add('select', 'disabled form multiple name required size', 'option optgroup');\n      add('optgroup', 'disabled label', 'option');\n      add('option', 'disabled label selected value');\n      add('textarea', 'cols dirname disabled form maxlength name readonly required rows wrap');\n      add('menu', 'type label', [\n        flowContent,\n        'li'\n      ].join(' '));\n      add('noscript', '', flowContent);\n      if (type !== 'html4') {\n        add('wbr');\n        add('ruby', '', [\n          phrasingContent,\n          'rt rp'\n        ].join(' '));\n        add('figcaption', '', flowContent);\n        add('mark rt rp bdi', '', phrasingContent);\n        add('summary', '', [\n          phrasingContent,\n          'h1 h2 h3 h4 h5 h6'\n        ].join(' '));\n        add('canvas', 'width height', flowContent);\n        add('data', 'value', phrasingContent);\n        add('video', 'src crossorigin poster preload autoplay mediagroup loop ' + 'muted controls width height buffered', [\n          flowContent,\n          'track source'\n        ].join(' '));\n        add('audio', 'src crossorigin preload autoplay mediagroup loop muted controls ' + 'buffered volume', [\n          flowContent,\n          'track source'\n        ].join(' '));\n        add('picture', '', 'img source');\n        add('source', 'src srcset type media sizes');\n        add('track', 'kind src srclang label default');\n        add('datalist', '', [\n          phrasingContent,\n          'option'\n        ].join(' '));\n        add('article section nav aside main header footer', '', flowContent);\n        add('hgroup', '', 'h1 h2 h3 h4 h5 h6');\n        add('figure', '', [\n          flowContent,\n          'figcaption'\n        ].join(' '));\n        add('time', 'datetime', phrasingContent);\n        add('dialog', 'open', flowContent);\n        add('command', 'type label icon disabled checked radiogroup command');\n        add('output', 'for form name', phrasingContent);\n        add('progress', 'value max', phrasingContent);\n        add('meter', 'value min max low high optimum', phrasingContent);\n        add('details', 'open', [\n          flowContent,\n          'summary'\n        ].join(' '));\n        add('keygen', 'autofocus challenge disabled form keytype name');\n        addElement('svg', 'id tabindex lang xml:space class style x y width height viewBox preserveAspectRatio zoomAndPan transform'.split(' '), []);\n      }\n      if (type !== 'html5-strict') {\n        addAttrs('script', 'language xml:space');\n        addAttrs('style', 'xml:space');\n        addAttrs('object', 'declare classid code codebase codetype archive standby align border hspace vspace');\n        addAttrs('embed', 'align name hspace vspace');\n        addAttrs('param', 'valuetype type');\n        addAttrs('a', 'charset name rev shape coords');\n        addAttrs('br', 'clear');\n        addAttrs('applet', 'codebase archive code object alt name width height align hspace vspace');\n        addAttrs('img', 'name longdesc align border hspace vspace');\n        addAttrs('iframe', 'longdesc frameborder marginwidth marginheight scrolling align');\n        addAttrs('font basefont', 'size color face');\n        addAttrs('input', 'usemap align');\n        addAttrs('select');\n        addAttrs('textarea');\n        addAttrs('h1 h2 h3 h4 h5 h6 div p legend caption', 'align');\n        addAttrs('ul', 'type compact');\n        addAttrs('li', 'type');\n        addAttrs('ol dl menu dir', 'compact');\n        addAttrs('pre', 'width xml:space');\n        addAttrs('hr', 'align noshade size width');\n        addAttrs('isindex', 'prompt');\n        addAttrs('table', 'summary width frame rules cellspacing cellpadding align bgcolor');\n        addAttrs('col', 'width align char charoff valign');\n        addAttrs('colgroup', 'width align char charoff valign');\n        addAttrs('thead', 'align char charoff valign');\n        addAttrs('tr', 'align char charoff valign bgcolor');\n        addAttrs('th', 'axis align char charoff valign nowrap bgcolor width height');\n        addAttrs('form', 'accept');\n        addAttrs('td', 'abbr axis scope align char charoff valign nowrap bgcolor width height');\n        addAttrs('tfoot', 'align char charoff valign');\n        addAttrs('tbody', 'align char charoff valign');\n        addAttrs('area', 'nohref');\n        addAttrs('body', 'background bgcolor text link vlink alink');\n      }\n      if (type !== 'html4') {\n        addAttrs('input button select textarea', 'autofocus');\n        addAttrs('input textarea', 'placeholder');\n        addAttrs('a', 'download');\n        addAttrs('link script img', 'crossorigin');\n        addAttrs('img', 'loading');\n        addAttrs('iframe', 'sandbox seamless allow allowfullscreen loading referrerpolicy');\n      }\n      if (type !== 'html4') {\n        each$e([\n          schema.video,\n          schema.audio\n        ], item => {\n          delete item.children.audio;\n          delete item.children.video;\n        });\n      }\n      each$e(split$1('a form meter progress dfn'), name => {\n        if (schema[name]) {\n          delete schema[name].children[name];\n        }\n      });\n      delete schema.caption.children.table;\n      delete schema.script;\n      return schema;\n    };\n\n    const prefixToOperation = prefix => prefix === '-' ? 'remove' : 'add';\n    const parseValidChild = name => {\n      const validChildRegExp = /^(@?)([A-Za-z0-9_\\-.\\u00b7\\u00c0-\\u00d6\\u00d8-\\u00f6\\u00f8-\\u037d\\u037f-\\u1fff\\u200c-\\u200d\\u203f-\\u2040\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]+)$/;\n      return Optional.from(validChildRegExp.exec(name)).map(matches => ({\n        preset: matches[1] === '@',\n        name: matches[2]\n      }));\n    };\n    const parseValidChildrenRules = value => {\n      const childRuleRegExp = /^([+\\-]?)([A-Za-z0-9_\\-.\\u00b7\\u00c0-\\u00d6\\u00d8-\\u00f6\\u00f8-\\u037d\\u037f-\\u1fff\\u200c-\\u200d\\u203f-\\u2040\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]+)\\[([^\\]]+)]$/;\n      return bind$3(split$1(value, ','), rule => {\n        const matches = childRuleRegExp.exec(rule);\n        if (matches) {\n          const prefix = matches[1];\n          const operation = prefix ? prefixToOperation(prefix) : 'replace';\n          const name = matches[2];\n          const validChildren = bind$3(split$1(matches[3], '|'), validChild => parseValidChild(validChild).toArray());\n          return [{\n              operation,\n              name,\n              validChildren\n            }];\n        } else {\n          return [];\n        }\n      });\n    };\n\n    const parseValidElementsAttrDataIntoElement = (attrData, targetElement) => {\n      const attrRuleRegExp = /^([!\\-])?(\\w+[\\\\:]:\\w+|[^=~<]+)?(?:([=~<])(.*))?$/;\n      const hasPatternsRegExp = /[*?+]/;\n      const {attributes, attributesOrder} = targetElement;\n      return each$e(split$1(attrData, '|'), rule => {\n        const matches = attrRuleRegExp.exec(rule);\n        if (matches) {\n          const attr = {};\n          const attrType = matches[1];\n          const attrName = matches[2].replace(/[\\\\:]:/g, ':');\n          const attrPrefix = matches[3];\n          const value = matches[4];\n          if (attrType === '!') {\n            targetElement.attributesRequired = targetElement.attributesRequired || [];\n            targetElement.attributesRequired.push(attrName);\n            attr.required = true;\n          }\n          if (attrType === '-') {\n            delete attributes[attrName];\n            attributesOrder.splice(Tools.inArray(attributesOrder, attrName), 1);\n            return;\n          }\n          if (attrPrefix) {\n            if (attrPrefix === '=') {\n              targetElement.attributesDefault = targetElement.attributesDefault || [];\n              targetElement.attributesDefault.push({\n                name: attrName,\n                value\n              });\n              attr.defaultValue = value;\n            } else if (attrPrefix === '~') {\n              targetElement.attributesForced = targetElement.attributesForced || [];\n              targetElement.attributesForced.push({\n                name: attrName,\n                value\n              });\n              attr.forcedValue = value;\n            } else if (attrPrefix === '<') {\n              attr.validValues = Tools.makeMap(value, '?');\n            }\n          }\n          if (hasPatternsRegExp.test(attrName)) {\n            const attrPattern = attr;\n            targetElement.attributePatterns = targetElement.attributePatterns || [];\n            attrPattern.pattern = patternToRegExp(attrName);\n            targetElement.attributePatterns.push(attrPattern);\n          } else {\n            if (!attributes[attrName]) {\n              attributesOrder.push(attrName);\n            }\n            attributes[attrName] = attr;\n          }\n        }\n      });\n    };\n    const cloneAttributesInto = (from, to) => {\n      each$d(from.attributes, (value, key) => {\n        to.attributes[key] = value;\n      });\n      to.attributesOrder.push(...from.attributesOrder);\n    };\n    const parseValidElementsRules = (globalElement, validElements) => {\n      const elementRuleRegExp = /^([#+\\-])?([^\\[!\\/]+)(?:\\/([^\\[!]+))?(?:(!?)\\[([^\\]]+)])?$/;\n      return bind$3(split$1(validElements, ','), rule => {\n        const matches = elementRuleRegExp.exec(rule);\n        if (matches) {\n          const prefix = matches[1];\n          const elementName = matches[2];\n          const outputName = matches[3];\n          const attrsPrefix = matches[4];\n          const attrData = matches[5];\n          const element = {\n            attributes: {},\n            attributesOrder: []\n          };\n          globalElement.each(el => cloneAttributesInto(el, element));\n          if (prefix === '#') {\n            element.paddEmpty = true;\n          } else if (prefix === '-') {\n            element.removeEmpty = true;\n          }\n          if (attrsPrefix === '!') {\n            element.removeEmptyAttrs = true;\n          }\n          if (attrData) {\n            parseValidElementsAttrDataIntoElement(attrData, element);\n          }\n          if (outputName) {\n            element.outputName = elementName;\n          }\n          if (elementName === '@') {\n            if (globalElement.isNone()) {\n              globalElement = Optional.some(element);\n            } else {\n              return [];\n            }\n          }\n          return [outputName ? {\n              name: elementName,\n              element,\n              aliasName: outputName\n            } : {\n              name: elementName,\n              element\n            }];\n        } else {\n          return [];\n        }\n      });\n    };\n\n    const mapCache = {};\n    const makeMap$2 = Tools.makeMap, each$b = Tools.each, extend$2 = Tools.extend, explode$2 = Tools.explode;\n    const createMap = (defaultValue, extendWith = {}) => {\n      const value = makeMap$2(defaultValue, ' ', makeMap$2(defaultValue.toUpperCase(), ' '));\n      return extend$2(value, extendWith);\n    };\n    const getTextRootBlockElements = schema => createMap('td th li dt dd figcaption caption details summary', schema.getTextBlockElements());\n    const compileElementMap = (value, mode) => {\n      if (value) {\n        const styles = {};\n        if (isString(value)) {\n          value = { '*': value };\n        }\n        each$b(value, (value, key) => {\n          styles[key] = styles[key.toUpperCase()] = mode === 'map' ? makeMap$2(value, /[, ]/) : explode$2(value, /[, ]/);\n        });\n        return styles;\n      } else {\n        return undefined;\n      }\n    };\n    const Schema = (settings = {}) => {\n      var _a;\n      const elements = {};\n      const children = {};\n      let patternElements = [];\n      const customElementsMap = {};\n      const specialElements = {};\n      const createLookupTable = (option, defaultValue, extendWith) => {\n        const value = settings[option];\n        if (!value) {\n          let newValue = mapCache[option];\n          if (!newValue) {\n            newValue = createMap(defaultValue, extendWith);\n            mapCache[option] = newValue;\n          }\n          return newValue;\n        } else {\n          return makeMap$2(value, /[, ]/, makeMap$2(value.toUpperCase(), /[, ]/));\n        }\n      };\n      const schemaType = (_a = settings.schema) !== null && _a !== void 0 ? _a : 'html5';\n      const schemaItems = makeSchema(schemaType);\n      if (settings.verify_html === false) {\n        settings.valid_elements = '*[*]';\n      }\n      const validStyles = compileElementMap(settings.valid_styles);\n      const invalidStyles = compileElementMap(settings.invalid_styles, 'map');\n      const validClasses = compileElementMap(settings.valid_classes, 'map');\n      const whitespaceElementsMap = createLookupTable('whitespace_elements', 'pre script noscript style textarea video audio iframe object code');\n      const selfClosingElementsMap = createLookupTable('self_closing_elements', 'colgroup dd dt li option p td tfoot th thead tr');\n      const voidElementsMap = createLookupTable('void_elements', 'area base basefont br col frame hr img input isindex link ' + 'meta param embed source wbr track');\n      const boolAttrMap = createLookupTable('boolean_attributes', 'checked compact declare defer disabled ismap multiple nohref noresize ' + 'noshade nowrap readonly selected autoplay loop controls allowfullscreen');\n      const nonEmptyOrMoveCaretBeforeOnEnter = 'td th iframe video audio object script code';\n      const nonEmptyElementsMap = createLookupTable('non_empty_elements', nonEmptyOrMoveCaretBeforeOnEnter + ' pre svg textarea summary', voidElementsMap);\n      const moveCaretBeforeOnEnterElementsMap = createLookupTable('move_caret_before_on_enter_elements', nonEmptyOrMoveCaretBeforeOnEnter + ' table', voidElementsMap);\n      const headings = 'h1 h2 h3 h4 h5 h6';\n      const textBlockElementsMap = createLookupTable('text_block_elements', headings + ' p div address pre form ' + 'blockquote center dir fieldset header footer article section hgroup aside main nav figure');\n      const blockElementsMap = createLookupTable('block_elements', 'hr table tbody thead tfoot ' + 'th tr td li ol ul caption dl dt dd noscript menu isindex option ' + 'datalist select optgroup figcaption details summary html body multicol listing', textBlockElementsMap);\n      const textInlineElementsMap = createLookupTable('text_inline_elements', 'span strong b em i font s strike u var cite ' + 'dfn code mark q sup sub samp');\n      const transparentElementsMap = createLookupTable('transparent_elements', 'a ins del canvas map');\n      const wrapBlockElementsMap = createLookupTable('wrap_block_elements', 'pre ' + headings);\n      each$b('script noscript iframe noframes noembed title style textarea xmp plaintext'.split(' '), name => {\n        specialElements[name] = new RegExp('</' + name + '[^>]*>', 'gi');\n      });\n      const addValidElements = validElements => {\n        const globalElement = Optional.from(elements['@']);\n        const hasPatternsRegExp = /[*?+]/;\n        each$e(parseValidElementsRules(globalElement, validElements !== null && validElements !== void 0 ? validElements : ''), ({name, element, aliasName}) => {\n          if (aliasName) {\n            elements[aliasName] = element;\n          }\n          if (hasPatternsRegExp.test(name)) {\n            const patternElement = element;\n            patternElement.pattern = patternToRegExp(name);\n            patternElements.push(patternElement);\n          } else {\n            elements[name] = element;\n          }\n        });\n      };\n      const setValidElements = validElements => {\n        patternElements = [];\n        each$e(keys(elements), name => {\n          delete elements[name];\n        });\n        addValidElements(validElements);\n      };\n      const addCustomElement = (name, spec) => {\n        var _a, _b;\n        delete mapCache.text_block_elements;\n        delete mapCache.block_elements;\n        const inline = spec.extends ? !isBlock(spec.extends) : false;\n        const cloneName = spec.extends;\n        children[name] = cloneName ? children[cloneName] : {};\n        customElementsMap[name] = cloneName !== null && cloneName !== void 0 ? cloneName : name;\n        nonEmptyElementsMap[name.toUpperCase()] = {};\n        nonEmptyElementsMap[name] = {};\n        if (!inline) {\n          blockElementsMap[name.toUpperCase()] = {};\n          blockElementsMap[name] = {};\n        }\n        if (cloneName && !elements[name] && elements[cloneName]) {\n          const customRule = deepCloneElementRule(elements[cloneName]);\n          delete customRule.removeEmptyAttrs;\n          delete customRule.removeEmpty;\n          elements[name] = customRule;\n        } else {\n          elements[name] = {\n            attributesOrder: [],\n            attributes: {}\n          };\n        }\n        if (isArray$1(spec.attributes)) {\n          const processAttrName = name => {\n            customRule.attributesOrder.push(name);\n            customRule.attributes[name] = {};\n          };\n          const customRule = (_a = elements[name]) !== null && _a !== void 0 ? _a : {};\n          delete customRule.attributesDefault;\n          delete customRule.attributesForced;\n          delete customRule.attributePatterns;\n          delete customRule.attributesRequired;\n          customRule.attributesOrder = [];\n          customRule.attributes = {};\n          each$e(spec.attributes, attrName => {\n            const globalAttrs = getGlobalAttributeSet(schemaType);\n            parseValidChild(attrName).each(({preset, name}) => {\n              if (preset) {\n                if (name === 'global') {\n                  each$e(globalAttrs, processAttrName);\n                }\n              } else {\n                processAttrName(name);\n              }\n            });\n          });\n          elements[name] = customRule;\n        }\n        if (isBoolean(spec.padEmpty)) {\n          const customRule = (_b = elements[name]) !== null && _b !== void 0 ? _b : {};\n          customRule.paddEmpty = spec.padEmpty;\n          elements[name] = customRule;\n        }\n        if (isArray$1(spec.children)) {\n          const customElementChildren = {};\n          const processNodeName = name => {\n            customElementChildren[name] = {};\n          };\n          const processPreset = name => {\n            getElementsPreset(schemaType, name).each(names => {\n              each$e(names, processNodeName);\n            });\n          };\n          each$e(spec.children, child => {\n            parseValidChild(child).each(({preset, name}) => {\n              if (preset) {\n                processPreset(name);\n              } else {\n                processNodeName(name);\n              }\n            });\n          });\n          children[name] = customElementChildren;\n        }\n        if (cloneName) {\n          each$d(children, (element, elmName) => {\n            if (element[cloneName]) {\n              children[elmName] = element = extend$2({}, children[elmName]);\n              element[name] = element[cloneName];\n            }\n          });\n        }\n      };\n      const addCustomElementsFromString = customElements => {\n        each$e(parseCustomElementsRules(customElements !== null && customElements !== void 0 ? customElements : ''), ({name, cloneName}) => {\n          addCustomElement(name, { extends: cloneName });\n        });\n      };\n      const addCustomElements = customElements => {\n        if (isObject(customElements)) {\n          each$d(customElements, (spec, name) => addCustomElement(name, spec));\n        } else if (isString(customElements)) {\n          addCustomElementsFromString(customElements);\n        }\n      };\n      const addValidChildren = validChildren => {\n        each$e(parseValidChildrenRules(validChildren !== null && validChildren !== void 0 ? validChildren : ''), ({operation, name, validChildren}) => {\n          const parent = operation === 'replace' ? { '#comment': {} } : children[name];\n          const processNodeName = name => {\n            if (operation === 'remove') {\n              delete parent[name];\n            } else {\n              parent[name] = {};\n            }\n          };\n          const processPreset = name => {\n            getElementsPreset(schemaType, name).each(names => {\n              each$e(names, processNodeName);\n            });\n          };\n          each$e(validChildren, ({preset, name}) => {\n            if (preset) {\n              processPreset(name);\n            } else {\n              processNodeName(name);\n            }\n          });\n          children[name] = parent;\n        });\n      };\n      const getElementRule = name => {\n        const element = elements[name];\n        if (element) {\n          return element;\n        }\n        let i = patternElements.length;\n        while (i--) {\n          const patternElement = patternElements[i];\n          if (patternElement.pattern.test(name)) {\n            return patternElement;\n          }\n        }\n        return undefined;\n      };\n      const setup = () => {\n        if (!settings.valid_elements) {\n          each$b(schemaItems, (element, name) => {\n            elements[name] = {\n              attributes: element.attributes,\n              attributesOrder: element.attributesOrder\n            };\n            children[name] = element.children;\n          });\n          each$b(split$1('strong/b em/i'), item => {\n            const items = split$1(item, '/');\n            elements[items[1]].outputName = items[0];\n          });\n          each$b(textInlineElementsMap, (_val, name) => {\n            if (elements[name]) {\n              if (settings.padd_empty_block_inline_children) {\n                elements[name].paddInEmptyBlock = true;\n              }\n              elements[name].removeEmpty = true;\n            }\n          });\n          each$b(split$1('ol ul blockquote a table tbody'), name => {\n            if (elements[name]) {\n              elements[name].removeEmpty = true;\n            }\n          });\n          each$b(split$1('p h1 h2 h3 h4 h5 h6 th td pre div address caption li summary'), name => {\n            if (elements[name]) {\n              elements[name].paddEmpty = true;\n            }\n          });\n          each$b(split$1('span'), name => {\n            elements[name].removeEmptyAttrs = true;\n          });\n        } else {\n          setValidElements(settings.valid_elements);\n          each$b(schemaItems, (element, name) => {\n            children[name] = element.children;\n          });\n        }\n        delete elements.svg;\n        addCustomElements(settings.custom_elements);\n        addValidChildren(settings.valid_children);\n        addValidElements(settings.extended_valid_elements);\n        addValidChildren('+ol[ul|ol],+ul[ul|ol]');\n        each$b({\n          dd: 'dl',\n          dt: 'dl',\n          li: 'ul ol',\n          td: 'tr',\n          th: 'tr',\n          tr: 'tbody thead tfoot',\n          tbody: 'table',\n          thead: 'table',\n          tfoot: 'table',\n          legend: 'fieldset',\n          area: 'map',\n          param: 'video audio object'\n        }, (parents, item) => {\n          if (elements[item]) {\n            elements[item].parentsRequired = split$1(parents);\n          }\n        });\n        if (settings.invalid_elements) {\n          each$b(explode$2(settings.invalid_elements), item => {\n            if (elements[item]) {\n              delete elements[item];\n            }\n          });\n        }\n        if (!getElementRule('span')) {\n          addValidElements('span[!data-mce-type|*]');\n        }\n      };\n      const getValidStyles = constant(validStyles);\n      const getInvalidStyles = constant(invalidStyles);\n      const getValidClasses = constant(validClasses);\n      const getBoolAttrs = constant(boolAttrMap);\n      const getBlockElements = constant(blockElementsMap);\n      const getTextBlockElements = constant(textBlockElementsMap);\n      const getTextInlineElements = constant(textInlineElementsMap);\n      const getVoidElements = constant(Object.seal(voidElementsMap));\n      const getSelfClosingElements = constant(selfClosingElementsMap);\n      const getNonEmptyElements = constant(nonEmptyElementsMap);\n      const getMoveCaretBeforeOnEnterElements = constant(moveCaretBeforeOnEnterElementsMap);\n      const getWhitespaceElements = constant(whitespaceElementsMap);\n      const getTransparentElements = constant(transparentElementsMap);\n      const getWrapBlockElements = constant(wrapBlockElementsMap);\n      const getSpecialElements = constant(Object.seal(specialElements));\n      const isValidChild = (name, child) => {\n        const parent = children[name.toLowerCase()];\n        return !!(parent && parent[child.toLowerCase()]);\n      };\n      const isValid = (name, attr) => {\n        const rule = getElementRule(name);\n        if (rule) {\n          if (attr) {\n            if (rule.attributes[attr]) {\n              return true;\n            }\n            const attrPatterns = rule.attributePatterns;\n            if (attrPatterns) {\n              let i = attrPatterns.length;\n              while (i--) {\n                if (attrPatterns[i].pattern.test(attr)) {\n                  return true;\n                }\n              }\n            }\n          } else {\n            return true;\n          }\n        }\n        return false;\n      };\n      const isBlock = name => has$2(getBlockElements(), name);\n      const isInline = name => !startsWith(name, '#') && isValid(name) && !isBlock(name);\n      const isWrapper = name => has$2(getWrapBlockElements(), name) || isInline(name);\n      const getCustomElements = constant(customElementsMap);\n      setup();\n      return {\n        type: schemaType,\n        children,\n        elements,\n        getValidStyles,\n        getValidClasses,\n        getBlockElements,\n        getInvalidStyles,\n        getVoidElements,\n        getTextBlockElements,\n        getTextInlineElements,\n        getBoolAttrs,\n        getElementRule,\n        getSelfClosingElements,\n        getNonEmptyElements,\n        getMoveCaretBeforeOnEnterElements,\n        getWhitespaceElements,\n        getTransparentElements,\n        getSpecialElements,\n        isValidChild,\n        isValid,\n        isBlock,\n        isInline,\n        isWrapper,\n        getCustomElements,\n        addValidElements,\n        setValidElements,\n        addCustomElements,\n        addValidChildren\n      };\n    };\n\n    const hexColour = value => ({ value: normalizeHex(value) });\n    const normalizeHex = hex => removeLeading(hex, '#').toUpperCase();\n    const toHex = component => {\n      const hex = component.toString(16);\n      return (hex.length === 1 ? '0' + hex : hex).toUpperCase();\n    };\n    const fromRgba = rgbaColour => {\n      const value = toHex(rgbaColour.red) + toHex(rgbaColour.green) + toHex(rgbaColour.blue);\n      return hexColour(value);\n    };\n\n    const rgbRegex = /^\\s*rgb\\s*\\(\\s*(\\d+)\\s*[,\\s]\\s*(\\d+)\\s*[,\\s]\\s*(\\d+)\\s*\\)\\s*$/i;\n    const rgbaRegex = /^\\s*rgba\\s*\\(\\s*(\\d+)\\s*[,\\s]\\s*(\\d+)\\s*[,\\s]\\s*(\\d+)\\s*[,\\s]\\s*((?:\\d?\\.\\d+|\\d+)%?)\\s*\\)\\s*$/i;\n    const rgbaColour = (red, green, blue, alpha) => ({\n      red,\n      green,\n      blue,\n      alpha\n    });\n    const fromStringValues = (red, green, blue, alpha) => {\n      const r = parseInt(red, 10);\n      const g = parseInt(green, 10);\n      const b = parseInt(blue, 10);\n      const a = parseFloat(alpha);\n      return rgbaColour(r, g, b, a);\n    };\n    const getColorFormat = colorString => {\n      if (rgbRegex.test(colorString)) {\n        return 'rgb';\n      } else if (rgbaRegex.test(colorString)) {\n        return 'rgba';\n      }\n      return 'other';\n    };\n    const fromString = rgbaString => {\n      const rgbMatch = rgbRegex.exec(rgbaString);\n      if (rgbMatch !== null) {\n        return Optional.some(fromStringValues(rgbMatch[1], rgbMatch[2], rgbMatch[3], '1'));\n      }\n      const rgbaMatch = rgbaRegex.exec(rgbaString);\n      if (rgbaMatch !== null) {\n        return Optional.some(fromStringValues(rgbaMatch[1], rgbaMatch[2], rgbaMatch[3], rgbaMatch[4]));\n      }\n      return Optional.none();\n    };\n    const toString = rgba => `rgba(${ rgba.red },${ rgba.green },${ rgba.blue },${ rgba.alpha })`;\n\n    const rgbaToHexString = color => fromString(color).map(fromRgba).map(h => '#' + h.value).getOr(color);\n\n    const Styles = (settings = {}, schema) => {\n      const urlOrStrRegExp = /(?:url(?:(?:\\(\\s*\\\"([^\\\"]+)\\\"\\s*\\))|(?:\\(\\s*\\'([^\\']+)\\'\\s*\\))|(?:\\(\\s*([^)\\s]+)\\s*\\))))|(?:\\'([^\\']+)\\')|(?:\\\"([^\\\"]+)\\\")/gi;\n      const styleRegExp = /\\s*([^:]+):\\s*([^;]+);?/g;\n      const trimRightRegExp = /\\s+$/;\n      const encodingLookup = {};\n      let validStyles;\n      let invalidStyles;\n      const invisibleChar = zeroWidth;\n      if (schema) {\n        validStyles = schema.getValidStyles();\n        invalidStyles = schema.getInvalidStyles();\n      }\n      const encodingItems = (`\\\\\" \\\\' \\\\; \\\\: ; : ` + invisibleChar).split(' ');\n      for (let i = 0; i < encodingItems.length; i++) {\n        encodingLookup[encodingItems[i]] = invisibleChar + i;\n        encodingLookup[invisibleChar + i] = encodingItems[i];\n      }\n      const self = {\n        parse: css => {\n          const styles = {};\n          let isEncoded = false;\n          const urlConverter = settings.url_converter;\n          const urlConverterScope = settings.url_converter_scope || self;\n          const compress = (prefix, suffix, noJoin) => {\n            const top = styles[prefix + '-top' + suffix];\n            if (!top) {\n              return;\n            }\n            const right = styles[prefix + '-right' + suffix];\n            if (!right) {\n              return;\n            }\n            const bottom = styles[prefix + '-bottom' + suffix];\n            if (!bottom) {\n              return;\n            }\n            const left = styles[prefix + '-left' + suffix];\n            if (!left) {\n              return;\n            }\n            const box = [\n              top,\n              right,\n              bottom,\n              left\n            ];\n            let i = box.length - 1;\n            while (i--) {\n              if (box[i] !== box[i + 1]) {\n                break;\n              }\n            }\n            if (i > -1 && noJoin) {\n              return;\n            }\n            styles[prefix + suffix] = i === -1 ? box[0] : box.join(' ');\n            delete styles[prefix + '-top' + suffix];\n            delete styles[prefix + '-right' + suffix];\n            delete styles[prefix + '-bottom' + suffix];\n            delete styles[prefix + '-left' + suffix];\n          };\n          const canCompress = key => {\n            const value = styles[key];\n            if (!value) {\n              return;\n            }\n            const values = value.indexOf(',') > -1 ? [value] : value.split(' ');\n            let i = values.length;\n            while (i--) {\n              if (values[i] !== values[0]) {\n                return false;\n              }\n            }\n            styles[key] = values[0];\n            return true;\n          };\n          const compress2 = (target, a, b, c) => {\n            if (!canCompress(a)) {\n              return;\n            }\n            if (!canCompress(b)) {\n              return;\n            }\n            if (!canCompress(c)) {\n              return;\n            }\n            styles[target] = styles[a] + ' ' + styles[b] + ' ' + styles[c];\n            delete styles[a];\n            delete styles[b];\n            delete styles[c];\n          };\n          const encode = str => {\n            isEncoded = true;\n            return encodingLookup[str];\n          };\n          const decode = (str, keepSlashes) => {\n            if (isEncoded) {\n              str = str.replace(/\\uFEFF[0-9]/g, str => {\n                return encodingLookup[str];\n              });\n            }\n            if (!keepSlashes) {\n              str = str.replace(/\\\\([\\'\\\";:])/g, '$1');\n            }\n            return str;\n          };\n          const decodeSingleHexSequence = escSeq => {\n            return String.fromCharCode(parseInt(escSeq.slice(1), 16));\n          };\n          const decodeHexSequences = value => {\n            return value.replace(/\\\\[0-9a-f]+/gi, decodeSingleHexSequence);\n          };\n          const processUrl = (match, url, url2, url3, str, str2) => {\n            str = str || str2;\n            if (str) {\n              str = decode(str);\n              return `'` + str.replace(/\\'/g, `\\\\'`) + `'`;\n            }\n            url = decode(url || url2 || url3 || '');\n            if (!settings.allow_script_urls) {\n              const scriptUrl = url.replace(/[\\s\\r\\n]+/g, '');\n              if (/(java|vb)script:/i.test(scriptUrl)) {\n                return '';\n              }\n              if (!settings.allow_svg_data_urls && /^data:image\\/svg/i.test(scriptUrl)) {\n                return '';\n              }\n            }\n            if (urlConverter) {\n              url = urlConverter.call(urlConverterScope, url, 'style');\n            }\n            return `url('` + url.replace(/\\'/g, `\\\\'`) + `')`;\n          };\n          if (css) {\n            css = css.replace(/[\\u0000-\\u001F]/g, '');\n            css = css.replace(/\\\\[\\\"\\';:\\uFEFF]/g, encode).replace(/\\\"[^\\\"]+\\\"|\\'[^\\']+\\'/g, str => {\n              return str.replace(/[;:]/g, encode);\n            });\n            let matches;\n            while (matches = styleRegExp.exec(css)) {\n              styleRegExp.lastIndex = matches.index + matches[0].length;\n              let name = matches[1].replace(trimRightRegExp, '').toLowerCase();\n              let value = matches[2].replace(trimRightRegExp, '');\n              if (name && value) {\n                name = decodeHexSequences(name);\n                value = decodeHexSequences(value);\n                if (name.indexOf(invisibleChar) !== -1 || name.indexOf('\"') !== -1) {\n                  continue;\n                }\n                if (!settings.allow_script_urls && (name === 'behavior' || /expression\\s*\\(|\\/\\*|\\*\\//.test(value))) {\n                  continue;\n                }\n                if (name === 'font-weight' && value === '700') {\n                  value = 'bold';\n                } else if (name === 'color' || name === 'background-color') {\n                  value = value.toLowerCase();\n                }\n                if (getColorFormat(value) === 'rgb') {\n                  fromString(value).each(rgba => {\n                    value = rgbaToHexString(toString(rgba)).toLowerCase();\n                  });\n                }\n                value = value.replace(urlOrStrRegExp, processUrl);\n                styles[name] = isEncoded ? decode(value, true) : value;\n              }\n            }\n            compress('border', '', true);\n            compress('border', '-width');\n            compress('border', '-color');\n            compress('border', '-style');\n            compress('padding', '');\n            compress('margin', '');\n            compress2('border', 'border-width', 'border-style', 'border-color');\n            if (styles.border === 'medium none') {\n              delete styles.border;\n            }\n            if (styles['border-image'] === 'none') {\n              delete styles['border-image'];\n            }\n          }\n          return styles;\n        },\n        serialize: (styles, elementName) => {\n          let css = '';\n          const serializeStyles = (elemName, validStyleList) => {\n            const styleList = validStyleList[elemName];\n            if (styleList) {\n              for (let i = 0, l = styleList.length; i < l; i++) {\n                const name = styleList[i];\n                const value = styles[name];\n                if (value) {\n                  css += (css.length > 0 ? ' ' : '') + name + ': ' + value + ';';\n                }\n              }\n            }\n          };\n          const isValid = (name, elemName) => {\n            if (!invalidStyles || !elemName) {\n              return true;\n            }\n            let styleMap = invalidStyles['*'];\n            if (styleMap && styleMap[name]) {\n              return false;\n            }\n            styleMap = invalidStyles[elemName];\n            return !(styleMap && styleMap[name]);\n          };\n          if (elementName && validStyles) {\n            serializeStyles('*', validStyles);\n            serializeStyles(elementName, validStyles);\n          } else {\n            each$d(styles, (value, name) => {\n              if (value && isValid(name, elementName)) {\n                css += (css.length > 0 ? ' ' : '') + name + ': ' + value + ';';\n              }\n            });\n          }\n          return css;\n        }\n      };\n      return self;\n    };\n\n    const deprecated = {\n      keyLocation: true,\n      layerX: true,\n      layerY: true,\n      returnValue: true,\n      webkitMovementX: true,\n      webkitMovementY: true,\n      keyIdentifier: true,\n      mozPressure: true\n    };\n    const isNativeEvent = event => event instanceof Event || isFunction(event.initEvent);\n    const hasIsDefaultPrevented = event => event.isDefaultPrevented === always || event.isDefaultPrevented === never;\n    const needsNormalizing = event => isNullable(event.preventDefault) || isNativeEvent(event);\n    const clone$3 = (originalEvent, data) => {\n      const event = data !== null && data !== void 0 ? data : {};\n      for (const name in originalEvent) {\n        if (!has$2(deprecated, name)) {\n          event[name] = originalEvent[name];\n        }\n      }\n      if (isNonNullable(originalEvent.composedPath)) {\n        event.composedPath = () => originalEvent.composedPath();\n      }\n      if (isNonNullable(originalEvent.getModifierState)) {\n        event.getModifierState = keyArg => originalEvent.getModifierState(keyArg);\n      }\n      if (isNonNullable(originalEvent.getTargetRanges)) {\n        event.getTargetRanges = () => originalEvent.getTargetRanges();\n      }\n      return event;\n    };\n    const normalize$3 = (type, originalEvent, fallbackTarget, data) => {\n      var _a;\n      const event = clone$3(originalEvent, data);\n      event.type = type;\n      if (isNullable(event.target)) {\n        event.target = (_a = event.srcElement) !== null && _a !== void 0 ? _a : fallbackTarget;\n      }\n      if (needsNormalizing(originalEvent)) {\n        event.preventDefault = () => {\n          event.defaultPrevented = true;\n          event.isDefaultPrevented = always;\n          if (isFunction(originalEvent.preventDefault)) {\n            originalEvent.preventDefault();\n          }\n        };\n        event.stopPropagation = () => {\n          event.cancelBubble = true;\n          event.isPropagationStopped = always;\n          if (isFunction(originalEvent.stopPropagation)) {\n            originalEvent.stopPropagation();\n          }\n        };\n        event.stopImmediatePropagation = () => {\n          event.isImmediatePropagationStopped = always;\n          event.stopPropagation();\n        };\n        if (!hasIsDefaultPrevented(event)) {\n          event.isDefaultPrevented = event.defaultPrevented === true ? always : never;\n          event.isPropagationStopped = event.cancelBubble === true ? always : never;\n          event.isImmediatePropagationStopped = never;\n        }\n      }\n      return event;\n    };\n\n    const eventExpandoPrefix = 'mce-data-';\n    const mouseEventRe = /^(?:mouse|contextmenu)|click/;\n    const addEvent = (target, name, callback, capture) => {\n      target.addEventListener(name, callback, capture || false);\n    };\n    const removeEvent = (target, name, callback, capture) => {\n      target.removeEventListener(name, callback, capture || false);\n    };\n    const isMouseEvent = event => isNonNullable(event) && mouseEventRe.test(event.type);\n    const fix = (originalEvent, data) => {\n      const event = normalize$3(originalEvent.type, originalEvent, document, data);\n      if (isMouseEvent(originalEvent) && isUndefined(originalEvent.pageX) && !isUndefined(originalEvent.clientX)) {\n        const eventDoc = event.target.ownerDocument || document;\n        const doc = eventDoc.documentElement;\n        const body = eventDoc.body;\n        const mouseEvent = event;\n        mouseEvent.pageX = originalEvent.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);\n        mouseEvent.pageY = originalEvent.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);\n      }\n      return event;\n    };\n    const bindOnReady = (win, callback, eventUtils) => {\n      const doc = win.document, event = { type: 'ready' };\n      if (eventUtils.domLoaded) {\n        callback(event);\n        return;\n      }\n      const isDocReady = () => {\n        return doc.readyState === 'complete' || doc.readyState === 'interactive' && doc.body;\n      };\n      const readyHandler = () => {\n        removeEvent(win, 'DOMContentLoaded', readyHandler);\n        removeEvent(win, 'load', readyHandler);\n        if (!eventUtils.domLoaded) {\n          eventUtils.domLoaded = true;\n          callback(event);\n        }\n        win = null;\n      };\n      if (isDocReady()) {\n        readyHandler();\n      } else {\n        addEvent(win, 'DOMContentLoaded', readyHandler);\n      }\n      if (!eventUtils.domLoaded) {\n        addEvent(win, 'load', readyHandler);\n      }\n    };\n    class EventUtils {\n      constructor() {\n        this.domLoaded = false;\n        this.events = {};\n        this.count = 1;\n        this.expando = eventExpandoPrefix + (+new Date()).toString(32);\n        this.hasFocusIn = 'onfocusin' in document.documentElement;\n        this.count = 1;\n      }\n      bind(target, names, callback, scope) {\n        const self = this;\n        let callbackList;\n        const win = window;\n        const defaultNativeHandler = evt => {\n          self.executeHandlers(fix(evt || win.event), id);\n        };\n        if (!target || isText$b(target) || isComment(target)) {\n          return callback;\n        }\n        let id;\n        if (!target[self.expando]) {\n          id = self.count++;\n          target[self.expando] = id;\n          self.events[id] = {};\n        } else {\n          id = target[self.expando];\n        }\n        scope = scope || target;\n        const namesList = names.split(' ');\n        let i = namesList.length;\n        while (i--) {\n          let name = namesList[i];\n          let nativeHandler = defaultNativeHandler;\n          let capture = false;\n          let fakeName = false;\n          if (name === 'DOMContentLoaded') {\n            name = 'ready';\n          }\n          if (self.domLoaded && name === 'ready' && target.readyState === 'complete') {\n            callback.call(scope, fix({ type: name }));\n            continue;\n          }\n          if (!self.hasFocusIn && (name === 'focusin' || name === 'focusout')) {\n            capture = true;\n            fakeName = name === 'focusin' ? 'focus' : 'blur';\n            nativeHandler = evt => {\n              const event = fix(evt || win.event);\n              event.type = event.type === 'focus' ? 'focusin' : 'focusout';\n              self.executeHandlers(event, id);\n            };\n          }\n          callbackList = self.events[id][name];\n          if (!callbackList) {\n            self.events[id][name] = callbackList = [{\n                func: callback,\n                scope\n              }];\n            callbackList.fakeName = fakeName;\n            callbackList.capture = capture;\n            callbackList.nativeHandler = nativeHandler;\n            if (name === 'ready') {\n              bindOnReady(target, nativeHandler, self);\n            } else {\n              addEvent(target, fakeName || name, nativeHandler, capture);\n            }\n          } else {\n            if (name === 'ready' && self.domLoaded) {\n              callback(fix({ type: name }));\n            } else {\n              callbackList.push({\n                func: callback,\n                scope\n              });\n            }\n          }\n        }\n        target = callbackList = null;\n        return callback;\n      }\n      unbind(target, names, callback) {\n        if (!target || isText$b(target) || isComment(target)) {\n          return this;\n        }\n        const id = target[this.expando];\n        if (id) {\n          let eventMap = this.events[id];\n          if (names) {\n            const namesList = names.split(' ');\n            let i = namesList.length;\n            while (i--) {\n              const name = namesList[i];\n              const callbackList = eventMap[name];\n              if (callbackList) {\n                if (callback) {\n                  let ci = callbackList.length;\n                  while (ci--) {\n                    if (callbackList[ci].func === callback) {\n                      const nativeHandler = callbackList.nativeHandler;\n                      const fakeName = callbackList.fakeName, capture = callbackList.capture;\n                      const newCallbackList = callbackList.slice(0, ci).concat(callbackList.slice(ci + 1));\n                      newCallbackList.nativeHandler = nativeHandler;\n                      newCallbackList.fakeName = fakeName;\n                      newCallbackList.capture = capture;\n                      eventMap[name] = newCallbackList;\n                    }\n                  }\n                }\n                if (!callback || callbackList.length === 0) {\n                  delete eventMap[name];\n                  removeEvent(target, callbackList.fakeName || name, callbackList.nativeHandler, callbackList.capture);\n                }\n              }\n            }\n          } else {\n            each$d(eventMap, (callbackList, name) => {\n              removeEvent(target, callbackList.fakeName || name, callbackList.nativeHandler, callbackList.capture);\n            });\n            eventMap = {};\n          }\n          for (const name in eventMap) {\n            if (has$2(eventMap, name)) {\n              return this;\n            }\n          }\n          delete this.events[id];\n          try {\n            delete target[this.expando];\n          } catch (ex) {\n            target[this.expando] = null;\n          }\n        }\n        return this;\n      }\n      fire(target, name, args) {\n        return this.dispatch(target, name, args);\n      }\n      dispatch(target, name, args) {\n        if (!target || isText$b(target) || isComment(target)) {\n          return this;\n        }\n        const event = fix({\n          type: name,\n          target\n        }, args);\n        do {\n          const id = target[this.expando];\n          if (id) {\n            this.executeHandlers(event, id);\n          }\n          target = target.parentNode || target.ownerDocument || target.defaultView || target.parentWindow;\n        } while (target && !event.isPropagationStopped());\n        return this;\n      }\n      clean(target) {\n        if (!target || isText$b(target) || isComment(target)) {\n          return this;\n        }\n        if (target[this.expando]) {\n          this.unbind(target);\n        }\n        if (!target.getElementsByTagName) {\n          target = target.document;\n        }\n        if (target && target.getElementsByTagName) {\n          this.unbind(target);\n          const children = target.getElementsByTagName('*');\n          let i = children.length;\n          while (i--) {\n            target = children[i];\n            if (target[this.expando]) {\n              this.unbind(target);\n            }\n          }\n        }\n        return this;\n      }\n      destroy() {\n        this.events = {};\n      }\n      cancel(e) {\n        if (e) {\n          e.preventDefault();\n          e.stopImmediatePropagation();\n        }\n        return false;\n      }\n      executeHandlers(evt, id) {\n        const container = this.events[id];\n        const callbackList = container && container[evt.type];\n        if (callbackList) {\n          for (let i = 0, l = callbackList.length; i < l; i++) {\n            const callback = callbackList[i];\n            if (callback && callback.func.call(callback.scope, evt) === false) {\n              evt.preventDefault();\n            }\n            if (evt.isImmediatePropagationStopped()) {\n              return;\n            }\n          }\n        }\n      }\n    }\n    EventUtils.Event = new EventUtils();\n\n    const each$a = Tools.each;\n    const grep = Tools.grep;\n    const internalStyleName = 'data-mce-style';\n    const numericalCssMap = Tools.makeMap('fill-opacity font-weight line-height opacity orphans widows z-index zoom', ' ');\n    const legacySetAttribute = (elm, name, value) => {\n      if (isNullable(value) || value === '') {\n        remove$9(elm, name);\n      } else {\n        set$3(elm, name, value);\n      }\n    };\n    const camelCaseToHyphens = name => name.replace(/[A-Z]/g, v => '-' + v.toLowerCase());\n    const findNodeIndex = (node, normalized) => {\n      let idx = 0;\n      if (node) {\n        for (let lastNodeType = node.nodeType, tempNode = node.previousSibling; tempNode; tempNode = tempNode.previousSibling) {\n          const nodeType = tempNode.nodeType;\n          if (normalized && isText$b(tempNode)) {\n            if (nodeType === lastNodeType || !tempNode.data.length) {\n              continue;\n            }\n          }\n          idx++;\n          lastNodeType = nodeType;\n        }\n      }\n      return idx;\n    };\n    const updateInternalStyleAttr = (styles, elm) => {\n      const rawValue = get$9(elm, 'style');\n      const value = styles.serialize(styles.parse(rawValue), name(elm));\n      legacySetAttribute(elm, internalStyleName, value);\n    };\n    const convertStyleToString = (cssValue, cssName) => {\n      if (isNumber(cssValue)) {\n        return has$2(numericalCssMap, cssName) ? cssValue + '' : cssValue + 'px';\n      } else {\n        return cssValue;\n      }\n    };\n    const applyStyle$1 = ($elm, cssName, cssValue) => {\n      const normalizedName = camelCaseToHyphens(cssName);\n      if (isNullable(cssValue) || cssValue === '') {\n        remove$5($elm, normalizedName);\n      } else {\n        set$2($elm, normalizedName, convertStyleToString(cssValue, normalizedName));\n      }\n    };\n    const setupAttrHooks = (styles, settings, getContext) => {\n      const keepValues = settings.keep_values;\n      const keepUrlHook = {\n        set: (elm, value, name) => {\n          const sugarElm = SugarElement.fromDom(elm);\n          if (isFunction(settings.url_converter) && isNonNullable(value)) {\n            value = settings.url_converter.call(settings.url_converter_scope || getContext(), String(value), name, elm);\n          }\n          const internalName = 'data-mce-' + name;\n          legacySetAttribute(sugarElm, internalName, value);\n          legacySetAttribute(sugarElm, name, value);\n        },\n        get: (elm, name) => {\n          const sugarElm = SugarElement.fromDom(elm);\n          return get$9(sugarElm, 'data-mce-' + name) || get$9(sugarElm, name);\n        }\n      };\n      const attrHooks = {\n        style: {\n          set: (elm, value) => {\n            const sugarElm = SugarElement.fromDom(elm);\n            if (keepValues) {\n              legacySetAttribute(sugarElm, internalStyleName, value);\n            }\n            remove$9(sugarElm, 'style');\n            if (isString(value)) {\n              setAll(sugarElm, styles.parse(value));\n            }\n          },\n          get: elm => {\n            const sugarElm = SugarElement.fromDom(elm);\n            const value = get$9(sugarElm, internalStyleName) || get$9(sugarElm, 'style');\n            return styles.serialize(styles.parse(value), name(sugarElm));\n          }\n        }\n      };\n      if (keepValues) {\n        attrHooks.href = attrHooks.src = keepUrlHook;\n      }\n      return attrHooks;\n    };\n    const DOMUtils = (doc, settings = {}) => {\n      const addedStyles = {};\n      const win = window;\n      const files = {};\n      let counter = 0;\n      const stdMode = true;\n      const boxModel = true;\n      const styleSheetLoader = instance.forElement(SugarElement.fromDom(doc), {\n        contentCssCors: settings.contentCssCors,\n        referrerPolicy: settings.referrerPolicy\n      });\n      const boundEvents = [];\n      const schema = settings.schema ? settings.schema : Schema({});\n      const styles = Styles({\n        url_converter: settings.url_converter,\n        url_converter_scope: settings.url_converter_scope\n      }, settings.schema);\n      const events = settings.ownEvents ? new EventUtils() : EventUtils.Event;\n      const blockElementsMap = schema.getBlockElements();\n      const isBlock = node => {\n        if (isString(node)) {\n          return has$2(blockElementsMap, node);\n        } else {\n          return isElement$6(node) && (has$2(blockElementsMap, node.nodeName) || isTransparentBlock(schema, node));\n        }\n      };\n      const get = elm => elm && doc && isString(elm) ? doc.getElementById(elm) : elm;\n      const _get = elm => {\n        const value = get(elm);\n        return isNonNullable(value) ? SugarElement.fromDom(value) : null;\n      };\n      const getAttrib = (elm, name, defaultVal = '') => {\n        let value;\n        const $elm = _get(elm);\n        if (isNonNullable($elm) && isElement$7($elm)) {\n          const hook = attrHooks[name];\n          if (hook && hook.get) {\n            value = hook.get($elm.dom, name);\n          } else {\n            value = get$9($elm, name);\n          }\n        }\n        return isNonNullable(value) ? value : defaultVal;\n      };\n      const getAttribs = elm => {\n        const node = get(elm);\n        return isNullable(node) ? [] : node.attributes;\n      };\n      const setAttrib = (elm, name, value) => {\n        run(elm, e => {\n          if (isElement$6(e)) {\n            const $elm = SugarElement.fromDom(e);\n            const val = value === '' ? null : value;\n            const originalValue = get$9($elm, name);\n            const hook = attrHooks[name];\n            if (hook && hook.set) {\n              hook.set($elm.dom, val, name);\n            } else {\n              legacySetAttribute($elm, name, val);\n            }\n            if (originalValue !== val && settings.onSetAttrib) {\n              settings.onSetAttrib({\n                attrElm: $elm.dom,\n                attrName: name,\n                attrValue: val\n              });\n            }\n          }\n        });\n      };\n      const clone = (node, deep) => {\n        return node.cloneNode(deep);\n      };\n      const getRoot = () => settings.root_element || doc.body;\n      const getViewPort = argWin => {\n        const vp = getBounds(argWin);\n        return {\n          x: vp.x,\n          y: vp.y,\n          w: vp.width,\n          h: vp.height\n        };\n      };\n      const getPos$1 = (elm, rootElm) => getPos(doc.body, get(elm), rootElm);\n      const setStyle = (elm, name, value) => {\n        run(elm, e => {\n          const $elm = SugarElement.fromDom(e);\n          applyStyle$1($elm, name, value);\n          if (settings.update_styles) {\n            updateInternalStyleAttr(styles, $elm);\n          }\n        });\n      };\n      const setStyles = (elm, stylesArg) => {\n        run(elm, e => {\n          const $elm = SugarElement.fromDom(e);\n          each$d(stylesArg, (v, n) => {\n            applyStyle$1($elm, n, v);\n          });\n          if (settings.update_styles) {\n            updateInternalStyleAttr(styles, $elm);\n          }\n        });\n      };\n      const getStyle = (elm, name, computed) => {\n        const $elm = get(elm);\n        if (isNullable($elm) || !isHTMLElement($elm) && !isSVGElement($elm)) {\n          return undefined;\n        }\n        if (computed) {\n          return get$7(SugarElement.fromDom($elm), camelCaseToHyphens(name));\n        } else {\n          name = name.replace(/-(\\D)/g, (a, b) => b.toUpperCase());\n          if (name === 'float') {\n            name = 'cssFloat';\n          }\n          return $elm.style ? $elm.style[name] : undefined;\n        }\n      };\n      const getSize = elm => {\n        const $elm = get(elm);\n        if (!$elm) {\n          return {\n            w: 0,\n            h: 0\n          };\n        }\n        let w = getStyle($elm, 'width');\n        let h = getStyle($elm, 'height');\n        if (!w || w.indexOf('px') === -1) {\n          w = '0';\n        }\n        if (!h || h.indexOf('px') === -1) {\n          h = '0';\n        }\n        return {\n          w: parseInt(w, 10) || $elm.offsetWidth || $elm.clientWidth,\n          h: parseInt(h, 10) || $elm.offsetHeight || $elm.clientHeight\n        };\n      };\n      const getRect = elm => {\n        const $elm = get(elm);\n        const pos = getPos$1($elm);\n        const size = getSize($elm);\n        return {\n          x: pos.x,\n          y: pos.y,\n          w: size.w,\n          h: size.h\n        };\n      };\n      const is = (elm, selector) => {\n        if (!elm) {\n          return false;\n        }\n        const elms = isArray$1(elm) ? elm : [elm];\n        return exists(elms, e => {\n          return is$1(SugarElement.fromDom(e), selector);\n        });\n      };\n      const getParents = (elm, selector, root, collect) => {\n        const result = [];\n        let node = get(elm);\n        collect = collect === undefined;\n        const resolvedRoot = root || (getRoot().nodeName !== 'BODY' ? getRoot().parentNode : null);\n        if (isString(selector)) {\n          if (selector === '*') {\n            selector = isElement$6;\n          } else {\n            const selectorVal = selector;\n            selector = node => is(node, selectorVal);\n          }\n        }\n        while (node) {\n          if (node === resolvedRoot || isNullable(node.nodeType) || isDocument$1(node) || isDocumentFragment(node)) {\n            break;\n          }\n          if (!selector || selector(node)) {\n            if (collect) {\n              result.push(node);\n            } else {\n              return [node];\n            }\n          }\n          node = node.parentNode;\n        }\n        return collect ? result : null;\n      };\n      const getParent = (node, selector, root) => {\n        const parents = getParents(node, selector, root, false);\n        return parents && parents.length > 0 ? parents[0] : null;\n      };\n      const _findSib = (node, selector, name) => {\n        let func = selector;\n        if (node) {\n          if (isString(selector)) {\n            func = node => {\n              return is(node, selector);\n            };\n          }\n          for (let tempNode = node[name]; tempNode; tempNode = tempNode[name]) {\n            if (isFunction(func) && func(tempNode)) {\n              return tempNode;\n            }\n          }\n        }\n        return null;\n      };\n      const getNext = (node, selector) => _findSib(node, selector, 'nextSibling');\n      const getPrev = (node, selector) => _findSib(node, selector, 'previousSibling');\n      const isParentNode = node => isFunction(node.querySelectorAll);\n      const select = (selector, scope) => {\n        var _a, _b;\n        const elm = (_b = (_a = get(scope)) !== null && _a !== void 0 ? _a : settings.root_element) !== null && _b !== void 0 ? _b : doc;\n        return isParentNode(elm) ? from(elm.querySelectorAll(selector)) : [];\n      };\n      const run = function (elm, func, scope) {\n        const context = scope !== null && scope !== void 0 ? scope : this;\n        if (isArray$1(elm)) {\n          const result = [];\n          each$a(elm, (e, i) => {\n            const node = get(e);\n            if (node) {\n              result.push(func.call(context, node, i));\n            }\n          });\n          return result;\n        } else {\n          const node = get(elm);\n          return !node ? false : func.call(context, node);\n        }\n      };\n      const setAttribs = (elm, attrs) => {\n        run(elm, $elm => {\n          each$d(attrs, (value, name) => {\n            setAttrib($elm, name, value);\n          });\n        });\n      };\n      const setHTML = (elm, html) => {\n        run(elm, e => {\n          const $elm = SugarElement.fromDom(e);\n          set$1($elm, html);\n        });\n      };\n      const add = (parentElm, name, attrs, html, create) => run(parentElm, parentElm => {\n        const newElm = isString(name) ? doc.createElement(name) : name;\n        if (isNonNullable(attrs)) {\n          setAttribs(newElm, attrs);\n        }\n        if (html) {\n          if (!isString(html) && html.nodeType) {\n            newElm.appendChild(html);\n          } else if (isString(html)) {\n            setHTML(newElm, html);\n          }\n        }\n        return !create ? parentElm.appendChild(newElm) : newElm;\n      });\n      const create = (name, attrs, html) => add(doc.createElement(name), name, attrs, html, true);\n      const decode = Entities.decode;\n      const encode = Entities.encodeAllRaw;\n      const createHTML = (name, attrs, html = '') => {\n        let outHtml = '<' + name;\n        for (const key in attrs) {\n          if (hasNonNullableKey(attrs, key)) {\n            outHtml += ' ' + key + '=\"' + encode(attrs[key]) + '\"';\n          }\n        }\n        if (isEmpty$3(html) && has$2(schema.getVoidElements(), name)) {\n          return outHtml + ' />';\n        } else {\n          return outHtml + '>' + html + '</' + name + '>';\n        }\n      };\n      const createFragment = html => {\n        const container = doc.createElement('div');\n        const frag = doc.createDocumentFragment();\n        frag.appendChild(container);\n        if (html) {\n          container.innerHTML = html;\n        }\n        let node;\n        while (node = container.firstChild) {\n          frag.appendChild(node);\n        }\n        frag.removeChild(container);\n        return frag;\n      };\n      const remove = (node, keepChildren) => {\n        return run(node, n => {\n          const $node = SugarElement.fromDom(n);\n          if (keepChildren) {\n            each$e(children$1($node), child => {\n              if (isText$c(child) && child.dom.length === 0) {\n                remove$4(child);\n              } else {\n                before$3($node, child);\n              }\n            });\n          }\n          remove$4($node);\n          return $node.dom;\n        });\n      };\n      const removeAllAttribs = e => run(e, e => {\n        const attrs = e.attributes;\n        for (let i = attrs.length - 1; i >= 0; i--) {\n          e.removeAttributeNode(attrs.item(i));\n        }\n      });\n      const parseStyle = cssText => styles.parse(cssText);\n      const serializeStyle = (stylesArg, name) => styles.serialize(stylesArg, name);\n      const addStyle = cssText => {\n        if (self !== DOMUtils.DOM && doc === document) {\n          if (addedStyles[cssText]) {\n            return;\n          }\n          addedStyles[cssText] = true;\n        }\n        let styleElm = doc.getElementById('mceDefaultStyles');\n        if (!styleElm) {\n          styleElm = doc.createElement('style');\n          styleElm.id = 'mceDefaultStyles';\n          styleElm.type = 'text/css';\n          const head = doc.head;\n          if (head.firstChild) {\n            head.insertBefore(styleElm, head.firstChild);\n          } else {\n            head.appendChild(styleElm);\n          }\n        }\n        if (styleElm.styleSheet) {\n          styleElm.styleSheet.cssText += cssText;\n        } else {\n          styleElm.appendChild(doc.createTextNode(cssText));\n        }\n      };\n      const loadCSS = urls => {\n        if (!urls) {\n          urls = '';\n        }\n        each$e(urls.split(','), url => {\n          files[url] = true;\n          styleSheetLoader.load(url).catch(noop);\n        });\n      };\n      const toggleClass = (elm, cls, state) => {\n        run(elm, e => {\n          if (isElement$6(e)) {\n            const $elm = SugarElement.fromDom(e);\n            const classes = cls.split(' ');\n            each$e(classes, c => {\n              if (isNonNullable(state)) {\n                const fn = state ? add$2 : remove$6;\n                fn($elm, c);\n              } else {\n                toggle$1($elm, c);\n              }\n            });\n          }\n        });\n      };\n      const addClass = (elm, cls) => {\n        toggleClass(elm, cls, true);\n      };\n      const removeClass = (elm, cls) => {\n        toggleClass(elm, cls, false);\n      };\n      const hasClass = (elm, cls) => {\n        const $elm = _get(elm);\n        const classes = cls.split(' ');\n        return isNonNullable($elm) && forall(classes, c => has($elm, c));\n      };\n      const show = elm => {\n        run(elm, e => remove$5(SugarElement.fromDom(e), 'display'));\n      };\n      const hide = elm => {\n        run(elm, e => set$2(SugarElement.fromDom(e), 'display', 'none'));\n      };\n      const isHidden = elm => {\n        const $elm = _get(elm);\n        return isNonNullable($elm) && is$2(getRaw($elm, 'display'), 'none');\n      };\n      const uniqueId = prefix => (!prefix ? 'mce_' : prefix) + counter++;\n      const getOuterHTML = elm => {\n        const $elm = _get(elm);\n        if (isNonNullable($elm)) {\n          return isElement$6($elm.dom) ? $elm.dom.outerHTML : getOuter($elm);\n        } else {\n          return '';\n        }\n      };\n      const setOuterHTML = (elm, html) => {\n        run(elm, $elm => {\n          if (isElement$6($elm)) {\n            $elm.outerHTML = html;\n          }\n        });\n      };\n      const insertAfter = (node, reference) => {\n        const referenceNode = get(reference);\n        return run(node, node => {\n          const parent = referenceNode === null || referenceNode === void 0 ? void 0 : referenceNode.parentNode;\n          const nextSibling = referenceNode === null || referenceNode === void 0 ? void 0 : referenceNode.nextSibling;\n          if (parent) {\n            if (nextSibling) {\n              parent.insertBefore(node, nextSibling);\n            } else {\n              parent.appendChild(node);\n            }\n          }\n          return node;\n        });\n      };\n      const replace = (newElm, oldElm, keepChildren) => run(oldElm, elm => {\n        var _a;\n        const replacee = isArray$1(oldElm) ? newElm.cloneNode(true) : newElm;\n        if (keepChildren) {\n          each$a(grep(elm.childNodes), node => {\n            replacee.appendChild(node);\n          });\n        }\n        (_a = elm.parentNode) === null || _a === void 0 ? void 0 : _a.replaceChild(replacee, elm);\n        return elm;\n      });\n      const rename = (elm, name) => {\n        if (elm.nodeName !== name.toUpperCase()) {\n          const newElm = create(name);\n          each$a(getAttribs(elm), attrNode => {\n            setAttrib(newElm, attrNode.nodeName, getAttrib(elm, attrNode.nodeName));\n          });\n          replace(newElm, elm, true);\n          return newElm;\n        } else {\n          return elm;\n        }\n      };\n      const findCommonAncestor = (a, b) => {\n        let ps = a;\n        while (ps) {\n          let pe = b;\n          while (pe && ps !== pe) {\n            pe = pe.parentNode;\n          }\n          if (ps === pe) {\n            break;\n          }\n          ps = ps.parentNode;\n        }\n        if (!ps && a.ownerDocument) {\n          return a.ownerDocument.documentElement;\n        } else {\n          return ps;\n        }\n      };\n      const isEmpty = (node, elements, options) => {\n        if (isPlainObject(elements)) {\n          const isContent = node => {\n            const name = node.nodeName.toLowerCase();\n            return Boolean(elements[name]);\n          };\n          return isEmptyNode(schema, node, {\n            ...options,\n            isContent\n          });\n        } else {\n          return isEmptyNode(schema, node, options);\n        }\n      };\n      const createRng = () => doc.createRange();\n      const split = (parentElm, splitElm, replacementElm) => {\n        let range = createRng();\n        let beforeFragment;\n        let afterFragment;\n        if (parentElm && splitElm && parentElm.parentNode && splitElm.parentNode) {\n          const parentNode = parentElm.parentNode;\n          range.setStart(parentNode, findNodeIndex(parentElm));\n          range.setEnd(splitElm.parentNode, findNodeIndex(splitElm));\n          beforeFragment = range.extractContents();\n          range = createRng();\n          range.setStart(splitElm.parentNode, findNodeIndex(splitElm) + 1);\n          range.setEnd(parentNode, findNodeIndex(parentElm) + 1);\n          afterFragment = range.extractContents();\n          parentNode.insertBefore(trimNode(self, beforeFragment, schema), parentElm);\n          if (replacementElm) {\n            parentNode.insertBefore(replacementElm, parentElm);\n          } else {\n            parentNode.insertBefore(splitElm, parentElm);\n          }\n          parentNode.insertBefore(trimNode(self, afterFragment, schema), parentElm);\n          remove(parentElm);\n          return replacementElm || splitElm;\n        } else {\n          return undefined;\n        }\n      };\n      const bind = (target, name, func, scope) => {\n        if (isArray$1(target)) {\n          let i = target.length;\n          const rv = [];\n          while (i--) {\n            rv[i] = bind(target[i], name, func, scope);\n          }\n          return rv;\n        } else {\n          if (settings.collect && (target === doc || target === win)) {\n            boundEvents.push([\n              target,\n              name,\n              func,\n              scope\n            ]);\n          }\n          return events.bind(target, name, func, scope || self);\n        }\n      };\n      const unbind = (target, name, func) => {\n        if (isArray$1(target)) {\n          let i = target.length;\n          const rv = [];\n          while (i--) {\n            rv[i] = unbind(target[i], name, func);\n          }\n          return rv;\n        } else {\n          if (boundEvents.length > 0 && (target === doc || target === win)) {\n            let i = boundEvents.length;\n            while (i--) {\n              const [boundTarget, boundName, boundFunc] = boundEvents[i];\n              if (target === boundTarget && (!name || name === boundName) && (!func || func === boundFunc)) {\n                events.unbind(boundTarget, boundName, boundFunc);\n              }\n            }\n          }\n          return events.unbind(target, name, func);\n        }\n      };\n      const dispatch = (target, name, evt) => events.dispatch(target, name, evt);\n      const fire = (target, name, evt) => events.dispatch(target, name, evt);\n      const getContentEditable = node => {\n        if (node && isHTMLElement(node)) {\n          const contentEditable = node.getAttribute('data-mce-contenteditable');\n          if (contentEditable && contentEditable !== 'inherit') {\n            return contentEditable;\n          }\n          return node.contentEditable !== 'inherit' ? node.contentEditable : null;\n        } else {\n          return null;\n        }\n      };\n      const getContentEditableParent = node => {\n        const root = getRoot();\n        let state = null;\n        for (let tempNode = node; tempNode && tempNode !== root; tempNode = tempNode.parentNode) {\n          state = getContentEditable(tempNode);\n          if (state !== null) {\n            break;\n          }\n        }\n        return state;\n      };\n      const isEditable = node => {\n        if (isNonNullable(node)) {\n          const scope = isElement$6(node) ? node : node.parentElement;\n          return isNonNullable(scope) && isHTMLElement(scope) && isEditable$2(SugarElement.fromDom(scope));\n        } else {\n          return false;\n        }\n      };\n      const destroy = () => {\n        if (boundEvents.length > 0) {\n          let i = boundEvents.length;\n          while (i--) {\n            const [boundTarget, boundName, boundFunc] = boundEvents[i];\n            events.unbind(boundTarget, boundName, boundFunc);\n          }\n        }\n        each$d(files, (_, url) => {\n          styleSheetLoader.unload(url);\n          delete files[url];\n        });\n      };\n      const isChildOf = (node, parent) => {\n        return node === parent || parent.contains(node);\n      };\n      const dumpRng = r => 'startContainer: ' + r.startContainer.nodeName + ', startOffset: ' + r.startOffset + ', endContainer: ' + r.endContainer.nodeName + ', endOffset: ' + r.endOffset;\n      const self = {\n        doc,\n        settings,\n        win,\n        files,\n        stdMode,\n        boxModel,\n        styleSheetLoader,\n        boundEvents,\n        styles,\n        schema,\n        events,\n        isBlock: isBlock,\n        root: null,\n        clone,\n        getRoot,\n        getViewPort,\n        getRect,\n        getSize,\n        getParent,\n        getParents: getParents,\n        get,\n        getNext,\n        getPrev,\n        select,\n        is,\n        add,\n        create,\n        createHTML,\n        createFragment,\n        remove,\n        setStyle,\n        getStyle: getStyle,\n        setStyles,\n        removeAllAttribs,\n        setAttrib,\n        setAttribs,\n        getAttrib,\n        getPos: getPos$1,\n        parseStyle,\n        serializeStyle,\n        addStyle,\n        loadCSS,\n        addClass,\n        removeClass,\n        hasClass,\n        toggleClass,\n        show,\n        hide,\n        isHidden,\n        uniqueId,\n        setHTML,\n        getOuterHTML,\n        setOuterHTML,\n        decode,\n        encode,\n        insertAfter,\n        replace,\n        rename,\n        findCommonAncestor,\n        run,\n        getAttribs,\n        isEmpty,\n        createRng,\n        nodeIndex: findNodeIndex,\n        split,\n        bind: bind,\n        unbind: unbind,\n        fire,\n        dispatch,\n        getContentEditable,\n        getContentEditableParent,\n        isEditable,\n        destroy,\n        isChildOf,\n        dumpRng\n      };\n      const attrHooks = setupAttrHooks(styles, settings, constant(self));\n      return self;\n    };\n    DOMUtils.DOM = DOMUtils(document);\n    DOMUtils.nodeIndex = findNodeIndex;\n\n    const DOM$b = DOMUtils.DOM;\n    const QUEUED = 0;\n    const LOADING = 1;\n    const LOADED = 2;\n    const FAILED = 3;\n    class ScriptLoader {\n      constructor(settings = {}) {\n        this.states = {};\n        this.queue = [];\n        this.scriptLoadedCallbacks = {};\n        this.queueLoadedCallbacks = [];\n        this.loading = false;\n        this.settings = settings;\n      }\n      _setReferrerPolicy(referrerPolicy) {\n        this.settings.referrerPolicy = referrerPolicy;\n      }\n      loadScript(url) {\n        return new Promise((resolve, reject) => {\n          const dom = DOM$b;\n          let elm;\n          const cleanup = () => {\n            dom.remove(id);\n            if (elm) {\n              elm.onerror = elm.onload = elm = null;\n            }\n          };\n          const done = () => {\n            cleanup();\n            resolve();\n          };\n          const error = () => {\n            cleanup();\n            reject('Failed to load script: ' + url);\n          };\n          const id = dom.uniqueId();\n          elm = document.createElement('script');\n          elm.id = id;\n          elm.type = 'text/javascript';\n          elm.src = Tools._addCacheSuffix(url);\n          if (this.settings.referrerPolicy) {\n            dom.setAttrib(elm, 'referrerpolicy', this.settings.referrerPolicy);\n          }\n          elm.onload = done;\n          elm.onerror = error;\n          (document.getElementsByTagName('head')[0] || document.body).appendChild(elm);\n        });\n      }\n      isDone(url) {\n        return this.states[url] === LOADED;\n      }\n      markDone(url) {\n        this.states[url] = LOADED;\n      }\n      add(url) {\n        const self = this;\n        self.queue.push(url);\n        const state = self.states[url];\n        if (state === undefined) {\n          self.states[url] = QUEUED;\n        }\n        return new Promise((resolve, reject) => {\n          if (!self.scriptLoadedCallbacks[url]) {\n            self.scriptLoadedCallbacks[url] = [];\n          }\n          self.scriptLoadedCallbacks[url].push({\n            resolve,\n            reject\n          });\n        });\n      }\n      load(url) {\n        return this.add(url);\n      }\n      remove(url) {\n        delete this.states[url];\n        delete this.scriptLoadedCallbacks[url];\n      }\n      loadQueue() {\n        const queue = this.queue;\n        this.queue = [];\n        return this.loadScripts(queue);\n      }\n      loadScripts(scripts) {\n        const self = this;\n        const execCallbacks = (name, url) => {\n          get$a(self.scriptLoadedCallbacks, url).each(callbacks => {\n            each$e(callbacks, callback => callback[name](url));\n          });\n          delete self.scriptLoadedCallbacks[url];\n        };\n        const processResults = results => {\n          const failures = filter$5(results, result => result.status === 'rejected');\n          if (failures.length > 0) {\n            return Promise.reject(bind$3(failures, ({reason}) => isArray$1(reason) ? reason : [reason]));\n          } else {\n            return Promise.resolve();\n          }\n        };\n        const load = urls => Promise.allSettled(map$3(urls, url => {\n          if (self.states[url] === LOADED) {\n            execCallbacks('resolve', url);\n            return Promise.resolve();\n          } else if (self.states[url] === FAILED) {\n            execCallbacks('reject', url);\n            return Promise.reject(url);\n          } else {\n            self.states[url] = LOADING;\n            return self.loadScript(url).then(() => {\n              self.states[url] = LOADED;\n              execCallbacks('resolve', url);\n              const queue = self.queue;\n              if (queue.length > 0) {\n                self.queue = [];\n                return load(queue).then(processResults);\n              } else {\n                return Promise.resolve();\n              }\n            }, () => {\n              self.states[url] = FAILED;\n              execCallbacks('reject', url);\n              return Promise.reject(url);\n            });\n          }\n        }));\n        const processQueue = urls => {\n          self.loading = true;\n          return load(urls).then(results => {\n            self.loading = false;\n            const nextQueuedItem = self.queueLoadedCallbacks.shift();\n            Optional.from(nextQueuedItem).each(call);\n            return processResults(results);\n          });\n        };\n        const uniqueScripts = stringArray(scripts);\n        if (self.loading) {\n          return new Promise((resolve, reject) => {\n            self.queueLoadedCallbacks.push(() => {\n              processQueue(uniqueScripts).then(resolve, reject);\n            });\n          });\n        } else {\n          return processQueue(uniqueScripts);\n        }\n      }\n    }\n    ScriptLoader.ScriptLoader = new ScriptLoader();\n\n    const isDuplicated = (items, item) => {\n      const firstIndex = items.indexOf(item);\n      return firstIndex !== -1 && items.indexOf(item, firstIndex + 1) > firstIndex;\n    };\n    const isRaw = str => isObject(str) && has$2(str, 'raw');\n    const isTokenised = str => isArray$1(str) && str.length > 1;\n    const data = {};\n    const currentCode = Cell('en');\n    const getLanguageData = () => get$a(data, currentCode.get());\n    const getData$1 = () => map$2(data, value => ({ ...value }));\n    const setCode = newCode => {\n      if (newCode) {\n        currentCode.set(newCode);\n      }\n    };\n    const getCode = () => currentCode.get();\n    const add$1 = (code, items) => {\n      let langData = data[code];\n      if (!langData) {\n        data[code] = langData = {};\n      }\n      const lcNames = map$3(keys(items), name => name.toLowerCase());\n      each$d(items, (translation, name) => {\n        const lcName = name.toLowerCase();\n        if (lcName !== name && isDuplicated(lcNames, lcName)) {\n          if (!has$2(items, lcName)) {\n            langData[lcName] = translation;\n          }\n          langData[name] = translation;\n        } else {\n          langData[lcName] = translation;\n        }\n      });\n    };\n    const translate = text => {\n      const langData = getLanguageData().getOr({});\n      const toString = obj => {\n        if (isFunction(obj)) {\n          return Object.prototype.toString.call(obj);\n        }\n        return !isEmpty(obj) ? '' + obj : '';\n      };\n      const isEmpty = text => text === '' || text === null || text === undefined;\n      const getLangData = text => {\n        const textStr = toString(text);\n        return has$2(langData, textStr) ? toString(langData[textStr]) : get$a(langData, textStr.toLowerCase()).map(toString).getOr(textStr);\n      };\n      const removeContext = str => str.replace(/{context:\\w+}$/, '');\n      if (isEmpty(text)) {\n        return '';\n      }\n      if (isRaw(text)) {\n        return toString(text.raw);\n      }\n      if (isTokenised(text)) {\n        const values = text.slice(1);\n        const substitued = getLangData(text[0]).replace(/\\{([0-9]+)\\}/g, ($1, $2) => has$2(values, $2) ? toString(values[$2]) : $1);\n        return removeContext(substitued);\n      }\n      return removeContext(getLangData(text));\n    };\n    const isRtl$1 = () => getLanguageData().bind(items => get$a(items, '_dir')).exists(dir => dir === 'rtl');\n    const hasCode = code => has$2(data, code);\n    const I18n = {\n      getData: getData$1,\n      setCode,\n      getCode,\n      add: add$1,\n      translate,\n      isRtl: isRtl$1,\n      hasCode\n    };\n\n    const AddOnManager = () => {\n      const items = [];\n      const urls = {};\n      const lookup = {};\n      const _listeners = [];\n      const runListeners = (name, state) => {\n        const matchedListeners = filter$5(_listeners, listener => listener.name === name && listener.state === state);\n        each$e(matchedListeners, listener => listener.resolve());\n      };\n      const isLoaded = name => has$2(urls, name);\n      const isAdded = name => has$2(lookup, name);\n      const get = name => {\n        if (lookup[name]) {\n          return lookup[name].instance;\n        }\n        return undefined;\n      };\n      const loadLanguagePack = (name, languages) => {\n        const language = I18n.getCode();\n        const wrappedLanguages = ',' + (languages || '') + ',';\n        if (!language || languages && wrappedLanguages.indexOf(',' + language + ',') === -1) {\n          return;\n        }\n        ScriptLoader.ScriptLoader.add(urls[name] + '/langs/' + language + '.js');\n      };\n      const requireLangPack = (name, languages) => {\n        if (AddOnManager.languageLoad !== false) {\n          if (isLoaded(name)) {\n            loadLanguagePack(name, languages);\n          } else {\n            waitFor(name, 'loaded').then(() => loadLanguagePack(name, languages));\n          }\n        }\n      };\n      const add = (id, addOn) => {\n        items.push(addOn);\n        lookup[id] = { instance: addOn };\n        runListeners(id, 'added');\n        return addOn;\n      };\n      const remove = name => {\n        delete urls[name];\n        delete lookup[name];\n      };\n      const createUrl = (baseUrl, dep) => {\n        if (isString(dep)) {\n          return isString(baseUrl) ? {\n            prefix: '',\n            resource: dep,\n            suffix: ''\n          } : {\n            prefix: baseUrl.prefix,\n            resource: dep,\n            suffix: baseUrl.suffix\n          };\n        } else {\n          return dep;\n        }\n      };\n      const load = (name, addOnUrl) => {\n        if (urls[name]) {\n          return Promise.resolve();\n        }\n        let urlString = isString(addOnUrl) ? addOnUrl : addOnUrl.prefix + addOnUrl.resource + addOnUrl.suffix;\n        if (urlString.indexOf('/') !== 0 && urlString.indexOf('://') === -1) {\n          urlString = AddOnManager.baseURL + '/' + urlString;\n        }\n        urls[name] = urlString.substring(0, urlString.lastIndexOf('/'));\n        const done = () => {\n          runListeners(name, 'loaded');\n          return Promise.resolve();\n        };\n        if (lookup[name]) {\n          return done();\n        } else {\n          return ScriptLoader.ScriptLoader.add(urlString).then(done);\n        }\n      };\n      const waitFor = (name, state = 'added') => {\n        if (state === 'added' && isAdded(name)) {\n          return Promise.resolve();\n        } else if (state === 'loaded' && isLoaded(name)) {\n          return Promise.resolve();\n        } else {\n          return new Promise(resolve => {\n            _listeners.push({\n              name,\n              state,\n              resolve\n            });\n          });\n        }\n      };\n      return {\n        items,\n        urls,\n        lookup,\n        get,\n        requireLangPack,\n        add,\n        remove,\n        createUrl,\n        load,\n        waitFor\n      };\n    };\n    AddOnManager.languageLoad = true;\n    AddOnManager.baseURL = '';\n    AddOnManager.PluginManager = AddOnManager();\n    AddOnManager.ThemeManager = AddOnManager();\n    AddOnManager.ModelManager = AddOnManager();\n\n    const first$1 = (fn, rate) => {\n      let timer = null;\n      const cancel = () => {\n        if (!isNull(timer)) {\n          clearTimeout(timer);\n          timer = null;\n        }\n      };\n      const throttle = (...args) => {\n        if (isNull(timer)) {\n          timer = setTimeout(() => {\n            timer = null;\n            fn.apply(null, args);\n          }, rate);\n        }\n      };\n      return {\n        cancel,\n        throttle\n      };\n    };\n    const last = (fn, rate) => {\n      let timer = null;\n      const cancel = () => {\n        if (!isNull(timer)) {\n          clearTimeout(timer);\n          timer = null;\n        }\n      };\n      const throttle = (...args) => {\n        cancel();\n        timer = setTimeout(() => {\n          timer = null;\n          fn.apply(null, args);\n        }, rate);\n      };\n      return {\n        cancel,\n        throttle\n      };\n    };\n\n    const ancestor$1 = (scope, selector, isRoot) => ancestor$3(scope, selector, isRoot).isSome();\n\n    const annotation = constant('mce-annotation');\n    const dataAnnotation = constant('data-mce-annotation');\n    const dataAnnotationId = constant('data-mce-annotation-uid');\n    const dataAnnotationActive = constant('data-mce-annotation-active');\n    const dataAnnotationClasses = constant('data-mce-annotation-classes');\n    const dataAnnotationAttributes = constant('data-mce-annotation-attrs');\n\n    const isRoot$1 = root => node => eq(node, root);\n    const identify = (editor, annotationName) => {\n      const rng = editor.selection.getRng();\n      const start = SugarElement.fromDom(rng.startContainer);\n      const root = SugarElement.fromDom(editor.getBody());\n      const selector = annotationName.fold(() => '.' + annotation(), an => `[${ dataAnnotation() }=\"${ an }\"]`);\n      const newStart = child$1(start, rng.startOffset).getOr(start);\n      const closest = closest$3(newStart, selector, isRoot$1(root));\n      return closest.bind(c => getOpt(c, `${ dataAnnotationId() }`).bind(uid => getOpt(c, `${ dataAnnotation() }`).map(name => {\n        const elements = findMarkers(editor, uid);\n        return {\n          uid,\n          name,\n          elements\n        };\n      })));\n    };\n    const isAnnotation = elem => isElement$7(elem) && has(elem, annotation());\n    const isBogusElement = (elem, root) => has$1(elem, 'data-mce-bogus') || ancestor$1(elem, '[data-mce-bogus=\"all\"]', isRoot$1(root));\n    const findMarkers = (editor, uid) => {\n      const body = SugarElement.fromDom(editor.getBody());\n      const descendants$1 = descendants(body, `[${ dataAnnotationId() }=\"${ uid }\"]`);\n      return filter$5(descendants$1, descendant => !isBogusElement(descendant, body));\n    };\n    const findAll = (editor, name) => {\n      const body = SugarElement.fromDom(editor.getBody());\n      const markers = descendants(body, `[${ dataAnnotation() }=\"${ name }\"]`);\n      const directory = {};\n      each$e(markers, m => {\n        if (!isBogusElement(m, body)) {\n          const uid = get$9(m, dataAnnotationId());\n          const nodesAlready = get$a(directory, uid).getOr([]);\n          directory[uid] = nodesAlready.concat([m]);\n        }\n      });\n      return directory;\n    };\n\n    const setup$y = (editor, registry) => {\n      const changeCallbacks = Cell({});\n      const initData = () => ({\n        listeners: [],\n        previous: value$2()\n      });\n      const withCallbacks = (name, f) => {\n        updateCallbacks(name, data => {\n          f(data);\n          return data;\n        });\n      };\n      const updateCallbacks = (name, f) => {\n        const callbackMap = changeCallbacks.get();\n        const data = get$a(callbackMap, name).getOrThunk(initData);\n        const outputData = f(data);\n        callbackMap[name] = outputData;\n        changeCallbacks.set(callbackMap);\n      };\n      const fireCallbacks = (name, uid, elements) => {\n        withCallbacks(name, data => {\n          each$e(data.listeners, f => f(true, name, {\n            uid,\n            nodes: map$3(elements, elem => elem.dom)\n          }));\n        });\n      };\n      const fireNoAnnotation = name => {\n        withCallbacks(name, data => {\n          each$e(data.listeners, f => f(false, name));\n        });\n      };\n      const toggleActiveAttr = (uid, state) => {\n        each$e(findMarkers(editor, uid), elem => {\n          if (state) {\n            set$3(elem, dataAnnotationActive(), 'true');\n          } else {\n            remove$9(elem, dataAnnotationActive());\n          }\n        });\n      };\n      const onNodeChange = last(() => {\n        const annotations = sort(registry.getNames());\n        each$e(annotations, name => {\n          updateCallbacks(name, data => {\n            const prev = data.previous.get();\n            identify(editor, Optional.some(name)).fold(() => {\n              prev.each(uid => {\n                fireNoAnnotation(name);\n                data.previous.clear();\n                toggleActiveAttr(uid, false);\n              });\n            }, ({uid, name, elements}) => {\n              if (!is$2(prev, uid)) {\n                prev.each(uid => toggleActiveAttr(uid, false));\n                fireCallbacks(name, uid, elements);\n                data.previous.set(uid);\n                toggleActiveAttr(uid, true);\n              }\n            });\n            return {\n              previous: data.previous,\n              listeners: data.listeners\n            };\n          });\n        });\n      }, 30);\n      editor.on('remove', () => {\n        onNodeChange.cancel();\n      });\n      editor.on('NodeChange', () => {\n        onNodeChange.throttle();\n      });\n      const addListener = (name, f) => {\n        updateCallbacks(name, data => ({\n          previous: data.previous,\n          listeners: data.listeners.concat([f])\n        }));\n      };\n      return { addListener };\n    };\n\n    const setup$x = (editor, registry) => {\n      const dataAnnotation$1 = dataAnnotation();\n      const identifyParserNode = node => Optional.from(node.attr(dataAnnotation$1)).bind(registry.lookup);\n      const removeDirectAnnotation = node => {\n        var _a, _b;\n        node.attr(dataAnnotationId(), null);\n        node.attr(dataAnnotation(), null);\n        node.attr(dataAnnotationActive(), null);\n        const customAttrNames = Optional.from(node.attr(dataAnnotationAttributes())).map(names => names.split(',')).getOr([]);\n        const customClasses = Optional.from(node.attr(dataAnnotationClasses())).map(names => names.split(',')).getOr([]);\n        each$e(customAttrNames, name => node.attr(name, null));\n        const classList = (_b = (_a = node.attr('class')) === null || _a === void 0 ? void 0 : _a.split(' ')) !== null && _b !== void 0 ? _b : [];\n        const newClassList = difference(classList, [annotation()].concat(customClasses));\n        node.attr('class', newClassList.length > 0 ? newClassList.join(' ') : null);\n        node.attr(dataAnnotationClasses(), null);\n        node.attr(dataAnnotationAttributes(), null);\n      };\n      editor.serializer.addTempAttr(dataAnnotationActive());\n      editor.serializer.addAttributeFilter(dataAnnotation$1, nodes => {\n        for (const node of nodes) {\n          identifyParserNode(node).each(settings => {\n            if (settings.persistent === false) {\n              if (node.name === 'span') {\n                node.unwrap();\n              } else {\n                removeDirectAnnotation(node);\n              }\n            }\n          });\n        }\n      });\n    };\n\n    const create$b = () => {\n      const annotations = {};\n      const register = (name, settings) => {\n        annotations[name] = {\n          name,\n          settings\n        };\n      };\n      const lookup = name => get$a(annotations, name).map(a => a.settings);\n      const getNames = () => keys(annotations);\n      return {\n        register,\n        lookup,\n        getNames\n      };\n    };\n\n    const clamp$2 = (value, min, max) => Math.min(Math.max(value, min), max);\n    const random = () => window.crypto.getRandomValues(new Uint32Array(1))[0] / 4294967295;\n\n    let unique = 0;\n    const generate$1 = prefix => {\n      const date = new Date();\n      const time = date.getTime();\n      const random$1 = Math.floor(random() * 1000000000);\n      unique++;\n      return prefix + '_' + random$1 + unique + String(time);\n    };\n\n    const add = (element, classes) => {\n      each$e(classes, x => {\n        add$2(element, x);\n      });\n    };\n    const remove$3 = (element, classes) => {\n      each$e(classes, x => {\n        remove$6(element, x);\n      });\n    };\n\n    const clone$2 = (original, isDeep) => SugarElement.fromDom(original.dom.cloneNode(isDeep));\n    const shallow$1 = original => clone$2(original, false);\n    const deep$1 = original => clone$2(original, true);\n    const shallowAs = (original, tag) => {\n      const nu = SugarElement.fromTag(tag);\n      const attributes = clone$4(original);\n      setAll$1(nu, attributes);\n      return nu;\n    };\n    const mutate = (original, tag) => {\n      const nu = shallowAs(original, tag);\n      after$4(original, nu);\n      const children = children$1(original);\n      append(nu, children);\n      remove$4(original);\n      return nu;\n    };\n\n    const TextWalker = (startNode, rootNode, isBoundary = never) => {\n      const walker = new DomTreeWalker(startNode, rootNode);\n      const walk = direction => {\n        let next;\n        do {\n          next = walker[direction]();\n        } while (next && !isText$b(next) && !isBoundary(next));\n        return Optional.from(next).filter(isText$b);\n      };\n      return {\n        current: () => Optional.from(walker.current()).filter(isText$b),\n        next: () => walk('next'),\n        prev: () => walk('prev'),\n        prev2: () => walk('prev2')\n      };\n    };\n\n    const TextSeeker = (dom, isBoundary) => {\n      const isBlockBoundary = isBoundary ? isBoundary : node => dom.isBlock(node) || isBr$6(node) || isContentEditableFalse$b(node);\n      const walk = (node, offset, walker, process) => {\n        if (isText$b(node)) {\n          const newOffset = process(node, offset, node.data);\n          if (newOffset !== -1) {\n            return Optional.some({\n              container: node,\n              offset: newOffset\n            });\n          }\n        }\n        return walker().bind(next => walk(next.container, next.offset, walker, process));\n      };\n      const backwards = (node, offset, process, root) => {\n        const walker = TextWalker(node, root !== null && root !== void 0 ? root : dom.getRoot(), isBlockBoundary);\n        return walk(node, offset, () => walker.prev().map(prev => ({\n          container: prev,\n          offset: prev.length\n        })), process).getOrNull();\n      };\n      const forwards = (node, offset, process, root) => {\n        const walker = TextWalker(node, root !== null && root !== void 0 ? root : dom.getRoot(), isBlockBoundary);\n        return walk(node, offset, () => walker.next().map(next => ({\n          container: next,\n          offset: 0\n        })), process).getOrNull();\n      };\n      return {\n        backwards,\n        forwards\n      };\n    };\n\n    const NodeValue = (is, name) => {\n      const get = element => {\n        if (!is(element)) {\n          throw new Error('Can only get ' + name + ' value of a ' + name + ' node');\n        }\n        return getOption(element).getOr('');\n      };\n      const getOption = element => is(element) ? Optional.from(element.dom.nodeValue) : Optional.none();\n      const set = (element, value) => {\n        if (!is(element)) {\n          throw new Error('Can only set raw ' + name + ' value of a ' + name + ' node');\n        }\n        element.dom.nodeValue = value;\n      };\n      return {\n        get,\n        getOption,\n        set\n      };\n    };\n\n    const api$1 = NodeValue(isText$c, 'text');\n    const get$3 = element => api$1.get(element);\n    const getOption = element => api$1.getOption(element);\n    const set = (element, value) => api$1.set(element, value);\n\n    const tableCells = [\n      'td',\n      'th'\n    ];\n    const tableSections = [\n      'thead',\n      'tbody',\n      'tfoot'\n    ];\n    const textBlocks = [\n      'h1',\n      'h2',\n      'h3',\n      'h4',\n      'h5',\n      'h6',\n      'p',\n      'div',\n      'address',\n      'pre',\n      'form',\n      'blockquote',\n      'center',\n      'dir',\n      'fieldset',\n      'header',\n      'footer',\n      'article',\n      'section',\n      'hgroup',\n      'aside',\n      'nav',\n      'figure'\n    ];\n    const listItems$1 = [\n      'li',\n      'dd',\n      'dt'\n    ];\n    const lists = [\n      'ul',\n      'ol',\n      'dl'\n    ];\n    const wsElements = [\n      'pre',\n      'script',\n      'textarea',\n      'style'\n    ];\n    const lazyLookup = items => {\n      let lookup;\n      return node => {\n        lookup = lookup ? lookup : mapToObject(items, always);\n        return has$2(lookup, name(node));\n      };\n    };\n    const isTable$1 = node => name(node) === 'table';\n    const isBr$5 = node => isElement$7(node) && name(node) === 'br';\n    const isTextBlock$2 = lazyLookup(textBlocks);\n    const isList = lazyLookup(lists);\n    const isListItem$1 = lazyLookup(listItems$1);\n    const isTableSection = lazyLookup(tableSections);\n    const isTableCell$2 = lazyLookup(tableCells);\n    const isWsPreserveElement = lazyLookup(wsElements);\n\n    const getLastChildren$1 = elm => {\n      const children = [];\n      let rawNode = elm.dom;\n      while (rawNode) {\n        children.push(SugarElement.fromDom(rawNode));\n        rawNode = rawNode.lastChild;\n      }\n      return children;\n    };\n    const removeTrailingBr = elm => {\n      const allBrs = descendants(elm, 'br');\n      const brs = filter$5(getLastChildren$1(elm).slice(-1), isBr$5);\n      if (allBrs.length === brs.length) {\n        each$e(brs, remove$4);\n      }\n    };\n    const createPaddingBr = () => {\n      const br = SugarElement.fromTag('br');\n      set$3(br, 'data-mce-bogus', '1');\n      return br;\n    };\n    const fillWithPaddingBr = elm => {\n      empty(elm);\n      append$1(elm, createPaddingBr());\n    };\n    const trimBlockTrailingBr = (elm, schema) => {\n      lastChild(elm).each(lastChild => {\n        prevSibling(lastChild).each(lastChildPrevSibling => {\n          if (schema.isBlock(name(elm)) && isBr$5(lastChild) && schema.isBlock(name(lastChildPrevSibling))) {\n            remove$4(lastChild);\n          }\n        });\n      });\n    };\n\n    const ZWSP$1 = zeroWidth;\n    const isZwsp = isZwsp$2;\n    const trim$2 = removeZwsp;\n    const insert$5 = editor => editor.insertContent(ZWSP$1, { preserve_zwsp: true });\n\n    const isElement$5 = isElement$6;\n    const isText$9 = isText$b;\n    const isCaretContainerBlock$1 = node => {\n      if (isText$9(node)) {\n        node = node.parentNode;\n      }\n      return isElement$5(node) && node.hasAttribute('data-mce-caret');\n    };\n    const isCaretContainerInline = node => isText$9(node) && isZwsp(node.data);\n    const isCaretContainer$2 = node => isCaretContainerBlock$1(node) || isCaretContainerInline(node);\n    const hasContent = node => node.firstChild !== node.lastChild || !isBr$6(node.firstChild);\n    const insertInline$1 = (node, before) => {\n      var _a;\n      const doc = (_a = node.ownerDocument) !== null && _a !== void 0 ? _a : document;\n      const textNode = doc.createTextNode(ZWSP$1);\n      const parentNode = node.parentNode;\n      if (!before) {\n        const sibling = node.nextSibling;\n        if (isText$9(sibling)) {\n          if (isCaretContainer$2(sibling)) {\n            return sibling;\n          }\n          if (startsWithCaretContainer$1(sibling)) {\n            sibling.splitText(1);\n            return sibling;\n          }\n        }\n        if (node.nextSibling) {\n          parentNode === null || parentNode === void 0 ? void 0 : parentNode.insertBefore(textNode, node.nextSibling);\n        } else {\n          parentNode === null || parentNode === void 0 ? void 0 : parentNode.appendChild(textNode);\n        }\n      } else {\n        const sibling = node.previousSibling;\n        if (isText$9(sibling)) {\n          if (isCaretContainer$2(sibling)) {\n            return sibling;\n          }\n          if (endsWithCaretContainer$1(sibling)) {\n            return sibling.splitText(sibling.data.length - 1);\n          }\n        }\n        parentNode === null || parentNode === void 0 ? void 0 : parentNode.insertBefore(textNode, node);\n      }\n      return textNode;\n    };\n    const isBeforeInline = pos => {\n      const container = pos.container();\n      if (!isText$b(container)) {\n        return false;\n      }\n      return container.data.charAt(pos.offset()) === ZWSP$1 || pos.isAtStart() && isCaretContainerInline(container.previousSibling);\n    };\n    const isAfterInline = pos => {\n      const container = pos.container();\n      if (!isText$b(container)) {\n        return false;\n      }\n      return container.data.charAt(pos.offset() - 1) === ZWSP$1 || pos.isAtEnd() && isCaretContainerInline(container.nextSibling);\n    };\n    const insertBlock = (blockName, node, before) => {\n      var _a;\n      const doc = (_a = node.ownerDocument) !== null && _a !== void 0 ? _a : document;\n      const blockNode = doc.createElement(blockName);\n      blockNode.setAttribute('data-mce-caret', before ? 'before' : 'after');\n      blockNode.setAttribute('data-mce-bogus', 'all');\n      blockNode.appendChild(createPaddingBr().dom);\n      const parentNode = node.parentNode;\n      if (!before) {\n        if (node.nextSibling) {\n          parentNode === null || parentNode === void 0 ? void 0 : parentNode.insertBefore(blockNode, node.nextSibling);\n        } else {\n          parentNode === null || parentNode === void 0 ? void 0 : parentNode.appendChild(blockNode);\n        }\n      } else {\n        parentNode === null || parentNode === void 0 ? void 0 : parentNode.insertBefore(blockNode, node);\n      }\n      return blockNode;\n    };\n    const startsWithCaretContainer$1 = node => isText$9(node) && node.data[0] === ZWSP$1;\n    const endsWithCaretContainer$1 = node => isText$9(node) && node.data[node.data.length - 1] === ZWSP$1;\n    const trimBogusBr = elm => {\n      var _a;\n      const brs = elm.getElementsByTagName('br');\n      const lastBr = brs[brs.length - 1];\n      if (isBogus$1(lastBr)) {\n        (_a = lastBr.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(lastBr);\n      }\n    };\n    const showCaretContainerBlock = caretContainer => {\n      if (caretContainer && caretContainer.hasAttribute('data-mce-caret')) {\n        trimBogusBr(caretContainer);\n        caretContainer.removeAttribute('data-mce-caret');\n        caretContainer.removeAttribute('data-mce-bogus');\n        caretContainer.removeAttribute('style');\n        caretContainer.removeAttribute('data-mce-style');\n        caretContainer.removeAttribute('_moz_abspos');\n        return caretContainer;\n      }\n      return null;\n    };\n    const isRangeInCaretContainerBlock = range => isCaretContainerBlock$1(range.startContainer);\n\n    const round$2 = Math.round;\n    const clone$1 = rect => {\n      if (!rect) {\n        return {\n          left: 0,\n          top: 0,\n          bottom: 0,\n          right: 0,\n          width: 0,\n          height: 0\n        };\n      }\n      return {\n        left: round$2(rect.left),\n        top: round$2(rect.top),\n        bottom: round$2(rect.bottom),\n        right: round$2(rect.right),\n        width: round$2(rect.width),\n        height: round$2(rect.height)\n      };\n    };\n    const collapse = (rect, toStart) => {\n      rect = clone$1(rect);\n      if (toStart) {\n        rect.right = rect.left;\n      } else {\n        rect.left = rect.left + rect.width;\n        rect.right = rect.left;\n      }\n      rect.width = 0;\n      return rect;\n    };\n    const isEqual = (rect1, rect2) => rect1.left === rect2.left && rect1.top === rect2.top && rect1.bottom === rect2.bottom && rect1.right === rect2.right;\n    const isValidOverflow = (overflowY, rect1, rect2) => overflowY >= 0 && overflowY <= Math.min(rect1.height, rect2.height) / 2;\n    const isAbove$1 = (rect1, rect2) => {\n      const halfHeight = Math.min(rect2.height / 2, rect1.height / 2);\n      if (rect1.bottom - halfHeight < rect2.top) {\n        return true;\n      }\n      if (rect1.top > rect2.bottom) {\n        return false;\n      }\n      return isValidOverflow(rect2.top - rect1.bottom, rect1, rect2);\n    };\n    const isBelow$1 = (rect1, rect2) => {\n      if (rect1.top > rect2.bottom) {\n        return true;\n      }\n      if (rect1.bottom < rect2.top) {\n        return false;\n      }\n      return isValidOverflow(rect2.bottom - rect1.top, rect1, rect2);\n    };\n    const containsXY = (rect, clientX, clientY) => clientX >= rect.left && clientX <= rect.right && clientY >= rect.top && clientY <= rect.bottom;\n    const boundingClientRectFromRects = rects => {\n      return foldl(rects, (acc, rect) => {\n        return acc.fold(() => Optional.some(rect), prevRect => {\n          const left = Math.min(rect.left, prevRect.left);\n          const top = Math.min(rect.top, prevRect.top);\n          const right = Math.max(rect.right, prevRect.right);\n          const bottom = Math.max(rect.bottom, prevRect.bottom);\n          return Optional.some({\n            top,\n            right,\n            bottom,\n            left,\n            width: right - left,\n            height: bottom - top\n          });\n        });\n      }, Optional.none());\n    };\n    const distanceToRectEdgeFromXY = (rect, x, y) => {\n      const cx = Math.max(Math.min(x, rect.left + rect.width), rect.left);\n      const cy = Math.max(Math.min(y, rect.top + rect.height), rect.top);\n      return Math.sqrt((x - cx) * (x - cx) + (y - cy) * (y - cy));\n    };\n    const overlapY = (r1, r2) => Math.max(0, Math.min(r1.bottom, r2.bottom) - Math.max(r1.top, r2.top));\n\n    const getSelectedNode = range => {\n      const startContainer = range.startContainer, startOffset = range.startOffset;\n      if (startContainer === range.endContainer && startContainer.hasChildNodes() && range.endOffset === startOffset + 1) {\n        return startContainer.childNodes[startOffset];\n      }\n      return null;\n    };\n    const getNode$1 = (container, offset) => {\n      if (isElement$6(container) && container.hasChildNodes()) {\n        const childNodes = container.childNodes;\n        const safeOffset = clamp$2(offset, 0, childNodes.length - 1);\n        return childNodes[safeOffset];\n      } else {\n        return container;\n      }\n    };\n    const getNodeUnsafe = (container, offset) => {\n      if (offset < 0 && isElement$6(container) && container.hasChildNodes()) {\n        return undefined;\n      } else {\n        return getNode$1(container, offset);\n      }\n    };\n\n    const extendingChars = new RegExp('[\\u0300-\\u036f\\u0483-\\u0487\\u0488-\\u0489\\u0591-\\u05bd\\u05bf\\u05c1-\\u05c2\\u05c4-\\u05c5\\u05c7\\u0610-\\u061a' + '\\u064b-\\u065f\\u0670\\u06d6-\\u06dc\\u06df-\\u06e4\\u06e7-\\u06e8\\u06ea-\\u06ed\\u0711\\u0730-\\u074a\\u07a6-\\u07b0' + '\\u07eb-\\u07f3\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0859-\\u085b\\u08e3-\\u0902\\u093a\\u093c' + '\\u0941-\\u0948\\u094d\\u0951-\\u0957\\u0962-\\u0963\\u0981\\u09bc\\u09be\\u09c1-\\u09c4\\u09cd\\u09d7\\u09e2-\\u09e3' + '\\u0a01-\\u0a02\\u0a3c\\u0a41-\\u0a42\\u0a47-\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a70-\\u0a71\\u0a75\\u0a81-\\u0a82\\u0abc' + '\\u0ac1-\\u0ac5\\u0ac7-\\u0ac8\\u0acd\\u0ae2-\\u0ae3\\u0b01\\u0b3c\\u0b3e\\u0b3f\\u0b41-\\u0b44\\u0b4d\\u0b56\\u0b57' + '\\u0b62-\\u0b63\\u0b82\\u0bbe\\u0bc0\\u0bcd\\u0bd7\\u0c00\\u0c3e-\\u0c40\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55-\\u0c56' + '\\u0c62-\\u0c63\\u0c81\\u0cbc\\u0cbf\\u0cc2\\u0cc6\\u0ccc-\\u0ccd\\u0cd5-\\u0cd6\\u0ce2-\\u0ce3\\u0d01\\u0d3e\\u0d41-\\u0d44' + '\\u0d4d\\u0d57\\u0d62-\\u0d63\\u0dca\\u0dcf\\u0dd2-\\u0dd4\\u0dd6\\u0ddf\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0eb1\\u0eb4-\\u0eb9' + '\\u0ebb-\\u0ebc\\u0ec8-\\u0ecd\\u0f18-\\u0f19\\u0f35\\u0f37\\u0f39\\u0f71-\\u0f7e\\u0f80-\\u0f84\\u0f86-\\u0f87\\u0f8d-\\u0f97' + '\\u0f99-\\u0fbc\\u0fc6\\u102d-\\u1030\\u1032-\\u1037\\u1039-\\u103a\\u103d-\\u103e\\u1058-\\u1059\\u105e-\\u1060\\u1071-\\u1074' + '\\u1082\\u1085-\\u1086\\u108d\\u109d\\u135d-\\u135f\\u1712-\\u1714\\u1732-\\u1734\\u1752-\\u1753\\u1772-\\u1773\\u17b4-\\u17b5' + '\\u17b7-\\u17bd\\u17c6\\u17c9-\\u17d3\\u17dd\\u180b-\\u180d\\u18a9\\u1920-\\u1922\\u1927-\\u1928\\u1932\\u1939-\\u193b\\u1a17-\\u1a18' + '\\u1a1b\\u1a56\\u1a58-\\u1a5e\\u1a60\\u1a62\\u1a65-\\u1a6c\\u1a73-\\u1a7c\\u1a7f\\u1ab0-\\u1abd\\u1ABE\\u1b00-\\u1b03\\u1b34' + '\\u1b36-\\u1b3a\\u1b3c\\u1b42\\u1b6b-\\u1b73\\u1b80-\\u1b81\\u1ba2-\\u1ba5\\u1ba8-\\u1ba9\\u1bab-\\u1bad\\u1be6\\u1be8-\\u1be9' + '\\u1bed\\u1bef-\\u1bf1\\u1c2c-\\u1c33\\u1c36-\\u1c37\\u1cd0-\\u1cd2\\u1cd4-\\u1ce0\\u1ce2-\\u1ce8\\u1ced\\u1cf4\\u1cf8-\\u1cf9' + '\\u1dc0-\\u1df5\\u1dfc-\\u1dff\\u200c-\\u200d\\u20d0-\\u20dc\\u20DD-\\u20E0\\u20e1\\u20E2-\\u20E4\\u20e5-\\u20f0\\u2cef-\\u2cf1' + '\\u2d7f\\u2de0-\\u2dff\\u302a-\\u302d\\u302e-\\u302f\\u3099-\\u309a\\ua66f\\uA670-\\uA672\\ua674-\\ua67d\\ua69e-\\ua69f\\ua6f0-\\ua6f1' + '\\ua802\\ua806\\ua80b\\ua825-\\ua826\\ua8c4\\ua8e0-\\ua8f1\\ua926-\\ua92d\\ua947-\\ua951\\ua980-\\ua982\\ua9b3\\ua9b6-\\ua9b9\\ua9bc' + '\\ua9e5\\uaa29-\\uaa2e\\uaa31-\\uaa32\\uaa35-\\uaa36\\uaa43\\uaa4c\\uaa7c\\uaab0\\uaab2-\\uaab4\\uaab7-\\uaab8\\uaabe-\\uaabf\\uaac1' + '\\uaaec-\\uaaed\\uaaf6\\uabe5\\uabe8\\uabed\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe2f\\uff9e-\\uff9f]');\n    const isExtendingChar = ch => isString(ch) && ch.charCodeAt(0) >= 768 && extendingChars.test(ch);\n\n    const or = (...args) => {\n      return x => {\n        for (let i = 0; i < args.length; i++) {\n          if (args[i](x)) {\n            return true;\n          }\n        }\n        return false;\n      };\n    };\n    const and = (...args) => {\n      return x => {\n        for (let i = 0; i < args.length; i++) {\n          if (!args[i](x)) {\n            return false;\n          }\n        }\n        return true;\n      };\n    };\n\n    const isContentEditableTrue$2 = isContentEditableTrue$3;\n    const isContentEditableFalse$a = isContentEditableFalse$b;\n    const isBr$4 = isBr$6;\n    const isText$8 = isText$b;\n    const isInvalidTextElement = matchNodeNames([\n      'script',\n      'style',\n      'textarea'\n    ]);\n    const isAtomicInline = matchNodeNames([\n      'img',\n      'input',\n      'textarea',\n      'hr',\n      'iframe',\n      'video',\n      'audio',\n      'object',\n      'embed'\n    ]);\n    const isTable = matchNodeNames(['table']);\n    const isCaretContainer$1 = isCaretContainer$2;\n    const isCaretCandidate$3 = node => {\n      if (isCaretContainer$1(node)) {\n        return false;\n      }\n      if (isText$8(node)) {\n        return !isInvalidTextElement(node.parentNode);\n      }\n      return isAtomicInline(node) || isBr$4(node) || isTable(node) || isNonUiContentEditableFalse(node);\n    };\n    const isUnselectable = node => isElement$6(node) && node.getAttribute('unselectable') === 'true';\n    const isNonUiContentEditableFalse = node => !isUnselectable(node) && isContentEditableFalse$a(node);\n    const isInEditable = (node, root) => {\n      for (let tempNode = node.parentNode; tempNode && tempNode !== root; tempNode = tempNode.parentNode) {\n        if (isNonUiContentEditableFalse(tempNode)) {\n          return false;\n        }\n        if (isContentEditableTrue$2(tempNode)) {\n          return true;\n        }\n      }\n      return true;\n    };\n    const isAtomicContentEditableFalse = node => {\n      if (!isNonUiContentEditableFalse(node)) {\n        return false;\n      }\n      return !foldl(from(node.getElementsByTagName('*')), (result, elm) => {\n        return result || isContentEditableTrue$2(elm);\n      }, false);\n    };\n    const isAtomic$1 = node => isAtomicInline(node) || isAtomicContentEditableFalse(node);\n    const isEditableCaretCandidate$1 = (node, root) => isCaretCandidate$3(node) && isInEditable(node, root);\n\n    const isElement$4 = isElement$6;\n    const isCaretCandidate$2 = isCaretCandidate$3;\n    const isBlock$2 = matchStyleValues('display', 'block table');\n    const isFloated = matchStyleValues('float', 'left right');\n    const isValidElementCaretCandidate = and(isElement$4, isCaretCandidate$2, not(isFloated));\n    const isNotPre = not(matchStyleValues('white-space', 'pre pre-line pre-wrap'));\n    const isText$7 = isText$b;\n    const isBr$3 = isBr$6;\n    const nodeIndex$1 = DOMUtils.nodeIndex;\n    const resolveIndex$1 = getNodeUnsafe;\n    const createRange$1 = doc => doc ? doc.createRange() : DOMUtils.DOM.createRng();\n    const isWhiteSpace$1 = chr => isString(chr) && /[\\r\\n\\t ]/.test(chr);\n    const isRange = rng => !!rng.setStart && !!rng.setEnd;\n    const isHiddenWhiteSpaceRange = range => {\n      const container = range.startContainer;\n      const offset = range.startOffset;\n      if (isWhiteSpace$1(range.toString()) && isNotPre(container.parentNode) && isText$b(container)) {\n        const text = container.data;\n        if (isWhiteSpace$1(text[offset - 1]) || isWhiteSpace$1(text[offset + 1])) {\n          return true;\n        }\n      }\n      return false;\n    };\n    const getBrClientRect = brNode => {\n      const doc = brNode.ownerDocument;\n      const rng = createRange$1(doc);\n      const nbsp$1 = doc.createTextNode(nbsp);\n      const parentNode = brNode.parentNode;\n      parentNode.insertBefore(nbsp$1, brNode);\n      rng.setStart(nbsp$1, 0);\n      rng.setEnd(nbsp$1, 1);\n      const clientRect = clone$1(rng.getBoundingClientRect());\n      parentNode.removeChild(nbsp$1);\n      return clientRect;\n    };\n    const getBoundingClientRectWebKitText = rng => {\n      const sc = rng.startContainer;\n      const ec = rng.endContainer;\n      const so = rng.startOffset;\n      const eo = rng.endOffset;\n      if (sc === ec && isText$b(ec) && so === 0 && eo === 1) {\n        const newRng = rng.cloneRange();\n        newRng.setEndAfter(ec);\n        return getBoundingClientRect$1(newRng);\n      } else {\n        return null;\n      }\n    };\n    const isZeroRect = r => r.left === 0 && r.right === 0 && r.top === 0 && r.bottom === 0;\n    const getBoundingClientRect$1 = item => {\n      var _a;\n      let clientRect;\n      const clientRects = item.getClientRects();\n      if (clientRects.length > 0) {\n        clientRect = clone$1(clientRects[0]);\n      } else {\n        clientRect = clone$1(item.getBoundingClientRect());\n      }\n      if (!isRange(item) && isBr$3(item) && isZeroRect(clientRect)) {\n        return getBrClientRect(item);\n      }\n      if (isZeroRect(clientRect) && isRange(item)) {\n        return (_a = getBoundingClientRectWebKitText(item)) !== null && _a !== void 0 ? _a : clientRect;\n      }\n      return clientRect;\n    };\n    const collapseAndInflateWidth = (clientRect, toStart) => {\n      const newClientRect = collapse(clientRect, toStart);\n      newClientRect.width = 1;\n      newClientRect.right = newClientRect.left + 1;\n      return newClientRect;\n    };\n    const getCaretPositionClientRects = caretPosition => {\n      const clientRects = [];\n      const addUniqueAndValidRect = clientRect => {\n        if (clientRect.height === 0) {\n          return;\n        }\n        if (clientRects.length > 0) {\n          if (isEqual(clientRect, clientRects[clientRects.length - 1])) {\n            return;\n          }\n        }\n        clientRects.push(clientRect);\n      };\n      const addCharacterOffset = (container, offset) => {\n        const range = createRange$1(container.ownerDocument);\n        if (offset < container.data.length) {\n          if (isExtendingChar(container.data[offset])) {\n            return;\n          }\n          if (isExtendingChar(container.data[offset - 1])) {\n            range.setStart(container, offset);\n            range.setEnd(container, offset + 1);\n            if (!isHiddenWhiteSpaceRange(range)) {\n              addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect$1(range), false));\n              return;\n            }\n          }\n        }\n        if (offset > 0) {\n          range.setStart(container, offset - 1);\n          range.setEnd(container, offset);\n          if (!isHiddenWhiteSpaceRange(range)) {\n            addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect$1(range), false));\n          }\n        }\n        if (offset < container.data.length) {\n          range.setStart(container, offset);\n          range.setEnd(container, offset + 1);\n          if (!isHiddenWhiteSpaceRange(range)) {\n            addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect$1(range), true));\n          }\n        }\n      };\n      const container = caretPosition.container();\n      const offset = caretPosition.offset();\n      if (isText$7(container)) {\n        addCharacterOffset(container, offset);\n        return clientRects;\n      }\n      if (isElement$4(container)) {\n        if (caretPosition.isAtEnd()) {\n          const node = resolveIndex$1(container, offset);\n          if (isText$7(node)) {\n            addCharacterOffset(node, node.data.length);\n          }\n          if (isValidElementCaretCandidate(node) && !isBr$3(node)) {\n            addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect$1(node), false));\n          }\n        } else {\n          const node = resolveIndex$1(container, offset);\n          if (isText$7(node)) {\n            addCharacterOffset(node, 0);\n          }\n          if (isValidElementCaretCandidate(node) && caretPosition.isAtEnd()) {\n            addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect$1(node), false));\n            return clientRects;\n          }\n          const beforeNode = resolveIndex$1(caretPosition.container(), caretPosition.offset() - 1);\n          if (isValidElementCaretCandidate(beforeNode) && !isBr$3(beforeNode)) {\n            if (isBlock$2(beforeNode) || isBlock$2(node) || !isValidElementCaretCandidate(node)) {\n              addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect$1(beforeNode), false));\n            }\n          }\n          if (isValidElementCaretCandidate(node)) {\n            addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect$1(node), true));\n          }\n        }\n      }\n      return clientRects;\n    };\n    const CaretPosition = (container, offset, clientRects) => {\n      const isAtStart = () => {\n        if (isText$7(container)) {\n          return offset === 0;\n        }\n        return offset === 0;\n      };\n      const isAtEnd = () => {\n        if (isText$7(container)) {\n          return offset >= container.data.length;\n        }\n        return offset >= container.childNodes.length;\n      };\n      const toRange = () => {\n        const range = createRange$1(container.ownerDocument);\n        range.setStart(container, offset);\n        range.setEnd(container, offset);\n        return range;\n      };\n      const getClientRects = () => {\n        if (!clientRects) {\n          clientRects = getCaretPositionClientRects(CaretPosition(container, offset));\n        }\n        return clientRects;\n      };\n      const isVisible = () => getClientRects().length > 0;\n      const isEqual = caretPosition => caretPosition && container === caretPosition.container() && offset === caretPosition.offset();\n      const getNode = before => resolveIndex$1(container, before ? offset - 1 : offset);\n      return {\n        container: constant(container),\n        offset: constant(offset),\n        toRange,\n        getClientRects,\n        isVisible,\n        isAtStart,\n        isAtEnd,\n        isEqual,\n        getNode\n      };\n    };\n    CaretPosition.fromRangeStart = range => CaretPosition(range.startContainer, range.startOffset);\n    CaretPosition.fromRangeEnd = range => CaretPosition(range.endContainer, range.endOffset);\n    CaretPosition.after = node => CaretPosition(node.parentNode, nodeIndex$1(node) + 1);\n    CaretPosition.before = node => CaretPosition(node.parentNode, nodeIndex$1(node));\n    CaretPosition.isAbove = (pos1, pos2) => lift2(head(pos2.getClientRects()), last$2(pos1.getClientRects()), isAbove$1).getOr(false);\n    CaretPosition.isBelow = (pos1, pos2) => lift2(last$2(pos2.getClientRects()), head(pos1.getClientRects()), isBelow$1).getOr(false);\n    CaretPosition.isAtStart = pos => pos ? pos.isAtStart() : false;\n    CaretPosition.isAtEnd = pos => pos ? pos.isAtEnd() : false;\n    CaretPosition.isTextPosition = pos => pos ? isText$b(pos.container()) : false;\n    CaretPosition.isElementPosition = pos => !CaretPosition.isTextPosition(pos);\n\n    const trimEmptyTextNode$1 = (dom, node) => {\n      if (isText$b(node) && node.data.length === 0) {\n        dom.remove(node);\n      }\n    };\n    const insertNode = (dom, rng, node) => {\n      rng.insertNode(node);\n      trimEmptyTextNode$1(dom, node.previousSibling);\n      trimEmptyTextNode$1(dom, node.nextSibling);\n    };\n    const insertFragment = (dom, rng, frag) => {\n      const firstChild = Optional.from(frag.firstChild);\n      const lastChild = Optional.from(frag.lastChild);\n      rng.insertNode(frag);\n      firstChild.each(child => trimEmptyTextNode$1(dom, child.previousSibling));\n      lastChild.each(child => trimEmptyTextNode$1(dom, child.nextSibling));\n    };\n    const rangeInsertNode = (dom, rng, node) => {\n      if (isDocumentFragment(node)) {\n        insertFragment(dom, rng, node);\n      } else {\n        insertNode(dom, rng, node);\n      }\n    };\n\n    const isText$6 = isText$b;\n    const isBogus = isBogus$1;\n    const nodeIndex = DOMUtils.nodeIndex;\n    const normalizedParent = node => {\n      const parentNode = node.parentNode;\n      if (isBogus(parentNode)) {\n        return normalizedParent(parentNode);\n      }\n      return parentNode;\n    };\n    const getChildNodes = node => {\n      if (!node) {\n        return [];\n      }\n      return reduce(node.childNodes, (result, node) => {\n        if (isBogus(node) && node.nodeName !== 'BR') {\n          result = result.concat(getChildNodes(node));\n        } else {\n          result.push(node);\n        }\n        return result;\n      }, []);\n    };\n    const normalizedTextOffset = (node, offset) => {\n      let tempNode = node;\n      while (tempNode = tempNode.previousSibling) {\n        if (!isText$6(tempNode)) {\n          break;\n        }\n        offset += tempNode.data.length;\n      }\n      return offset;\n    };\n    const equal = a => b => a === b;\n    const normalizedNodeIndex = node => {\n      let nodes, index;\n      nodes = getChildNodes(normalizedParent(node));\n      index = findIndex$1(nodes, equal(node), node);\n      nodes = nodes.slice(0, index + 1);\n      const numTextFragments = reduce(nodes, (result, node, i) => {\n        if (isText$6(node) && isText$6(nodes[i - 1])) {\n          result++;\n        }\n        return result;\n      }, 0);\n      nodes = filter$3(nodes, matchNodeNames([node.nodeName]));\n      index = findIndex$1(nodes, equal(node), node);\n      return index - numTextFragments;\n    };\n    const createPathItem = node => {\n      const name = isText$6(node) ? 'text()' : node.nodeName.toLowerCase();\n      return name + '[' + normalizedNodeIndex(node) + ']';\n    };\n    const parentsUntil$1 = (root, node, predicate) => {\n      const parents = [];\n      for (let tempNode = node.parentNode; tempNode && tempNode !== root; tempNode = tempNode.parentNode) {\n        if (predicate && predicate(tempNode)) {\n          break;\n        }\n        parents.push(tempNode);\n      }\n      return parents;\n    };\n    const create$a = (root, caretPosition) => {\n      let path = [];\n      let container = caretPosition.container();\n      let offset = caretPosition.offset();\n      let outputOffset;\n      if (isText$6(container)) {\n        outputOffset = normalizedTextOffset(container, offset);\n      } else {\n        const childNodes = container.childNodes;\n        if (offset >= childNodes.length) {\n          outputOffset = 'after';\n          offset = childNodes.length - 1;\n        } else {\n          outputOffset = 'before';\n        }\n        container = childNodes[offset];\n      }\n      path.push(createPathItem(container));\n      let parents = parentsUntil$1(root, container);\n      parents = filter$3(parents, not(isBogus$1));\n      path = path.concat(map$1(parents, node => {\n        return createPathItem(node);\n      }));\n      return path.reverse().join('/') + ',' + outputOffset;\n    };\n    const resolvePathItem = (node, name, index) => {\n      let nodes = getChildNodes(node);\n      nodes = filter$3(nodes, (node, index) => {\n        return !isText$6(node) || !isText$6(nodes[index - 1]);\n      });\n      nodes = filter$3(nodes, matchNodeNames([name]));\n      return nodes[index];\n    };\n    const findTextPosition = (container, offset) => {\n      let node = container;\n      let targetOffset = 0;\n      while (isText$6(node)) {\n        const dataLen = node.data.length;\n        if (offset >= targetOffset && offset <= targetOffset + dataLen) {\n          container = node;\n          offset = offset - targetOffset;\n          break;\n        }\n        if (!isText$6(node.nextSibling)) {\n          container = node;\n          offset = dataLen;\n          break;\n        }\n        targetOffset += dataLen;\n        node = node.nextSibling;\n      }\n      if (isText$6(container) && offset > container.data.length) {\n        offset = container.data.length;\n      }\n      return CaretPosition(container, offset);\n    };\n    const resolve$1 = (root, path) => {\n      if (!path) {\n        return null;\n      }\n      const parts = path.split(',');\n      const paths = parts[0].split('/');\n      const offset = parts.length > 1 ? parts[1] : 'before';\n      const container = reduce(paths, (result, value) => {\n        const match = /([\\w\\-\\(\\)]+)\\[([0-9]+)\\]/.exec(value);\n        if (!match) {\n          return null;\n        }\n        if (match[1] === 'text()') {\n          match[1] = '#text';\n        }\n        return resolvePathItem(result, match[1], parseInt(match[2], 10));\n      }, root);\n      if (!container) {\n        return null;\n      }\n      if (!isText$6(container) && container.parentNode) {\n        let nodeOffset;\n        if (offset === 'after') {\n          nodeOffset = nodeIndex(container) + 1;\n        } else {\n          nodeOffset = nodeIndex(container);\n        }\n        return CaretPosition(container.parentNode, nodeOffset);\n      }\n      return findTextPosition(container, parseInt(offset, 10));\n    };\n\n    const isContentEditableFalse$9 = isContentEditableFalse$b;\n    const getNormalizedTextOffset$1 = (trim, container, offset) => {\n      let trimmedOffset = trim(container.data.slice(0, offset)).length;\n      for (let node = container.previousSibling; node && isText$b(node); node = node.previousSibling) {\n        trimmedOffset += trim(node.data).length;\n      }\n      return trimmedOffset;\n    };\n    const getPoint = (dom, trim, normalized, rng, start) => {\n      const container = start ? rng.startContainer : rng.endContainer;\n      let offset = start ? rng.startOffset : rng.endOffset;\n      const point = [];\n      const root = dom.getRoot();\n      if (isText$b(container)) {\n        point.push(normalized ? getNormalizedTextOffset$1(trim, container, offset) : offset);\n      } else {\n        let after = 0;\n        const childNodes = container.childNodes;\n        if (offset >= childNodes.length && childNodes.length) {\n          after = 1;\n          offset = Math.max(0, childNodes.length - 1);\n        }\n        point.push(dom.nodeIndex(childNodes[offset], normalized) + after);\n      }\n      for (let node = container; node && node !== root; node = node.parentNode) {\n        point.push(dom.nodeIndex(node, normalized));\n      }\n      return point;\n    };\n    const getLocation = (trim, selection, normalized, rng) => {\n      const dom = selection.dom;\n      const start = getPoint(dom, trim, normalized, rng, true);\n      const forward = selection.isForward();\n      const fakeCaret = isRangeInCaretContainerBlock(rng) ? { isFakeCaret: true } : {};\n      if (!selection.isCollapsed()) {\n        const end = getPoint(dom, trim, normalized, rng, false);\n        return {\n          start,\n          end,\n          forward,\n          ...fakeCaret\n        };\n      } else {\n        return {\n          start,\n          forward,\n          ...fakeCaret\n        };\n      }\n    };\n    const findIndex = (dom, name, element) => {\n      let count = 0;\n      Tools.each(dom.select(name), node => {\n        if (node.getAttribute('data-mce-bogus') === 'all') {\n          return;\n        } else if (node === element) {\n          return false;\n        } else {\n          count++;\n          return;\n        }\n      });\n      return count;\n    };\n    const moveEndPoint$1 = (rng, start) => {\n      let container = start ? rng.startContainer : rng.endContainer;\n      let offset = start ? rng.startOffset : rng.endOffset;\n      if (isElement$6(container) && container.nodeName === 'TR') {\n        const childNodes = container.childNodes;\n        container = childNodes[Math.min(start ? offset : offset - 1, childNodes.length - 1)];\n        if (container) {\n          offset = start ? 0 : container.childNodes.length;\n          if (start) {\n            rng.setStart(container, offset);\n          } else {\n            rng.setEnd(container, offset);\n          }\n        }\n      }\n    };\n    const normalizeTableCellSelection = rng => {\n      moveEndPoint$1(rng, true);\n      moveEndPoint$1(rng, false);\n      return rng;\n    };\n    const findSibling = (node, offset) => {\n      if (isElement$6(node)) {\n        node = getNode$1(node, offset);\n        if (isContentEditableFalse$9(node)) {\n          return node;\n        }\n      }\n      if (isCaretContainer$2(node)) {\n        if (isText$b(node) && isCaretContainerBlock$1(node)) {\n          node = node.parentNode;\n        }\n        let sibling = node.previousSibling;\n        if (isContentEditableFalse$9(sibling)) {\n          return sibling;\n        }\n        sibling = node.nextSibling;\n        if (isContentEditableFalse$9(sibling)) {\n          return sibling;\n        }\n      }\n      return undefined;\n    };\n    const findAdjacentContentEditableFalseElm = rng => {\n      return findSibling(rng.startContainer, rng.startOffset) || findSibling(rng.endContainer, rng.endOffset);\n    };\n    const getOffsetBookmark = (trim, normalized, selection) => {\n      const element = selection.getNode();\n      const rng = selection.getRng();\n      if (element.nodeName === 'IMG' || isContentEditableFalse$9(element)) {\n        const name = element.nodeName;\n        return {\n          name,\n          index: findIndex(selection.dom, name, element)\n        };\n      }\n      const sibling = findAdjacentContentEditableFalseElm(rng);\n      if (sibling) {\n        const name = sibling.tagName;\n        return {\n          name,\n          index: findIndex(selection.dom, name, sibling)\n        };\n      }\n      return getLocation(trim, selection, normalized, rng);\n    };\n    const getCaretBookmark = selection => {\n      const rng = selection.getRng();\n      return {\n        start: create$a(selection.dom.getRoot(), CaretPosition.fromRangeStart(rng)),\n        end: create$a(selection.dom.getRoot(), CaretPosition.fromRangeEnd(rng)),\n        forward: selection.isForward()\n      };\n    };\n    const getRangeBookmark = selection => {\n      return {\n        rng: selection.getRng(),\n        forward: selection.isForward()\n      };\n    };\n    const createBookmarkSpan = (dom, id, filled) => {\n      const args = {\n        'data-mce-type': 'bookmark',\n        id,\n        'style': 'overflow:hidden;line-height:0px'\n      };\n      return filled ? dom.create('span', args, '&#xFEFF;') : dom.create('span', args);\n    };\n    const getPersistentBookmark = (selection, filled) => {\n      const dom = selection.dom;\n      let rng = selection.getRng();\n      const id = dom.uniqueId();\n      const collapsed = selection.isCollapsed();\n      const element = selection.getNode();\n      const name = element.nodeName;\n      const forward = selection.isForward();\n      if (name === 'IMG') {\n        return {\n          name,\n          index: findIndex(dom, name, element)\n        };\n      }\n      const rng2 = normalizeTableCellSelection(rng.cloneRange());\n      if (!collapsed) {\n        rng2.collapse(false);\n        const endBookmarkNode = createBookmarkSpan(dom, id + '_end', filled);\n        rangeInsertNode(dom, rng2, endBookmarkNode);\n      }\n      rng = normalizeTableCellSelection(rng);\n      rng.collapse(true);\n      const startBookmarkNode = createBookmarkSpan(dom, id + '_start', filled);\n      rangeInsertNode(dom, rng, startBookmarkNode);\n      selection.moveToBookmark({\n        id,\n        keep: true,\n        forward\n      });\n      return {\n        id,\n        forward\n      };\n    };\n    const getBookmark$3 = (selection, type, normalized = false) => {\n      if (type === 2) {\n        return getOffsetBookmark(trim$2, normalized, selection);\n      } else if (type === 3) {\n        return getCaretBookmark(selection);\n      } else if (type) {\n        return getRangeBookmark(selection);\n      } else {\n        return getPersistentBookmark(selection, false);\n      }\n    };\n    const getUndoBookmark = curry(getOffsetBookmark, identity, true);\n\n    const value$1 = value => {\n      const applyHelper = fn => fn(value);\n      const constHelper = constant(value);\n      const outputHelper = () => output;\n      const output = {\n        tag: true,\n        inner: value,\n        fold: (_onError, onValue) => onValue(value),\n        isValue: always,\n        isError: never,\n        map: mapper => Result.value(mapper(value)),\n        mapError: outputHelper,\n        bind: applyHelper,\n        exists: applyHelper,\n        forall: applyHelper,\n        getOr: constHelper,\n        or: outputHelper,\n        getOrThunk: constHelper,\n        orThunk: outputHelper,\n        getOrDie: constHelper,\n        each: fn => {\n          fn(value);\n        },\n        toOptional: () => Optional.some(value)\n      };\n      return output;\n    };\n    const error = error => {\n      const outputHelper = () => output;\n      const output = {\n        tag: false,\n        inner: error,\n        fold: (onError, _onValue) => onError(error),\n        isValue: never,\n        isError: always,\n        map: outputHelper,\n        mapError: mapper => Result.error(mapper(error)),\n        bind: outputHelper,\n        exists: never,\n        forall: always,\n        getOr: identity,\n        or: identity,\n        getOrThunk: apply$1,\n        orThunk: apply$1,\n        getOrDie: die(String(error)),\n        each: noop,\n        toOptional: Optional.none\n      };\n      return output;\n    };\n    const fromOption = (optional, err) => optional.fold(() => error(err), value$1);\n    const Result = {\n      value: value$1,\n      error,\n      fromOption\n    };\n\n    const generate = cases => {\n      if (!isArray$1(cases)) {\n        throw new Error('cases must be an array');\n      }\n      if (cases.length === 0) {\n        throw new Error('there must be at least one case');\n      }\n      const constructors = [];\n      const adt = {};\n      each$e(cases, (acase, count) => {\n        const keys$1 = keys(acase);\n        if (keys$1.length !== 1) {\n          throw new Error('one and only one name per case');\n        }\n        const key = keys$1[0];\n        const value = acase[key];\n        if (adt[key] !== undefined) {\n          throw new Error('duplicate key detected:' + key);\n        } else if (key === 'cata') {\n          throw new Error('cannot have a case named cata (sorry)');\n        } else if (!isArray$1(value)) {\n          throw new Error('case arguments must be an array');\n        }\n        constructors.push(key);\n        adt[key] = (...args) => {\n          const argLength = args.length;\n          if (argLength !== value.length) {\n            throw new Error('Wrong number of arguments to case ' + key + '. Expected ' + value.length + ' (' + value + '), got ' + argLength);\n          }\n          const match = branches => {\n            const branchKeys = keys(branches);\n            if (constructors.length !== branchKeys.length) {\n              throw new Error('Wrong number of arguments to match. Expected: ' + constructors.join(',') + '\\nActual: ' + branchKeys.join(','));\n            }\n            const allReqd = forall(constructors, reqKey => {\n              return contains$2(branchKeys, reqKey);\n            });\n            if (!allReqd) {\n              throw new Error('Not all branches were specified when using match. Specified: ' + branchKeys.join(', ') + '\\nRequired: ' + constructors.join(', '));\n            }\n            return branches[key].apply(null, args);\n          };\n          return {\n            fold: (...foldArgs) => {\n              if (foldArgs.length !== cases.length) {\n                throw new Error('Wrong number of arguments to fold. Expected ' + cases.length + ', got ' + foldArgs.length);\n              }\n              const target = foldArgs[count];\n              return target.apply(null, args);\n            },\n            match,\n            log: label => {\n              console.log(label, {\n                constructors,\n                constructor: key,\n                params: args\n              });\n            }\n          };\n        };\n      });\n      return adt;\n    };\n    const Adt = { generate };\n\n    Adt.generate([\n      {\n        bothErrors: [\n          'error1',\n          'error2'\n        ]\n      },\n      {\n        firstError: [\n          'error1',\n          'value2'\n        ]\n      },\n      {\n        secondError: [\n          'value1',\n          'error2'\n        ]\n      },\n      {\n        bothValues: [\n          'value1',\n          'value2'\n        ]\n      }\n    ]);\n    const partition$1 = results => {\n      const errors = [];\n      const values = [];\n      each$e(results, result => {\n        result.fold(err => {\n          errors.push(err);\n        }, value => {\n          values.push(value);\n        });\n      });\n      return {\n        errors,\n        values\n      };\n    };\n\n    const isInlinePattern = pattern => pattern.type === 'inline-command' || pattern.type === 'inline-format';\n    const isBlockPattern = pattern => pattern.type === 'block-command' || pattern.type === 'block-format';\n    const hasBlockTrigger = (pattern, trigger) => (pattern.type === 'block-command' || pattern.type === 'block-format') && pattern.trigger === trigger;\n    const normalizePattern = pattern => {\n      var _a;\n      const err = message => Result.error({\n        message,\n        pattern\n      });\n      const formatOrCmd = (name, onFormat, onCommand) => {\n        if (pattern.format !== undefined) {\n          let formats;\n          if (isArray$1(pattern.format)) {\n            if (!forall(pattern.format, isString)) {\n              return err(name + ' pattern has non-string items in the `format` array');\n            }\n            formats = pattern.format;\n          } else if (isString(pattern.format)) {\n            formats = [pattern.format];\n          } else {\n            return err(name + ' pattern has non-string `format` parameter');\n          }\n          return Result.value(onFormat(formats));\n        } else if (pattern.cmd !== undefined) {\n          if (!isString(pattern.cmd)) {\n            return err(name + ' pattern has non-string `cmd` parameter');\n          }\n          return Result.value(onCommand(pattern.cmd, pattern.value));\n        } else {\n          return err(name + ' pattern is missing both `format` and `cmd` parameters');\n        }\n      };\n      if (!isObject(pattern)) {\n        return err('Raw pattern is not an object');\n      }\n      if (!isString(pattern.start)) {\n        return err('Raw pattern is missing `start` parameter');\n      }\n      if (pattern.end !== undefined) {\n        if (!isString(pattern.end)) {\n          return err('Inline pattern has non-string `end` parameter');\n        }\n        if (pattern.start.length === 0 && pattern.end.length === 0) {\n          return err('Inline pattern has empty `start` and `end` parameters');\n        }\n        let start = pattern.start;\n        let end = pattern.end;\n        if (end.length === 0) {\n          end = start;\n          start = '';\n        }\n        return formatOrCmd('Inline', format => ({\n          type: 'inline-format',\n          start,\n          end,\n          format\n        }), (cmd, value) => ({\n          type: 'inline-command',\n          start,\n          end,\n          cmd,\n          value\n        }));\n      } else if (pattern.replacement !== undefined) {\n        if (!isString(pattern.replacement)) {\n          return err('Replacement pattern has non-string `replacement` parameter');\n        }\n        if (pattern.start.length === 0) {\n          return err('Replacement pattern has empty `start` parameter');\n        }\n        return Result.value({\n          type: 'inline-command',\n          start: '',\n          end: pattern.start,\n          cmd: 'mceInsertContent',\n          value: pattern.replacement\n        });\n      } else {\n        const trigger = (_a = pattern.trigger) !== null && _a !== void 0 ? _a : 'space';\n        if (pattern.start.length === 0) {\n          return err('Block pattern has empty `start` parameter');\n        }\n        return formatOrCmd('Block', formats => ({\n          type: 'block-format',\n          start: pattern.start,\n          format: formats[0],\n          trigger\n        }), (command, commandValue) => ({\n          type: 'block-command',\n          start: pattern.start,\n          cmd: command,\n          value: commandValue,\n          trigger\n        }));\n      }\n    };\n    const getBlockPatterns = patterns => filter$5(patterns, isBlockPattern);\n    const getInlinePatterns = patterns => filter$5(patterns, isInlinePattern);\n    const createPatternSet = (patterns, dynamicPatternsLookup) => ({\n      inlinePatterns: getInlinePatterns(patterns),\n      blockPatterns: getBlockPatterns(patterns),\n      dynamicPatternsLookup\n    });\n    const filterByTrigger = (patterns, trigger) => {\n      return {\n        ...patterns,\n        blockPatterns: filter$5(patterns.blockPatterns, pattern => hasBlockTrigger(pattern, trigger))\n      };\n    };\n    const fromRawPatterns = patterns => {\n      const normalized = partition$1(map$3(patterns, normalizePattern));\n      each$e(normalized.errors, err => console.error(err.message, err.pattern));\n      return normalized.values;\n    };\n    const fromRawPatternsLookup = lookupFn => {\n      return ctx => {\n        const rawPatterns = lookupFn(ctx);\n        return fromRawPatterns(rawPatterns);\n      };\n    };\n\n    const deviceDetection$1 = detect$1().deviceType;\n    const isTouch = deviceDetection$1.isTouch();\n    const DOM$a = DOMUtils.DOM;\n    const getHash = value => {\n      const items = value.indexOf('=') > 0 ? value.split(/[;,](?![^=;,]*(?:[;,]|$))/) : value.split(',');\n      return foldl(items, (output, item) => {\n        const arr = item.split('=');\n        const key = arr[0];\n        const val = arr.length > 1 ? arr[1] : key;\n        output[trim$4(key)] = trim$4(val);\n        return output;\n      }, {});\n    };\n    const isRegExp = x => is$4(x, RegExp);\n    const option = name => editor => editor.options.get(name);\n    const stringOrObjectProcessor = value => isString(value) || isObject(value);\n    const bodyOptionProcessor = (editor, defaultValue = '') => value => {\n      const valid = isString(value);\n      if (valid) {\n        if (value.indexOf('=') !== -1) {\n          const bodyObj = getHash(value);\n          return {\n            value: get$a(bodyObj, editor.id).getOr(defaultValue),\n            valid\n          };\n        } else {\n          return {\n            value,\n            valid\n          };\n        }\n      } else {\n        return {\n          valid: false,\n          message: 'Must be a string.'\n        };\n      }\n    };\n    const register$7 = editor => {\n      const registerOption = editor.options.register;\n      registerOption('id', {\n        processor: 'string',\n        default: editor.id\n      });\n      registerOption('selector', { processor: 'string' });\n      registerOption('target', { processor: 'object' });\n      registerOption('suffix', { processor: 'string' });\n      registerOption('cache_suffix', { processor: 'string' });\n      registerOption('base_url', { processor: 'string' });\n      registerOption('referrer_policy', {\n        processor: 'string',\n        default: ''\n      });\n      registerOption('language_load', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('inline', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('iframe_attrs', {\n        processor: 'object',\n        default: {}\n      });\n      registerOption('doctype', {\n        processor: 'string',\n        default: '<!DOCTYPE html>'\n      });\n      registerOption('document_base_url', {\n        processor: 'string',\n        default: editor.documentBaseUrl\n      });\n      registerOption('body_id', {\n        processor: bodyOptionProcessor(editor, 'tinymce'),\n        default: 'tinymce'\n      });\n      registerOption('body_class', {\n        processor: bodyOptionProcessor(editor),\n        default: ''\n      });\n      registerOption('content_security_policy', {\n        processor: 'string',\n        default: ''\n      });\n      registerOption('br_in_pre', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('forced_root_block', {\n        processor: value => {\n          const valid = isString(value) && isNotEmpty(value);\n          if (valid) {\n            return {\n              value,\n              valid\n            };\n          } else {\n            return {\n              valid: false,\n              message: 'Must be a non-empty string.'\n            };\n          }\n        },\n        default: 'p'\n      });\n      registerOption('forced_root_block_attrs', {\n        processor: 'object',\n        default: {}\n      });\n      registerOption('newline_behavior', {\n        processor: value => {\n          const valid = contains$2([\n            'block',\n            'linebreak',\n            'invert',\n            'default'\n          ], value);\n          return valid ? {\n            value,\n            valid\n          } : {\n            valid: false,\n            message: 'Must be one of: block, linebreak, invert or default.'\n          };\n        },\n        default: 'default'\n      });\n      registerOption('br_newline_selector', {\n        processor: 'string',\n        default: '.mce-toc h2,figcaption,caption'\n      });\n      registerOption('no_newline_selector', {\n        processor: 'string',\n        default: ''\n      });\n      registerOption('keep_styles', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('end_container_on_empty_block', {\n        processor: value => {\n          if (isBoolean(value)) {\n            return {\n              valid: true,\n              value\n            };\n          } else if (isString(value)) {\n            return {\n              valid: true,\n              value\n            };\n          } else {\n            return {\n              valid: false,\n              message: 'Must be boolean or a string'\n            };\n          }\n        },\n        default: 'blockquote'\n      });\n      registerOption('font_size_style_values', {\n        processor: 'string',\n        default: 'xx-small,x-small,small,medium,large,x-large,xx-large'\n      });\n      registerOption('font_size_legacy_values', {\n        processor: 'string',\n        default: 'xx-small,small,medium,large,x-large,xx-large,300%'\n      });\n      registerOption('font_size_classes', {\n        processor: 'string',\n        default: ''\n      });\n      registerOption('automatic_uploads', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('images_reuse_filename', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('images_replace_blob_uris', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('icons', {\n        processor: 'string',\n        default: ''\n      });\n      registerOption('icons_url', {\n        processor: 'string',\n        default: ''\n      });\n      registerOption('images_upload_url', {\n        processor: 'string',\n        default: ''\n      });\n      registerOption('images_upload_base_path', {\n        processor: 'string',\n        default: ''\n      });\n      registerOption('images_upload_credentials', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('images_upload_handler', { processor: 'function' });\n      registerOption('language', {\n        processor: 'string',\n        default: 'en'\n      });\n      registerOption('language_url', {\n        processor: 'string',\n        default: ''\n      });\n      registerOption('entity_encoding', {\n        processor: 'string',\n        default: 'named'\n      });\n      registerOption('indent', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('indent_before', {\n        processor: 'string',\n        default: 'p,h1,h2,h3,h4,h5,h6,blockquote,div,title,style,pre,script,td,th,ul,ol,li,dl,dt,dd,area,table,thead,' + 'tfoot,tbody,tr,section,details,summary,article,hgroup,aside,figure,figcaption,option,optgroup,datalist'\n      });\n      registerOption('indent_after', {\n        processor: 'string',\n        default: 'p,h1,h2,h3,h4,h5,h6,blockquote,div,title,style,pre,script,td,th,ul,ol,li,dl,dt,dd,area,table,thead,' + 'tfoot,tbody,tr,section,details,summary,article,hgroup,aside,figure,figcaption,option,optgroup,datalist'\n      });\n      registerOption('indent_use_margin', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('indentation', {\n        processor: 'string',\n        default: '40px'\n      });\n      registerOption('content_css', {\n        processor: value => {\n          const valid = value === false || isString(value) || isArrayOf(value, isString);\n          if (valid) {\n            if (isString(value)) {\n              return {\n                value: map$3(value.split(','), trim$4),\n                valid\n              };\n            } else if (isArray$1(value)) {\n              return {\n                value,\n                valid\n              };\n            } else if (value === false) {\n              return {\n                value: [],\n                valid\n              };\n            } else {\n              return {\n                value,\n                valid\n              };\n            }\n          } else {\n            return {\n              valid: false,\n              message: 'Must be false, a string or an array of strings.'\n            };\n          }\n        },\n        default: isInline$1(editor) ? [] : ['default']\n      });\n      registerOption('content_style', { processor: 'string' });\n      registerOption('content_css_cors', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('font_css', {\n        processor: value => {\n          const valid = isString(value) || isArrayOf(value, isString);\n          if (valid) {\n            const newValue = isArray$1(value) ? value : map$3(value.split(','), trim$4);\n            return {\n              value: newValue,\n              valid\n            };\n          } else {\n            return {\n              valid: false,\n              message: 'Must be a string or an array of strings.'\n            };\n          }\n        },\n        default: []\n      });\n      registerOption('inline_boundaries', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('inline_boundaries_selector', {\n        processor: 'string',\n        default: 'a[href],code,span.mce-annotation'\n      });\n      registerOption('object_resizing', {\n        processor: value => {\n          const valid = isBoolean(value) || isString(value);\n          if (valid) {\n            if (value === false || deviceDetection$1.isiPhone() || deviceDetection$1.isiPad()) {\n              return {\n                value: '',\n                valid\n              };\n            } else {\n              return {\n                value: value === true ? 'table,img,figure.image,div,video,iframe' : value,\n                valid\n              };\n            }\n          } else {\n            return {\n              valid: false,\n              message: 'Must be boolean or a string'\n            };\n          }\n        },\n        default: !isTouch\n      });\n      registerOption('resize_img_proportional', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('event_root', { processor: 'string' });\n      registerOption('service_message', { processor: 'string' });\n      registerOption('theme', {\n        processor: value => value === false || isString(value) || isFunction(value),\n        default: 'silver'\n      });\n      registerOption('theme_url', { processor: 'string' });\n      registerOption('formats', { processor: 'object' });\n      registerOption('format_empty_lines', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('format_noneditable_selector', {\n        processor: 'string',\n        default: ''\n      });\n      registerOption('preview_styles', {\n        processor: value => {\n          const valid = value === false || isString(value);\n          if (valid) {\n            return {\n              value: value === false ? '' : value,\n              valid\n            };\n          } else {\n            return {\n              valid: false,\n              message: 'Must be false or a string'\n            };\n          }\n        },\n        default: 'font-family font-size font-weight font-style text-decoration text-transform color background-color border border-radius outline text-shadow'\n      });\n      registerOption('custom_ui_selector', {\n        processor: 'string',\n        default: ''\n      });\n      registerOption('hidden_input', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('submit_patch', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('encoding', { processor: 'string' });\n      registerOption('add_form_submit_trigger', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('add_unload_trigger', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('custom_undo_redo_levels', {\n        processor: 'number',\n        default: 0\n      });\n      registerOption('disable_nodechange', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('readonly', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('editable_root', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('plugins', {\n        processor: 'string[]',\n        default: []\n      });\n      registerOption('external_plugins', { processor: 'object' });\n      registerOption('forced_plugins', { processor: 'string[]' });\n      registerOption('model', {\n        processor: 'string',\n        default: editor.hasPlugin('rtc') ? 'plugin' : 'dom'\n      });\n      registerOption('model_url', { processor: 'string' });\n      registerOption('block_unsupported_drop', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('visual', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('visual_table_class', {\n        processor: 'string',\n        default: 'mce-item-table'\n      });\n      registerOption('visual_anchor_class', {\n        processor: 'string',\n        default: 'mce-item-anchor'\n      });\n      registerOption('iframe_aria_text', {\n        processor: 'string',\n        default: 'Rich Text Area. Press ALT-0 for help.'\n      });\n      registerOption('setup', { processor: 'function' });\n      registerOption('init_instance_callback', { processor: 'function' });\n      registerOption('url_converter', {\n        processor: 'function',\n        default: editor.convertURL\n      });\n      registerOption('url_converter_scope', {\n        processor: 'object',\n        default: editor\n      });\n      registerOption('urlconverter_callback', { processor: 'function' });\n      registerOption('allow_conditional_comments', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('allow_html_data_urls', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('allow_svg_data_urls', { processor: 'boolean' });\n      registerOption('allow_html_in_named_anchor', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('allow_script_urls', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('allow_unsafe_link_target', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('allow_mathml_annotation_encodings', {\n        processor: value => {\n          const valid = isArrayOf(value, isString);\n          return valid ? {\n            value,\n            valid\n          } : {\n            valid: false,\n            message: 'Must be an array of strings.'\n          };\n        },\n        default: []\n      });\n      registerOption('convert_fonts_to_spans', {\n        processor: 'boolean',\n        default: true,\n        deprecated: true\n      });\n      registerOption('fix_list_elements', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('preserve_cdata', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('remove_trailing_brs', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('pad_empty_with_br', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('inline_styles', {\n        processor: 'boolean',\n        default: true,\n        deprecated: true\n      });\n      registerOption('element_format', {\n        processor: 'string',\n        default: 'html'\n      });\n      registerOption('entities', { processor: 'string' });\n      registerOption('schema', {\n        processor: 'string',\n        default: 'html5'\n      });\n      registerOption('convert_urls', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('relative_urls', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('remove_script_host', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('custom_elements', { processor: stringOrObjectProcessor });\n      registerOption('extended_valid_elements', { processor: 'string' });\n      registerOption('invalid_elements', { processor: 'string' });\n      registerOption('invalid_styles', { processor: stringOrObjectProcessor });\n      registerOption('valid_children', { processor: 'string' });\n      registerOption('valid_classes', { processor: stringOrObjectProcessor });\n      registerOption('valid_elements', { processor: 'string' });\n      registerOption('valid_styles', { processor: stringOrObjectProcessor });\n      registerOption('verify_html', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('auto_focus', { processor: value => isString(value) || value === true });\n      registerOption('browser_spellcheck', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('protect', { processor: 'array' });\n      registerOption('images_file_types', {\n        processor: 'string',\n        default: 'jpeg,jpg,jpe,jfi,jif,jfif,png,gif,bmp,webp'\n      });\n      registerOption('deprecation_warnings', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('a11y_advanced_options', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('api_key', { processor: 'string' });\n      registerOption('license_key', { processor: 'string' });\n      registerOption('paste_block_drop', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('paste_data_images', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('paste_preprocess', { processor: 'function' });\n      registerOption('paste_postprocess', { processor: 'function' });\n      registerOption('paste_webkit_styles', {\n        processor: 'string',\n        default: 'none'\n      });\n      registerOption('paste_remove_styles_if_webkit', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('paste_merge_formats', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('smart_paste', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('paste_as_text', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('paste_tab_spaces', {\n        processor: 'number',\n        default: 4\n      });\n      registerOption('text_patterns', {\n        processor: value => {\n          if (isArrayOf(value, isObject) || value === false) {\n            const patterns = value === false ? [] : value;\n            return {\n              value: fromRawPatterns(patterns),\n              valid: true\n            };\n          } else {\n            return {\n              valid: false,\n              message: 'Must be an array of objects or false.'\n            };\n          }\n        },\n        default: [\n          {\n            start: '*',\n            end: '*',\n            format: 'italic'\n          },\n          {\n            start: '**',\n            end: '**',\n            format: 'bold'\n          },\n          {\n            start: '#',\n            format: 'h1',\n            trigger: 'space'\n          },\n          {\n            start: '##',\n            format: 'h2',\n            trigger: 'space'\n          },\n          {\n            start: '###',\n            format: 'h3',\n            trigger: 'space'\n          },\n          {\n            start: '####',\n            format: 'h4',\n            trigger: 'space'\n          },\n          {\n            start: '#####',\n            format: 'h5',\n            trigger: 'space'\n          },\n          {\n            start: '######',\n            format: 'h6',\n            trigger: 'space'\n          },\n          {\n            start: '1.',\n            cmd: 'InsertOrderedList',\n            trigger: 'space'\n          },\n          {\n            start: '*',\n            cmd: 'InsertUnorderedList',\n            trigger: 'space'\n          },\n          {\n            start: '-',\n            cmd: 'InsertUnorderedList',\n            trigger: 'space'\n          },\n          {\n            start: '>',\n            cmd: 'mceBlockQuote',\n            trigger: 'space'\n          },\n          {\n            start: '---',\n            cmd: 'InsertHorizontalRule',\n            trigger: 'space'\n          }\n        ]\n      });\n      registerOption('text_patterns_lookup', {\n        processor: value => {\n          if (isFunction(value)) {\n            return {\n              value: fromRawPatternsLookup(value),\n              valid: true\n            };\n          } else {\n            return {\n              valid: false,\n              message: 'Must be a single function'\n            };\n          }\n        },\n        default: _ctx => []\n      });\n      registerOption('noneditable_class', {\n        processor: 'string',\n        default: 'mceNonEditable'\n      });\n      registerOption('editable_class', {\n        processor: 'string',\n        default: 'mceEditable'\n      });\n      registerOption('noneditable_regexp', {\n        processor: value => {\n          if (isArrayOf(value, isRegExp)) {\n            return {\n              value,\n              valid: true\n            };\n          } else if (isRegExp(value)) {\n            return {\n              value: [value],\n              valid: true\n            };\n          } else {\n            return {\n              valid: false,\n              message: 'Must be a RegExp or an array of RegExp.'\n            };\n          }\n        },\n        default: []\n      });\n      registerOption('table_tab_navigation', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('highlight_on_focus', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('xss_sanitization', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('details_initial_state', {\n        processor: value => {\n          const valid = contains$2([\n            'inherited',\n            'collapsed',\n            'expanded'\n          ], value);\n          return valid ? {\n            value,\n            valid\n          } : {\n            valid: false,\n            message: 'Must be one of: inherited, collapsed, or expanded.'\n          };\n        },\n        default: 'inherited'\n      });\n      registerOption('details_serialized_state', {\n        processor: value => {\n          const valid = contains$2([\n            'inherited',\n            'collapsed',\n            'expanded'\n          ], value);\n          return valid ? {\n            value,\n            valid\n          } : {\n            valid: false,\n            message: 'Must be one of: inherited, collapsed, or expanded.'\n          };\n        },\n        default: 'inherited'\n      });\n      registerOption('init_content_sync', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('newdocument_content', {\n        processor: 'string',\n        default: ''\n      });\n      registerOption('sandbox_iframes', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('sandbox_iframes_exclusions', {\n        processor: 'string[]',\n        default: [\n          'youtube.com',\n          'youtu.be',\n          'vimeo.com',\n          'player.vimeo.com',\n          'dailymotion.com',\n          'embed.music.apple.com',\n          'open.spotify.com',\n          'giphy.com',\n          'dai.ly',\n          'codepen.io'\n        ]\n      });\n      registerOption('convert_unsafe_embeds', {\n        processor: 'boolean',\n        default: true\n      });\n      editor.on('ScriptsLoaded', () => {\n        registerOption('directionality', {\n          processor: 'string',\n          default: I18n.isRtl() ? 'rtl' : undefined\n        });\n        registerOption('placeholder', {\n          processor: 'string',\n          default: DOM$a.getAttrib(editor.getElement(), 'placeholder')\n        });\n      });\n    };\n    const getIframeAttrs = option('iframe_attrs');\n    const getDocType = option('doctype');\n    const getDocumentBaseUrl = option('document_base_url');\n    const getBodyId = option('body_id');\n    const getBodyClass = option('body_class');\n    const getContentSecurityPolicy = option('content_security_policy');\n    const shouldPutBrInPre$1 = option('br_in_pre');\n    const getForcedRootBlock = option('forced_root_block');\n    const getForcedRootBlockAttrs = option('forced_root_block_attrs');\n    const getNewlineBehavior = option('newline_behavior');\n    const getBrNewLineSelector = option('br_newline_selector');\n    const getNoNewLineSelector = option('no_newline_selector');\n    const shouldKeepStyles = option('keep_styles');\n    const shouldEndContainerOnEmptyBlock = option('end_container_on_empty_block');\n    const isAutomaticUploadsEnabled = option('automatic_uploads');\n    const shouldReuseFileName = option('images_reuse_filename');\n    const shouldReplaceBlobUris = option('images_replace_blob_uris');\n    const getIconPackName = option('icons');\n    const getIconsUrl = option('icons_url');\n    const getImageUploadUrl = option('images_upload_url');\n    const getImageUploadBasePath = option('images_upload_base_path');\n    const getImagesUploadCredentials = option('images_upload_credentials');\n    const getImagesUploadHandler = option('images_upload_handler');\n    const shouldUseContentCssCors = option('content_css_cors');\n    const getReferrerPolicy = option('referrer_policy');\n    const getLanguageCode = option('language');\n    const getLanguageUrl = option('language_url');\n    const shouldIndentUseMargin = option('indent_use_margin');\n    const getIndentation = option('indentation');\n    const getContentCss = option('content_css');\n    const getContentStyle = option('content_style');\n    const getFontCss = option('font_css');\n    const getDirectionality = option('directionality');\n    const getInlineBoundarySelector = option('inline_boundaries_selector');\n    const getObjectResizing = option('object_resizing');\n    const getResizeImgProportional = option('resize_img_proportional');\n    const getPlaceholder = option('placeholder');\n    const getEventRoot = option('event_root');\n    const getServiceMessage = option('service_message');\n    const getTheme = option('theme');\n    const getThemeUrl = option('theme_url');\n    const getModel = option('model');\n    const getModelUrl = option('model_url');\n    const isInlineBoundariesEnabled = option('inline_boundaries');\n    const getFormats = option('formats');\n    const getPreviewStyles = option('preview_styles');\n    const canFormatEmptyLines = option('format_empty_lines');\n    const getFormatNoneditableSelector = option('format_noneditable_selector');\n    const getCustomUiSelector = option('custom_ui_selector');\n    const isInline$1 = option('inline');\n    const hasHiddenInput = option('hidden_input');\n    const shouldPatchSubmit = option('submit_patch');\n    const shouldAddFormSubmitTrigger = option('add_form_submit_trigger');\n    const shouldAddUnloadTrigger = option('add_unload_trigger');\n    const getCustomUndoRedoLevels = option('custom_undo_redo_levels');\n    const shouldDisableNodeChange = option('disable_nodechange');\n    const isReadOnly$1 = option('readonly');\n    const hasEditableRoot$1 = option('editable_root');\n    const hasContentCssCors = option('content_css_cors');\n    const getPlugins = option('plugins');\n    const getExternalPlugins$1 = option('external_plugins');\n    const shouldBlockUnsupportedDrop = option('block_unsupported_drop');\n    const isVisualAidsEnabled = option('visual');\n    const getVisualAidsTableClass = option('visual_table_class');\n    const getVisualAidsAnchorClass = option('visual_anchor_class');\n    const getIframeAriaText = option('iframe_aria_text');\n    const getSetupCallback = option('setup');\n    const getInitInstanceCallback = option('init_instance_callback');\n    const getUrlConverterCallback = option('urlconverter_callback');\n    const getAutoFocus = option('auto_focus');\n    const shouldBrowserSpellcheck = option('browser_spellcheck');\n    const getProtect = option('protect');\n    const shouldPasteBlockDrop = option('paste_block_drop');\n    const shouldPasteDataImages = option('paste_data_images');\n    const getPastePreProcess = option('paste_preprocess');\n    const getPastePostProcess = option('paste_postprocess');\n    const getNewDocumentContent = option('newdocument_content');\n    const getPasteWebkitStyles = option('paste_webkit_styles');\n    const shouldPasteRemoveWebKitStyles = option('paste_remove_styles_if_webkit');\n    const shouldPasteMergeFormats = option('paste_merge_formats');\n    const isSmartPasteEnabled = option('smart_paste');\n    const isPasteAsTextEnabled = option('paste_as_text');\n    const getPasteTabSpaces = option('paste_tab_spaces');\n    const shouldAllowHtmlDataUrls = option('allow_html_data_urls');\n    const getTextPatterns = option('text_patterns');\n    const getTextPatternsLookup = option('text_patterns_lookup');\n    const getNonEditableClass = option('noneditable_class');\n    const getEditableClass = option('editable_class');\n    const getNonEditableRegExps = option('noneditable_regexp');\n    const shouldPreserveCData = option('preserve_cdata');\n    const shouldHighlightOnFocus = option('highlight_on_focus');\n    const shouldSanitizeXss = option('xss_sanitization');\n    const shouldUseDocumentWrite = option('init_content_sync');\n    const hasTextPatternsLookup = editor => editor.options.isSet('text_patterns_lookup');\n    const getFontStyleValues = editor => Tools.explode(editor.options.get('font_size_style_values'));\n    const getFontSizeClasses = editor => Tools.explode(editor.options.get('font_size_classes'));\n    const isEncodingXml = editor => editor.options.get('encoding') === 'xml';\n    const getAllowedImageFileTypes = editor => Tools.explode(editor.options.get('images_file_types'));\n    const hasTableTabNavigation = option('table_tab_navigation');\n    const getDetailsInitialState = option('details_initial_state');\n    const getDetailsSerializedState = option('details_serialized_state');\n    const shouldSandboxIframes = option('sandbox_iframes');\n    const getSandboxIframesExclusions = editor => editor.options.get('sandbox_iframes_exclusions');\n    const shouldConvertUnsafeEmbeds = option('convert_unsafe_embeds');\n    const getLicenseKey = option('license_key');\n    const getApiKey = option('api_key');\n\n    const isElement$3 = isElement$6;\n    const isText$5 = isText$b;\n    const removeNode$1 = node => {\n      const parentNode = node.parentNode;\n      if (parentNode) {\n        parentNode.removeChild(node);\n      }\n    };\n    const trimCount = text => {\n      const trimmedText = trim$2(text);\n      return {\n        count: text.length - trimmedText.length,\n        text: trimmedText\n      };\n    };\n    const deleteZwspChars = caretContainer => {\n      let idx;\n      while ((idx = caretContainer.data.lastIndexOf(ZWSP$1)) !== -1) {\n        caretContainer.deleteData(idx, 1);\n      }\n    };\n    const removeUnchanged = (caretContainer, pos) => {\n      remove$2(caretContainer);\n      return pos;\n    };\n    const removeTextAndReposition = (caretContainer, pos) => {\n      const before = trimCount(caretContainer.data.substr(0, pos.offset()));\n      const after = trimCount(caretContainer.data.substr(pos.offset()));\n      const text = before.text + after.text;\n      if (text.length > 0) {\n        deleteZwspChars(caretContainer);\n        return CaretPosition(caretContainer, pos.offset() - before.count);\n      } else {\n        return pos;\n      }\n    };\n    const removeElementAndReposition = (caretContainer, pos) => {\n      const parentNode = pos.container();\n      const newPosition = indexOf$1(from(parentNode.childNodes), caretContainer).map(index => {\n        return index < pos.offset() ? CaretPosition(parentNode, pos.offset() - 1) : pos;\n      }).getOr(pos);\n      remove$2(caretContainer);\n      return newPosition;\n    };\n    const removeTextCaretContainer = (caretContainer, pos) => isText$5(caretContainer) && pos.container() === caretContainer ? removeTextAndReposition(caretContainer, pos) : removeUnchanged(caretContainer, pos);\n    const removeElementCaretContainer = (caretContainer, pos) => pos.container() === caretContainer.parentNode ? removeElementAndReposition(caretContainer, pos) : removeUnchanged(caretContainer, pos);\n    const removeAndReposition = (container, pos) => CaretPosition.isTextPosition(pos) ? removeTextCaretContainer(container, pos) : removeElementCaretContainer(container, pos);\n    const remove$2 = caretContainerNode => {\n      if (isElement$3(caretContainerNode) && isCaretContainer$2(caretContainerNode)) {\n        if (hasContent(caretContainerNode)) {\n          caretContainerNode.removeAttribute('data-mce-caret');\n        } else {\n          removeNode$1(caretContainerNode);\n        }\n      }\n      if (isText$5(caretContainerNode)) {\n        deleteZwspChars(caretContainerNode);\n        if (caretContainerNode.data.length === 0) {\n          removeNode$1(caretContainerNode);\n        }\n      }\n    };\n\n    const isContentEditableFalse$8 = isContentEditableFalse$b;\n    const isMedia$1 = isMedia$2;\n    const isTableCell$1 = isTableCell$3;\n    const inlineFakeCaretSelector = '*[contentEditable=false],video,audio,embed,object';\n    const getAbsoluteClientRect = (root, element, before) => {\n      const clientRect = collapse(element.getBoundingClientRect(), before);\n      let scrollX;\n      let scrollY;\n      if (root.tagName === 'BODY') {\n        const docElm = root.ownerDocument.documentElement;\n        scrollX = root.scrollLeft || docElm.scrollLeft;\n        scrollY = root.scrollTop || docElm.scrollTop;\n      } else {\n        const rootRect = root.getBoundingClientRect();\n        scrollX = root.scrollLeft - rootRect.left;\n        scrollY = root.scrollTop - rootRect.top;\n      }\n      clientRect.left += scrollX;\n      clientRect.right += scrollX;\n      clientRect.top += scrollY;\n      clientRect.bottom += scrollY;\n      clientRect.width = 1;\n      let margin = element.offsetWidth - element.clientWidth;\n      if (margin > 0) {\n        if (before) {\n          margin *= -1;\n        }\n        clientRect.left += margin;\n        clientRect.right += margin;\n      }\n      return clientRect;\n    };\n    const trimInlineCaretContainers = root => {\n      var _a, _b;\n      const fakeCaretTargetNodes = descendants(SugarElement.fromDom(root), inlineFakeCaretSelector);\n      for (let i = 0; i < fakeCaretTargetNodes.length; i++) {\n        const node = fakeCaretTargetNodes[i].dom;\n        let sibling = node.previousSibling;\n        if (endsWithCaretContainer$1(sibling)) {\n          const data = sibling.data;\n          if (data.length === 1) {\n            (_a = sibling.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(sibling);\n          } else {\n            sibling.deleteData(data.length - 1, 1);\n          }\n        }\n        sibling = node.nextSibling;\n        if (startsWithCaretContainer$1(sibling)) {\n          const data = sibling.data;\n          if (data.length === 1) {\n            (_b = sibling.parentNode) === null || _b === void 0 ? void 0 : _b.removeChild(sibling);\n          } else {\n            sibling.deleteData(0, 1);\n          }\n        }\n      }\n    };\n    const FakeCaret = (editor, root, isBlock, hasFocus) => {\n      const lastVisualCaret = value$2();\n      let cursorInterval;\n      let caretContainerNode;\n      const caretBlock = getForcedRootBlock(editor);\n      const dom = editor.dom;\n      const show = (before, element) => {\n        let rng;\n        hide();\n        if (isTableCell$1(element)) {\n          return null;\n        }\n        if (isBlock(element)) {\n          const caretContainer = insertBlock(caretBlock, element, before);\n          const clientRect = getAbsoluteClientRect(root, element, before);\n          dom.setStyle(caretContainer, 'top', clientRect.top);\n          dom.setStyle(caretContainer, 'caret-color', 'transparent');\n          caretContainerNode = caretContainer;\n          const caret = dom.create('div', {\n            'class': 'mce-visual-caret',\n            'data-mce-bogus': 'all'\n          });\n          dom.setStyles(caret, { ...clientRect });\n          dom.add(root, caret);\n          lastVisualCaret.set({\n            caret,\n            element,\n            before\n          });\n          if (before) {\n            dom.addClass(caret, 'mce-visual-caret-before');\n          }\n          startBlink();\n          rng = element.ownerDocument.createRange();\n          rng.setStart(caretContainer, 0);\n          rng.setEnd(caretContainer, 0);\n        } else {\n          caretContainerNode = insertInline$1(element, before);\n          rng = element.ownerDocument.createRange();\n          if (isInlineFakeCaretTarget(caretContainerNode.nextSibling)) {\n            rng.setStart(caretContainerNode, 0);\n            rng.setEnd(caretContainerNode, 0);\n          } else {\n            rng.setStart(caretContainerNode, 1);\n            rng.setEnd(caretContainerNode, 1);\n          }\n          return rng;\n        }\n        return rng;\n      };\n      const hide = () => {\n        trimInlineCaretContainers(root);\n        if (caretContainerNode) {\n          remove$2(caretContainerNode);\n          caretContainerNode = null;\n        }\n        lastVisualCaret.on(caretState => {\n          dom.remove(caretState.caret);\n          lastVisualCaret.clear();\n        });\n        if (cursorInterval) {\n          clearInterval(cursorInterval);\n          cursorInterval = undefined;\n        }\n      };\n      const startBlink = () => {\n        cursorInterval = setInterval(() => {\n          lastVisualCaret.on(caretState => {\n            if (hasFocus()) {\n              dom.toggleClass(caretState.caret, 'mce-visual-caret-hidden');\n            } else {\n              dom.addClass(caretState.caret, 'mce-visual-caret-hidden');\n            }\n          });\n        }, 500);\n      };\n      const reposition = () => {\n        lastVisualCaret.on(caretState => {\n          const clientRect = getAbsoluteClientRect(root, caretState.element, caretState.before);\n          dom.setStyles(caretState.caret, { ...clientRect });\n        });\n      };\n      const destroy = () => clearInterval(cursorInterval);\n      const getCss = () => '.mce-visual-caret {' + 'position: absolute;' + 'background-color: black;' + 'background-color: currentcolor;' + '}' + '.mce-visual-caret-hidden {' + 'display: none;' + '}' + '*[data-mce-caret] {' + 'position: absolute;' + 'left: -1000px;' + 'right: auto;' + 'top: 0;' + 'margin: 0;' + 'padding: 0;' + '}';\n      return {\n        show,\n        hide,\n        getCss,\n        reposition,\n        destroy\n      };\n    };\n    const isFakeCaretTableBrowser = () => Env.browser.isFirefox();\n    const isInlineFakeCaretTarget = node => isContentEditableFalse$8(node) || isMedia$1(node);\n    const isFakeCaretTarget = node => {\n      const isTarget = isInlineFakeCaretTarget(node) || isTable$2(node) && isFakeCaretTableBrowser();\n      return isTarget && parentElement(SugarElement.fromDom(node)).exists(isEditable$2);\n    };\n\n    const isContentEditableTrue$1 = isContentEditableTrue$3;\n    const isContentEditableFalse$7 = isContentEditableFalse$b;\n    const isMedia = isMedia$2;\n    const isBlockLike = matchStyleValues('display', 'block table table-cell table-row table-caption list-item');\n    const isCaretContainer = isCaretContainer$2;\n    const isCaretContainerBlock = isCaretContainerBlock$1;\n    const isElement$2 = isElement$6;\n    const isText$4 = isText$b;\n    const isCaretCandidate$1 = isCaretCandidate$3;\n    const isForwards = direction => direction > 0;\n    const isBackwards = direction => direction < 0;\n    const skipCaretContainers = (walk, shallow) => {\n      let node;\n      while (node = walk(shallow)) {\n        if (!isCaretContainerBlock(node)) {\n          return node;\n        }\n      }\n      return null;\n    };\n    const findNode = (node, direction, predicateFn, rootNode, shallow) => {\n      const walker = new DomTreeWalker(node, rootNode);\n      const isCefOrCaretContainer = isContentEditableFalse$7(node) || isCaretContainerBlock(node);\n      let tempNode;\n      if (isBackwards(direction)) {\n        if (isCefOrCaretContainer) {\n          tempNode = skipCaretContainers(walker.prev.bind(walker), true);\n          if (predicateFn(tempNode)) {\n            return tempNode;\n          }\n        }\n        while (tempNode = skipCaretContainers(walker.prev.bind(walker), shallow)) {\n          if (predicateFn(tempNode)) {\n            return tempNode;\n          }\n        }\n      }\n      if (isForwards(direction)) {\n        if (isCefOrCaretContainer) {\n          tempNode = skipCaretContainers(walker.next.bind(walker), true);\n          if (predicateFn(tempNode)) {\n            return tempNode;\n          }\n        }\n        while (tempNode = skipCaretContainers(walker.next.bind(walker), shallow)) {\n          if (predicateFn(tempNode)) {\n            return tempNode;\n          }\n        }\n      }\n      return null;\n    };\n    const getEditingHost = (node, rootNode) => {\n      const isCETrue = node => isContentEditableTrue$1(node.dom);\n      const isRoot = node => node.dom === rootNode;\n      return ancestor$4(SugarElement.fromDom(node), isCETrue, isRoot).map(elm => elm.dom).getOr(rootNode);\n    };\n    const getParentBlock$3 = (node, rootNode) => {\n      while (node && node !== rootNode) {\n        if (isBlockLike(node)) {\n          return node;\n        }\n        node = node.parentNode;\n      }\n      return null;\n    };\n    const isInSameBlock = (caretPosition1, caretPosition2, rootNode) => getParentBlock$3(caretPosition1.container(), rootNode) === getParentBlock$3(caretPosition2.container(), rootNode);\n    const getChildNodeAtRelativeOffset = (relativeOffset, caretPosition) => {\n      if (!caretPosition) {\n        return Optional.none();\n      }\n      const container = caretPosition.container();\n      const offset = caretPosition.offset();\n      if (!isElement$2(container)) {\n        return Optional.none();\n      }\n      return Optional.from(container.childNodes[offset + relativeOffset]);\n    };\n    const beforeAfter = (before, node) => {\n      var _a;\n      const doc = (_a = node.ownerDocument) !== null && _a !== void 0 ? _a : document;\n      const range = doc.createRange();\n      if (before) {\n        range.setStartBefore(node);\n        range.setEndBefore(node);\n      } else {\n        range.setStartAfter(node);\n        range.setEndAfter(node);\n      }\n      return range;\n    };\n    const isNodesInSameBlock = (root, node1, node2) => getParentBlock$3(node1, root) === getParentBlock$3(node2, root);\n    const lean = (left, root, node) => {\n      const siblingName = left ? 'previousSibling' : 'nextSibling';\n      let tempNode = node;\n      while (tempNode && tempNode !== root) {\n        let sibling = tempNode[siblingName];\n        if (sibling && isCaretContainer(sibling)) {\n          sibling = sibling[siblingName];\n        }\n        if (isContentEditableFalse$7(sibling) || isMedia(sibling)) {\n          if (isNodesInSameBlock(root, sibling, tempNode)) {\n            return sibling;\n          }\n          break;\n        }\n        if (isCaretCandidate$1(sibling)) {\n          break;\n        }\n        tempNode = tempNode.parentNode;\n      }\n      return null;\n    };\n    const before$2 = curry(beforeAfter, true);\n    const after$2 = curry(beforeAfter, false);\n    const normalizeRange = (direction, root, range) => {\n      let node;\n      const leanLeft = curry(lean, true, root);\n      const leanRight = curry(lean, false, root);\n      const container = range.startContainer;\n      const offset = range.startOffset;\n      if (isCaretContainerBlock$1(container)) {\n        const block = isText$4(container) ? container.parentNode : container;\n        const location = block.getAttribute('data-mce-caret');\n        if (location === 'before') {\n          node = block.nextSibling;\n          if (isFakeCaretTarget(node)) {\n            return before$2(node);\n          }\n        }\n        if (location === 'after') {\n          node = block.previousSibling;\n          if (isFakeCaretTarget(node)) {\n            return after$2(node);\n          }\n        }\n      }\n      if (!range.collapsed) {\n        return range;\n      }\n      if (isText$b(container)) {\n        if (isCaretContainer(container)) {\n          if (direction === 1) {\n            node = leanRight(container);\n            if (node) {\n              return before$2(node);\n            }\n            node = leanLeft(container);\n            if (node) {\n              return after$2(node);\n            }\n          }\n          if (direction === -1) {\n            node = leanLeft(container);\n            if (node) {\n              return after$2(node);\n            }\n            node = leanRight(container);\n            if (node) {\n              return before$2(node);\n            }\n          }\n          return range;\n        }\n        if (endsWithCaretContainer$1(container) && offset >= container.data.length - 1) {\n          if (direction === 1) {\n            node = leanRight(container);\n            if (node) {\n              return before$2(node);\n            }\n          }\n          return range;\n        }\n        if (startsWithCaretContainer$1(container) && offset <= 1) {\n          if (direction === -1) {\n            node = leanLeft(container);\n            if (node) {\n              return after$2(node);\n            }\n          }\n          return range;\n        }\n        if (offset === container.data.length) {\n          node = leanRight(container);\n          if (node) {\n            return before$2(node);\n          }\n          return range;\n        }\n        if (offset === 0) {\n          node = leanLeft(container);\n          if (node) {\n            return after$2(node);\n          }\n          return range;\n        }\n      }\n      return range;\n    };\n    const getRelativeCefElm = (forward, caretPosition) => getChildNodeAtRelativeOffset(forward ? 0 : -1, caretPosition).filter(isContentEditableFalse$7);\n    const getNormalizedRangeEndPoint = (direction, root, range) => {\n      const normalizedRange = normalizeRange(direction, root, range);\n      return direction === -1 ? CaretPosition.fromRangeStart(normalizedRange) : CaretPosition.fromRangeEnd(normalizedRange);\n    };\n    const getElementFromPosition = pos => Optional.from(pos.getNode()).map(SugarElement.fromDom);\n    const getElementFromPrevPosition = pos => Optional.from(pos.getNode(true)).map(SugarElement.fromDom);\n    const getVisualCaretPosition = (walkFn, caretPosition) => {\n      let pos = caretPosition;\n      while (pos = walkFn(pos)) {\n        if (pos.isVisible()) {\n          return pos;\n        }\n      }\n      return pos;\n    };\n    const isMoveInsideSameBlock = (from, to) => {\n      const inSameBlock = isInSameBlock(from, to);\n      if (!inSameBlock && isBr$6(from.getNode())) {\n        return true;\n      }\n      return inSameBlock;\n    };\n\n    var HDirection;\n    (function (HDirection) {\n      HDirection[HDirection['Backwards'] = -1] = 'Backwards';\n      HDirection[HDirection['Forwards'] = 1] = 'Forwards';\n    }(HDirection || (HDirection = {})));\n    const isContentEditableFalse$6 = isContentEditableFalse$b;\n    const isText$3 = isText$b;\n    const isElement$1 = isElement$6;\n    const isBr$2 = isBr$6;\n    const isCaretCandidate = isCaretCandidate$3;\n    const isAtomic = isAtomic$1;\n    const isEditableCaretCandidate = isEditableCaretCandidate$1;\n    const getParents$3 = (node, root) => {\n      const parents = [];\n      let tempNode = node;\n      while (tempNode && tempNode !== root) {\n        parents.push(tempNode);\n        tempNode = tempNode.parentNode;\n      }\n      return parents;\n    };\n    const nodeAtIndex = (container, offset) => {\n      if (container.hasChildNodes() && offset < container.childNodes.length) {\n        return container.childNodes[offset];\n      }\n      return null;\n    };\n    const getCaretCandidatePosition = (direction, node) => {\n      if (isForwards(direction)) {\n        if (isCaretCandidate(node.previousSibling) && !isText$3(node.previousSibling)) {\n          return CaretPosition.before(node);\n        }\n        if (isText$3(node)) {\n          return CaretPosition(node, 0);\n        }\n      }\n      if (isBackwards(direction)) {\n        if (isCaretCandidate(node.nextSibling) && !isText$3(node.nextSibling)) {\n          return CaretPosition.after(node);\n        }\n        if (isText$3(node)) {\n          return CaretPosition(node, node.data.length);\n        }\n      }\n      if (isBackwards(direction)) {\n        if (isBr$2(node)) {\n          return CaretPosition.before(node);\n        }\n        return CaretPosition.after(node);\n      }\n      return CaretPosition.before(node);\n    };\n    const moveForwardFromBr = (root, nextNode) => {\n      const nextSibling = nextNode.nextSibling;\n      if (nextSibling && isCaretCandidate(nextSibling)) {\n        if (isText$3(nextSibling)) {\n          return CaretPosition(nextSibling, 0);\n        } else {\n          return CaretPosition.before(nextSibling);\n        }\n      } else {\n        return findCaretPosition$1(HDirection.Forwards, CaretPosition.after(nextNode), root);\n      }\n    };\n    const findCaretPosition$1 = (direction, startPos, root) => {\n      let node;\n      let nextNode;\n      let innerNode;\n      let caretPosition;\n      if (!isElement$1(root) || !startPos) {\n        return null;\n      }\n      if (startPos.isEqual(CaretPosition.after(root)) && root.lastChild) {\n        caretPosition = CaretPosition.after(root.lastChild);\n        if (isBackwards(direction) && isCaretCandidate(root.lastChild) && isElement$1(root.lastChild)) {\n          return isBr$2(root.lastChild) ? CaretPosition.before(root.lastChild) : caretPosition;\n        }\n      } else {\n        caretPosition = startPos;\n      }\n      const container = caretPosition.container();\n      let offset = caretPosition.offset();\n      if (isText$3(container)) {\n        if (isBackwards(direction) && offset > 0) {\n          return CaretPosition(container, --offset);\n        }\n        if (isForwards(direction) && offset < container.length) {\n          return CaretPosition(container, ++offset);\n        }\n        node = container;\n      } else {\n        if (isBackwards(direction) && offset > 0) {\n          nextNode = nodeAtIndex(container, offset - 1);\n          if (isCaretCandidate(nextNode)) {\n            if (!isAtomic(nextNode)) {\n              innerNode = findNode(nextNode, direction, isEditableCaretCandidate, nextNode);\n              if (innerNode) {\n                if (isText$3(innerNode)) {\n                  return CaretPosition(innerNode, innerNode.data.length);\n                }\n                return CaretPosition.after(innerNode);\n              }\n            }\n            if (isText$3(nextNode)) {\n              return CaretPosition(nextNode, nextNode.data.length);\n            }\n            return CaretPosition.before(nextNode);\n          }\n        }\n        if (isForwards(direction) && offset < container.childNodes.length) {\n          nextNode = nodeAtIndex(container, offset);\n          if (isCaretCandidate(nextNode)) {\n            if (isBr$2(nextNode)) {\n              return moveForwardFromBr(root, nextNode);\n            }\n            if (!isAtomic(nextNode)) {\n              innerNode = findNode(nextNode, direction, isEditableCaretCandidate, nextNode);\n              if (innerNode) {\n                if (isText$3(innerNode)) {\n                  return CaretPosition(innerNode, 0);\n                }\n                return CaretPosition.before(innerNode);\n              }\n            }\n            if (isText$3(nextNode)) {\n              return CaretPosition(nextNode, 0);\n            }\n            return CaretPosition.after(nextNode);\n          }\n        }\n        node = nextNode ? nextNode : caretPosition.getNode();\n      }\n      if (node && (isForwards(direction) && caretPosition.isAtEnd() || isBackwards(direction) && caretPosition.isAtStart())) {\n        node = findNode(node, direction, always, root, true);\n        if (isEditableCaretCandidate(node, root)) {\n          return getCaretCandidatePosition(direction, node);\n        }\n      }\n      nextNode = node ? findNode(node, direction, isEditableCaretCandidate, root) : node;\n      const rootContentEditableFalseElm = last$1(filter$5(getParents$3(container, root), isContentEditableFalse$6));\n      if (rootContentEditableFalseElm && (!nextNode || !rootContentEditableFalseElm.contains(nextNode))) {\n        if (isForwards(direction)) {\n          caretPosition = CaretPosition.after(rootContentEditableFalseElm);\n        } else {\n          caretPosition = CaretPosition.before(rootContentEditableFalseElm);\n        }\n        return caretPosition;\n      }\n      if (nextNode) {\n        return getCaretCandidatePosition(direction, nextNode);\n      }\n      return null;\n    };\n    const CaretWalker = root => ({\n      next: caretPosition => {\n        return findCaretPosition$1(HDirection.Forwards, caretPosition, root);\n      },\n      prev: caretPosition => {\n        return findCaretPosition$1(HDirection.Backwards, caretPosition, root);\n      }\n    });\n\n    const walkToPositionIn = (forward, root, start) => {\n      const position = forward ? CaretPosition.before(start) : CaretPosition.after(start);\n      return fromPosition(forward, root, position);\n    };\n    const afterElement = node => isBr$6(node) ? CaretPosition.before(node) : CaretPosition.after(node);\n    const isBeforeOrStart = position => {\n      if (CaretPosition.isTextPosition(position)) {\n        return position.offset() === 0;\n      } else {\n        return isCaretCandidate$3(position.getNode());\n      }\n    };\n    const isAfterOrEnd = position => {\n      if (CaretPosition.isTextPosition(position)) {\n        const container = position.container();\n        return position.offset() === container.data.length;\n      } else {\n        return isCaretCandidate$3(position.getNode(true));\n      }\n    };\n    const isBeforeAfterSameElement = (from, to) => !CaretPosition.isTextPosition(from) && !CaretPosition.isTextPosition(to) && from.getNode() === to.getNode(true);\n    const isAtBr = position => !CaretPosition.isTextPosition(position) && isBr$6(position.getNode());\n    const shouldSkipPosition = (forward, from, to) => {\n      if (forward) {\n        return !isBeforeAfterSameElement(from, to) && !isAtBr(from) && isAfterOrEnd(from) && isBeforeOrStart(to);\n      } else {\n        return !isBeforeAfterSameElement(to, from) && isBeforeOrStart(from) && isAfterOrEnd(to);\n      }\n    };\n    const fromPosition = (forward, root, pos) => {\n      const walker = CaretWalker(root);\n      return Optional.from(forward ? walker.next(pos) : walker.prev(pos));\n    };\n    const navigate = (forward, root, from) => fromPosition(forward, root, from).bind(to => {\n      if (isInSameBlock(from, to, root) && shouldSkipPosition(forward, from, to)) {\n        return fromPosition(forward, root, to);\n      } else {\n        return Optional.some(to);\n      }\n    });\n    const navigateIgnore = (forward, root, from, ignoreFilter) => navigate(forward, root, from).bind(pos => ignoreFilter(pos) ? navigateIgnore(forward, root, pos, ignoreFilter) : Optional.some(pos));\n    const positionIn = (forward, element) => {\n      const startNode = forward ? element.firstChild : element.lastChild;\n      if (isText$b(startNode)) {\n        return Optional.some(CaretPosition(startNode, forward ? 0 : startNode.data.length));\n      } else if (startNode) {\n        if (isCaretCandidate$3(startNode)) {\n          return Optional.some(forward ? CaretPosition.before(startNode) : afterElement(startNode));\n        } else {\n          return walkToPositionIn(forward, element, startNode);\n        }\n      } else {\n        return Optional.none();\n      }\n    };\n    const nextPosition = curry(fromPosition, true);\n    const prevPosition = curry(fromPosition, false);\n    const firstPositionIn = curry(positionIn, true);\n    const lastPositionIn = curry(positionIn, false);\n\n    const CARET_ID = '_mce_caret';\n    const isCaretNode = node => isElement$6(node) && node.id === CARET_ID;\n    const getParentCaretContainer = (body, node) => {\n      let currentNode = node;\n      while (currentNode && currentNode !== body) {\n        if (isCaretNode(currentNode)) {\n          return currentNode;\n        }\n        currentNode = currentNode.parentNode;\n      }\n      return null;\n    };\n\n    const isStringPathBookmark = bookmark => isString(bookmark.start);\n    const isRangeBookmark = bookmark => has$2(bookmark, 'rng');\n    const isIdBookmark = bookmark => has$2(bookmark, 'id');\n    const isIndexBookmark = bookmark => has$2(bookmark, 'name');\n    const isPathBookmark = bookmark => Tools.isArray(bookmark.start);\n\n    const isForwardBookmark = bookmark => !isIndexBookmark(bookmark) && isBoolean(bookmark.forward) ? bookmark.forward : true;\n    const addBogus = (dom, node) => {\n      if (isElement$6(node) && dom.isBlock(node) && !node.innerHTML) {\n        node.innerHTML = '<br data-mce-bogus=\"1\" />';\n      }\n      return node;\n    };\n    const resolveCaretPositionBookmark = (dom, bookmark) => {\n      const startPos = Optional.from(resolve$1(dom.getRoot(), bookmark.start));\n      const endPos = Optional.from(resolve$1(dom.getRoot(), bookmark.end));\n      return lift2(startPos, endPos, (start, end) => {\n        const range = dom.createRng();\n        range.setStart(start.container(), start.offset());\n        range.setEnd(end.container(), end.offset());\n        return {\n          range,\n          forward: isForwardBookmark(bookmark)\n        };\n      });\n    };\n    const insertZwsp = (node, rng) => {\n      var _a;\n      const doc = (_a = node.ownerDocument) !== null && _a !== void 0 ? _a : document;\n      const textNode = doc.createTextNode(ZWSP$1);\n      node.appendChild(textNode);\n      rng.setStart(textNode, 0);\n      rng.setEnd(textNode, 0);\n    };\n    const isEmpty$1 = node => !node.hasChildNodes();\n    const tryFindRangePosition = (node, rng) => lastPositionIn(node).fold(never, pos => {\n      rng.setStart(pos.container(), pos.offset());\n      rng.setEnd(pos.container(), pos.offset());\n      return true;\n    });\n    const padEmptyCaretContainer = (root, node, rng) => {\n      if (isEmpty$1(node) && getParentCaretContainer(root, node)) {\n        insertZwsp(node, rng);\n        return true;\n      } else {\n        return false;\n      }\n    };\n    const setEndPoint = (dom, start, bookmark, rng) => {\n      const point = bookmark[start ? 'start' : 'end'];\n      const root = dom.getRoot();\n      if (point) {\n        let node = root;\n        let offset = point[0];\n        for (let i = point.length - 1; node && i >= 1; i--) {\n          const children = node.childNodes;\n          if (padEmptyCaretContainer(root, node, rng)) {\n            return true;\n          }\n          if (point[i] > children.length - 1) {\n            if (padEmptyCaretContainer(root, node, rng)) {\n              return true;\n            }\n            return tryFindRangePosition(node, rng);\n          }\n          node = children[point[i]];\n        }\n        if (isText$b(node)) {\n          offset = Math.min(point[0], node.data.length);\n        }\n        if (isElement$6(node)) {\n          offset = Math.min(point[0], node.childNodes.length);\n        }\n        if (start) {\n          rng.setStart(node, offset);\n        } else {\n          rng.setEnd(node, offset);\n        }\n      }\n      return true;\n    };\n    const isValidTextNode = node => isText$b(node) && node.data.length > 0;\n    const restoreEndPoint = (dom, suffix, bookmark) => {\n      const marker = dom.get(bookmark.id + '_' + suffix);\n      const markerParent = marker === null || marker === void 0 ? void 0 : marker.parentNode;\n      const keep = bookmark.keep;\n      if (marker && markerParent) {\n        let container;\n        let offset;\n        if (suffix === 'start') {\n          if (!keep) {\n            container = markerParent;\n            offset = dom.nodeIndex(marker);\n          } else {\n            if (marker.hasChildNodes()) {\n              container = marker.firstChild;\n              offset = 1;\n            } else if (isValidTextNode(marker.nextSibling)) {\n              container = marker.nextSibling;\n              offset = 0;\n            } else if (isValidTextNode(marker.previousSibling)) {\n              container = marker.previousSibling;\n              offset = marker.previousSibling.data.length;\n            } else {\n              container = markerParent;\n              offset = dom.nodeIndex(marker) + 1;\n            }\n          }\n        } else {\n          if (!keep) {\n            container = markerParent;\n            offset = dom.nodeIndex(marker);\n          } else {\n            if (marker.hasChildNodes()) {\n              container = marker.firstChild;\n              offset = 1;\n            } else if (isValidTextNode(marker.previousSibling)) {\n              container = marker.previousSibling;\n              offset = marker.previousSibling.data.length;\n            } else {\n              container = markerParent;\n              offset = dom.nodeIndex(marker);\n            }\n          }\n        }\n        if (!keep) {\n          const prev = marker.previousSibling;\n          const next = marker.nextSibling;\n          Tools.each(Tools.grep(marker.childNodes), node => {\n            if (isText$b(node)) {\n              node.data = node.data.replace(/\\uFEFF/g, '');\n            }\n          });\n          let otherMarker;\n          while (otherMarker = dom.get(bookmark.id + '_' + suffix)) {\n            dom.remove(otherMarker, true);\n          }\n          if (isText$b(next) && isText$b(prev) && !Env.browser.isOpera()) {\n            const idx = prev.data.length;\n            prev.appendData(next.data);\n            dom.remove(next);\n            container = prev;\n            offset = idx;\n          }\n        }\n        return Optional.some(CaretPosition(container, offset));\n      } else {\n        return Optional.none();\n      }\n    };\n    const resolvePaths = (dom, bookmark) => {\n      const range = dom.createRng();\n      if (setEndPoint(dom, true, bookmark, range) && setEndPoint(dom, false, bookmark, range)) {\n        return Optional.some({\n          range,\n          forward: isForwardBookmark(bookmark)\n        });\n      } else {\n        return Optional.none();\n      }\n    };\n    const resolveId = (dom, bookmark) => {\n      const startPos = restoreEndPoint(dom, 'start', bookmark);\n      const endPos = restoreEndPoint(dom, 'end', bookmark);\n      return lift2(startPos, endPos.or(startPos), (spos, epos) => {\n        const range = dom.createRng();\n        range.setStart(addBogus(dom, spos.container()), spos.offset());\n        range.setEnd(addBogus(dom, epos.container()), epos.offset());\n        return {\n          range,\n          forward: isForwardBookmark(bookmark)\n        };\n      });\n    };\n    const resolveIndex = (dom, bookmark) => Optional.from(dom.select(bookmark.name)[bookmark.index]).map(elm => {\n      const range = dom.createRng();\n      range.selectNode(elm);\n      return {\n        range,\n        forward: true\n      };\n    });\n    const resolve = (selection, bookmark) => {\n      const dom = selection.dom;\n      if (bookmark) {\n        if (isPathBookmark(bookmark)) {\n          return resolvePaths(dom, bookmark);\n        } else if (isStringPathBookmark(bookmark)) {\n          return resolveCaretPositionBookmark(dom, bookmark);\n        } else if (isIdBookmark(bookmark)) {\n          return resolveId(dom, bookmark);\n        } else if (isIndexBookmark(bookmark)) {\n          return resolveIndex(dom, bookmark);\n        } else if (isRangeBookmark(bookmark)) {\n          return Optional.some({\n            range: bookmark.rng,\n            forward: isForwardBookmark(bookmark)\n          });\n        }\n      }\n      return Optional.none();\n    };\n\n    const getBookmark$2 = (selection, type, normalized) => {\n      return getBookmark$3(selection, type, normalized);\n    };\n    const moveToBookmark = (selection, bookmark) => {\n      resolve(selection, bookmark).each(({range, forward}) => {\n        selection.setRng(range, forward);\n      });\n    };\n    const isBookmarkNode$1 = node => {\n      return isElement$6(node) && node.tagName === 'SPAN' && node.getAttribute('data-mce-type') === 'bookmark';\n    };\n\n    const is = expected => actual => expected === actual;\n    const isNbsp = is(nbsp);\n    const isWhiteSpace = chr => chr !== '' && ' \\f\\n\\r\\t\\x0B'.indexOf(chr) !== -1;\n    const isContent = chr => !isWhiteSpace(chr) && !isNbsp(chr) && !isZwsp$2(chr);\n\n    const getRanges$1 = selection => {\n      const ranges = [];\n      if (selection) {\n        for (let i = 0; i < selection.rangeCount; i++) {\n          ranges.push(selection.getRangeAt(i));\n        }\n      }\n      return ranges;\n    };\n    const getSelectedNodes = ranges => {\n      return bind$3(ranges, range => {\n        const node = getSelectedNode(range);\n        return node ? [SugarElement.fromDom(node)] : [];\n      });\n    };\n    const hasMultipleRanges = selection => {\n      return getRanges$1(selection).length > 1;\n    };\n\n    const getCellsFromRanges = ranges => filter$5(getSelectedNodes(ranges), isTableCell$2);\n    const getCellsFromElement = elm => descendants(elm, 'td[data-mce-selected],th[data-mce-selected]');\n    const getCellsFromElementOrRanges = (ranges, element) => {\n      const selectedCells = getCellsFromElement(element);\n      return selectedCells.length > 0 ? selectedCells : getCellsFromRanges(ranges);\n    };\n    const getCellsFromEditor = editor => getCellsFromElementOrRanges(getRanges$1(editor.selection.getSel()), SugarElement.fromDom(editor.getBody()));\n    const getClosestTable = (cell, isRoot) => ancestor$3(cell, 'table', isRoot);\n\n    const getStartNode = rng => {\n      const sc = rng.startContainer, so = rng.startOffset;\n      if (isText$b(sc)) {\n        return so === 0 ? Optional.some(SugarElement.fromDom(sc)) : Optional.none();\n      } else {\n        return Optional.from(sc.childNodes[so]).map(SugarElement.fromDom);\n      }\n    };\n    const getEndNode = rng => {\n      const ec = rng.endContainer, eo = rng.endOffset;\n      if (isText$b(ec)) {\n        return eo === ec.data.length ? Optional.some(SugarElement.fromDom(ec)) : Optional.none();\n      } else {\n        return Optional.from(ec.childNodes[eo - 1]).map(SugarElement.fromDom);\n      }\n    };\n    const getFirstChildren = node => {\n      return firstChild(node).fold(constant([node]), child => {\n        return [node].concat(getFirstChildren(child));\n      });\n    };\n    const getLastChildren = node => {\n      return lastChild(node).fold(constant([node]), child => {\n        if (name(child) === 'br') {\n          return prevSibling(child).map(sibling => {\n            return [node].concat(getLastChildren(sibling));\n          }).getOr([]);\n        } else {\n          return [node].concat(getLastChildren(child));\n        }\n      });\n    };\n    const hasAllContentsSelected = (elm, rng) => {\n      return lift2(getStartNode(rng), getEndNode(rng), (startNode, endNode) => {\n        const start = find$2(getFirstChildren(elm), curry(eq, startNode));\n        const end = find$2(getLastChildren(elm), curry(eq, endNode));\n        return start.isSome() && end.isSome();\n      }).getOr(false);\n    };\n    const moveEndPoint = (dom, rng, node, start) => {\n      const root = node;\n      const walker = new DomTreeWalker(node, root);\n      const moveCaretBeforeOnEnterElementsMap = filter$4(dom.schema.getMoveCaretBeforeOnEnterElements(), (_, name) => !contains$2([\n        'td',\n        'th',\n        'table'\n      ], name.toLowerCase()));\n      let currentNode = node;\n      do {\n        if (isText$b(currentNode) && Tools.trim(currentNode.data).length !== 0) {\n          if (start) {\n            rng.setStart(currentNode, 0);\n          } else {\n            rng.setEnd(currentNode, currentNode.data.length);\n          }\n          return;\n        }\n        if (moveCaretBeforeOnEnterElementsMap[currentNode.nodeName]) {\n          if (start) {\n            rng.setStartBefore(currentNode);\n          } else {\n            if (currentNode.nodeName === 'BR') {\n              rng.setEndBefore(currentNode);\n            } else {\n              rng.setEndAfter(currentNode);\n            }\n          }\n          return;\n        }\n      } while (currentNode = start ? walker.next() : walker.prev());\n      if (root.nodeName === 'BODY') {\n        if (start) {\n          rng.setStart(root, 0);\n        } else {\n          rng.setEnd(root, root.childNodes.length);\n        }\n      }\n    };\n    const hasAnyRanges = editor => {\n      const sel = editor.selection.getSel();\n      return isNonNullable(sel) && sel.rangeCount > 0;\n    };\n    const runOnRanges = (editor, executor) => {\n      const fakeSelectionNodes = getCellsFromEditor(editor);\n      if (fakeSelectionNodes.length > 0) {\n        each$e(fakeSelectionNodes, elem => {\n          const node = elem.dom;\n          const fakeNodeRng = editor.dom.createRng();\n          fakeNodeRng.setStartBefore(node);\n          fakeNodeRng.setEndAfter(node);\n          executor(fakeNodeRng, true);\n        });\n      } else {\n        executor(editor.selection.getRng(), false);\n      }\n    };\n    const preserve = (selection, fillBookmark, executor) => {\n      const bookmark = getPersistentBookmark(selection, fillBookmark);\n      executor(bookmark);\n      selection.moveToBookmark(bookmark);\n    };\n\n    const isNode = node => isNumber(node === null || node === void 0 ? void 0 : node.nodeType);\n    const isElementNode$1 = node => isElement$6(node) && !isBookmarkNode$1(node) && !isCaretNode(node) && !isBogus$1(node);\n    const isElementDirectlySelected = (dom, node) => {\n      if (isElementNode$1(node) && !/^(TD|TH)$/.test(node.nodeName)) {\n        const selectedAttr = dom.getAttrib(node, 'data-mce-selected');\n        const value = parseInt(selectedAttr, 10);\n        return !isNaN(value) && value > 0;\n      } else {\n        return false;\n      }\n    };\n    const preserveSelection = (editor, action, shouldMoveStart) => {\n      const {selection, dom} = editor;\n      const selectedNodeBeforeAction = selection.getNode();\n      const isSelectedBeforeNodeNoneditable = isContentEditableFalse$b(selectedNodeBeforeAction);\n      preserve(selection, true, () => {\n        action();\n      });\n      const isBeforeNodeStillNoneditable = isSelectedBeforeNodeNoneditable && isContentEditableFalse$b(selectedNodeBeforeAction);\n      if (isBeforeNodeStillNoneditable && dom.isChildOf(selectedNodeBeforeAction, editor.getBody())) {\n        editor.selection.select(selectedNodeBeforeAction);\n      } else if (shouldMoveStart(selection.getStart())) {\n        moveStartToNearestText(dom, selection);\n      }\n    };\n    const moveStartToNearestText = (dom, selection) => {\n      var _a, _b;\n      const rng = selection.getRng();\n      const {startContainer, startOffset} = rng;\n      const selectedNode = selection.getNode();\n      if (isElementDirectlySelected(dom, selectedNode)) {\n        return;\n      }\n      if (isElement$6(startContainer)) {\n        const nodes = startContainer.childNodes;\n        const root = dom.getRoot();\n        let walker;\n        if (startOffset < nodes.length) {\n          const startNode = nodes[startOffset];\n          walker = new DomTreeWalker(startNode, (_a = dom.getParent(startNode, dom.isBlock)) !== null && _a !== void 0 ? _a : root);\n        } else {\n          const startNode = nodes[nodes.length - 1];\n          walker = new DomTreeWalker(startNode, (_b = dom.getParent(startNode, dom.isBlock)) !== null && _b !== void 0 ? _b : root);\n          walker.next(true);\n        }\n        for (let node = walker.current(); node; node = walker.next()) {\n          if (dom.getContentEditable(node) === 'false') {\n            return;\n          } else if (isText$b(node) && !isWhiteSpaceNode$1(node)) {\n            rng.setStart(node, 0);\n            selection.setRng(rng);\n            return;\n          }\n        }\n      }\n    };\n    const getNonWhiteSpaceSibling = (node, next, inc) => {\n      if (node) {\n        const nextName = next ? 'nextSibling' : 'previousSibling';\n        for (node = inc ? node : node[nextName]; node; node = node[nextName]) {\n          if (isElement$6(node) || !isWhiteSpaceNode$1(node)) {\n            return node;\n          }\n        }\n      }\n      return undefined;\n    };\n    const isTextBlock$1 = (schema, node) => !!schema.getTextBlockElements()[node.nodeName.toLowerCase()] || isTransparentBlock(schema, node);\n    const isValid = (ed, parent, child) => {\n      return ed.schema.isValidChild(parent, child);\n    };\n    const isWhiteSpaceNode$1 = (node, allowSpaces = false) => {\n      if (isNonNullable(node) && isText$b(node)) {\n        const data = allowSpaces ? node.data.replace(/ /g, '\\xA0') : node.data;\n        return isWhitespaceText(data);\n      } else {\n        return false;\n      }\n    };\n    const isEmptyTextNode$1 = node => {\n      return isNonNullable(node) && isText$b(node) && node.length === 0;\n    };\n    const isWrapNoneditableTarget = (editor, node) => {\n      const baseDataSelector = '[data-mce-cef-wrappable]';\n      const formatNoneditableSelector = getFormatNoneditableSelector(editor);\n      const selector = isEmpty$3(formatNoneditableSelector) ? baseDataSelector : `${ baseDataSelector },${ formatNoneditableSelector }`;\n      return is$1(SugarElement.fromDom(node), selector);\n    };\n    const isWrappableNoneditable = (editor, node) => {\n      const dom = editor.dom;\n      return isElementNode$1(node) && dom.getContentEditable(node) === 'false' && isWrapNoneditableTarget(editor, node) && dom.select('[contenteditable=\"true\"]', node).length === 0;\n    };\n    const replaceVars = (value, vars) => {\n      if (isFunction(value)) {\n        return value(vars);\n      } else if (isNonNullable(vars)) {\n        value = value.replace(/%(\\w+)/g, (str, name) => {\n          return vars[name] || str;\n        });\n      }\n      return value;\n    };\n    const isEq$5 = (str1, str2) => {\n      str1 = str1 || '';\n      str2 = str2 || '';\n      str1 = '' + (str1.nodeName || str1);\n      str2 = '' + (str2.nodeName || str2);\n      return str1.toLowerCase() === str2.toLowerCase();\n    };\n    const normalizeStyleValue = (value, name) => {\n      if (isNullable(value)) {\n        return null;\n      } else {\n        let strValue = String(value);\n        if (name === 'color' || name === 'backgroundColor') {\n          strValue = rgbaToHexString(strValue);\n        }\n        if (name === 'fontWeight' && value === 700) {\n          strValue = 'bold';\n        }\n        if (name === 'fontFamily') {\n          strValue = strValue.replace(/[\\'\\\"]/g, '').replace(/,\\s+/g, ',');\n        }\n        return strValue;\n      }\n    };\n    const getStyle = (dom, node, name) => {\n      const style = dom.getStyle(node, name);\n      return normalizeStyleValue(style, name);\n    };\n    const getTextDecoration = (dom, node) => {\n      let decoration;\n      dom.getParent(node, n => {\n        if (isElement$6(n)) {\n          decoration = dom.getStyle(n, 'text-decoration');\n          return !!decoration && decoration !== 'none';\n        } else {\n          return false;\n        }\n      });\n      return decoration;\n    };\n    const getParents$2 = (dom, node, selector) => {\n      return dom.getParents(node, selector, dom.getRoot());\n    };\n    const isFormatPredicate = (editor, formatName, predicate) => {\n      const formats = editor.formatter.get(formatName);\n      return isNonNullable(formats) && exists(formats, predicate);\n    };\n    const isVariableFormatName = (editor, formatName) => {\n      const hasVariableValues = format => {\n        const isVariableValue = val => isFunction(val) || val.length > 1 && val.charAt(0) === '%';\n        return exists([\n          'styles',\n          'attributes'\n        ], key => get$a(format, key).exists(field => {\n          const fieldValues = isArray$1(field) ? field : values(field);\n          return exists(fieldValues, isVariableValue);\n        }));\n      };\n      return isFormatPredicate(editor, formatName, hasVariableValues);\n    };\n    const areSimilarFormats = (editor, formatName, otherFormatName) => {\n      const validKeys = [\n        'inline',\n        'block',\n        'selector',\n        'attributes',\n        'styles',\n        'classes'\n      ];\n      const filterObj = format => filter$4(format, (_, key) => exists(validKeys, validKey => validKey === key));\n      return isFormatPredicate(editor, formatName, fmt1 => {\n        const filteredFmt1 = filterObj(fmt1);\n        return isFormatPredicate(editor, otherFormatName, fmt2 => {\n          const filteredFmt2 = filterObj(fmt2);\n          return equal$1(filteredFmt1, filteredFmt2);\n        });\n      });\n    };\n    const isBlockFormat = format => hasNonNullableKey(format, 'block');\n    const isWrappingBlockFormat = format => isBlockFormat(format) && format.wrapper === true;\n    const isNonWrappingBlockFormat = format => isBlockFormat(format) && format.wrapper !== true;\n    const isSelectorFormat = format => hasNonNullableKey(format, 'selector');\n    const isInlineFormat = format => hasNonNullableKey(format, 'inline');\n    const isMixedFormat = format => isSelectorFormat(format) && isInlineFormat(format) && is$2(get$a(format, 'mixed'), true);\n    const shouldExpandToSelector = format => isSelectorFormat(format) && format.expand !== false && !isInlineFormat(format);\n    const getEmptyCaretContainers = node => {\n      const nodes = [];\n      let tempNode = node;\n      while (tempNode) {\n        if (isText$b(tempNode) && tempNode.data !== ZWSP$1 || tempNode.childNodes.length > 1) {\n          return [];\n        }\n        if (isElement$6(tempNode)) {\n          nodes.push(tempNode);\n        }\n        tempNode = tempNode.firstChild;\n      }\n      return nodes;\n    };\n    const isCaretContainerEmpty = node => {\n      return getEmptyCaretContainers(node).length > 0;\n    };\n    const isEmptyCaretFormatElement = element => {\n      return isCaretNode(element.dom) && isCaretContainerEmpty(element.dom);\n    };\n\n    const isBookmarkNode = isBookmarkNode$1;\n    const getParents$1 = getParents$2;\n    const isWhiteSpaceNode = isWhiteSpaceNode$1;\n    const isTextBlock = isTextBlock$1;\n    const isBogusBr = node => {\n      return isBr$6(node) && node.getAttribute('data-mce-bogus') && !node.nextSibling;\n    };\n    const findParentContentEditable = (dom, node) => {\n      let parent = node;\n      while (parent) {\n        if (isElement$6(parent) && dom.getContentEditable(parent)) {\n          return dom.getContentEditable(parent) === 'false' ? parent : node;\n        }\n        parent = parent.parentNode;\n      }\n      return node;\n    };\n    const walkText = (start, node, offset, predicate) => {\n      const str = node.data;\n      if (start) {\n        for (let i = offset; i > 0; i--) {\n          if (predicate(str.charAt(i - 1))) {\n            return i;\n          }\n        }\n      } else {\n        for (let i = offset; i < str.length; i++) {\n          if (predicate(str.charAt(i))) {\n            return i;\n          }\n        }\n      }\n      return -1;\n    };\n    const findSpace = (start, node, offset) => walkText(start, node, offset, c => isNbsp(c) || isWhiteSpace(c));\n    const findContent = (start, node, offset) => walkText(start, node, offset, isContent);\n    const findWordEndPoint = (dom, body, container, offset, start, includeTrailingSpaces) => {\n      let lastTextNode;\n      const rootNode = dom.getParent(container, dom.isBlock) || body;\n      const walk = (container, offset, pred) => {\n        const textSeeker = TextSeeker(dom);\n        const walker = start ? textSeeker.backwards : textSeeker.forwards;\n        return Optional.from(walker(container, offset, (text, textOffset) => {\n          if (isBookmarkNode(text.parentNode)) {\n            return -1;\n          } else {\n            lastTextNode = text;\n            return pred(start, text, textOffset);\n          }\n        }, rootNode));\n      };\n      const spaceResult = walk(container, offset, findSpace);\n      return spaceResult.bind(result => includeTrailingSpaces ? walk(result.container, result.offset + (start ? -1 : 0), findContent) : Optional.some(result)).orThunk(() => lastTextNode ? Optional.some({\n        container: lastTextNode,\n        offset: start ? 0 : lastTextNode.length\n      }) : Optional.none());\n    };\n    const findSelectorEndPoint = (dom, formatList, rng, container, siblingName) => {\n      const sibling = container[siblingName];\n      if (isText$b(container) && isEmpty$3(container.data) && sibling) {\n        container = sibling;\n      }\n      const parents = getParents$1(dom, container);\n      for (let i = 0; i < parents.length; i++) {\n        for (let y = 0; y < formatList.length; y++) {\n          const curFormat = formatList[y];\n          if (isNonNullable(curFormat.collapsed) && curFormat.collapsed !== rng.collapsed) {\n            continue;\n          }\n          if (isSelectorFormat(curFormat) && dom.is(parents[i], curFormat.selector)) {\n            return parents[i];\n          }\n        }\n      }\n      return container;\n    };\n    const findBlockEndPoint = (dom, formatList, container, siblingName) => {\n      var _a;\n      let node = container;\n      const root = dom.getRoot();\n      const format = formatList[0];\n      if (isBlockFormat(format)) {\n        node = format.wrapper ? null : dom.getParent(container, format.block, root);\n      }\n      if (!node) {\n        const scopeRoot = (_a = dom.getParent(container, 'LI,TD,TH,SUMMARY')) !== null && _a !== void 0 ? _a : root;\n        node = dom.getParent(isText$b(container) ? container.parentNode : container, node => node !== root && isTextBlock(dom.schema, node), scopeRoot);\n      }\n      if (node && isBlockFormat(format) && format.wrapper) {\n        node = getParents$1(dom, node, 'ul,ol').reverse()[0] || node;\n      }\n      if (!node) {\n        node = container;\n        while (node && node[siblingName] && !dom.isBlock(node[siblingName])) {\n          node = node[siblingName];\n          if (isEq$5(node, 'br')) {\n            break;\n          }\n        }\n      }\n      return node || container;\n    };\n    const isAtBlockBoundary$1 = (dom, root, container, siblingName) => {\n      const parent = container.parentNode;\n      if (isNonNullable(container[siblingName])) {\n        return false;\n      } else if (parent === root || isNullable(parent) || dom.isBlock(parent)) {\n        return true;\n      } else {\n        return isAtBlockBoundary$1(dom, root, parent, siblingName);\n      }\n    };\n    const findParentContainer = (dom, formatList, container, offset, start) => {\n      let parent = container;\n      const siblingName = start ? 'previousSibling' : 'nextSibling';\n      const root = dom.getRoot();\n      if (isText$b(container) && !isWhiteSpaceNode(container)) {\n        if (start ? offset > 0 : offset < container.data.length) {\n          return container;\n        }\n      }\n      while (parent) {\n        if (!formatList[0].block_expand && dom.isBlock(parent)) {\n          return parent;\n        }\n        for (let sibling = parent[siblingName]; sibling; sibling = sibling[siblingName]) {\n          const allowSpaces = isText$b(sibling) && !isAtBlockBoundary$1(dom, root, sibling, siblingName);\n          if (!isBookmarkNode(sibling) && !isBogusBr(sibling) && !isWhiteSpaceNode(sibling, allowSpaces)) {\n            return parent;\n          }\n        }\n        if (parent === root || parent.parentNode === root) {\n          container = parent;\n          break;\n        }\n        parent = parent.parentNode;\n      }\n      return container;\n    };\n    const isSelfOrParentBookmark = container => isBookmarkNode(container.parentNode) || isBookmarkNode(container);\n    const expandRng = (dom, rng, formatList, includeTrailingSpace = false) => {\n      let {startContainer, startOffset, endContainer, endOffset} = rng;\n      const format = formatList[0];\n      if (isElement$6(startContainer) && startContainer.hasChildNodes()) {\n        startContainer = getNode$1(startContainer, startOffset);\n        if (isText$b(startContainer)) {\n          startOffset = 0;\n        }\n      }\n      if (isElement$6(endContainer) && endContainer.hasChildNodes()) {\n        endContainer = getNode$1(endContainer, rng.collapsed ? endOffset : endOffset - 1);\n        if (isText$b(endContainer)) {\n          endOffset = endContainer.data.length;\n        }\n      }\n      startContainer = findParentContentEditable(dom, startContainer);\n      endContainer = findParentContentEditable(dom, endContainer);\n      if (isSelfOrParentBookmark(startContainer)) {\n        startContainer = isBookmarkNode(startContainer) ? startContainer : startContainer.parentNode;\n        if (rng.collapsed) {\n          startContainer = startContainer.previousSibling || startContainer;\n        } else {\n          startContainer = startContainer.nextSibling || startContainer;\n        }\n        if (isText$b(startContainer)) {\n          startOffset = rng.collapsed ? startContainer.length : 0;\n        }\n      }\n      if (isSelfOrParentBookmark(endContainer)) {\n        endContainer = isBookmarkNode(endContainer) ? endContainer : endContainer.parentNode;\n        if (rng.collapsed) {\n          endContainer = endContainer.nextSibling || endContainer;\n        } else {\n          endContainer = endContainer.previousSibling || endContainer;\n        }\n        if (isText$b(endContainer)) {\n          endOffset = rng.collapsed ? 0 : endContainer.length;\n        }\n      }\n      if (rng.collapsed) {\n        const startPoint = findWordEndPoint(dom, dom.getRoot(), startContainer, startOffset, true, includeTrailingSpace);\n        startPoint.each(({container, offset}) => {\n          startContainer = container;\n          startOffset = offset;\n        });\n        const endPoint = findWordEndPoint(dom, dom.getRoot(), endContainer, endOffset, false, includeTrailingSpace);\n        endPoint.each(({container, offset}) => {\n          endContainer = container;\n          endOffset = offset;\n        });\n      }\n      if (isInlineFormat(format) || format.block_expand) {\n        if (!isInlineFormat(format) || (!isText$b(startContainer) || startOffset === 0)) {\n          startContainer = findParentContainer(dom, formatList, startContainer, startOffset, true);\n        }\n        if (!isInlineFormat(format) || (!isText$b(endContainer) || endOffset === endContainer.data.length)) {\n          endContainer = findParentContainer(dom, formatList, endContainer, endOffset, false);\n        }\n      }\n      if (shouldExpandToSelector(format)) {\n        startContainer = findSelectorEndPoint(dom, formatList, rng, startContainer, 'previousSibling');\n        endContainer = findSelectorEndPoint(dom, formatList, rng, endContainer, 'nextSibling');\n      }\n      if (isBlockFormat(format) || isSelectorFormat(format)) {\n        startContainer = findBlockEndPoint(dom, formatList, startContainer, 'previousSibling');\n        endContainer = findBlockEndPoint(dom, formatList, endContainer, 'nextSibling');\n        if (isBlockFormat(format)) {\n          if (!dom.isBlock(startContainer)) {\n            startContainer = findParentContainer(dom, formatList, startContainer, startOffset, true);\n            if (isText$b(startContainer)) {\n              startOffset = 0;\n            }\n          }\n          if (!dom.isBlock(endContainer)) {\n            endContainer = findParentContainer(dom, formatList, endContainer, endOffset, false);\n            if (isText$b(endContainer)) {\n              endOffset = endContainer.data.length;\n            }\n          }\n        }\n      }\n      if (isElement$6(startContainer) && startContainer.parentNode) {\n        startOffset = dom.nodeIndex(startContainer);\n        startContainer = startContainer.parentNode;\n      }\n      if (isElement$6(endContainer) && endContainer.parentNode) {\n        endOffset = dom.nodeIndex(endContainer) + 1;\n        endContainer = endContainer.parentNode;\n      }\n      return {\n        startContainer,\n        startOffset,\n        endContainer,\n        endOffset\n      };\n    };\n\n    const walk$3 = (dom, rng, callback) => {\n      var _a;\n      const startOffset = rng.startOffset;\n      const startContainer = getNode$1(rng.startContainer, startOffset);\n      const endOffset = rng.endOffset;\n      const endContainer = getNode$1(rng.endContainer, endOffset - 1);\n      const exclude = nodes => {\n        const firstNode = nodes[0];\n        if (isText$b(firstNode) && firstNode === startContainer && startOffset >= firstNode.data.length) {\n          nodes.splice(0, 1);\n        }\n        const lastNode = nodes[nodes.length - 1];\n        if (endOffset === 0 && nodes.length > 0 && lastNode === endContainer && isText$b(lastNode)) {\n          nodes.splice(nodes.length - 1, 1);\n        }\n        return nodes;\n      };\n      const collectSiblings = (node, name, endNode) => {\n        const siblings = [];\n        for (; node && node !== endNode; node = node[name]) {\n          siblings.push(node);\n        }\n        return siblings;\n      };\n      const findEndPoint = (node, root) => dom.getParent(node, node => node.parentNode === root, root);\n      const walkBoundary = (startNode, endNode, next) => {\n        const siblingName = next ? 'nextSibling' : 'previousSibling';\n        for (let node = startNode, parent = node.parentNode; node && node !== endNode; node = parent) {\n          parent = node.parentNode;\n          const siblings = collectSiblings(node === startNode ? node : node[siblingName], siblingName);\n          if (siblings.length) {\n            if (!next) {\n              siblings.reverse();\n            }\n            callback(exclude(siblings));\n          }\n        }\n      };\n      if (startContainer === endContainer) {\n        return callback(exclude([startContainer]));\n      }\n      const ancestor = (_a = dom.findCommonAncestor(startContainer, endContainer)) !== null && _a !== void 0 ? _a : dom.getRoot();\n      if (dom.isChildOf(startContainer, endContainer)) {\n        return walkBoundary(startContainer, ancestor, true);\n      }\n      if (dom.isChildOf(endContainer, startContainer)) {\n        return walkBoundary(endContainer, ancestor);\n      }\n      const startPoint = findEndPoint(startContainer, ancestor) || startContainer;\n      const endPoint = findEndPoint(endContainer, ancestor) || endContainer;\n      walkBoundary(startContainer, startPoint, true);\n      const siblings = collectSiblings(startPoint === startContainer ? startPoint : startPoint.nextSibling, 'nextSibling', endPoint === endContainer ? endPoint.nextSibling : endPoint);\n      if (siblings.length) {\n        callback(exclude(siblings));\n      }\n      walkBoundary(endContainer, endPoint);\n    };\n\n    const validBlocks = [\n      'pre[class*=language-][contenteditable=\"false\"]',\n      'figure.image',\n      'div[data-ephox-embed-iri]',\n      'div.tiny-pageembed',\n      'div.mce-toc',\n      'div[data-mce-toc]'\n    ];\n    const isZeroWidth = elem => isText$c(elem) && get$3(elem) === ZWSP$1;\n    const context = (editor, elem, wrapName, nodeName) => parent(elem).fold(() => 'skipping', parent => {\n      if (nodeName === 'br' || isZeroWidth(elem)) {\n        return 'valid';\n      } else if (isAnnotation(elem)) {\n        return 'existing';\n      } else if (isCaretNode(elem.dom)) {\n        return 'caret';\n      } else if (exists(validBlocks, selector => is$1(elem, selector))) {\n        return 'valid-block';\n      } else if (!isValid(editor, wrapName, nodeName) || !isValid(editor, name(parent), wrapName)) {\n        return 'invalid-child';\n      } else {\n        return 'valid';\n      }\n    });\n\n    const applyWordGrab = (editor, rng) => {\n      const r = expandRng(editor.dom, rng, [{ inline: 'span' }]);\n      rng.setStart(r.startContainer, r.startOffset);\n      rng.setEnd(r.endContainer, r.endOffset);\n      editor.selection.setRng(rng);\n    };\n    const applyAnnotation = (elem, masterUId, data, annotationName, decorate, directAnnotation) => {\n      const {uid = masterUId, ...otherData} = data;\n      add$2(elem, annotation());\n      set$3(elem, `${ dataAnnotationId() }`, uid);\n      set$3(elem, `${ dataAnnotation() }`, annotationName);\n      const {attributes = {}, classes = []} = decorate(uid, otherData);\n      setAll$1(elem, attributes);\n      add(elem, classes);\n      if (directAnnotation) {\n        if (classes.length > 0) {\n          set$3(elem, `${ dataAnnotationClasses() }`, classes.join(','));\n        }\n        const attributeNames = keys(attributes);\n        if (attributeNames.length > 0) {\n          set$3(elem, `${ dataAnnotationAttributes() }`, attributeNames.join(','));\n        }\n      }\n    };\n    const removeDirectAnnotation = elem => {\n      remove$6(elem, annotation());\n      remove$9(elem, `${ dataAnnotationId() }`);\n      remove$9(elem, `${ dataAnnotation() }`);\n      remove$9(elem, `${ dataAnnotationActive() }`);\n      const customAttrNames = getOpt(elem, `${ dataAnnotationAttributes() }`).map(names => names.split(',')).getOr([]);\n      const customClasses = getOpt(elem, `${ dataAnnotationClasses() }`).map(names => names.split(',')).getOr([]);\n      each$e(customAttrNames, name => remove$9(elem, name));\n      remove$3(elem, customClasses);\n      remove$9(elem, `${ dataAnnotationClasses() }`);\n      remove$9(elem, `${ dataAnnotationAttributes() }`);\n    };\n    const makeAnnotation = (eDoc, uid, data, annotationName, decorate) => {\n      const master = SugarElement.fromTag('span', eDoc);\n      applyAnnotation(master, uid, data, annotationName, decorate, false);\n      return master;\n    };\n    const annotate = (editor, rng, uid, annotationName, decorate, data) => {\n      const newWrappers = [];\n      const master = makeAnnotation(editor.getDoc(), uid, data, annotationName, decorate);\n      const wrapper = value$2();\n      const finishWrapper = () => {\n        wrapper.clear();\n      };\n      const getOrOpenWrapper = () => wrapper.get().getOrThunk(() => {\n        const nu = shallow$1(master);\n        newWrappers.push(nu);\n        wrapper.set(nu);\n        return nu;\n      });\n      const processElements = elems => {\n        each$e(elems, processElement);\n      };\n      const processElement = elem => {\n        const ctx = context(editor, elem, 'span', name(elem));\n        switch (ctx) {\n        case 'invalid-child': {\n            finishWrapper();\n            const children = children$1(elem);\n            processElements(children);\n            finishWrapper();\n            break;\n          }\n        case 'valid-block': {\n            finishWrapper();\n            applyAnnotation(elem, uid, data, annotationName, decorate, true);\n            break;\n          }\n        case 'valid': {\n            const w = getOrOpenWrapper();\n            wrap$2(elem, w);\n            break;\n          }\n        }\n      };\n      const processNodes = nodes => {\n        const elems = map$3(nodes, SugarElement.fromDom);\n        processElements(elems);\n      };\n      walk$3(editor.dom, rng, nodes => {\n        finishWrapper();\n        processNodes(nodes);\n      });\n      return newWrappers;\n    };\n    const annotateWithBookmark = (editor, name, settings, data) => {\n      editor.undoManager.transact(() => {\n        const selection = editor.selection;\n        const initialRng = selection.getRng();\n        const hasFakeSelection = getCellsFromEditor(editor).length > 0;\n        const masterUid = generate$1('mce-annotation');\n        if (initialRng.collapsed && !hasFakeSelection) {\n          applyWordGrab(editor, initialRng);\n        }\n        if (selection.getRng().collapsed && !hasFakeSelection) {\n          const wrapper = makeAnnotation(editor.getDoc(), masterUid, data, name, settings.decorate);\n          set$1(wrapper, nbsp);\n          selection.getRng().insertNode(wrapper.dom);\n          selection.select(wrapper.dom);\n        } else {\n          preserve(selection, false, () => {\n            runOnRanges(editor, selectionRng => {\n              annotate(editor, selectionRng, masterUid, name, settings.decorate, data);\n            });\n          });\n        }\n      });\n    };\n\n    const Annotator = editor => {\n      const registry = create$b();\n      setup$x(editor, registry);\n      const changes = setup$y(editor, registry);\n      const isSpan = isTag('span');\n      const removeAnnotations = elements => {\n        each$e(elements, element => {\n          if (isSpan(element)) {\n            unwrap(element);\n          } else {\n            removeDirectAnnotation(element);\n          }\n        });\n      };\n      return {\n        register: (name, settings) => {\n          registry.register(name, settings);\n        },\n        annotate: (name, data) => {\n          registry.lookup(name).each(settings => {\n            annotateWithBookmark(editor, name, settings, data);\n          });\n        },\n        annotationChanged: (name, callback) => {\n          changes.addListener(name, callback);\n        },\n        remove: name => {\n          identify(editor, Optional.some(name)).each(({elements}) => {\n            const bookmark = editor.selection.getBookmark();\n            removeAnnotations(elements);\n            editor.selection.moveToBookmark(bookmark);\n          });\n        },\n        removeAll: name => {\n          const bookmark = editor.selection.getBookmark();\n          each$d(findAll(editor, name), (elements, _) => {\n            removeAnnotations(elements);\n          });\n          editor.selection.moveToBookmark(bookmark);\n        },\n        getAll: name => {\n          const directory = findAll(editor, name);\n          return map$2(directory, elems => map$3(elems, elem => elem.dom));\n        }\n      };\n    };\n\n    const BookmarkManager = selection => {\n      return {\n        getBookmark: curry(getBookmark$2, selection),\n        moveToBookmark: curry(moveToBookmark, selection)\n      };\n    };\n    BookmarkManager.isBookmarkNode = isBookmarkNode$1;\n\n    const isXYWithinRange = (clientX, clientY, range) => {\n      if (range.collapsed) {\n        return false;\n      } else {\n        return exists(range.getClientRects(), rect => containsXY(rect, clientX, clientY));\n      }\n    };\n\n    const firePreProcess = (editor, args) => editor.dispatch('PreProcess', args);\n    const firePostProcess = (editor, args) => editor.dispatch('PostProcess', args);\n    const fireRemove = editor => {\n      editor.dispatch('remove');\n    };\n    const fireDetach = editor => {\n      editor.dispatch('detach');\n    };\n    const fireSwitchMode = (editor, mode) => {\n      editor.dispatch('SwitchMode', { mode });\n    };\n    const fireObjectResizeStart = (editor, target, width, height, origin) => {\n      editor.dispatch('ObjectResizeStart', {\n        target,\n        width,\n        height,\n        origin\n      });\n    };\n    const fireObjectResized = (editor, target, width, height, origin) => {\n      editor.dispatch('ObjectResized', {\n        target,\n        width,\n        height,\n        origin\n      });\n    };\n    const firePreInit = editor => {\n      editor.dispatch('PreInit');\n    };\n    const firePostRender = editor => {\n      editor.dispatch('PostRender');\n    };\n    const fireInit = editor => {\n      editor.dispatch('Init');\n    };\n    const firePlaceholderToggle = (editor, state) => {\n      editor.dispatch('PlaceholderToggle', { state });\n    };\n    const fireError = (editor, errorType, error) => {\n      editor.dispatch(errorType, error);\n    };\n    const fireFormatApply = (editor, format, node, vars) => {\n      editor.dispatch('FormatApply', {\n        format,\n        node,\n        vars\n      });\n    };\n    const fireFormatRemove = (editor, format, node, vars) => {\n      editor.dispatch('FormatRemove', {\n        format,\n        node,\n        vars\n      });\n    };\n    const fireBeforeSetContent = (editor, args) => editor.dispatch('BeforeSetContent', args);\n    const fireSetContent = (editor, args) => editor.dispatch('SetContent', args);\n    const fireBeforeGetContent = (editor, args) => editor.dispatch('BeforeGetContent', args);\n    const fireGetContent = (editor, args) => editor.dispatch('GetContent', args);\n    const fireAutocompleterStart = (editor, args) => {\n      editor.dispatch('AutocompleterStart', args);\n    };\n    const fireAutocompleterUpdate = (editor, args) => {\n      editor.dispatch('AutocompleterUpdate', args);\n    };\n    const fireAutocompleterUpdateActiveRange = (editor, args) => {\n      editor.dispatch('AutocompleterUpdateActiveRange', args);\n    };\n    const fireAutocompleterEnd = editor => {\n      editor.dispatch('AutocompleterEnd');\n    };\n    const firePastePreProcess = (editor, html, internal) => editor.dispatch('PastePreProcess', {\n      content: html,\n      internal\n    });\n    const firePastePostProcess = (editor, node, internal) => editor.dispatch('PastePostProcess', {\n      node,\n      internal\n    });\n    const firePastePlainTextToggle = (editor, state) => editor.dispatch('PastePlainTextToggle', { state });\n    const fireEditableRootStateChange = (editor, state) => editor.dispatch('EditableRootStateChange', { state });\n\n    const VK = {\n      BACKSPACE: 8,\n      DELETE: 46,\n      DOWN: 40,\n      ENTER: 13,\n      ESC: 27,\n      LEFT: 37,\n      RIGHT: 39,\n      SPACEBAR: 32,\n      TAB: 9,\n      UP: 38,\n      PAGE_UP: 33,\n      PAGE_DOWN: 34,\n      END: 35,\n      HOME: 36,\n      modifierPressed: e => {\n        return e.shiftKey || e.ctrlKey || e.altKey || VK.metaKeyPressed(e);\n      },\n      metaKeyPressed: e => {\n        return Env.os.isMacOS() || Env.os.isiOS() ? e.metaKey : e.ctrlKey && !e.altKey;\n      }\n    };\n\n    const elementSelectionAttr = 'data-mce-selected';\n    const controlElmSelector = 'table,img,figure.image,hr,video,span.mce-preview-object,details';\n    const abs = Math.abs;\n    const round$1 = Math.round;\n    const resizeHandles = {\n      nw: [\n        0,\n        0,\n        -1,\n        -1\n      ],\n      ne: [\n        1,\n        0,\n        1,\n        -1\n      ],\n      se: [\n        1,\n        1,\n        1,\n        1\n      ],\n      sw: [\n        0,\n        1,\n        -1,\n        1\n      ]\n    };\n    const isTouchEvent = evt => evt.type === 'longpress' || evt.type.indexOf('touch') === 0;\n    const ControlSelection = (selection, editor) => {\n      const dom = editor.dom;\n      const editableDoc = editor.getDoc();\n      const rootDocument = document;\n      const rootElement = editor.getBody();\n      let selectedElm, selectedElmGhost, resizeHelper, selectedHandle, resizeBackdrop;\n      let startX, startY, selectedElmX, selectedElmY, startW, startH, ratio, resizeStarted;\n      let width;\n      let height;\n      let startScrollWidth;\n      let startScrollHeight;\n      const isImage = elm => isNonNullable(elm) && (isImg(elm) || dom.is(elm, 'figure.image'));\n      const isMedia = elm => isMedia$2(elm) || dom.hasClass(elm, 'mce-preview-object');\n      const isEventOnImageOutsideRange = (evt, range) => {\n        if (isTouchEvent(evt)) {\n          const touch = evt.touches[0];\n          return isImage(evt.target) && !isXYWithinRange(touch.clientX, touch.clientY, range);\n        } else {\n          return isImage(evt.target) && !isXYWithinRange(evt.clientX, evt.clientY, range);\n        }\n      };\n      const contextMenuSelectImage = evt => {\n        const target = evt.target;\n        if (isEventOnImageOutsideRange(evt, editor.selection.getRng()) && !evt.isDefaultPrevented()) {\n          editor.selection.select(target);\n        }\n      };\n      const getResizeTargets = elm => {\n        if (dom.hasClass(elm, 'mce-preview-object') && isNonNullable(elm.firstElementChild)) {\n          return [\n            elm,\n            elm.firstElementChild\n          ];\n        } else if (dom.is(elm, 'figure.image')) {\n          return [elm.querySelector('img')];\n        } else {\n          return [elm];\n        }\n      };\n      const isResizable = elm => {\n        const selector = getObjectResizing(editor);\n        if (!selector || editor.mode.isReadOnly()) {\n          return false;\n        }\n        if (elm.getAttribute('data-mce-resize') === 'false') {\n          return false;\n        }\n        if (elm === editor.getBody()) {\n          return false;\n        }\n        if (dom.hasClass(elm, 'mce-preview-object') && isNonNullable(elm.firstElementChild)) {\n          return is$1(SugarElement.fromDom(elm.firstElementChild), selector);\n        } else {\n          return is$1(SugarElement.fromDom(elm), selector);\n        }\n      };\n      const createGhostElement = (dom, elm) => {\n        if (isMedia(elm)) {\n          return dom.create('img', { src: Env.transparentSrc });\n        } else if (isTable$2(elm)) {\n          const isNorth = startsWith(selectedHandle.name, 'n');\n          const rowSelect = isNorth ? head : last$2;\n          const tableElm = elm.cloneNode(true);\n          rowSelect(dom.select('tr', tableElm)).each(tr => {\n            const cells = dom.select('td,th', tr);\n            dom.setStyle(tr, 'height', null);\n            each$e(cells, cell => dom.setStyle(cell, 'height', null));\n          });\n          return tableElm;\n        } else {\n          return elm.cloneNode(true);\n        }\n      };\n      const setSizeProp = (element, name, value) => {\n        if (isNonNullable(value)) {\n          const targets = getResizeTargets(element);\n          each$e(targets, target => {\n            if (target.style[name] || !editor.schema.isValid(target.nodeName.toLowerCase(), name)) {\n              dom.setStyle(target, name, value);\n            } else {\n              dom.setAttrib(target, name, '' + value);\n            }\n          });\n        }\n      };\n      const setGhostElmSize = (ghostElm, width, height) => {\n        setSizeProp(ghostElm, 'width', width);\n        setSizeProp(ghostElm, 'height', height);\n      };\n      const resizeGhostElement = e => {\n        let deltaX, deltaY, proportional;\n        let resizeHelperX, resizeHelperY;\n        deltaX = e.screenX - startX;\n        deltaY = e.screenY - startY;\n        width = deltaX * selectedHandle[2] + startW;\n        height = deltaY * selectedHandle[3] + startH;\n        width = width < 5 ? 5 : width;\n        height = height < 5 ? 5 : height;\n        if ((isImage(selectedElm) || isMedia(selectedElm)) && getResizeImgProportional(editor) !== false) {\n          proportional = !VK.modifierPressed(e);\n        } else {\n          proportional = VK.modifierPressed(e);\n        }\n        if (proportional) {\n          if (abs(deltaX) > abs(deltaY)) {\n            height = round$1(width * ratio);\n            width = round$1(height / ratio);\n          } else {\n            width = round$1(height / ratio);\n            height = round$1(width * ratio);\n          }\n        }\n        setGhostElmSize(selectedElmGhost, width, height);\n        resizeHelperX = selectedHandle.startPos.x + deltaX;\n        resizeHelperY = selectedHandle.startPos.y + deltaY;\n        resizeHelperX = resizeHelperX > 0 ? resizeHelperX : 0;\n        resizeHelperY = resizeHelperY > 0 ? resizeHelperY : 0;\n        dom.setStyles(resizeHelper, {\n          left: resizeHelperX,\n          top: resizeHelperY,\n          display: 'block'\n        });\n        resizeHelper.innerHTML = width + ' &times; ' + height;\n        if (selectedHandle[2] < 0 && selectedElmGhost.clientWidth <= width) {\n          dom.setStyle(selectedElmGhost, 'left', selectedElmX + (startW - width));\n        }\n        if (selectedHandle[3] < 0 && selectedElmGhost.clientHeight <= height) {\n          dom.setStyle(selectedElmGhost, 'top', selectedElmY + (startH - height));\n        }\n        deltaX = rootElement.scrollWidth - startScrollWidth;\n        deltaY = rootElement.scrollHeight - startScrollHeight;\n        if (deltaX + deltaY !== 0) {\n          dom.setStyles(resizeHelper, {\n            left: resizeHelperX - deltaX,\n            top: resizeHelperY - deltaY\n          });\n        }\n        if (!resizeStarted) {\n          fireObjectResizeStart(editor, selectedElm, startW, startH, 'corner-' + selectedHandle.name);\n          resizeStarted = true;\n        }\n      };\n      const endGhostResize = () => {\n        const wasResizeStarted = resizeStarted;\n        resizeStarted = false;\n        if (wasResizeStarted) {\n          setSizeProp(selectedElm, 'width', width);\n          setSizeProp(selectedElm, 'height', height);\n        }\n        dom.unbind(editableDoc, 'mousemove', resizeGhostElement);\n        dom.unbind(editableDoc, 'mouseup', endGhostResize);\n        if (rootDocument !== editableDoc) {\n          dom.unbind(rootDocument, 'mousemove', resizeGhostElement);\n          dom.unbind(rootDocument, 'mouseup', endGhostResize);\n        }\n        dom.remove(selectedElmGhost);\n        dom.remove(resizeHelper);\n        dom.remove(resizeBackdrop);\n        showResizeRect(selectedElm);\n        if (wasResizeStarted) {\n          fireObjectResized(editor, selectedElm, width, height, 'corner-' + selectedHandle.name);\n          dom.setAttrib(selectedElm, 'style', dom.getAttrib(selectedElm, 'style'));\n        }\n        editor.nodeChanged();\n      };\n      const showResizeRect = targetElm => {\n        unbindResizeHandleEvents();\n        const position = dom.getPos(targetElm, rootElement);\n        const selectedElmX = position.x;\n        const selectedElmY = position.y;\n        const rect = targetElm.getBoundingClientRect();\n        const targetWidth = rect.width || rect.right - rect.left;\n        const targetHeight = rect.height || rect.bottom - rect.top;\n        if (selectedElm !== targetElm) {\n          hideResizeRect();\n          selectedElm = targetElm;\n          width = height = 0;\n        }\n        const e = editor.dispatch('ObjectSelected', { target: targetElm });\n        if (isResizable(targetElm) && !e.isDefaultPrevented()) {\n          each$d(resizeHandles, (handle, name) => {\n            const startDrag = e => {\n              const target = getResizeTargets(selectedElm)[0];\n              startX = e.screenX;\n              startY = e.screenY;\n              startW = target.clientWidth;\n              startH = target.clientHeight;\n              ratio = startH / startW;\n              selectedHandle = handle;\n              selectedHandle.name = name;\n              selectedHandle.startPos = {\n                x: targetWidth * handle[0] + selectedElmX,\n                y: targetHeight * handle[1] + selectedElmY\n              };\n              startScrollWidth = rootElement.scrollWidth;\n              startScrollHeight = rootElement.scrollHeight;\n              resizeBackdrop = dom.add(rootElement, 'div', {\n                'class': 'mce-resize-backdrop',\n                'data-mce-bogus': 'all'\n              });\n              dom.setStyles(resizeBackdrop, {\n                position: 'fixed',\n                left: '0',\n                top: '0',\n                width: '100%',\n                height: '100%'\n              });\n              selectedElmGhost = createGhostElement(dom, selectedElm);\n              dom.addClass(selectedElmGhost, 'mce-clonedresizable');\n              dom.setAttrib(selectedElmGhost, 'data-mce-bogus', 'all');\n              selectedElmGhost.contentEditable = 'false';\n              dom.setStyles(selectedElmGhost, {\n                left: selectedElmX,\n                top: selectedElmY,\n                margin: 0\n              });\n              setGhostElmSize(selectedElmGhost, targetWidth, targetHeight);\n              selectedElmGhost.removeAttribute(elementSelectionAttr);\n              rootElement.appendChild(selectedElmGhost);\n              dom.bind(editableDoc, 'mousemove', resizeGhostElement);\n              dom.bind(editableDoc, 'mouseup', endGhostResize);\n              if (rootDocument !== editableDoc) {\n                dom.bind(rootDocument, 'mousemove', resizeGhostElement);\n                dom.bind(rootDocument, 'mouseup', endGhostResize);\n              }\n              resizeHelper = dom.add(rootElement, 'div', {\n                'class': 'mce-resize-helper',\n                'data-mce-bogus': 'all'\n              }, startW + ' &times; ' + startH);\n            };\n            let handleElm = dom.get('mceResizeHandle' + name);\n            if (handleElm) {\n              dom.remove(handleElm);\n            }\n            handleElm = dom.add(rootElement, 'div', {\n              'id': 'mceResizeHandle' + name,\n              'data-mce-bogus': 'all',\n              'class': 'mce-resizehandle',\n              'unselectable': true,\n              'style': 'cursor:' + name + '-resize; margin:0; padding:0'\n            });\n            dom.bind(handleElm, 'mousedown', e => {\n              e.stopImmediatePropagation();\n              e.preventDefault();\n              startDrag(e);\n            });\n            handle.elm = handleElm;\n            dom.setStyles(handleElm, {\n              left: targetWidth * handle[0] + selectedElmX - handleElm.offsetWidth / 2,\n              top: targetHeight * handle[1] + selectedElmY - handleElm.offsetHeight / 2\n            });\n          });\n        } else {\n          hideResizeRect(false);\n        }\n      };\n      const throttledShowResizeRect = first$1(showResizeRect, 0);\n      const hideResizeRect = (removeSelected = true) => {\n        throttledShowResizeRect.cancel();\n        unbindResizeHandleEvents();\n        if (selectedElm && removeSelected) {\n          selectedElm.removeAttribute(elementSelectionAttr);\n        }\n        each$d(resizeHandles, (value, name) => {\n          const handleElm = dom.get('mceResizeHandle' + name);\n          if (handleElm) {\n            dom.unbind(handleElm);\n            dom.remove(handleElm);\n          }\n        });\n      };\n      const isChildOrEqual = (node, parent) => dom.isChildOf(node, parent);\n      const updateResizeRect = e => {\n        if (resizeStarted || editor.removed || editor.composing) {\n          return;\n        }\n        const targetElm = e.type === 'mousedown' ? e.target : selection.getNode();\n        const controlElm = closest$3(SugarElement.fromDom(targetElm), controlElmSelector).map(e => e.dom).filter(e => dom.isEditable(e.parentElement) || e.nodeName === 'IMG' && dom.isEditable(e)).getOrUndefined();\n        const selectedValue = isNonNullable(controlElm) ? dom.getAttrib(controlElm, elementSelectionAttr, '1') : '1';\n        each$e(dom.select(`img[${ elementSelectionAttr }],hr[${ elementSelectionAttr }]`), img => {\n          img.removeAttribute(elementSelectionAttr);\n        });\n        if (isNonNullable(controlElm) && isChildOrEqual(controlElm, rootElement) && editor.hasFocus()) {\n          disableGeckoResize();\n          const startElm = selection.getStart(true);\n          if (isChildOrEqual(startElm, controlElm) && isChildOrEqual(selection.getEnd(true), controlElm)) {\n            dom.setAttrib(controlElm, elementSelectionAttr, selectedValue);\n            throttledShowResizeRect.throttle(controlElm);\n            return;\n          }\n        }\n        hideResizeRect();\n      };\n      const unbindResizeHandleEvents = () => {\n        each$d(resizeHandles, handle => {\n          if (handle.elm) {\n            dom.unbind(handle.elm);\n            delete handle.elm;\n          }\n        });\n      };\n      const disableGeckoResize = () => {\n        try {\n          editor.getDoc().execCommand('enableObjectResizing', false, 'false');\n        } catch (ex) {\n        }\n      };\n      editor.on('init', () => {\n        disableGeckoResize();\n        editor.on('NodeChange ResizeEditor ResizeWindow ResizeContent drop', updateResizeRect);\n        editor.on('keyup compositionend', e => {\n          if (selectedElm && selectedElm.nodeName === 'TABLE') {\n            updateResizeRect(e);\n          }\n        });\n        editor.on('hide blur', hideResizeRect);\n        editor.on('contextmenu longpress', contextMenuSelectImage, true);\n      });\n      editor.on('remove', unbindResizeHandleEvents);\n      const destroy = () => {\n        throttledShowResizeRect.cancel();\n        selectedElm = selectedElmGhost = resizeBackdrop = null;\n      };\n      return {\n        isResizable,\n        showResizeRect,\n        hideResizeRect,\n        updateResizeRect,\n        destroy\n      };\n    };\n\n    const setStart = (rng, situ) => {\n      situ.fold(e => {\n        rng.setStartBefore(e.dom);\n      }, (e, o) => {\n        rng.setStart(e.dom, o);\n      }, e => {\n        rng.setStartAfter(e.dom);\n      });\n    };\n    const setFinish = (rng, situ) => {\n      situ.fold(e => {\n        rng.setEndBefore(e.dom);\n      }, (e, o) => {\n        rng.setEnd(e.dom, o);\n      }, e => {\n        rng.setEndAfter(e.dom);\n      });\n    };\n    const relativeToNative = (win, startSitu, finishSitu) => {\n      const range = win.document.createRange();\n      setStart(range, startSitu);\n      setFinish(range, finishSitu);\n      return range;\n    };\n    const exactToNative = (win, start, soffset, finish, foffset) => {\n      const rng = win.document.createRange();\n      rng.setStart(start.dom, soffset);\n      rng.setEnd(finish.dom, foffset);\n      return rng;\n    };\n\n    const adt$3 = Adt.generate([\n      {\n        ltr: [\n          'start',\n          'soffset',\n          'finish',\n          'foffset'\n        ]\n      },\n      {\n        rtl: [\n          'start',\n          'soffset',\n          'finish',\n          'foffset'\n        ]\n      }\n    ]);\n    const fromRange = (win, type, range) => type(SugarElement.fromDom(range.startContainer), range.startOffset, SugarElement.fromDom(range.endContainer), range.endOffset);\n    const getRanges = (win, selection) => selection.match({\n      domRange: rng => {\n        return {\n          ltr: constant(rng),\n          rtl: Optional.none\n        };\n      },\n      relative: (startSitu, finishSitu) => {\n        return {\n          ltr: cached(() => relativeToNative(win, startSitu, finishSitu)),\n          rtl: cached(() => Optional.some(relativeToNative(win, finishSitu, startSitu)))\n        };\n      },\n      exact: (start, soffset, finish, foffset) => {\n        return {\n          ltr: cached(() => exactToNative(win, start, soffset, finish, foffset)),\n          rtl: cached(() => Optional.some(exactToNative(win, finish, foffset, start, soffset)))\n        };\n      }\n    });\n    const doDiagnose = (win, ranges) => {\n      const rng = ranges.ltr();\n      if (rng.collapsed) {\n        const reversed = ranges.rtl().filter(rev => rev.collapsed === false);\n        return reversed.map(rev => adt$3.rtl(SugarElement.fromDom(rev.endContainer), rev.endOffset, SugarElement.fromDom(rev.startContainer), rev.startOffset)).getOrThunk(() => fromRange(win, adt$3.ltr, rng));\n      } else {\n        return fromRange(win, adt$3.ltr, rng);\n      }\n    };\n    const diagnose = (win, selection) => {\n      const ranges = getRanges(win, selection);\n      return doDiagnose(win, ranges);\n    };\n    adt$3.ltr;\n    adt$3.rtl;\n\n    const create$9 = (start, soffset, finish, foffset) => ({\n      start,\n      soffset,\n      finish,\n      foffset\n    });\n    const SimRange = { create: create$9 };\n\n    const caretPositionFromPoint = (doc, x, y) => {\n      var _a;\n      return Optional.from((_a = doc.caretPositionFromPoint) === null || _a === void 0 ? void 0 : _a.call(doc, x, y)).bind(pos => {\n        if (pos.offsetNode === null) {\n          return Optional.none();\n        }\n        const r = doc.createRange();\n        r.setStart(pos.offsetNode, pos.offset);\n        r.collapse();\n        return Optional.some(r);\n      });\n    };\n    const caretRangeFromPoint = (doc, x, y) => {\n      var _a;\n      return Optional.from((_a = doc.caretRangeFromPoint) === null || _a === void 0 ? void 0 : _a.call(doc, x, y));\n    };\n    const availableSearch = (doc, x, y) => {\n      if (doc.caretPositionFromPoint) {\n        return caretPositionFromPoint(doc, x, y);\n      } else if (doc.caretRangeFromPoint) {\n        return caretRangeFromPoint(doc, x, y);\n      } else {\n        return Optional.none();\n      }\n    };\n    const fromPoint$1 = (win, x, y) => {\n      const doc = win.document;\n      return availableSearch(doc, x, y).map(rng => SimRange.create(SugarElement.fromDom(rng.startContainer), rng.startOffset, SugarElement.fromDom(rng.endContainer), rng.endOffset));\n    };\n\n    const adt$2 = Adt.generate([\n      { before: ['element'] },\n      {\n        on: [\n          'element',\n          'offset'\n        ]\n      },\n      { after: ['element'] }\n    ]);\n    const cata = (subject, onBefore, onOn, onAfter) => subject.fold(onBefore, onOn, onAfter);\n    const getStart$2 = situ => situ.fold(identity, identity, identity);\n    const before$1 = adt$2.before;\n    const on = adt$2.on;\n    const after$1 = adt$2.after;\n    const Situ = {\n      before: before$1,\n      on,\n      after: after$1,\n      cata,\n      getStart: getStart$2\n    };\n\n    const adt$1 = Adt.generate([\n      { domRange: ['rng'] },\n      {\n        relative: [\n          'startSitu',\n          'finishSitu'\n        ]\n      },\n      {\n        exact: [\n          'start',\n          'soffset',\n          'finish',\n          'foffset'\n        ]\n      }\n    ]);\n    const exactFromRange = simRange => adt$1.exact(simRange.start, simRange.soffset, simRange.finish, simRange.foffset);\n    const getStart$1 = selection => selection.match({\n      domRange: rng => SugarElement.fromDom(rng.startContainer),\n      relative: (startSitu, _finishSitu) => Situ.getStart(startSitu),\n      exact: (start, _soffset, _finish, _foffset) => start\n    });\n    const domRange = adt$1.domRange;\n    const relative = adt$1.relative;\n    const exact = adt$1.exact;\n    const getWin = selection => {\n      const start = getStart$1(selection);\n      return defaultView(start);\n    };\n    const range = SimRange.create;\n    const SimSelection = {\n      domRange,\n      relative,\n      exact,\n      exactFromRange,\n      getWin,\n      range\n    };\n\n    const beforeSpecial = (element, offset) => {\n      const name$1 = name(element);\n      if ('input' === name$1) {\n        return Situ.after(element);\n      } else if (!contains$2([\n          'br',\n          'img'\n        ], name$1)) {\n        return Situ.on(element, offset);\n      } else {\n        return offset === 0 ? Situ.before(element) : Situ.after(element);\n      }\n    };\n    const preprocessRelative = (startSitu, finishSitu) => {\n      const start = startSitu.fold(Situ.before, beforeSpecial, Situ.after);\n      const finish = finishSitu.fold(Situ.before, beforeSpecial, Situ.after);\n      return SimSelection.relative(start, finish);\n    };\n    const preprocessExact = (start, soffset, finish, foffset) => {\n      const startSitu = beforeSpecial(start, soffset);\n      const finishSitu = beforeSpecial(finish, foffset);\n      return SimSelection.relative(startSitu, finishSitu);\n    };\n    const preprocess = selection => selection.match({\n      domRange: rng => {\n        const start = SugarElement.fromDom(rng.startContainer);\n        const finish = SugarElement.fromDom(rng.endContainer);\n        return preprocessExact(start, rng.startOffset, finish, rng.endOffset);\n      },\n      relative: preprocessRelative,\n      exact: preprocessExact\n    });\n\n    const fromElements = (elements, scope) => {\n      const doc = scope || document;\n      const fragment = doc.createDocumentFragment();\n      each$e(elements, element => {\n        fragment.appendChild(element.dom);\n      });\n      return SugarElement.fromDom(fragment);\n    };\n\n    const toNative = selection => {\n      const win = SimSelection.getWin(selection).dom;\n      const getDomRange = (start, soffset, finish, foffset) => exactToNative(win, start, soffset, finish, foffset);\n      const filtered = preprocess(selection);\n      return diagnose(win, filtered).match({\n        ltr: getDomRange,\n        rtl: getDomRange\n      });\n    };\n    const getAtPoint = (win, x, y) => fromPoint$1(win, x, y);\n\n    const fromPoint = (clientX, clientY, doc) => {\n      const win = defaultView(SugarElement.fromDom(doc));\n      return getAtPoint(win.dom, clientX, clientY).map(simRange => {\n        const rng = doc.createRange();\n        rng.setStart(simRange.start.dom, simRange.soffset);\n        rng.setEnd(simRange.finish.dom, simRange.foffset);\n        return rng;\n      }).getOrUndefined();\n    };\n\n    const isEq$4 = (rng1, rng2) => {\n      return isNonNullable(rng1) && isNonNullable(rng2) && (rng1.startContainer === rng2.startContainer && rng1.startOffset === rng2.startOffset) && (rng1.endContainer === rng2.endContainer && rng1.endOffset === rng2.endOffset);\n    };\n\n    const findParent = (node, rootNode, predicate) => {\n      let currentNode = node;\n      while (currentNode && currentNode !== rootNode) {\n        if (predicate(currentNode)) {\n          return currentNode;\n        }\n        currentNode = currentNode.parentNode;\n      }\n      return null;\n    };\n    const hasParent$1 = (node, rootNode, predicate) => findParent(node, rootNode, predicate) !== null;\n    const hasParentWithName = (node, rootNode, name) => hasParent$1(node, rootNode, node => node.nodeName === name);\n    const isCeFalseCaretContainer = (node, rootNode) => isCaretContainer$2(node) && !hasParent$1(node, rootNode, isCaretNode);\n    const hasBrBeforeAfter = (dom, node, left) => {\n      const parentNode = node.parentNode;\n      if (parentNode) {\n        const walker = new DomTreeWalker(node, dom.getParent(parentNode, dom.isBlock) || dom.getRoot());\n        let currentNode;\n        while (currentNode = walker[left ? 'prev' : 'next']()) {\n          if (isBr$6(currentNode)) {\n            return true;\n          }\n        }\n      }\n      return false;\n    };\n    const isPrevNode = (node, name) => {\n      var _a;\n      return ((_a = node.previousSibling) === null || _a === void 0 ? void 0 : _a.nodeName) === name;\n    };\n    const hasContentEditableFalseParent$1 = (root, node) => {\n      let currentNode = node;\n      while (currentNode && currentNode !== root) {\n        if (isContentEditableFalse$b(currentNode)) {\n          return true;\n        }\n        currentNode = currentNode.parentNode;\n      }\n      return false;\n    };\n    const findTextNodeRelative = (dom, isAfterNode, collapsed, left, startNode) => {\n      const body = dom.getRoot();\n      const nonEmptyElementsMap = dom.schema.getNonEmptyElements();\n      const parentNode = startNode.parentNode;\n      let lastInlineElement;\n      let node;\n      if (!parentNode) {\n        return Optional.none();\n      }\n      const parentBlockContainer = dom.getParent(parentNode, dom.isBlock) || body;\n      if (left && isBr$6(startNode) && isAfterNode && dom.isEmpty(parentBlockContainer)) {\n        return Optional.some(CaretPosition(parentNode, dom.nodeIndex(startNode)));\n      }\n      const walker = new DomTreeWalker(startNode, parentBlockContainer);\n      while (node = walker[left ? 'prev' : 'next']()) {\n        if (dom.getContentEditableParent(node) === 'false' || isCeFalseCaretContainer(node, body)) {\n          return Optional.none();\n        }\n        if (isText$b(node) && node.data.length > 0) {\n          if (!hasParentWithName(node, body, 'A')) {\n            return Optional.some(CaretPosition(node, left ? node.data.length : 0));\n          }\n          return Optional.none();\n        }\n        if (dom.isBlock(node) || nonEmptyElementsMap[node.nodeName.toLowerCase()]) {\n          return Optional.none();\n        }\n        lastInlineElement = node;\n      }\n      if (isComment(lastInlineElement)) {\n        return Optional.none();\n      }\n      if (collapsed && lastInlineElement) {\n        return Optional.some(CaretPosition(lastInlineElement, 0));\n      }\n      return Optional.none();\n    };\n    const normalizeEndPoint = (dom, collapsed, start, rng) => {\n      const body = dom.getRoot();\n      let node;\n      let normalized = false;\n      let container = start ? rng.startContainer : rng.endContainer;\n      let offset = start ? rng.startOffset : rng.endOffset;\n      const isAfterNode = isElement$6(container) && offset === container.childNodes.length;\n      const nonEmptyElementsMap = dom.schema.getNonEmptyElements();\n      let directionLeft = start;\n      if (isCaretContainer$2(container)) {\n        return Optional.none();\n      }\n      if (isElement$6(container) && offset > container.childNodes.length - 1) {\n        directionLeft = false;\n      }\n      if (isDocument$1(container)) {\n        container = body;\n        offset = 0;\n      }\n      if (container === body) {\n        if (directionLeft) {\n          node = container.childNodes[offset > 0 ? offset - 1 : 0];\n          if (node) {\n            if (isCaretContainer$2(node)) {\n              return Optional.none();\n            }\n            if (nonEmptyElementsMap[node.nodeName] || isTable$2(node)) {\n              return Optional.none();\n            }\n          }\n        }\n        if (container.hasChildNodes()) {\n          offset = Math.min(!directionLeft && offset > 0 ? offset - 1 : offset, container.childNodes.length - 1);\n          container = container.childNodes[offset];\n          offset = isText$b(container) && isAfterNode ? container.data.length : 0;\n          if (!collapsed && container === body.lastChild && isTable$2(container)) {\n            return Optional.none();\n          }\n          if (hasContentEditableFalseParent$1(body, container) || isCaretContainer$2(container)) {\n            return Optional.none();\n          }\n          if (isDetails(container)) {\n            return Optional.none();\n          }\n          if (container.hasChildNodes() && !isTable$2(container)) {\n            node = container;\n            const walker = new DomTreeWalker(container, body);\n            do {\n              if (isContentEditableFalse$b(node) || isCaretContainer$2(node)) {\n                normalized = false;\n                break;\n              }\n              if (isText$b(node) && node.data.length > 0) {\n                offset = directionLeft ? 0 : node.data.length;\n                container = node;\n                normalized = true;\n                break;\n              }\n              if (nonEmptyElementsMap[node.nodeName.toLowerCase()] && !isTableCellOrCaption(node)) {\n                offset = dom.nodeIndex(node);\n                container = node.parentNode;\n                if (!directionLeft) {\n                  offset++;\n                }\n                normalized = true;\n                break;\n              }\n            } while (node = directionLeft ? walker.next() : walker.prev());\n          }\n        }\n      }\n      if (collapsed) {\n        if (isText$b(container) && offset === 0) {\n          findTextNodeRelative(dom, isAfterNode, collapsed, true, container).each(pos => {\n            container = pos.container();\n            offset = pos.offset();\n            normalized = true;\n          });\n        }\n        if (isElement$6(container)) {\n          node = container.childNodes[offset];\n          if (!node) {\n            node = container.childNodes[offset - 1];\n          }\n          if (node && isBr$6(node) && !isPrevNode(node, 'A') && !hasBrBeforeAfter(dom, node, false) && !hasBrBeforeAfter(dom, node, true)) {\n            findTextNodeRelative(dom, isAfterNode, collapsed, true, node).each(pos => {\n              container = pos.container();\n              offset = pos.offset();\n              normalized = true;\n            });\n          }\n        }\n      }\n      if (directionLeft && !collapsed && isText$b(container) && offset === container.data.length) {\n        findTextNodeRelative(dom, isAfterNode, collapsed, false, container).each(pos => {\n          container = pos.container();\n          offset = pos.offset();\n          normalized = true;\n        });\n      }\n      return normalized && container ? Optional.some(CaretPosition(container, offset)) : Optional.none();\n    };\n    const normalize$2 = (dom, rng) => {\n      const collapsed = rng.collapsed, normRng = rng.cloneRange();\n      const startPos = CaretPosition.fromRangeStart(rng);\n      normalizeEndPoint(dom, collapsed, true, normRng).each(pos => {\n        if (!collapsed || !CaretPosition.isAbove(startPos, pos)) {\n          normRng.setStart(pos.container(), pos.offset());\n        }\n      });\n      if (!collapsed) {\n        normalizeEndPoint(dom, collapsed, false, normRng).each(pos => {\n          normRng.setEnd(pos.container(), pos.offset());\n        });\n      }\n      if (collapsed) {\n        normRng.collapse(true);\n      }\n      return isEq$4(rng, normRng) ? Optional.none() : Optional.some(normRng);\n    };\n\n    const splitText = (node, offset) => {\n      return node.splitText(offset);\n    };\n    const split = rng => {\n      let startContainer = rng.startContainer, startOffset = rng.startOffset, endContainer = rng.endContainer, endOffset = rng.endOffset;\n      if (startContainer === endContainer && isText$b(startContainer)) {\n        if (startOffset > 0 && startOffset < startContainer.data.length) {\n          endContainer = splitText(startContainer, startOffset);\n          startContainer = endContainer.previousSibling;\n          if (endOffset > startOffset) {\n            endOffset = endOffset - startOffset;\n            const newContainer = splitText(endContainer, endOffset).previousSibling;\n            startContainer = endContainer = newContainer;\n            endOffset = newContainer.data.length;\n            startOffset = 0;\n          } else {\n            endOffset = 0;\n          }\n        }\n      } else {\n        if (isText$b(startContainer) && startOffset > 0 && startOffset < startContainer.data.length) {\n          startContainer = splitText(startContainer, startOffset);\n          startOffset = 0;\n        }\n        if (isText$b(endContainer) && endOffset > 0 && endOffset < endContainer.data.length) {\n          const newContainer = splitText(endContainer, endOffset).previousSibling;\n          endContainer = newContainer;\n          endOffset = newContainer.data.length;\n        }\n      }\n      return {\n        startContainer,\n        startOffset,\n        endContainer,\n        endOffset\n      };\n    };\n\n    const RangeUtils = dom => {\n      const walk = (rng, callback) => {\n        return walk$3(dom, rng, callback);\n      };\n      const split$1 = split;\n      const normalize = rng => {\n        return normalize$2(dom, rng).fold(never, normalizedRng => {\n          rng.setStart(normalizedRng.startContainer, normalizedRng.startOffset);\n          rng.setEnd(normalizedRng.endContainer, normalizedRng.endOffset);\n          return true;\n        });\n      };\n      const expand = (rng, options = { type: 'word' }) => {\n        if (options.type === 'word') {\n          const rangeLike = expandRng(dom, rng, [{ inline: 'span' }]);\n          const newRange = dom.createRng();\n          newRange.setStart(rangeLike.startContainer, rangeLike.startOffset);\n          newRange.setEnd(rangeLike.endContainer, rangeLike.endOffset);\n          return newRange;\n        }\n        return rng;\n      };\n      return {\n        walk,\n        split: split$1,\n        expand,\n        normalize\n      };\n    };\n    RangeUtils.compareRanges = isEq$4;\n    RangeUtils.getCaretRangeFromPoint = fromPoint;\n    RangeUtils.getSelectedNode = getSelectedNode;\n    RangeUtils.getNode = getNode$1;\n\n    const Dimension = (name, getOffset) => {\n      const set = (element, h) => {\n        if (!isNumber(h) && !h.match(/^[0-9]+$/)) {\n          throw new Error(name + '.set accepts only positive integer values. Value was ' + h);\n        }\n        const dom = element.dom;\n        if (isSupported(dom)) {\n          dom.style[name] = h + 'px';\n        }\n      };\n      const get = element => {\n        const r = getOffset(element);\n        if (r <= 0 || r === null) {\n          const css = get$7(element, name);\n          return parseFloat(css) || 0;\n        }\n        return r;\n      };\n      const getOuter = get;\n      const aggregate = (element, properties) => foldl(properties, (acc, property) => {\n        const val = get$7(element, property);\n        const value = val === undefined ? 0 : parseInt(val, 10);\n        return isNaN(value) ? acc : acc + value;\n      }, 0);\n      const max = (element, value, properties) => {\n        const cumulativeInclusions = aggregate(element, properties);\n        const absoluteMax = value > cumulativeInclusions ? value - cumulativeInclusions : 0;\n        return absoluteMax;\n      };\n      return {\n        set,\n        get,\n        getOuter,\n        aggregate,\n        max\n      };\n    };\n\n    const api = Dimension('height', element => {\n      const dom = element.dom;\n      return inBody(element) ? dom.getBoundingClientRect().height : dom.offsetHeight;\n    });\n    const get$2 = element => api.get(element);\n\n    const getDocument = () => SugarElement.fromDom(document);\n\n    const walkUp = (navigation, doc) => {\n      const frame = navigation.view(doc);\n      return frame.fold(constant([]), f => {\n        const parent = navigation.owner(f);\n        const rest = walkUp(navigation, parent);\n        return [f].concat(rest);\n      });\n    };\n    const pathTo = (element, navigation) => {\n      const d = navigation.owner(element);\n      return walkUp(navigation, d);\n    };\n\n    const view = doc => {\n      var _a;\n      const element = doc.dom === document ? Optional.none() : Optional.from((_a = doc.dom.defaultView) === null || _a === void 0 ? void 0 : _a.frameElement);\n      return element.map(SugarElement.fromDom);\n    };\n    const owner = element => documentOrOwner(element);\n\n    var Navigation = /*#__PURE__*/Object.freeze({\n        __proto__: null,\n        view: view,\n        owner: owner\n    });\n\n    const find = element => {\n      const doc = getDocument();\n      const scroll = get$5(doc);\n      const frames = pathTo(element, Navigation);\n      const offset = viewport(element);\n      const r = foldr(frames, (b, a) => {\n        const loc = viewport(a);\n        return {\n          left: b.left + loc.left,\n          top: b.top + loc.top\n        };\n      }, {\n        left: 0,\n        top: 0\n      });\n      return SugarPosition(r.left + offset.left + scroll.left, r.top + offset.top + scroll.top);\n    };\n\n    const excludeFromDescend = element => name(element) === 'textarea';\n    const fireScrollIntoViewEvent = (editor, data) => {\n      const scrollEvent = editor.dispatch('ScrollIntoView', data);\n      return scrollEvent.isDefaultPrevented();\n    };\n    const fireAfterScrollIntoViewEvent = (editor, data) => {\n      editor.dispatch('AfterScrollIntoView', data);\n    };\n    const descend = (element, offset) => {\n      const children = children$1(element);\n      if (children.length === 0 || excludeFromDescend(element)) {\n        return {\n          element,\n          offset\n        };\n      } else if (offset < children.length && !excludeFromDescend(children[offset])) {\n        return {\n          element: children[offset],\n          offset: 0\n        };\n      } else {\n        const last = children[children.length - 1];\n        if (excludeFromDescend(last)) {\n          return {\n            element,\n            offset\n          };\n        } else {\n          if (name(last) === 'img') {\n            return {\n              element: last,\n              offset: 1\n            };\n          } else if (isText$c(last)) {\n            return {\n              element: last,\n              offset: get$3(last).length\n            };\n          } else {\n            return {\n              element: last,\n              offset: children$1(last).length\n            };\n          }\n        }\n      }\n    };\n    const markerInfo = (element, cleanupFun) => {\n      const pos = absolute(element);\n      const height = get$2(element);\n      return {\n        element,\n        bottom: pos.top + height,\n        height,\n        pos,\n        cleanup: cleanupFun\n      };\n    };\n    const createMarker$1 = (element, offset) => {\n      const startPoint = descend(element, offset);\n      const span = SugarElement.fromHtml('<span data-mce-bogus=\"all\" style=\"display: inline-block;\">' + ZWSP$1 + '</span>');\n      before$3(startPoint.element, span);\n      return markerInfo(span, () => remove$4(span));\n    };\n    const elementMarker = element => markerInfo(SugarElement.fromDom(element), noop);\n    const withMarker = (editor, f, rng, alignToTop) => {\n      preserveWith(editor, (_s, _e) => applyWithMarker(editor, f, rng, alignToTop), rng);\n    };\n    const withScrollEvents = (editor, doc, f, marker, alignToTop) => {\n      const data = {\n        elm: marker.element.dom,\n        alignToTop\n      };\n      if (fireScrollIntoViewEvent(editor, data)) {\n        return;\n      }\n      const scrollTop = get$5(doc).top;\n      f(editor, doc, scrollTop, marker, alignToTop);\n      fireAfterScrollIntoViewEvent(editor, data);\n    };\n    const applyWithMarker = (editor, f, rng, alignToTop) => {\n      const body = SugarElement.fromDom(editor.getBody());\n      const doc = SugarElement.fromDom(editor.getDoc());\n      reflow(body);\n      const marker = createMarker$1(SugarElement.fromDom(rng.startContainer), rng.startOffset);\n      withScrollEvents(editor, doc, f, marker, alignToTop);\n      marker.cleanup();\n    };\n    const withElement = (editor, element, f, alignToTop) => {\n      const doc = SugarElement.fromDom(editor.getDoc());\n      withScrollEvents(editor, doc, f, elementMarker(element), alignToTop);\n    };\n    const preserveWith = (editor, f, rng) => {\n      const startElement = rng.startContainer;\n      const startOffset = rng.startOffset;\n      const endElement = rng.endContainer;\n      const endOffset = rng.endOffset;\n      f(SugarElement.fromDom(startElement), SugarElement.fromDom(endElement));\n      const newRng = editor.dom.createRng();\n      newRng.setStart(startElement, startOffset);\n      newRng.setEnd(endElement, endOffset);\n      editor.selection.setRng(rng);\n    };\n    const scrollToMarker = (editor, marker, viewHeight, alignToTop, doc) => {\n      const pos = marker.pos;\n      if (alignToTop) {\n        to(pos.left, pos.top, doc);\n      } else {\n        const y = pos.top - viewHeight + marker.height;\n        to(-editor.getBody().getBoundingClientRect().left, y, doc);\n      }\n    };\n    const intoWindowIfNeeded = (editor, doc, scrollTop, viewHeight, marker, alignToTop) => {\n      const viewportBottom = viewHeight + scrollTop;\n      const markerTop = marker.pos.top;\n      const markerBottom = marker.bottom;\n      const largerThanViewport = markerBottom - markerTop >= viewHeight;\n      if (markerTop < scrollTop) {\n        scrollToMarker(editor, marker, viewHeight, alignToTop !== false, doc);\n      } else if (markerTop > viewportBottom) {\n        const align = largerThanViewport ? alignToTop !== false : alignToTop === true;\n        scrollToMarker(editor, marker, viewHeight, align, doc);\n      } else if (markerBottom > viewportBottom && !largerThanViewport) {\n        scrollToMarker(editor, marker, viewHeight, alignToTop === true, doc);\n      }\n    };\n    const intoWindow = (editor, doc, scrollTop, marker, alignToTop) => {\n      const viewHeight = defaultView(doc).dom.innerHeight;\n      intoWindowIfNeeded(editor, doc, scrollTop, viewHeight, marker, alignToTop);\n    };\n    const intoFrame = (editor, doc, scrollTop, marker, alignToTop) => {\n      const frameViewHeight = defaultView(doc).dom.innerHeight;\n      intoWindowIfNeeded(editor, doc, scrollTop, frameViewHeight, marker, alignToTop);\n      const op = find(marker.element);\n      const viewportBounds = getBounds(window);\n      if (op.top < viewportBounds.y) {\n        intoView(marker.element, alignToTop !== false);\n      } else if (op.top > viewportBounds.bottom) {\n        intoView(marker.element, alignToTop === true);\n      }\n    };\n    const rangeIntoWindow = (editor, rng, alignToTop) => withMarker(editor, intoWindow, rng, alignToTop);\n    const elementIntoWindow = (editor, element, alignToTop) => withElement(editor, element, intoWindow, alignToTop);\n    const rangeIntoFrame = (editor, rng, alignToTop) => withMarker(editor, intoFrame, rng, alignToTop);\n    const elementIntoFrame = (editor, element, alignToTop) => withElement(editor, element, intoFrame, alignToTop);\n    const scrollElementIntoView = (editor, element, alignToTop) => {\n      const scroller = editor.inline ? elementIntoWindow : elementIntoFrame;\n      scroller(editor, element, alignToTop);\n    };\n    const scrollRangeIntoView = (editor, rng, alignToTop) => {\n      const scroller = editor.inline ? rangeIntoWindow : rangeIntoFrame;\n      scroller(editor, rng, alignToTop);\n    };\n\n    const focus$1 = (element, preventScroll = false) => element.dom.focus({ preventScroll });\n    const hasFocus$1 = element => {\n      const root = getRootNode(element).dom;\n      return element.dom === root.activeElement;\n    };\n    const active$1 = (root = getDocument()) => Optional.from(root.dom.activeElement).map(SugarElement.fromDom);\n    const search = element => active$1(getRootNode(element)).filter(e => element.dom.contains(e.dom));\n\n    const clamp$1 = (offset, element) => {\n      const max = isText$c(element) ? get$3(element).length : children$1(element).length + 1;\n      if (offset > max) {\n        return max;\n      } else if (offset < 0) {\n        return 0;\n      }\n      return offset;\n    };\n    const normalizeRng = rng => SimSelection.range(rng.start, clamp$1(rng.soffset, rng.start), rng.finish, clamp$1(rng.foffset, rng.finish));\n    const isOrContains = (root, elm) => !isRestrictedNode(elm.dom) && (contains(root, elm) || eq(root, elm));\n    const isRngInRoot = root => rng => isOrContains(root, rng.start) && isOrContains(root, rng.finish);\n    const shouldStore = editor => editor.inline || Env.browser.isFirefox();\n    const nativeRangeToSelectionRange = r => SimSelection.range(SugarElement.fromDom(r.startContainer), r.startOffset, SugarElement.fromDom(r.endContainer), r.endOffset);\n    const readRange = win => {\n      const selection = win.getSelection();\n      const rng = !selection || selection.rangeCount === 0 ? Optional.none() : Optional.from(selection.getRangeAt(0));\n      return rng.map(nativeRangeToSelectionRange);\n    };\n    const getBookmark$1 = root => {\n      const win = defaultView(root);\n      return readRange(win.dom).filter(isRngInRoot(root));\n    };\n    const validate = (root, bookmark) => Optional.from(bookmark).filter(isRngInRoot(root)).map(normalizeRng);\n    const bookmarkToNativeRng = bookmark => {\n      const rng = document.createRange();\n      try {\n        rng.setStart(bookmark.start.dom, bookmark.soffset);\n        rng.setEnd(bookmark.finish.dom, bookmark.foffset);\n        return Optional.some(rng);\n      } catch (_) {\n        return Optional.none();\n      }\n    };\n    const store = editor => {\n      const newBookmark = shouldStore(editor) ? getBookmark$1(SugarElement.fromDom(editor.getBody())) : Optional.none();\n      editor.bookmark = newBookmark.isSome() ? newBookmark : editor.bookmark;\n    };\n    const getRng = editor => {\n      const bookmark = editor.bookmark ? editor.bookmark : Optional.none();\n      return bookmark.bind(x => validate(SugarElement.fromDom(editor.getBody()), x)).bind(bookmarkToNativeRng);\n    };\n    const restore = editor => {\n      getRng(editor).each(rng => editor.selection.setRng(rng));\n    };\n\n    const isEditorUIElement$1 = elm => {\n      const className = elm.className.toString();\n      return className.indexOf('tox-') !== -1 || className.indexOf('mce-') !== -1;\n    };\n    const FocusManager = { isEditorUIElement: isEditorUIElement$1 };\n\n    const wrappedSetTimeout = (callback, time) => {\n      if (!isNumber(time)) {\n        time = 0;\n      }\n      return setTimeout(callback, time);\n    };\n    const wrappedSetInterval = (callback, time) => {\n      if (!isNumber(time)) {\n        time = 0;\n      }\n      return setInterval(callback, time);\n    };\n    const Delay = {\n      setEditorTimeout: (editor, callback, time) => {\n        return wrappedSetTimeout(() => {\n          if (!editor.removed) {\n            callback();\n          }\n        }, time);\n      },\n      setEditorInterval: (editor, callback, time) => {\n        const timer = wrappedSetInterval(() => {\n          if (!editor.removed) {\n            callback();\n          } else {\n            clearInterval(timer);\n          }\n        }, time);\n        return timer;\n      }\n    };\n\n    const isManualNodeChange = e => {\n      return e.type === 'nodechange' && e.selectionChange;\n    };\n    const registerPageMouseUp = (editor, throttledStore) => {\n      const mouseUpPage = () => {\n        throttledStore.throttle();\n      };\n      DOMUtils.DOM.bind(document, 'mouseup', mouseUpPage);\n      editor.on('remove', () => {\n        DOMUtils.DOM.unbind(document, 'mouseup', mouseUpPage);\n      });\n    };\n    const registerMouseUp = (editor, throttledStore) => {\n      editor.on('mouseup touchend', _e => {\n        throttledStore.throttle();\n      });\n    };\n    const registerEditorEvents = (editor, throttledStore) => {\n      registerMouseUp(editor, throttledStore);\n      editor.on('keyup NodeChange AfterSetSelectionRange', e => {\n        if (!isManualNodeChange(e)) {\n          store(editor);\n        }\n      });\n    };\n    const register$6 = editor => {\n      const throttledStore = first$1(() => {\n        store(editor);\n      }, 0);\n      editor.on('init', () => {\n        if (editor.inline) {\n          registerPageMouseUp(editor, throttledStore);\n        }\n        registerEditorEvents(editor, throttledStore);\n      });\n      editor.on('remove', () => {\n        throttledStore.cancel();\n      });\n    };\n\n    let documentFocusInHandler;\n    const DOM$9 = DOMUtils.DOM;\n    const isEditorUIElement = elm => {\n      return isElement$6(elm) && FocusManager.isEditorUIElement(elm);\n    };\n    const isEditorContentAreaElement = elm => {\n      const classList = elm.classList;\n      if (classList !== undefined) {\n        return classList.contains('tox-edit-area') || classList.contains('tox-edit-area__iframe') || classList.contains('mce-content-body');\n      } else {\n        return false;\n      }\n    };\n    const isUIElement = (editor, elm) => {\n      const customSelector = getCustomUiSelector(editor);\n      const parent = DOM$9.getParent(elm, elm => {\n        return isEditorUIElement(elm) || (customSelector ? editor.dom.is(elm, customSelector) : false);\n      });\n      return parent !== null;\n    };\n    const getActiveElement = editor => {\n      try {\n        const root = getRootNode(SugarElement.fromDom(editor.getElement()));\n        return active$1(root).fold(() => document.body, x => x.dom);\n      } catch (ex) {\n        return document.body;\n      }\n    };\n    const registerEvents$1 = (editorManager, e) => {\n      const editor = e.editor;\n      register$6(editor);\n      const toggleContentAreaOnFocus = (editor, fn) => {\n        if (shouldHighlightOnFocus(editor) && editor.inline !== true) {\n          const contentArea = SugarElement.fromDom(editor.getContainer());\n          fn(contentArea, 'tox-edit-focus');\n        }\n      };\n      editor.on('focusin', () => {\n        const focusedEditor = editorManager.focusedEditor;\n        if (isEditorContentAreaElement(getActiveElement(editor))) {\n          toggleContentAreaOnFocus(editor, add$2);\n        }\n        if (focusedEditor !== editor) {\n          if (focusedEditor) {\n            focusedEditor.dispatch('blur', { focusedEditor: editor });\n          }\n          editorManager.setActive(editor);\n          editorManager.focusedEditor = editor;\n          editor.dispatch('focus', { blurredEditor: focusedEditor });\n          editor.focus(true);\n        }\n      });\n      editor.on('focusout', () => {\n        Delay.setEditorTimeout(editor, () => {\n          const focusedEditor = editorManager.focusedEditor;\n          if (!isEditorContentAreaElement(getActiveElement(editor)) || focusedEditor !== editor) {\n            toggleContentAreaOnFocus(editor, remove$6);\n          }\n          if (!isUIElement(editor, getActiveElement(editor)) && focusedEditor === editor) {\n            editor.dispatch('blur', { focusedEditor: null });\n            editorManager.focusedEditor = null;\n          }\n        });\n      });\n      if (!documentFocusInHandler) {\n        documentFocusInHandler = e => {\n          const activeEditor = editorManager.activeEditor;\n          if (activeEditor) {\n            getOriginalEventTarget(e).each(target => {\n              const elem = target;\n              if (elem.ownerDocument === document) {\n                if (elem !== document.body && !isUIElement(activeEditor, elem) && editorManager.focusedEditor === activeEditor) {\n                  activeEditor.dispatch('blur', { focusedEditor: null });\n                  editorManager.focusedEditor = null;\n                }\n              }\n            });\n          }\n        };\n        DOM$9.bind(document, 'focusin', documentFocusInHandler);\n      }\n    };\n    const unregisterDocumentEvents = (editorManager, e) => {\n      if (editorManager.focusedEditor === e.editor) {\n        editorManager.focusedEditor = null;\n      }\n      if (!editorManager.activeEditor && documentFocusInHandler) {\n        DOM$9.unbind(document, 'focusin', documentFocusInHandler);\n        documentFocusInHandler = null;\n      }\n    };\n    const setup$w = editorManager => {\n      editorManager.on('AddEditor', curry(registerEvents$1, editorManager));\n      editorManager.on('RemoveEditor', curry(unregisterDocumentEvents, editorManager));\n    };\n\n    const getContentEditableHost = (editor, node) => editor.dom.getParent(node, node => editor.dom.getContentEditable(node) === 'true');\n    const hasContentEditableFalseParent = (editor, node) => editor.dom.getParent(node, node => editor.dom.getContentEditable(node) === 'false') !== null;\n    const getCollapsedNode = rng => rng.collapsed ? Optional.from(getNode$1(rng.startContainer, rng.startOffset)).map(SugarElement.fromDom) : Optional.none();\n    const getFocusInElement = (root, rng) => getCollapsedNode(rng).bind(node => {\n      if (isTableSection(node)) {\n        return Optional.some(node);\n      } else if (!contains(root, node)) {\n        return Optional.some(root);\n      } else {\n        return Optional.none();\n      }\n    });\n    const normalizeSelection = (editor, rng) => {\n      getFocusInElement(SugarElement.fromDom(editor.getBody()), rng).bind(elm => {\n        return firstPositionIn(elm.dom);\n      }).fold(() => {\n        editor.selection.normalize();\n      }, caretPos => editor.selection.setRng(caretPos.toRange()));\n    };\n    const focusBody = body => {\n      if (body.setActive) {\n        try {\n          body.setActive();\n        } catch (ex) {\n          body.focus();\n        }\n      } else {\n        body.focus();\n      }\n    };\n    const hasElementFocus = elm => hasFocus$1(elm) || search(elm).isSome();\n    const hasIframeFocus = editor => isNonNullable(editor.iframeElement) && hasFocus$1(SugarElement.fromDom(editor.iframeElement));\n    const hasInlineFocus = editor => {\n      const rawBody = editor.getBody();\n      return rawBody && hasElementFocus(SugarElement.fromDom(rawBody));\n    };\n    const hasUiFocus = editor => {\n      const dos = getRootNode(SugarElement.fromDom(editor.getElement()));\n      return active$1(dos).filter(elem => !isEditorContentAreaElement(elem.dom) && isUIElement(editor, elem.dom)).isSome();\n    };\n    const hasFocus = editor => editor.inline ? hasInlineFocus(editor) : hasIframeFocus(editor);\n    const hasEditorOrUiFocus = editor => hasFocus(editor) || hasUiFocus(editor);\n    const focusEditor = editor => {\n      const selection = editor.selection;\n      const body = editor.getBody();\n      let rng = selection.getRng();\n      editor.quirks.refreshContentEditable();\n      const restoreBookmark = editor => {\n        getRng(editor).each(bookmarkRng => {\n          editor.selection.setRng(bookmarkRng);\n          rng = bookmarkRng;\n        });\n      };\n      if (!hasFocus(editor) && editor.hasEditableRoot()) {\n        restoreBookmark(editor);\n      }\n      const contentEditableHost = getContentEditableHost(editor, selection.getNode());\n      if (contentEditableHost && editor.dom.isChildOf(contentEditableHost, body)) {\n        if (!hasContentEditableFalseParent(editor, contentEditableHost)) {\n          focusBody(body);\n        }\n        focusBody(contentEditableHost);\n        if (!editor.hasEditableRoot()) {\n          restoreBookmark(editor);\n        }\n        normalizeSelection(editor, rng);\n        activateEditor(editor);\n        return;\n      }\n      if (!editor.inline) {\n        if (!Env.browser.isOpera()) {\n          focusBody(body);\n        }\n        editor.getWin().focus();\n      }\n      if (Env.browser.isFirefox() || editor.inline) {\n        focusBody(body);\n        normalizeSelection(editor, rng);\n      }\n      activateEditor(editor);\n    };\n    const activateEditor = editor => editor.editorManager.setActive(editor);\n    const focus = (editor, skipFocus) => {\n      if (editor.removed) {\n        return;\n      }\n      if (skipFocus) {\n        activateEditor(editor);\n      } else {\n        focusEditor(editor);\n      }\n    };\n\n    const isEditableRange = (dom, rng) => {\n      if (rng.collapsed) {\n        return dom.isEditable(rng.startContainer);\n      } else {\n        return dom.isEditable(rng.startContainer) && dom.isEditable(rng.endContainer);\n      }\n    };\n\n    const getEndpointElement = (root, rng, start, real, resolve) => {\n      const container = start ? rng.startContainer : rng.endContainer;\n      const offset = start ? rng.startOffset : rng.endOffset;\n      return Optional.from(container).map(SugarElement.fromDom).map(elm => !real || !rng.collapsed ? child$1(elm, resolve(elm, offset)).getOr(elm) : elm).bind(elm => isElement$7(elm) ? Optional.some(elm) : parent(elm).filter(isElement$7)).map(elm => elm.dom).getOr(root);\n    };\n    const getStart = (root, rng, real = false) => getEndpointElement(root, rng, true, real, (elm, offset) => Math.min(childNodesCount(elm), offset));\n    const getEnd = (root, rng, real = false) => getEndpointElement(root, rng, false, real, (elm, offset) => offset > 0 ? offset - 1 : offset);\n    const skipEmptyTextNodes = (node, forwards) => {\n      const orig = node;\n      while (node && isText$b(node) && node.length === 0) {\n        node = forwards ? node.nextSibling : node.previousSibling;\n      }\n      return node || orig;\n    };\n    const getNode = (root, rng) => {\n      if (!rng) {\n        return root;\n      }\n      let startContainer = rng.startContainer;\n      let endContainer = rng.endContainer;\n      const startOffset = rng.startOffset;\n      const endOffset = rng.endOffset;\n      let node = rng.commonAncestorContainer;\n      if (!rng.collapsed) {\n        if (startContainer === endContainer) {\n          if (endOffset - startOffset < 2) {\n            if (startContainer.hasChildNodes()) {\n              node = startContainer.childNodes[startOffset];\n            }\n          }\n        }\n        if (isText$b(startContainer) && isText$b(endContainer)) {\n          if (startContainer.length === startOffset) {\n            startContainer = skipEmptyTextNodes(startContainer.nextSibling, true);\n          } else {\n            startContainer = startContainer.parentNode;\n          }\n          if (endOffset === 0) {\n            endContainer = skipEmptyTextNodes(endContainer.previousSibling, false);\n          } else {\n            endContainer = endContainer.parentNode;\n          }\n          if (startContainer && startContainer === endContainer) {\n            node = startContainer;\n          }\n        }\n      }\n      const elm = isText$b(node) ? node.parentNode : node;\n      return isHTMLElement(elm) ? elm : root;\n    };\n    const getSelectedBlocks = (dom, rng, startElm, endElm) => {\n      const selectedBlocks = [];\n      const root = dom.getRoot();\n      const start = dom.getParent(startElm || getStart(root, rng, rng.collapsed), dom.isBlock);\n      const end = dom.getParent(endElm || getEnd(root, rng, rng.collapsed), dom.isBlock);\n      if (start && start !== root) {\n        selectedBlocks.push(start);\n      }\n      if (start && end && start !== end) {\n        let node;\n        const walker = new DomTreeWalker(start, root);\n        while ((node = walker.next()) && node !== end) {\n          if (dom.isBlock(node)) {\n            selectedBlocks.push(node);\n          }\n        }\n      }\n      if (end && start !== end && end !== root) {\n        selectedBlocks.push(end);\n      }\n      return selectedBlocks;\n    };\n    const select = (dom, node, content) => Optional.from(node).bind(node => Optional.from(node.parentNode).map(parent => {\n      const idx = dom.nodeIndex(node);\n      const rng = dom.createRng();\n      rng.setStart(parent, idx);\n      rng.setEnd(parent, idx + 1);\n      if (content) {\n        moveEndPoint(dom, rng, node, true);\n        moveEndPoint(dom, rng, node, false);\n      }\n      return rng;\n    }));\n\n    const processRanges = (editor, ranges) => map$3(ranges, range => {\n      const evt = editor.dispatch('GetSelectionRange', { range });\n      return evt.range !== range ? evt.range : range;\n    });\n\n    const typeLookup = {\n      '#text': 3,\n      '#comment': 8,\n      '#cdata': 4,\n      '#pi': 7,\n      '#doctype': 10,\n      '#document-fragment': 11\n    };\n    const walk$2 = (node, root, prev) => {\n      const startName = prev ? 'lastChild' : 'firstChild';\n      const siblingName = prev ? 'prev' : 'next';\n      if (node[startName]) {\n        return node[startName];\n      }\n      if (node !== root) {\n        let sibling = node[siblingName];\n        if (sibling) {\n          return sibling;\n        }\n        for (let parent = node.parent; parent && parent !== root; parent = parent.parent) {\n          sibling = parent[siblingName];\n          if (sibling) {\n            return sibling;\n          }\n        }\n      }\n      return undefined;\n    };\n    const isEmptyTextNode = node => {\n      var _a;\n      const text = (_a = node.value) !== null && _a !== void 0 ? _a : '';\n      if (!isWhitespaceText(text)) {\n        return false;\n      }\n      const parentNode = node.parent;\n      if (parentNode && (parentNode.name !== 'span' || parentNode.attr('style')) && /^[ ]+$/.test(text)) {\n        return false;\n      }\n      return true;\n    };\n    const isNonEmptyElement = node => {\n      const isNamedAnchor = node.name === 'a' && !node.attr('href') && node.attr('id');\n      return node.attr('name') || node.attr('id') && !node.firstChild || node.attr('data-mce-bookmark') || isNamedAnchor;\n    };\n    class AstNode {\n      static create(name, attrs) {\n        const node = new AstNode(name, typeLookup[name] || 1);\n        if (attrs) {\n          each$d(attrs, (value, attrName) => {\n            node.attr(attrName, value);\n          });\n        }\n        return node;\n      }\n      constructor(name, type) {\n        this.name = name;\n        this.type = type;\n        if (type === 1) {\n          this.attributes = [];\n          this.attributes.map = {};\n        }\n      }\n      replace(node) {\n        const self = this;\n        if (node.parent) {\n          node.remove();\n        }\n        self.insert(node, self);\n        self.remove();\n        return self;\n      }\n      attr(name, value) {\n        const self = this;\n        if (!isString(name)) {\n          if (isNonNullable(name)) {\n            each$d(name, (value, key) => {\n              self.attr(key, value);\n            });\n          }\n          return self;\n        }\n        const attrs = self.attributes;\n        if (attrs) {\n          if (value !== undefined) {\n            if (value === null) {\n              if (name in attrs.map) {\n                delete attrs.map[name];\n                let i = attrs.length;\n                while (i--) {\n                  if (attrs[i].name === name) {\n                    attrs.splice(i, 1);\n                    return self;\n                  }\n                }\n              }\n              return self;\n            }\n            if (name in attrs.map) {\n              let i = attrs.length;\n              while (i--) {\n                if (attrs[i].name === name) {\n                  attrs[i].value = value;\n                  break;\n                }\n              }\n            } else {\n              attrs.push({\n                name,\n                value\n              });\n            }\n            attrs.map[name] = value;\n            return self;\n          }\n          return attrs.map[name];\n        }\n        return undefined;\n      }\n      clone() {\n        const self = this;\n        const clone = new AstNode(self.name, self.type);\n        const selfAttrs = self.attributes;\n        if (selfAttrs) {\n          const cloneAttrs = [];\n          cloneAttrs.map = {};\n          for (let i = 0, l = selfAttrs.length; i < l; i++) {\n            const selfAttr = selfAttrs[i];\n            if (selfAttr.name !== 'id') {\n              cloneAttrs[cloneAttrs.length] = {\n                name: selfAttr.name,\n                value: selfAttr.value\n              };\n              cloneAttrs.map[selfAttr.name] = selfAttr.value;\n            }\n          }\n          clone.attributes = cloneAttrs;\n        }\n        clone.value = self.value;\n        return clone;\n      }\n      wrap(wrapper) {\n        const self = this;\n        if (self.parent) {\n          self.parent.insert(wrapper, self);\n          wrapper.append(self);\n        }\n        return self;\n      }\n      unwrap() {\n        const self = this;\n        for (let node = self.firstChild; node;) {\n          const next = node.next;\n          self.insert(node, self, true);\n          node = next;\n        }\n        self.remove();\n      }\n      remove() {\n        const self = this, parent = self.parent, next = self.next, prev = self.prev;\n        if (parent) {\n          if (parent.firstChild === self) {\n            parent.firstChild = next;\n            if (next) {\n              next.prev = null;\n            }\n          } else if (prev) {\n            prev.next = next;\n          }\n          if (parent.lastChild === self) {\n            parent.lastChild = prev;\n            if (prev) {\n              prev.next = null;\n            }\n          } else if (next) {\n            next.prev = prev;\n          }\n          self.parent = self.next = self.prev = null;\n        }\n        return self;\n      }\n      append(node) {\n        const self = this;\n        if (node.parent) {\n          node.remove();\n        }\n        const last = self.lastChild;\n        if (last) {\n          last.next = node;\n          node.prev = last;\n          self.lastChild = node;\n        } else {\n          self.lastChild = self.firstChild = node;\n        }\n        node.parent = self;\n        return node;\n      }\n      insert(node, refNode, before) {\n        if (node.parent) {\n          node.remove();\n        }\n        const parent = refNode.parent || this;\n        if (before) {\n          if (refNode === parent.firstChild) {\n            parent.firstChild = node;\n          } else if (refNode.prev) {\n            refNode.prev.next = node;\n          }\n          node.prev = refNode.prev;\n          node.next = refNode;\n          refNode.prev = node;\n        } else {\n          if (refNode === parent.lastChild) {\n            parent.lastChild = node;\n          } else if (refNode.next) {\n            refNode.next.prev = node;\n          }\n          node.next = refNode.next;\n          node.prev = refNode;\n          refNode.next = node;\n        }\n        node.parent = parent;\n        return node;\n      }\n      getAll(name) {\n        const self = this;\n        const collection = [];\n        for (let node = self.firstChild; node; node = walk$2(node, self)) {\n          if (node.name === name) {\n            collection.push(node);\n          }\n        }\n        return collection;\n      }\n      children() {\n        const self = this;\n        const collection = [];\n        for (let node = self.firstChild; node; node = node.next) {\n          collection.push(node);\n        }\n        return collection;\n      }\n      empty() {\n        const self = this;\n        if (self.firstChild) {\n          const nodes = [];\n          for (let node = self.firstChild; node; node = walk$2(node, self)) {\n            nodes.push(node);\n          }\n          let i = nodes.length;\n          while (i--) {\n            const node = nodes[i];\n            node.parent = node.firstChild = node.lastChild = node.next = node.prev = null;\n          }\n        }\n        self.firstChild = self.lastChild = null;\n        return self;\n      }\n      isEmpty(elements, whitespace = {}, predicate) {\n        var _a;\n        const self = this;\n        let node = self.firstChild;\n        if (isNonEmptyElement(self)) {\n          return false;\n        }\n        if (node) {\n          do {\n            if (node.type === 1) {\n              if (node.attr('data-mce-bogus')) {\n                continue;\n              }\n              if (elements[node.name]) {\n                return false;\n              }\n              if (isNonEmptyElement(node)) {\n                return false;\n              }\n            }\n            if (node.type === 8) {\n              return false;\n            }\n            if (node.type === 3 && !isEmptyTextNode(node)) {\n              return false;\n            }\n            if (node.type === 3 && node.parent && whitespace[node.parent.name] && isWhitespaceText((_a = node.value) !== null && _a !== void 0 ? _a : '')) {\n              return false;\n            }\n            if (predicate && predicate(node)) {\n              return false;\n            }\n          } while (node = walk$2(node, self));\n        }\n        return true;\n      }\n      walk(prev) {\n        return walk$2(this, null, prev);\n      }\n    }\n\n    const unescapedTextParents = Tools.makeMap('NOSCRIPT STYLE SCRIPT XMP IFRAME NOEMBED NOFRAMES PLAINTEXT', ' ');\n    const containsZwsp = node => isString(node.nodeValue) && node.nodeValue.includes(ZWSP$1);\n    const getTemporaryNodeSelector = tempAttrs => `${ tempAttrs.length === 0 ? '' : `${ map$3(tempAttrs, attr => `[${ attr }]`).join(',') },` }[data-mce-bogus=\"all\"]`;\n    const getTemporaryNodes = (tempAttrs, body) => body.querySelectorAll(getTemporaryNodeSelector(tempAttrs));\n    const createZwspCommentWalker = body => document.createTreeWalker(body, NodeFilter.SHOW_COMMENT, node => containsZwsp(node) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP);\n    const createUnescapedZwspTextWalker = body => document.createTreeWalker(body, NodeFilter.SHOW_TEXT, node => {\n      if (containsZwsp(node)) {\n        const parent = node.parentNode;\n        return parent && has$2(unescapedTextParents, parent.nodeName) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;\n      } else {\n        return NodeFilter.FILTER_SKIP;\n      }\n    });\n    const hasZwspComment = body => createZwspCommentWalker(body).nextNode() !== null;\n    const hasUnescapedZwspText = body => createUnescapedZwspTextWalker(body).nextNode() !== null;\n    const hasTemporaryNode = (tempAttrs, body) => body.querySelector(getTemporaryNodeSelector(tempAttrs)) !== null;\n    const trimTemporaryNodes = (tempAttrs, body) => {\n      each$e(getTemporaryNodes(tempAttrs, body), elm => {\n        const element = SugarElement.fromDom(elm);\n        if (get$9(element, 'data-mce-bogus') === 'all') {\n          remove$4(element);\n        } else {\n          each$e(tempAttrs, attr => {\n            if (has$1(element, attr)) {\n              remove$9(element, attr);\n            }\n          });\n        }\n      });\n    };\n    const emptyAllNodeValuesInWalker = walker => {\n      let curr = walker.nextNode();\n      while (curr !== null) {\n        curr.nodeValue = null;\n        curr = walker.nextNode();\n      }\n    };\n    const emptyZwspComments = compose(emptyAllNodeValuesInWalker, createZwspCommentWalker);\n    const emptyUnescapedZwspTexts = compose(emptyAllNodeValuesInWalker, createUnescapedZwspTextWalker);\n    const trim$1 = (body, tempAttrs) => {\n      const conditionalTrims = [\n        {\n          condition: curry(hasTemporaryNode, tempAttrs),\n          action: curry(trimTemporaryNodes, tempAttrs)\n        },\n        {\n          condition: hasZwspComment,\n          action: emptyZwspComments\n        },\n        {\n          condition: hasUnescapedZwspText,\n          action: emptyUnescapedZwspTexts\n        }\n      ];\n      let trimmed = body;\n      let cloned = false;\n      each$e(conditionalTrims, ({condition, action}) => {\n        if (condition(trimmed)) {\n          if (!cloned) {\n            trimmed = body.cloneNode(true);\n            cloned = true;\n          }\n          action(trimmed);\n        }\n      });\n      return trimmed;\n    };\n\n    const cleanupBogusElements = parent => {\n      const bogusElements = descendants(parent, '[data-mce-bogus]');\n      each$e(bogusElements, elem => {\n        const bogusValue = get$9(elem, 'data-mce-bogus');\n        if (bogusValue === 'all') {\n          remove$4(elem);\n        } else if (isBr$5(elem)) {\n          before$3(elem, SugarElement.fromText(zeroWidth));\n          remove$4(elem);\n        } else {\n          unwrap(elem);\n        }\n      });\n    };\n    const cleanupInputNames = parent => {\n      const inputs = descendants(parent, 'input');\n      each$e(inputs, input => {\n        remove$9(input, 'name');\n      });\n    };\n\n    const trimEmptyContents = (editor, html) => {\n      const blockName = getForcedRootBlock(editor);\n      const emptyRegExp = new RegExp(`^(<${ blockName }[^>]*>(&nbsp;|&#160;|\\\\s|\\u00a0|<br \\\\/>|)<\\\\/${ blockName }>[\\r\\n]*|<br \\\\/>[\\r\\n]*)$`);\n      return html.replace(emptyRegExp, '');\n    };\n    const getPlainTextContent = (editor, body) => {\n      const doc = editor.getDoc();\n      const dos = getRootNode(SugarElement.fromDom(editor.getBody()));\n      const offscreenDiv = SugarElement.fromTag('div', doc);\n      set$3(offscreenDiv, 'data-mce-bogus', 'all');\n      setAll(offscreenDiv, {\n        position: 'fixed',\n        left: '-9999999px',\n        top: '0'\n      });\n      set$1(offscreenDiv, body.innerHTML);\n      cleanupBogusElements(offscreenDiv);\n      cleanupInputNames(offscreenDiv);\n      const root = getContentContainer(dos);\n      append$1(root, offscreenDiv);\n      const content = trim$2(offscreenDiv.dom.innerText);\n      remove$4(offscreenDiv);\n      return content;\n    };\n    const getContentFromBody = (editor, args, body) => {\n      let content;\n      if (args.format === 'raw') {\n        content = Tools.trim(trim$2(trim$1(body, editor.serializer.getTempAttrs()).innerHTML));\n      } else if (args.format === 'text') {\n        content = getPlainTextContent(editor, body);\n      } else if (args.format === 'tree') {\n        content = editor.serializer.serialize(body, args);\n      } else {\n        content = trimEmptyContents(editor, editor.serializer.serialize(body, args));\n      }\n      const shouldTrim = args.format !== 'text' && !isWsPreserveElement(SugarElement.fromDom(body));\n      return shouldTrim && isString(content) ? Tools.trim(content) : content;\n    };\n    const getContentInternal = (editor, args) => Optional.from(editor.getBody()).fold(constant(args.format === 'tree' ? new AstNode('body', 11) : ''), body => getContentFromBody(editor, args, body));\n\n    const makeMap$1 = Tools.makeMap;\n    const Writer = settings => {\n      const html = [];\n      settings = settings || {};\n      const indent = settings.indent;\n      const indentBefore = makeMap$1(settings.indent_before || '');\n      const indentAfter = makeMap$1(settings.indent_after || '');\n      const encode = Entities.getEncodeFunc(settings.entity_encoding || 'raw', settings.entities);\n      const htmlOutput = settings.element_format !== 'xhtml';\n      return {\n        start: (name, attrs, empty) => {\n          if (indent && indentBefore[name] && html.length > 0) {\n            const value = html[html.length - 1];\n            if (value.length > 0 && value !== '\\n') {\n              html.push('\\n');\n            }\n          }\n          html.push('<', name);\n          if (attrs) {\n            for (let i = 0, l = attrs.length; i < l; i++) {\n              const attr = attrs[i];\n              html.push(' ', attr.name, '=\"', encode(attr.value, true), '\"');\n            }\n          }\n          if (!empty || htmlOutput) {\n            html[html.length] = '>';\n          } else {\n            html[html.length] = ' />';\n          }\n          if (empty && indent && indentAfter[name] && html.length > 0) {\n            const value = html[html.length - 1];\n            if (value.length > 0 && value !== '\\n') {\n              html.push('\\n');\n            }\n          }\n        },\n        end: name => {\n          let value;\n          html.push('</', name, '>');\n          if (indent && indentAfter[name] && html.length > 0) {\n            value = html[html.length - 1];\n            if (value.length > 0 && value !== '\\n') {\n              html.push('\\n');\n            }\n          }\n        },\n        text: (text, raw) => {\n          if (text.length > 0) {\n            html[html.length] = raw ? text : encode(text);\n          }\n        },\n        cdata: text => {\n          html.push('<![CDATA[', text, ']]>');\n        },\n        comment: text => {\n          html.push('<!--', text, '-->');\n        },\n        pi: (name, text) => {\n          if (text) {\n            html.push('<?', name, ' ', encode(text), '?>');\n          } else {\n            html.push('<?', name, '?>');\n          }\n          if (indent) {\n            html.push('\\n');\n          }\n        },\n        doctype: text => {\n          html.push('<!DOCTYPE', text, '>', indent ? '\\n' : '');\n        },\n        reset: () => {\n          html.length = 0;\n        },\n        getContent: () => {\n          return html.join('').replace(/\\n$/, '');\n        }\n      };\n    };\n\n    const HtmlSerializer = (settings = {}, schema = Schema()) => {\n      const writer = Writer(settings);\n      settings.validate = 'validate' in settings ? settings.validate : true;\n      const serialize = node => {\n        const validate = settings.validate;\n        const handlers = {\n          3: node => {\n            var _a;\n            writer.text((_a = node.value) !== null && _a !== void 0 ? _a : '', node.raw);\n          },\n          8: node => {\n            var _a;\n            writer.comment((_a = node.value) !== null && _a !== void 0 ? _a : '');\n          },\n          7: node => {\n            writer.pi(node.name, node.value);\n          },\n          10: node => {\n            var _a;\n            writer.doctype((_a = node.value) !== null && _a !== void 0 ? _a : '');\n          },\n          4: node => {\n            var _a;\n            writer.cdata((_a = node.value) !== null && _a !== void 0 ? _a : '');\n          },\n          11: node => {\n            let tempNode = node;\n            if (tempNode = tempNode.firstChild) {\n              do {\n                walk(tempNode);\n              } while (tempNode = tempNode.next);\n            }\n          }\n        };\n        writer.reset();\n        const walk = node => {\n          var _a;\n          const handler = handlers[node.type];\n          if (!handler) {\n            const name = node.name;\n            const isEmpty = name in schema.getVoidElements();\n            let attrs = node.attributes;\n            if (validate && attrs && attrs.length > 1) {\n              const sortedAttrs = [];\n              sortedAttrs.map = {};\n              const elementRule = schema.getElementRule(node.name);\n              if (elementRule) {\n                for (let i = 0, l = elementRule.attributesOrder.length; i < l; i++) {\n                  const attrName = elementRule.attributesOrder[i];\n                  if (attrName in attrs.map) {\n                    const attrValue = attrs.map[attrName];\n                    sortedAttrs.map[attrName] = attrValue;\n                    sortedAttrs.push({\n                      name: attrName,\n                      value: attrValue\n                    });\n                  }\n                }\n                for (let i = 0, l = attrs.length; i < l; i++) {\n                  const attrName = attrs[i].name;\n                  if (!(attrName in sortedAttrs.map)) {\n                    const attrValue = attrs.map[attrName];\n                    sortedAttrs.map[attrName] = attrValue;\n                    sortedAttrs.push({\n                      name: attrName,\n                      value: attrValue\n                    });\n                  }\n                }\n                attrs = sortedAttrs;\n              }\n            }\n            writer.start(name, attrs, isEmpty);\n            if (isNonHtmlElementRootName(name)) {\n              if (isString(node.value)) {\n                writer.text(node.value, true);\n              }\n              writer.end(name);\n            } else {\n              if (!isEmpty) {\n                let child = node.firstChild;\n                if (child) {\n                  if ((name === 'pre' || name === 'textarea') && child.type === 3 && ((_a = child.value) === null || _a === void 0 ? void 0 : _a[0]) === '\\n') {\n                    writer.text('\\n', true);\n                  }\n                  do {\n                    walk(child);\n                  } while (child = child.next);\n                }\n                writer.end(name);\n              }\n            }\n          } else {\n            handler(node);\n          }\n        };\n        if (node.type === 1 && !settings.inner) {\n          walk(node);\n        } else if (node.type === 3) {\n          handlers[3](node);\n        } else {\n          handlers[11](node);\n        }\n        return writer.getContent();\n      };\n      return { serialize };\n    };\n\n    const nonInheritableStyles = new Set();\n    (() => {\n      const nonInheritableStylesArr = [\n        'margin',\n        'margin-left',\n        'margin-right',\n        'margin-top',\n        'margin-bottom',\n        'padding',\n        'padding-left',\n        'padding-right',\n        'padding-top',\n        'padding-bottom',\n        'border',\n        'border-width',\n        'border-style',\n        'border-color',\n        'background',\n        'background-attachment',\n        'background-clip',\n        'background-image',\n        'background-origin',\n        'background-position',\n        'background-repeat',\n        'background-size',\n        'float',\n        'position',\n        'left',\n        'right',\n        'top',\n        'bottom',\n        'z-index',\n        'display',\n        'transform',\n        'width',\n        'max-width',\n        'min-width',\n        'height',\n        'max-height',\n        'min-height',\n        'overflow',\n        'overflow-x',\n        'overflow-y',\n        'text-overflow',\n        'vertical-align',\n        'transition',\n        'transition-delay',\n        'transition-duration',\n        'transition-property',\n        'transition-timing-function'\n      ];\n      each$e(nonInheritableStylesArr, style => {\n        nonInheritableStyles.add(style);\n      });\n    })();\n    const conditionalNonInheritableStyles = new Set();\n    (() => {\n      const conditionalNonInheritableStylesArr = ['background-color'];\n      each$e(conditionalNonInheritableStylesArr, style => {\n        conditionalNonInheritableStyles.add(style);\n      });\n    })();\n    const shorthandStyleProps = [\n      'font',\n      'text-decoration',\n      'text-emphasis'\n    ];\n    const getStyles$1 = (dom, node) => dom.parseStyle(dom.getAttrib(node, 'style'));\n    const getStyleProps = (dom, node) => keys(getStyles$1(dom, node));\n    const isNonInheritableStyle = style => nonInheritableStyles.has(style);\n    const isConditionalNonInheritableStyle = style => conditionalNonInheritableStyles.has(style);\n    const hasNonInheritableStyles = (dom, node) => exists(getStyleProps(dom, node), style => isNonInheritableStyle(style));\n    const hasConditionalNonInheritableStyles = (dom, node) => hasNonInheritableStyles(dom, node) && exists(getStyleProps(dom, node), style => isConditionalNonInheritableStyle(style));\n    const getLonghandStyleProps = styles => filter$5(styles, style => exists(shorthandStyleProps, prop => startsWith(style, prop)));\n    const hasStyleConflict = (dom, node, parentNode) => {\n      const nodeStyleProps = getStyleProps(dom, node);\n      const parentNodeStyleProps = getStyleProps(dom, parentNode);\n      const valueMismatch = prop => {\n        var _a, _b;\n        const nodeValue = (_a = dom.getStyle(node, prop)) !== null && _a !== void 0 ? _a : '';\n        const parentValue = (_b = dom.getStyle(parentNode, prop)) !== null && _b !== void 0 ? _b : '';\n        return isNotEmpty(nodeValue) && isNotEmpty(parentValue) && nodeValue !== parentValue;\n      };\n      return exists(nodeStyleProps, nodeStyleProp => {\n        const propExists = props => exists(props, prop => prop === nodeStyleProp);\n        if (!propExists(parentNodeStyleProps) && propExists(shorthandStyleProps)) {\n          const longhandProps = getLonghandStyleProps(parentNodeStyleProps);\n          return exists(longhandProps, valueMismatch);\n        } else {\n          return valueMismatch(nodeStyleProp);\n        }\n      });\n    };\n\n    const isChar = (forward, predicate, pos) => Optional.from(pos.container()).filter(isText$b).exists(text => {\n      const delta = forward ? 0 : -1;\n      return predicate(text.data.charAt(pos.offset() + delta));\n    });\n    const isBeforeSpace = curry(isChar, true, isWhiteSpace);\n    const isAfterSpace = curry(isChar, false, isWhiteSpace);\n    const isEmptyText = pos => {\n      const container = pos.container();\n      return isText$b(container) && (container.data.length === 0 || isZwsp(container.data) && BookmarkManager.isBookmarkNode(container.parentNode));\n    };\n    const matchesElementPosition = (before, predicate) => pos => getChildNodeAtRelativeOffset(before ? 0 : -1, pos).filter(predicate).isSome();\n    const isImageBlock = node => isImg(node) && get$7(SugarElement.fromDom(node), 'display') === 'block';\n    const isCefNode = node => isContentEditableFalse$b(node) && !isBogusAll(node);\n    const isBeforeImageBlock = matchesElementPosition(true, isImageBlock);\n    const isAfterImageBlock = matchesElementPosition(false, isImageBlock);\n    const isBeforeMedia = matchesElementPosition(true, isMedia$2);\n    const isAfterMedia = matchesElementPosition(false, isMedia$2);\n    const isBeforeTable = matchesElementPosition(true, isTable$2);\n    const isAfterTable = matchesElementPosition(false, isTable$2);\n    const isBeforeContentEditableFalse = matchesElementPosition(true, isCefNode);\n    const isAfterContentEditableFalse = matchesElementPosition(false, isCefNode);\n\n    const dropLast = xs => xs.slice(0, -1);\n    const parentsUntil = (start, root, predicate) => {\n      if (contains(root, start)) {\n        return dropLast(parents$1(start, elm => {\n          return predicate(elm) || eq(elm, root);\n        }));\n      } else {\n        return [];\n      }\n    };\n    const parents = (start, root) => parentsUntil(start, root, never);\n    const parentsAndSelf = (start, root) => [start].concat(parents(start, root));\n\n    const navigateIgnoreEmptyTextNodes = (forward, root, from) => navigateIgnore(forward, root, from, isEmptyText);\n    const isBlock$1 = schema => el => schema.isBlock(name(el));\n    const getClosestBlock$1 = (root, pos, schema) => find$2(parentsAndSelf(SugarElement.fromDom(pos.container()), root), isBlock$1(schema));\n    const isAtBeforeAfterBlockBoundary = (forward, root, pos, schema) => navigateIgnoreEmptyTextNodes(forward, root.dom, pos).forall(newPos => getClosestBlock$1(root, pos, schema).fold(() => !isInSameBlock(newPos, pos, root.dom), fromBlock => !isInSameBlock(newPos, pos, root.dom) && contains(fromBlock, SugarElement.fromDom(newPos.container()))));\n    const isAtBlockBoundary = (forward, root, pos, schema) => getClosestBlock$1(root, pos, schema).fold(() => navigateIgnoreEmptyTextNodes(forward, root.dom, pos).forall(newPos => !isInSameBlock(newPos, pos, root.dom)), parent => navigateIgnoreEmptyTextNodes(forward, parent.dom, pos).isNone());\n    const isAtStartOfBlock = curry(isAtBlockBoundary, false);\n    const isAtEndOfBlock = curry(isAtBlockBoundary, true);\n    const isBeforeBlock = curry(isAtBeforeAfterBlockBoundary, false);\n    const isAfterBlock = curry(isAtBeforeAfterBlockBoundary, true);\n\n    const isBr$1 = pos => getElementFromPosition(pos).exists(isBr$5);\n    const findBr = (forward, root, pos, schema) => {\n      const parentBlocks = filter$5(parentsAndSelf(SugarElement.fromDom(pos.container()), root), el => schema.isBlock(name(el)));\n      const scope = head(parentBlocks).getOr(root);\n      return fromPosition(forward, scope.dom, pos).filter(isBr$1);\n    };\n    const isBeforeBr$1 = (root, pos, schema) => getElementFromPosition(pos).exists(isBr$5) || findBr(true, root, pos, schema).isSome();\n    const isAfterBr = (root, pos, schema) => getElementFromPrevPosition(pos).exists(isBr$5) || findBr(false, root, pos, schema).isSome();\n    const findPreviousBr = curry(findBr, false);\n    const findNextBr = curry(findBr, true);\n\n    const isInMiddleOfText = pos => CaretPosition.isTextPosition(pos) && !pos.isAtStart() && !pos.isAtEnd();\n    const getClosestBlock = (root, pos, schema) => {\n      const parentBlocks = filter$5(parentsAndSelf(SugarElement.fromDom(pos.container()), root), el => schema.isBlock(name(el)));\n      return head(parentBlocks).getOr(root);\n    };\n    const hasSpaceBefore = (root, pos, schema) => {\n      if (isInMiddleOfText(pos)) {\n        return isAfterSpace(pos);\n      } else {\n        return isAfterSpace(pos) || prevPosition(getClosestBlock(root, pos, schema).dom, pos).exists(isAfterSpace);\n      }\n    };\n    const hasSpaceAfter = (root, pos, schema) => {\n      if (isInMiddleOfText(pos)) {\n        return isBeforeSpace(pos);\n      } else {\n        return isBeforeSpace(pos) || nextPosition(getClosestBlock(root, pos, schema).dom, pos).exists(isBeforeSpace);\n      }\n    };\n    const isPreValue = value => contains$2([\n      'pre',\n      'pre-wrap'\n    ], value);\n    const isInPre = pos => getElementFromPosition(pos).bind(elm => closest$4(elm, isElement$7)).exists(elm => isPreValue(get$7(elm, 'white-space')));\n    const isAtBeginningOfBody = (root, pos) => prevPosition(root.dom, pos).isNone();\n    const isAtEndOfBody = (root, pos) => nextPosition(root.dom, pos).isNone();\n    const isAtLineBoundary = (root, pos, schema) => isAtBeginningOfBody(root, pos) || isAtEndOfBody(root, pos) || isAtStartOfBlock(root, pos, schema) || isAtEndOfBlock(root, pos, schema) || isAfterBr(root, pos, schema) || isBeforeBr$1(root, pos, schema);\n    const isCefBlock = node => isNonNullable(node) && isContentEditableFalse$b(node) && isBlockLike(node);\n    const isSiblingCefBlock = (root, direction) => container => {\n      return isCefBlock(new DomTreeWalker(container, root)[direction]());\n    };\n    const isBeforeCefBlock = (root, pos) => {\n      const nextPos = nextPosition(root.dom, pos).getOr(pos);\n      const isNextCefBlock = isSiblingCefBlock(root.dom, 'next');\n      return pos.isAtEnd() && (isNextCefBlock(pos.container()) || isNextCefBlock(nextPos.container()));\n    };\n    const isAfterCefBlock = (root, pos) => {\n      const prevPos = prevPosition(root.dom, pos).getOr(pos);\n      const isPrevCefBlock = isSiblingCefBlock(root.dom, 'prev');\n      return pos.isAtStart() && (isPrevCefBlock(pos.container()) || isPrevCefBlock(prevPos.container()));\n    };\n    const needsToHaveNbsp = (root, pos, schema) => {\n      if (isInPre(pos)) {\n        return false;\n      } else {\n        return isAtLineBoundary(root, pos, schema) || hasSpaceBefore(root, pos, schema) || hasSpaceAfter(root, pos, schema);\n      }\n    };\n    const needsToBeNbspLeft = (root, pos, schema) => {\n      if (isInPre(pos)) {\n        return false;\n      } else {\n        return isAtStartOfBlock(root, pos, schema) || isBeforeBlock(root, pos, schema) || isAfterBr(root, pos, schema) || hasSpaceBefore(root, pos, schema) || isAfterCefBlock(root, pos);\n      }\n    };\n    const leanRight = pos => {\n      const container = pos.container();\n      const offset = pos.offset();\n      if (isText$b(container) && offset < container.data.length) {\n        return CaretPosition(container, offset + 1);\n      } else {\n        return pos;\n      }\n    };\n    const needsToBeNbspRight = (root, pos, schema) => {\n      if (isInPre(pos)) {\n        return false;\n      } else {\n        return isAtEndOfBlock(root, pos, schema) || isAfterBlock(root, pos, schema) || isBeforeBr$1(root, pos, schema) || hasSpaceAfter(root, pos, schema) || isBeforeCefBlock(root, pos);\n      }\n    };\n    const needsToBeNbsp = (root, pos, schema) => needsToBeNbspLeft(root, pos, schema) || needsToBeNbspRight(root, leanRight(pos), schema);\n    const isNbspAt = (text, offset) => isNbsp(text.charAt(offset));\n    const isWhiteSpaceAt = (text, offset) => isWhiteSpace(text.charAt(offset));\n    const hasNbsp = pos => {\n      const container = pos.container();\n      return isText$b(container) && contains$1(container.data, nbsp);\n    };\n    const normalizeNbspMiddle = text => {\n      const chars = text.split('');\n      return map$3(chars, (chr, i) => {\n        if (isNbsp(chr) && i > 0 && i < chars.length - 1 && isContent(chars[i - 1]) && isContent(chars[i + 1])) {\n          return ' ';\n        } else {\n          return chr;\n        }\n      }).join('');\n    };\n    const normalizeNbspAtStart = (root, node, makeNbsp, schema) => {\n      const text = node.data;\n      const firstPos = CaretPosition(node, 0);\n      if (!makeNbsp && isNbspAt(text, 0) && !needsToBeNbsp(root, firstPos, schema)) {\n        node.data = ' ' + text.slice(1);\n        return true;\n      } else if (makeNbsp && isWhiteSpaceAt(text, 0) && needsToBeNbspLeft(root, firstPos, schema)) {\n        node.data = nbsp + text.slice(1);\n        return true;\n      } else {\n        return false;\n      }\n    };\n    const normalizeNbspInMiddleOfTextNode = node => {\n      const text = node.data;\n      const newText = normalizeNbspMiddle(text);\n      if (newText !== text) {\n        node.data = newText;\n        return true;\n      } else {\n        return false;\n      }\n    };\n    const normalizeNbspAtEnd = (root, node, makeNbsp, schema) => {\n      const text = node.data;\n      const lastPos = CaretPosition(node, text.length - 1);\n      if (!makeNbsp && isNbspAt(text, text.length - 1) && !needsToBeNbsp(root, lastPos, schema)) {\n        node.data = text.slice(0, -1) + ' ';\n        return true;\n      } else if (makeNbsp && isWhiteSpaceAt(text, text.length - 1) && needsToBeNbspRight(root, lastPos, schema)) {\n        node.data = text.slice(0, -1) + nbsp;\n        return true;\n      } else {\n        return false;\n      }\n    };\n    const normalizeNbsps$1 = (root, pos, schema) => {\n      const container = pos.container();\n      if (!isText$b(container)) {\n        return Optional.none();\n      }\n      if (hasNbsp(pos)) {\n        const normalized = normalizeNbspAtStart(root, container, false, schema) || normalizeNbspInMiddleOfTextNode(container) || normalizeNbspAtEnd(root, container, false, schema);\n        return someIf(normalized, pos);\n      } else if (needsToBeNbsp(root, pos, schema)) {\n        const normalized = normalizeNbspAtStart(root, container, true, schema) || normalizeNbspAtEnd(root, container, true, schema);\n        return someIf(normalized, pos);\n      } else {\n        return Optional.none();\n      }\n    };\n    const normalizeNbspsInEditor = editor => {\n      const root = SugarElement.fromDom(editor.getBody());\n      if (editor.selection.isCollapsed()) {\n        normalizeNbsps$1(root, CaretPosition.fromRangeStart(editor.selection.getRng()), editor.schema).each(pos => {\n          editor.selection.setRng(pos.toRange());\n        });\n      }\n    };\n\n    const normalize$1 = (node, offset, count, schema) => {\n      if (count === 0) {\n        return;\n      }\n      const elm = SugarElement.fromDom(node);\n      const root = ancestor$4(elm, el => schema.isBlock(name(el))).getOr(elm);\n      const whitespace = node.data.slice(offset, offset + count);\n      const isEndOfContent = offset + count >= node.data.length && needsToBeNbspRight(root, CaretPosition(node, node.data.length), schema);\n      const isStartOfContent = offset === 0 && needsToBeNbspLeft(root, CaretPosition(node, 0), schema);\n      node.replaceData(offset, count, normalize$4(whitespace, 4, isStartOfContent, isEndOfContent));\n    };\n    const normalizeWhitespaceAfter = (node, offset, schema) => {\n      const content = node.data.slice(offset);\n      const whitespaceCount = content.length - lTrim(content).length;\n      normalize$1(node, offset, whitespaceCount, schema);\n    };\n    const normalizeWhitespaceBefore = (node, offset, schema) => {\n      const content = node.data.slice(0, offset);\n      const whitespaceCount = content.length - rTrim(content).length;\n      normalize$1(node, offset - whitespaceCount, whitespaceCount, schema);\n    };\n    const mergeTextNodes = (prevNode, nextNode, schema, normalizeWhitespace, mergeToPrev = true) => {\n      const whitespaceOffset = rTrim(prevNode.data).length;\n      const newNode = mergeToPrev ? prevNode : nextNode;\n      const removeNode = mergeToPrev ? nextNode : prevNode;\n      if (mergeToPrev) {\n        newNode.appendData(removeNode.data);\n      } else {\n        newNode.insertData(0, removeNode.data);\n      }\n      remove$4(SugarElement.fromDom(removeNode));\n      if (normalizeWhitespace) {\n        normalizeWhitespaceAfter(newNode, whitespaceOffset, schema);\n      }\n      return newNode;\n    };\n\n    const needsReposition = (pos, elm) => {\n      const container = pos.container();\n      const offset = pos.offset();\n      return !CaretPosition.isTextPosition(pos) && container === elm.parentNode && offset > CaretPosition.before(elm).offset();\n    };\n    const reposition = (elm, pos) => needsReposition(pos, elm) ? CaretPosition(pos.container(), pos.offset() - 1) : pos;\n    const beforeOrStartOf = node => isText$b(node) ? CaretPosition(node, 0) : CaretPosition.before(node);\n    const afterOrEndOf = node => isText$b(node) ? CaretPosition(node, node.data.length) : CaretPosition.after(node);\n    const getPreviousSiblingCaretPosition = elm => {\n      if (isCaretCandidate$3(elm.previousSibling)) {\n        return Optional.some(afterOrEndOf(elm.previousSibling));\n      } else {\n        return elm.previousSibling ? lastPositionIn(elm.previousSibling) : Optional.none();\n      }\n    };\n    const getNextSiblingCaretPosition = elm => {\n      if (isCaretCandidate$3(elm.nextSibling)) {\n        return Optional.some(beforeOrStartOf(elm.nextSibling));\n      } else {\n        return elm.nextSibling ? firstPositionIn(elm.nextSibling) : Optional.none();\n      }\n    };\n    const findCaretPositionBackwardsFromElm = (rootElement, elm) => {\n      return Optional.from(elm.previousSibling ? elm.previousSibling : elm.parentNode).bind(node => prevPosition(rootElement, CaretPosition.before(node))).orThunk(() => nextPosition(rootElement, CaretPosition.after(elm)));\n    };\n    const findCaretPositionForwardsFromElm = (rootElement, elm) => nextPosition(rootElement, CaretPosition.after(elm)).orThunk(() => prevPosition(rootElement, CaretPosition.before(elm)));\n    const findCaretPositionBackwards = (rootElement, elm) => getPreviousSiblingCaretPosition(elm).orThunk(() => getNextSiblingCaretPosition(elm)).orThunk(() => findCaretPositionBackwardsFromElm(rootElement, elm));\n    const findCaretPositionForward = (rootElement, elm) => getNextSiblingCaretPosition(elm).orThunk(() => getPreviousSiblingCaretPosition(elm)).orThunk(() => findCaretPositionForwardsFromElm(rootElement, elm));\n    const findCaretPosition = (forward, rootElement, elm) => forward ? findCaretPositionForward(rootElement, elm) : findCaretPositionBackwards(rootElement, elm);\n    const findCaretPosOutsideElmAfterDelete = (forward, rootElement, elm) => findCaretPosition(forward, rootElement, elm).map(curry(reposition, elm));\n    const setSelection$1 = (editor, forward, pos) => {\n      pos.fold(() => {\n        editor.focus();\n      }, pos => {\n        editor.selection.setRng(pos.toRange(), forward);\n      });\n    };\n    const eqRawNode = rawNode => elm => elm.dom === rawNode;\n    const isBlock = (editor, elm) => elm && has$2(editor.schema.getBlockElements(), name(elm));\n    const paddEmptyBlock = (schema, elm, preserveEmptyCaret) => {\n      if (isEmpty$2(schema, elm)) {\n        const br = SugarElement.fromHtml('<br data-mce-bogus=\"1\">');\n        if (preserveEmptyCaret) {\n          each$e(children$1(elm), node => {\n            if (!isEmptyCaretFormatElement(node)) {\n              remove$4(node);\n            }\n          });\n        } else {\n          empty(elm);\n        }\n        append$1(elm, br);\n        return Optional.some(CaretPosition.before(br.dom));\n      } else {\n        return Optional.none();\n      }\n    };\n    const deleteNormalized = (elm, afterDeletePosOpt, schema, normalizeWhitespace) => {\n      const prevTextOpt = prevSibling(elm).filter(isText$c);\n      const nextTextOpt = nextSibling(elm).filter(isText$c);\n      remove$4(elm);\n      return lift3(prevTextOpt, nextTextOpt, afterDeletePosOpt, (prev, next, pos) => {\n        const prevNode = prev.dom, nextNode = next.dom;\n        const offset = prevNode.data.length;\n        mergeTextNodes(prevNode, nextNode, schema, normalizeWhitespace);\n        return pos.container() === nextNode ? CaretPosition(prevNode, offset) : pos;\n      }).orThunk(() => {\n        if (normalizeWhitespace) {\n          prevTextOpt.each(elm => normalizeWhitespaceBefore(elm.dom, elm.dom.length, schema));\n          nextTextOpt.each(elm => normalizeWhitespaceAfter(elm.dom, 0, schema));\n        }\n        return afterDeletePosOpt;\n      });\n    };\n    const isInlineElement = (editor, element) => has$2(editor.schema.getTextInlineElements(), name(element));\n    const deleteElement$2 = (editor, forward, elm, moveCaret = true, preserveEmptyCaret = false) => {\n      const afterDeletePos = findCaretPosOutsideElmAfterDelete(forward, editor.getBody(), elm.dom);\n      const parentBlock = ancestor$4(elm, curry(isBlock, editor), eqRawNode(editor.getBody()));\n      const normalizedAfterDeletePos = deleteNormalized(elm, afterDeletePos, editor.schema, isInlineElement(editor, elm));\n      if (editor.dom.isEmpty(editor.getBody())) {\n        editor.setContent('');\n        editor.selection.setCursorLocation();\n      } else {\n        parentBlock.bind(elm => paddEmptyBlock(editor.schema, elm, preserveEmptyCaret)).fold(() => {\n          if (moveCaret) {\n            setSelection$1(editor, forward, normalizedAfterDeletePos);\n          }\n        }, paddPos => {\n          if (moveCaret) {\n            setSelection$1(editor, forward, Optional.some(paddPos));\n          }\n        });\n      }\n    };\n\n    const strongRtl = /[\\u0591-\\u07FF\\uFB1D-\\uFDFF\\uFE70-\\uFEFC]/;\n    const hasStrongRtl = text => strongRtl.test(text);\n\n    const isInlineTarget = (editor, elm) => is$1(SugarElement.fromDom(elm), getInlineBoundarySelector(editor)) && !isTransparentBlock(editor.schema, elm) && editor.dom.isEditable(elm);\n    const isRtl = element => {\n      var _a;\n      return DOMUtils.DOM.getStyle(element, 'direction', true) === 'rtl' || hasStrongRtl((_a = element.textContent) !== null && _a !== void 0 ? _a : '');\n    };\n    const findInlineParents = (isInlineTarget, rootNode, pos) => filter$5(DOMUtils.DOM.getParents(pos.container(), '*', rootNode), isInlineTarget);\n    const findRootInline = (isInlineTarget, rootNode, pos) => {\n      const parents = findInlineParents(isInlineTarget, rootNode, pos);\n      return Optional.from(parents[parents.length - 1]);\n    };\n    const hasSameParentBlock = (rootNode, node1, node2) => {\n      const block1 = getParentBlock$3(node1, rootNode);\n      const block2 = getParentBlock$3(node2, rootNode);\n      return isNonNullable(block1) && block1 === block2;\n    };\n    const isAtZwsp = pos => isBeforeInline(pos) || isAfterInline(pos);\n    const normalizePosition = (forward, pos) => {\n      const container = pos.container(), offset = pos.offset();\n      if (forward) {\n        if (isCaretContainerInline(container)) {\n          if (isText$b(container.nextSibling)) {\n            return CaretPosition(container.nextSibling, 0);\n          } else {\n            return CaretPosition.after(container);\n          }\n        } else {\n          return isBeforeInline(pos) ? CaretPosition(container, offset + 1) : pos;\n        }\n      } else {\n        if (isCaretContainerInline(container)) {\n          if (isText$b(container.previousSibling)) {\n            return CaretPosition(container.previousSibling, container.previousSibling.data.length);\n          } else {\n            return CaretPosition.before(container);\n          }\n        } else {\n          return isAfterInline(pos) ? CaretPosition(container, offset - 1) : pos;\n        }\n      }\n    };\n    const normalizeForwards = curry(normalizePosition, true);\n    const normalizeBackwards = curry(normalizePosition, false);\n\n    const execCommandIgnoreInputEvents = (editor, command) => {\n      const inputBlocker = e => e.stopImmediatePropagation();\n      editor.on('beforeinput input', inputBlocker, true);\n      editor.getDoc().execCommand(command);\n      editor.off('beforeinput input', inputBlocker);\n    };\n    const execEditorDeleteCommand = editor => {\n      editor.execCommand('delete');\n    };\n    const execNativeDeleteCommand = editor => execCommandIgnoreInputEvents(editor, 'Delete');\n    const execNativeForwardDeleteCommand = editor => execCommandIgnoreInputEvents(editor, 'ForwardDelete');\n    const isBeforeRoot = rootNode => elm => is$2(parent(elm), rootNode, eq);\n    const isTextBlockOrListItem = element => isTextBlock$2(element) || isListItem$1(element);\n    const getParentBlock$2 = (rootNode, elm) => {\n      if (contains(rootNode, elm)) {\n        return closest$4(elm, isTextBlockOrListItem, isBeforeRoot(rootNode));\n      } else {\n        return Optional.none();\n      }\n    };\n    const paddEmptyBody = (editor, moveSelection = true) => {\n      if (editor.dom.isEmpty(editor.getBody())) {\n        editor.setContent('', { no_selection: !moveSelection });\n      }\n    };\n    const willDeleteLastPositionInElement = (forward, fromPos, elm) => lift2(firstPositionIn(elm), lastPositionIn(elm), (firstPos, lastPos) => {\n      const normalizedFirstPos = normalizePosition(true, firstPos);\n      const normalizedLastPos = normalizePosition(false, lastPos);\n      const normalizedFromPos = normalizePosition(false, fromPos);\n      if (forward) {\n        return nextPosition(elm, normalizedFromPos).exists(nextPos => nextPos.isEqual(normalizedLastPos) && fromPos.isEqual(normalizedFirstPos));\n      } else {\n        return prevPosition(elm, normalizedFromPos).exists(prevPos => prevPos.isEqual(normalizedFirstPos) && fromPos.isEqual(normalizedLastPos));\n      }\n    }).getOr(true);\n    const freefallRtl = root => {\n      const child = isComment$1(root) ? prevSibling(root) : lastChild(root);\n      return child.bind(freefallRtl).orThunk(() => Optional.some(root));\n    };\n    const deleteRangeContents = (editor, rng, root, moveSelection = true) => {\n      var _a;\n      rng.deleteContents();\n      const lastNode = freefallRtl(root).getOr(root);\n      const lastBlock = SugarElement.fromDom((_a = editor.dom.getParent(lastNode.dom, editor.dom.isBlock)) !== null && _a !== void 0 ? _a : root.dom);\n      if (lastBlock.dom === editor.getBody()) {\n        paddEmptyBody(editor, moveSelection);\n      } else if (isEmpty$2(editor.schema, lastBlock, { checkRootAsContent: false })) {\n        fillWithPaddingBr(lastBlock);\n        if (moveSelection) {\n          editor.selection.setCursorLocation(lastBlock.dom, 0);\n        }\n      }\n      if (!eq(root, lastBlock)) {\n        const additionalCleanupNodes = is$2(parent(lastBlock), root) ? [] : siblings(lastBlock);\n        each$e(additionalCleanupNodes.concat(children$1(root)), node => {\n          if (!eq(node, lastBlock) && !contains(node, lastBlock) && isEmpty$2(editor.schema, node)) {\n            remove$4(node);\n          }\n        });\n      }\n    };\n\n    const isRootFromElement = root => cur => eq(root, cur);\n    const getTableCells = table => descendants(table, 'td,th');\n    const getTable$1 = (node, isRoot) => getClosestTable(SugarElement.fromDom(node), isRoot);\n    const selectionInTableWithNestedTable = details => {\n      return lift2(details.startTable, details.endTable, (startTable, endTable) => {\n        const isStartTableParentOfEndTable = descendant(startTable, t => eq(t, endTable));\n        const isEndTableParentOfStartTable = descendant(endTable, t => eq(t, startTable));\n        return !isStartTableParentOfEndTable && !isEndTableParentOfStartTable ? details : {\n          ...details,\n          startTable: isStartTableParentOfEndTable ? Optional.none() : details.startTable,\n          endTable: isEndTableParentOfStartTable ? Optional.none() : details.endTable,\n          isSameTable: false,\n          isMultiTable: false\n        };\n      }).getOr(details);\n    };\n    const adjustQuirksInDetails = details => {\n      return selectionInTableWithNestedTable(details);\n    };\n    const getTableDetailsFromRange = (rng, isRoot) => {\n      const startTable = getTable$1(rng.startContainer, isRoot);\n      const endTable = getTable$1(rng.endContainer, isRoot);\n      const isStartInTable = startTable.isSome();\n      const isEndInTable = endTable.isSome();\n      const isSameTable = lift2(startTable, endTable, eq).getOr(false);\n      const isMultiTable = !isSameTable && isStartInTable && isEndInTable;\n      return adjustQuirksInDetails({\n        startTable,\n        endTable,\n        isStartInTable,\n        isEndInTable,\n        isSameTable,\n        isMultiTable\n      });\n    };\n\n    const tableCellRng = (start, end) => ({\n      start,\n      end\n    });\n    const tableSelection = (rng, table, cells) => ({\n      rng,\n      table,\n      cells\n    });\n    const deleteAction = Adt.generate([\n      {\n        singleCellTable: [\n          'rng',\n          'cell'\n        ]\n      },\n      { fullTable: ['table'] },\n      {\n        partialTable: [\n          'cells',\n          'outsideDetails'\n        ]\n      },\n      {\n        multiTable: [\n          'startTableCells',\n          'endTableCells',\n          'betweenRng'\n        ]\n      }\n    ]);\n    const getClosestCell$1 = (container, isRoot) => closest$3(SugarElement.fromDom(container), 'td,th', isRoot);\n    const isExpandedCellRng = cellRng => !eq(cellRng.start, cellRng.end);\n    const getTableFromCellRng = (cellRng, isRoot) => getClosestTable(cellRng.start, isRoot).bind(startParentTable => getClosestTable(cellRng.end, isRoot).bind(endParentTable => someIf(eq(startParentTable, endParentTable), startParentTable)));\n    const isSingleCellTable = (cellRng, isRoot) => !isExpandedCellRng(cellRng) && getTableFromCellRng(cellRng, isRoot).exists(table => {\n      const rows = table.dom.rows;\n      return rows.length === 1 && rows[0].cells.length === 1;\n    });\n    const getCellRng = (rng, isRoot) => {\n      const startCell = getClosestCell$1(rng.startContainer, isRoot);\n      const endCell = getClosestCell$1(rng.endContainer, isRoot);\n      return lift2(startCell, endCell, tableCellRng);\n    };\n    const getCellRangeFromStartTable = isRoot => startCell => getClosestTable(startCell, isRoot).bind(table => last$2(getTableCells(table)).map(endCell => tableCellRng(startCell, endCell)));\n    const getCellRangeFromEndTable = isRoot => endCell => getClosestTable(endCell, isRoot).bind(table => head(getTableCells(table)).map(startCell => tableCellRng(startCell, endCell)));\n    const getTableSelectionFromCellRng = isRoot => cellRng => getTableFromCellRng(cellRng, isRoot).map(table => tableSelection(cellRng, table, getTableCells(table)));\n    const getTableSelections = (cellRng, selectionDetails, rng, isRoot) => {\n      if (rng.collapsed || !cellRng.forall(isExpandedCellRng)) {\n        return Optional.none();\n      } else if (selectionDetails.isSameTable) {\n        const sameTableSelection = cellRng.bind(getTableSelectionFromCellRng(isRoot));\n        return Optional.some({\n          start: sameTableSelection,\n          end: sameTableSelection\n        });\n      } else {\n        const startCell = getClosestCell$1(rng.startContainer, isRoot);\n        const endCell = getClosestCell$1(rng.endContainer, isRoot);\n        const startTableSelection = startCell.bind(getCellRangeFromStartTable(isRoot)).bind(getTableSelectionFromCellRng(isRoot));\n        const endTableSelection = endCell.bind(getCellRangeFromEndTable(isRoot)).bind(getTableSelectionFromCellRng(isRoot));\n        return Optional.some({\n          start: startTableSelection,\n          end: endTableSelection\n        });\n      }\n    };\n    const getCellIndex = (cells, cell) => findIndex$2(cells, x => eq(x, cell));\n    const getSelectedCells = tableSelection => lift2(getCellIndex(tableSelection.cells, tableSelection.rng.start), getCellIndex(tableSelection.cells, tableSelection.rng.end), (startIndex, endIndex) => tableSelection.cells.slice(startIndex, endIndex + 1));\n    const isSingleCellTableContentSelected = (optCellRng, rng, isRoot) => optCellRng.exists(cellRng => isSingleCellTable(cellRng, isRoot) && hasAllContentsSelected(cellRng.start, rng));\n    const unselectCells = (rng, selectionDetails) => {\n      const {startTable, endTable} = selectionDetails;\n      const otherContentRng = rng.cloneRange();\n      startTable.each(table => otherContentRng.setStartAfter(table.dom));\n      endTable.each(table => otherContentRng.setEndBefore(table.dom));\n      return otherContentRng;\n    };\n    const handleSingleTable = (cellRng, selectionDetails, rng, isRoot) => getTableSelections(cellRng, selectionDetails, rng, isRoot).bind(({start, end}) => start.or(end)).bind(tableSelection => {\n      const {isSameTable} = selectionDetails;\n      const selectedCells = getSelectedCells(tableSelection).getOr([]);\n      if (isSameTable && tableSelection.cells.length === selectedCells.length) {\n        return Optional.some(deleteAction.fullTable(tableSelection.table));\n      } else if (selectedCells.length > 0) {\n        if (isSameTable) {\n          return Optional.some(deleteAction.partialTable(selectedCells, Optional.none()));\n        } else {\n          const otherContentRng = unselectCells(rng, selectionDetails);\n          return Optional.some(deleteAction.partialTable(selectedCells, Optional.some({\n            ...selectionDetails,\n            rng: otherContentRng\n          })));\n        }\n      } else {\n        return Optional.none();\n      }\n    });\n    const handleMultiTable = (cellRng, selectionDetails, rng, isRoot) => getTableSelections(cellRng, selectionDetails, rng, isRoot).bind(({start, end}) => {\n      const startTableSelectedCells = start.bind(getSelectedCells).getOr([]);\n      const endTableSelectedCells = end.bind(getSelectedCells).getOr([]);\n      if (startTableSelectedCells.length > 0 && endTableSelectedCells.length > 0) {\n        const otherContentRng = unselectCells(rng, selectionDetails);\n        return Optional.some(deleteAction.multiTable(startTableSelectedCells, endTableSelectedCells, otherContentRng));\n      } else {\n        return Optional.none();\n      }\n    });\n    const getActionFromRange = (root, rng) => {\n      const isRoot = isRootFromElement(root);\n      const optCellRng = getCellRng(rng, isRoot);\n      const selectionDetails = getTableDetailsFromRange(rng, isRoot);\n      if (isSingleCellTableContentSelected(optCellRng, rng, isRoot)) {\n        return optCellRng.map(cellRng => deleteAction.singleCellTable(rng, cellRng.start));\n      } else if (selectionDetails.isMultiTable) {\n        return handleMultiTable(optCellRng, selectionDetails, rng, isRoot);\n      } else {\n        return handleSingleTable(optCellRng, selectionDetails, rng, isRoot);\n      }\n    };\n\n    const cleanCells = cells => each$e(cells, cell => {\n      remove$9(cell, 'contenteditable');\n      fillWithPaddingBr(cell);\n    });\n    const getOutsideBlock = (editor, container) => Optional.from(editor.dom.getParent(container, editor.dom.isBlock)).map(SugarElement.fromDom);\n    const handleEmptyBlock = (editor, startInTable, emptyBlock) => {\n      emptyBlock.each(block => {\n        if (startInTable) {\n          remove$4(block);\n        } else {\n          fillWithPaddingBr(block);\n          editor.selection.setCursorLocation(block.dom, 0);\n        }\n      });\n    };\n    const deleteContentInsideCell = (editor, cell, rng, isFirstCellInSelection) => {\n      const insideTableRng = rng.cloneRange();\n      if (isFirstCellInSelection) {\n        insideTableRng.setStart(rng.startContainer, rng.startOffset);\n        insideTableRng.setEndAfter(cell.dom.lastChild);\n      } else {\n        insideTableRng.setStartBefore(cell.dom.firstChild);\n        insideTableRng.setEnd(rng.endContainer, rng.endOffset);\n      }\n      deleteCellContents(editor, insideTableRng, cell, false).each(action => action());\n    };\n    const collapseAndRestoreCellSelection = editor => {\n      const selectedCells = getCellsFromEditor(editor);\n      const selectedNode = SugarElement.fromDom(editor.selection.getNode());\n      if (isTableCell$3(selectedNode.dom) && isEmpty$2(editor.schema, selectedNode)) {\n        editor.selection.setCursorLocation(selectedNode.dom, 0);\n      } else {\n        editor.selection.collapse(true);\n      }\n      if (selectedCells.length > 1 && exists(selectedCells, cell => eq(cell, selectedNode))) {\n        set$3(selectedNode, 'data-mce-selected', '1');\n      }\n    };\n    const emptySingleTableCells = (editor, cells, outsideDetails) => Optional.some(() => {\n      const editorRng = editor.selection.getRng();\n      const cellsToClean = outsideDetails.bind(({rng, isStartInTable}) => {\n        const outsideBlock = getOutsideBlock(editor, isStartInTable ? rng.endContainer : rng.startContainer);\n        rng.deleteContents();\n        handleEmptyBlock(editor, isStartInTable, outsideBlock.filter(curry(isEmpty$2, editor.schema)));\n        const endPointCell = isStartInTable ? cells[0] : cells[cells.length - 1];\n        deleteContentInsideCell(editor, endPointCell, editorRng, isStartInTable);\n        if (!isEmpty$2(editor.schema, endPointCell)) {\n          return Optional.some(isStartInTable ? cells.slice(1) : cells.slice(0, -1));\n        } else {\n          return Optional.none();\n        }\n      }).getOr(cells);\n      cleanCells(cellsToClean);\n      collapseAndRestoreCellSelection(editor);\n    });\n    const emptyMultiTableCells = (editor, startTableCells, endTableCells, betweenRng) => Optional.some(() => {\n      const rng = editor.selection.getRng();\n      const startCell = startTableCells[0];\n      const endCell = endTableCells[endTableCells.length - 1];\n      deleteContentInsideCell(editor, startCell, rng, true);\n      deleteContentInsideCell(editor, endCell, rng, false);\n      const startTableCellsToClean = isEmpty$2(editor.schema, startCell) ? startTableCells : startTableCells.slice(1);\n      const endTableCellsToClean = isEmpty$2(editor.schema, endCell) ? endTableCells : endTableCells.slice(0, -1);\n      cleanCells(startTableCellsToClean.concat(endTableCellsToClean));\n      betweenRng.deleteContents();\n      collapseAndRestoreCellSelection(editor);\n    });\n    const deleteCellContents = (editor, rng, cell, moveSelection = true) => Optional.some(() => {\n      deleteRangeContents(editor, rng, cell, moveSelection);\n    });\n    const deleteTableElement = (editor, table) => Optional.some(() => deleteElement$2(editor, false, table));\n    const deleteCellRange = (editor, rootElm, rng) => getActionFromRange(rootElm, rng).bind(action => action.fold(curry(deleteCellContents, editor), curry(deleteTableElement, editor), curry(emptySingleTableCells, editor), curry(emptyMultiTableCells, editor)));\n    const deleteCaptionRange = (editor, caption) => emptyElement(editor, caption);\n    const deleteTableRange = (editor, rootElm, rng, startElm) => getParentCaption(rootElm, startElm).fold(() => deleteCellRange(editor, rootElm, rng), caption => deleteCaptionRange(editor, caption));\n    const deleteRange$3 = (editor, startElm, selectedCells) => {\n      const rootNode = SugarElement.fromDom(editor.getBody());\n      const rng = editor.selection.getRng();\n      return selectedCells.length !== 0 ? emptySingleTableCells(editor, selectedCells, Optional.none()) : deleteTableRange(editor, rootNode, rng, startElm);\n    };\n    const getParentCell = (rootElm, elm) => find$2(parentsAndSelf(elm, rootElm), isTableCell$2);\n    const getParentCaption = (rootElm, elm) => find$2(parentsAndSelf(elm, rootElm), isTag('caption'));\n    const deleteBetweenCells = (editor, rootElm, forward, fromCell, from) => navigate(forward, editor.getBody(), from).bind(to => getParentCell(rootElm, SugarElement.fromDom(to.getNode())).bind(toCell => eq(toCell, fromCell) ? Optional.none() : Optional.some(noop)));\n    const emptyElement = (editor, elm) => Optional.some(() => {\n      fillWithPaddingBr(elm);\n      editor.selection.setCursorLocation(elm.dom, 0);\n    });\n    const isDeleteOfLastCharPos = (fromCaption, forward, from, to) => firstPositionIn(fromCaption.dom).bind(first => lastPositionIn(fromCaption.dom).map(last => forward ? from.isEqual(first) && to.isEqual(last) : from.isEqual(last) && to.isEqual(first))).getOr(true);\n    const emptyCaretCaption = (editor, elm) => emptyElement(editor, elm);\n    const validateCaretCaption = (rootElm, fromCaption, to) => getParentCaption(rootElm, SugarElement.fromDom(to.getNode())).fold(() => Optional.some(noop), toCaption => someIf(!eq(toCaption, fromCaption), noop));\n    const deleteCaretInsideCaption = (editor, rootElm, forward, fromCaption, from) => navigate(forward, editor.getBody(), from).fold(() => Optional.some(noop), to => isDeleteOfLastCharPos(fromCaption, forward, from, to) ? emptyCaretCaption(editor, fromCaption) : validateCaretCaption(rootElm, fromCaption, to));\n    const deleteCaretCells = (editor, forward, rootElm, startElm) => {\n      const from = CaretPosition.fromRangeStart(editor.selection.getRng());\n      return getParentCell(rootElm, startElm).bind(fromCell => isEmpty$2(editor.schema, fromCell, { checkRootAsContent: false }) ? emptyElement(editor, fromCell) : deleteBetweenCells(editor, rootElm, forward, fromCell, from));\n    };\n    const deleteCaretCaption = (editor, forward, rootElm, fromCaption) => {\n      const from = CaretPosition.fromRangeStart(editor.selection.getRng());\n      return isEmpty$2(editor.schema, fromCaption) ? emptyElement(editor, fromCaption) : deleteCaretInsideCaption(editor, rootElm, forward, fromCaption, from);\n    };\n    const isNearTable = (forward, pos) => forward ? isBeforeTable(pos) : isAfterTable(pos);\n    const isBeforeOrAfterTable = (editor, forward) => {\n      const fromPos = CaretPosition.fromRangeStart(editor.selection.getRng());\n      return isNearTable(forward, fromPos) || fromPosition(forward, editor.getBody(), fromPos).exists(pos => isNearTable(forward, pos));\n    };\n    const deleteCaret$3 = (editor, forward, startElm) => {\n      const rootElm = SugarElement.fromDom(editor.getBody());\n      return getParentCaption(rootElm, startElm).fold(() => deleteCaretCells(editor, forward, rootElm, startElm).orThunk(() => someIf(isBeforeOrAfterTable(editor, forward), noop)), fromCaption => deleteCaretCaption(editor, forward, rootElm, fromCaption));\n    };\n    const backspaceDelete$b = (editor, forward) => {\n      const startElm = SugarElement.fromDom(editor.selection.getStart(true));\n      const cells = getCellsFromEditor(editor);\n      return editor.selection.isCollapsed() && cells.length === 0 ? deleteCaret$3(editor, forward, startElm) : deleteRange$3(editor, startElm, cells);\n    };\n\n    const getContentEditableRoot$1 = (root, node) => {\n      let tempNode = node;\n      while (tempNode && tempNode !== root) {\n        if (isContentEditableTrue$3(tempNode) || isContentEditableFalse$b(tempNode)) {\n          return tempNode;\n        }\n        tempNode = tempNode.parentNode;\n      }\n      return null;\n    };\n\n    const internalAttributesPrefixes = [\n      'data-ephox-',\n      'data-mce-',\n      'data-alloy-',\n      'data-snooker-',\n      '_'\n    ];\n    const each$9 = Tools.each;\n    const ElementUtils = editor => {\n      const dom = editor.dom;\n      const internalAttributes = new Set(editor.serializer.getTempAttrs());\n      const compare = (node1, node2) => {\n        if (node1.nodeName !== node2.nodeName || node1.nodeType !== node2.nodeType) {\n          return false;\n        }\n        const getAttribs = node => {\n          const attribs = {};\n          each$9(dom.getAttribs(node), attr => {\n            const name = attr.nodeName.toLowerCase();\n            if (name !== 'style' && !isAttributeInternal(name)) {\n              attribs[name] = dom.getAttrib(node, name);\n            }\n          });\n          return attribs;\n        };\n        const compareObjects = (obj1, obj2) => {\n          for (const name in obj1) {\n            if (has$2(obj1, name)) {\n              const value = obj2[name];\n              if (isUndefined(value)) {\n                return false;\n              }\n              if (obj1[name] !== value) {\n                return false;\n              }\n              delete obj2[name];\n            }\n          }\n          for (const name in obj2) {\n            if (has$2(obj2, name)) {\n              return false;\n            }\n          }\n          return true;\n        };\n        if (isElement$6(node1) && isElement$6(node2)) {\n          if (!compareObjects(getAttribs(node1), getAttribs(node2))) {\n            return false;\n          }\n          if (!compareObjects(dom.parseStyle(dom.getAttrib(node1, 'style')), dom.parseStyle(dom.getAttrib(node2, 'style')))) {\n            return false;\n          }\n        }\n        return !isBookmarkNode$1(node1) && !isBookmarkNode$1(node2);\n      };\n      const isAttributeInternal = attributeName => exists(internalAttributesPrefixes, value => startsWith(attributeName, value)) || internalAttributes.has(attributeName);\n      return {\n        compare,\n        isAttributeInternal\n      };\n    };\n\n    const isHeading = node => [\n      'h1',\n      'h2',\n      'h3',\n      'h4',\n      'h5',\n      'h6'\n    ].includes(node.name);\n    const isSummary = node => node.name === 'summary';\n\n    const traverse = (root, fn) => {\n      let node = root;\n      while (node = node.walk()) {\n        fn(node);\n      }\n    };\n    const matchNode$1 = (nodeFilters, attributeFilters, node, matches) => {\n      const name = node.name;\n      for (let ni = 0, nl = nodeFilters.length; ni < nl; ni++) {\n        const filter = nodeFilters[ni];\n        if (filter.name === name) {\n          const match = matches.nodes[name];\n          if (match) {\n            match.nodes.push(node);\n          } else {\n            matches.nodes[name] = {\n              filter,\n              nodes: [node]\n            };\n          }\n        }\n      }\n      if (node.attributes) {\n        for (let ai = 0, al = attributeFilters.length; ai < al; ai++) {\n          const filter = attributeFilters[ai];\n          const attrName = filter.name;\n          if (attrName in node.attributes.map) {\n            const match = matches.attributes[attrName];\n            if (match) {\n              match.nodes.push(node);\n            } else {\n              matches.attributes[attrName] = {\n                filter,\n                nodes: [node]\n              };\n            }\n          }\n        }\n      }\n    };\n    const findMatchingNodes = (nodeFilters, attributeFilters, node) => {\n      const matches = {\n        nodes: {},\n        attributes: {}\n      };\n      if (node.firstChild) {\n        traverse(node, childNode => {\n          matchNode$1(nodeFilters, attributeFilters, childNode, matches);\n        });\n      }\n      return matches;\n    };\n    const runFilters = (matches, args) => {\n      const run = (matchRecord, filteringAttributes) => {\n        each$d(matchRecord, match => {\n          const nodes = from(match.nodes);\n          each$e(match.filter.callbacks, callback => {\n            for (let i = nodes.length - 1; i >= 0; i--) {\n              const node = nodes[i];\n              const valueMatches = filteringAttributes ? node.attr(match.filter.name) !== undefined : node.name === match.filter.name;\n              if (!valueMatches || isNullable(node.parent)) {\n                nodes.splice(i, 1);\n              }\n            }\n            if (nodes.length > 0) {\n              callback(nodes, match.filter.name, args);\n            }\n          });\n        });\n      };\n      run(matches.nodes, false);\n      run(matches.attributes, true);\n    };\n    const filter$2 = (nodeFilters, attributeFilters, node, args = {}) => {\n      const matches = findMatchingNodes(nodeFilters, attributeFilters, node);\n      runFilters(matches, args);\n    };\n\n    const paddEmptyNode = (settings, args, isBlock, node) => {\n      const brPreferred = settings.pad_empty_with_br || args.insert;\n      if (brPreferred && isBlock(node)) {\n        const astNode = new AstNode('br', 1);\n        if (args.insert) {\n          astNode.attr('data-mce-bogus', '1');\n        }\n        node.empty().append(astNode);\n      } else {\n        node.empty().append(new AstNode('#text', 3)).value = nbsp;\n      }\n    };\n    const isPaddedWithNbsp = node => {\n      var _a;\n      return hasOnlyChild(node, '#text') && ((_a = node === null || node === void 0 ? void 0 : node.firstChild) === null || _a === void 0 ? void 0 : _a.value) === nbsp;\n    };\n    const hasOnlyChild = (node, name) => {\n      const firstChild = node === null || node === void 0 ? void 0 : node.firstChild;\n      return isNonNullable(firstChild) && firstChild === node.lastChild && firstChild.name === name;\n    };\n    const isPadded = (schema, node) => {\n      const rule = schema.getElementRule(node.name);\n      return (rule === null || rule === void 0 ? void 0 : rule.paddEmpty) === true;\n    };\n    const isEmpty = (schema, nonEmptyElements, whitespaceElements, node) => node.isEmpty(nonEmptyElements, whitespaceElements, node => isPadded(schema, node));\n    const isLineBreakNode = (node, isBlock) => isNonNullable(node) && (isBlock(node) || node.name === 'br');\n    const findClosestEditingHost = scope => {\n      let editableNode;\n      for (let node = scope; node; node = node.parent) {\n        const contentEditable = node.attr('contenteditable');\n        if (contentEditable === 'false') {\n          break;\n        } else if (contentEditable === 'true') {\n          editableNode = node;\n        }\n      }\n      return Optional.from(editableNode);\n    };\n\n    const removeOrUnwrapInvalidNode = (node, schema, originalNodeParent = node.parent) => {\n      if (schema.getSpecialElements()[node.name]) {\n        node.empty().remove();\n      } else {\n        const children = node.children();\n        for (const childNode of children) {\n          if (originalNodeParent && !schema.isValidChild(originalNodeParent.name, childNode.name)) {\n            removeOrUnwrapInvalidNode(childNode, schema, originalNodeParent);\n          }\n        }\n        node.unwrap();\n      }\n    };\n    const cleanInvalidNodes = (nodes, schema, rootNode, onCreate = noop) => {\n      const textBlockElements = schema.getTextBlockElements();\n      const nonEmptyElements = schema.getNonEmptyElements();\n      const whitespaceElements = schema.getWhitespaceElements();\n      const nonSplittableElements = Tools.makeMap('tr,td,th,tbody,thead,tfoot,table,summary');\n      const fixed = new Set();\n      const isSplittableElement = node => node !== rootNode && !nonSplittableElements[node.name];\n      for (let ni = 0; ni < nodes.length; ni++) {\n        const node = nodes[ni];\n        let parent;\n        let newParent;\n        let tempNode;\n        if (!node.parent || fixed.has(node)) {\n          continue;\n        }\n        if (textBlockElements[node.name] && node.parent.name === 'li') {\n          let sibling = node.next;\n          while (sibling) {\n            if (textBlockElements[sibling.name]) {\n              sibling.name = 'li';\n              fixed.add(sibling);\n              node.parent.insert(sibling, node.parent);\n            } else {\n              break;\n            }\n            sibling = sibling.next;\n          }\n          node.unwrap();\n          continue;\n        }\n        const parents = [node];\n        for (parent = node.parent; parent && !schema.isValidChild(parent.name, node.name) && isSplittableElement(parent); parent = parent.parent) {\n          parents.push(parent);\n        }\n        if (parent && parents.length > 1) {\n          if (!isInvalid(schema, node, parent)) {\n            parents.reverse();\n            newParent = parents[0].clone();\n            onCreate(newParent);\n            let currentNode = newParent;\n            for (let i = 0; i < parents.length - 1; i++) {\n              if (schema.isValidChild(currentNode.name, parents[i].name) && i > 0) {\n                tempNode = parents[i].clone();\n                onCreate(tempNode);\n                currentNode.append(tempNode);\n              } else {\n                tempNode = currentNode;\n              }\n              for (let childNode = parents[i].firstChild; childNode && childNode !== parents[i + 1];) {\n                const nextNode = childNode.next;\n                tempNode.append(childNode);\n                childNode = nextNode;\n              }\n              currentNode = tempNode;\n            }\n            if (!isEmpty(schema, nonEmptyElements, whitespaceElements, newParent)) {\n              parent.insert(newParent, parents[0], true);\n              parent.insert(node, newParent);\n            } else {\n              parent.insert(node, parents[0], true);\n            }\n            parent = parents[0];\n            if (isEmpty(schema, nonEmptyElements, whitespaceElements, parent) || hasOnlyChild(parent, 'br')) {\n              parent.empty().remove();\n            }\n          } else {\n            removeOrUnwrapInvalidNode(node, schema);\n          }\n        } else if (node.parent) {\n          if (node.name === 'li') {\n            let sibling = node.prev;\n            if (sibling && (sibling.name === 'ul' || sibling.name === 'ol')) {\n              sibling.append(node);\n              continue;\n            }\n            sibling = node.next;\n            if (sibling && (sibling.name === 'ul' || sibling.name === 'ol') && sibling.firstChild) {\n              sibling.insert(node, sibling.firstChild, true);\n              continue;\n            }\n            const wrapper = new AstNode('ul', 1);\n            onCreate(wrapper);\n            node.wrap(wrapper);\n            continue;\n          }\n          if (schema.isValidChild(node.parent.name, 'div') && schema.isValidChild('div', node.name)) {\n            const wrapper = new AstNode('div', 1);\n            onCreate(wrapper);\n            node.wrap(wrapper);\n          } else {\n            removeOrUnwrapInvalidNode(node, schema);\n          }\n        }\n      }\n    };\n    const hasClosest = (node, parentName) => {\n      let tempNode = node;\n      while (tempNode) {\n        if (tempNode.name === parentName) {\n          return true;\n        }\n        tempNode = tempNode.parent;\n      }\n      return false;\n    };\n    const isInvalid = (schema, node, parent = node.parent) => {\n      if (!parent) {\n        return false;\n      }\n      if (schema.children[node.name] && !schema.isValidChild(parent.name, node.name)) {\n        return true;\n      }\n      if (node.name === 'a' && hasClosest(parent, 'a')) {\n        return true;\n      }\n      if (isSummary(parent) && isHeading(node)) {\n        return !((parent === null || parent === void 0 ? void 0 : parent.firstChild) === node && (parent === null || parent === void 0 ? void 0 : parent.lastChild) === node);\n      }\n      return false;\n    };\n\n    const createRange = (sc, so, ec, eo) => {\n      const rng = document.createRange();\n      rng.setStart(sc, so);\n      rng.setEnd(ec, eo);\n      return rng;\n    };\n    const normalizeBlockSelectionRange = rng => {\n      const startPos = CaretPosition.fromRangeStart(rng);\n      const endPos = CaretPosition.fromRangeEnd(rng);\n      const rootNode = rng.commonAncestorContainer;\n      return fromPosition(false, rootNode, endPos).map(newEndPos => {\n        if (!isInSameBlock(startPos, endPos, rootNode) && isInSameBlock(startPos, newEndPos, rootNode)) {\n          return createRange(startPos.container(), startPos.offset(), newEndPos.container(), newEndPos.offset());\n        } else {\n          return rng;\n        }\n      }).getOr(rng);\n    };\n    const normalize = rng => rng.collapsed ? rng : normalizeBlockSelectionRange(rng);\n\n    const hasOnlyOneChild$1 = node => {\n      return isNonNullable(node.firstChild) && node.firstChild === node.lastChild;\n    };\n    const isPaddingNode = node => {\n      return node.name === 'br' || node.value === nbsp;\n    };\n    const isPaddedEmptyBlock = (schema, node) => {\n      const blockElements = schema.getBlockElements();\n      return blockElements[node.name] && hasOnlyOneChild$1(node) && isPaddingNode(node.firstChild);\n    };\n    const isEmptyFragmentElement = (schema, node) => {\n      const nonEmptyElements = schema.getNonEmptyElements();\n      return isNonNullable(node) && (node.isEmpty(nonEmptyElements) || isPaddedEmptyBlock(schema, node));\n    };\n    const isListFragment = (schema, fragment) => {\n      let firstChild = fragment.firstChild;\n      let lastChild = fragment.lastChild;\n      if (firstChild && firstChild.name === 'meta') {\n        firstChild = firstChild.next;\n      }\n      if (lastChild && lastChild.attr('id') === 'mce_marker') {\n        lastChild = lastChild.prev;\n      }\n      if (isEmptyFragmentElement(schema, lastChild)) {\n        lastChild = lastChild === null || lastChild === void 0 ? void 0 : lastChild.prev;\n      }\n      if (!firstChild || firstChild !== lastChild) {\n        return false;\n      }\n      return firstChild.name === 'ul' || firstChild.name === 'ol';\n    };\n    const cleanupDomFragment = domFragment => {\n      var _a, _b;\n      const firstChild = domFragment.firstChild;\n      const lastChild = domFragment.lastChild;\n      if (firstChild && firstChild.nodeName === 'META') {\n        (_a = firstChild.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(firstChild);\n      }\n      if (lastChild && lastChild.id === 'mce_marker') {\n        (_b = lastChild.parentNode) === null || _b === void 0 ? void 0 : _b.removeChild(lastChild);\n      }\n      return domFragment;\n    };\n    const toDomFragment = (dom, serializer, fragment) => {\n      const html = serializer.serialize(fragment);\n      const domFragment = dom.createFragment(html);\n      return cleanupDomFragment(domFragment);\n    };\n    const listItems = elm => {\n      var _a;\n      return filter$5((_a = elm === null || elm === void 0 ? void 0 : elm.childNodes) !== null && _a !== void 0 ? _a : [], child => {\n        return child.nodeName === 'LI';\n      });\n    };\n    const isPadding = node => {\n      return node.data === nbsp || isBr$6(node);\n    };\n    const isListItemPadded = node => {\n      return isNonNullable(node === null || node === void 0 ? void 0 : node.firstChild) && node.firstChild === node.lastChild && isPadding(node.firstChild);\n    };\n    const isEmptyOrPadded = elm => {\n      return !elm.firstChild || isListItemPadded(elm);\n    };\n    const trimListItems = elms => {\n      return elms.length > 0 && isEmptyOrPadded(elms[elms.length - 1]) ? elms.slice(0, -1) : elms;\n    };\n    const getParentLi = (dom, node) => {\n      const parentBlock = dom.getParent(node, dom.isBlock);\n      return parentBlock && parentBlock.nodeName === 'LI' ? parentBlock : null;\n    };\n    const isParentBlockLi = (dom, node) => {\n      return !!getParentLi(dom, node);\n    };\n    const getSplit = (parentNode, rng) => {\n      const beforeRng = rng.cloneRange();\n      const afterRng = rng.cloneRange();\n      beforeRng.setStartBefore(parentNode);\n      afterRng.setEndAfter(parentNode);\n      return [\n        beforeRng.cloneContents(),\n        afterRng.cloneContents()\n      ];\n    };\n    const findFirstIn = (node, rootNode) => {\n      const caretPos = CaretPosition.before(node);\n      const caretWalker = CaretWalker(rootNode);\n      const newCaretPos = caretWalker.next(caretPos);\n      return newCaretPos ? newCaretPos.toRange() : null;\n    };\n    const findLastOf = (node, rootNode) => {\n      const caretPos = CaretPosition.after(node);\n      const caretWalker = CaretWalker(rootNode);\n      const newCaretPos = caretWalker.prev(caretPos);\n      return newCaretPos ? newCaretPos.toRange() : null;\n    };\n    const insertMiddle = (target, elms, rootNode, rng) => {\n      const parts = getSplit(target, rng);\n      const parentElm = target.parentNode;\n      if (parentElm) {\n        parentElm.insertBefore(parts[0], target);\n        Tools.each(elms, li => {\n          parentElm.insertBefore(li, target);\n        });\n        parentElm.insertBefore(parts[1], target);\n        parentElm.removeChild(target);\n      }\n      return findLastOf(elms[elms.length - 1], rootNode);\n    };\n    const insertBefore$2 = (target, elms, rootNode) => {\n      const parentElm = target.parentNode;\n      if (parentElm) {\n        Tools.each(elms, elm => {\n          parentElm.insertBefore(elm, target);\n        });\n      }\n      return findFirstIn(target, rootNode);\n    };\n    const insertAfter$2 = (target, elms, rootNode, dom) => {\n      dom.insertAfter(elms.reverse(), target);\n      return findLastOf(elms[0], rootNode);\n    };\n    const insertAtCaret$1 = (serializer, dom, rng, fragment) => {\n      const domFragment = toDomFragment(dom, serializer, fragment);\n      const liTarget = getParentLi(dom, rng.startContainer);\n      const liElms = trimListItems(listItems(domFragment.firstChild));\n      const BEGINNING = 1, END = 2;\n      const rootNode = dom.getRoot();\n      const isAt = location => {\n        const caretPos = CaretPosition.fromRangeStart(rng);\n        const caretWalker = CaretWalker(dom.getRoot());\n        const newPos = location === BEGINNING ? caretWalker.prev(caretPos) : caretWalker.next(caretPos);\n        const newPosNode = newPos === null || newPos === void 0 ? void 0 : newPos.getNode();\n        return newPosNode ? getParentLi(dom, newPosNode) !== liTarget : true;\n      };\n      if (!liTarget) {\n        return null;\n      } else if (isAt(BEGINNING)) {\n        return insertBefore$2(liTarget, liElms, rootNode);\n      } else if (isAt(END)) {\n        return insertAfter$2(liTarget, liElms, rootNode, dom);\n      } else {\n        return insertMiddle(liTarget, liElms, rootNode, rng);\n      }\n    };\n\n    const mergeableWrappedElements = ['pre'];\n    const shouldPasteContentOnly = (dom, fragment, parentNode, root) => {\n      var _a;\n      const firstNode = fragment.firstChild;\n      const lastNode = fragment.lastChild;\n      const last = lastNode.attr('data-mce-type') === 'bookmark' ? lastNode.prev : lastNode;\n      const isPastingSingleElement = firstNode === last;\n      const isWrappedElement = contains$2(mergeableWrappedElements, firstNode.name);\n      if (isPastingSingleElement && isWrappedElement) {\n        const isContentEditable = firstNode.attr('contenteditable') !== 'false';\n        const isPastingInTheSameBlockTag = ((_a = dom.getParent(parentNode, dom.isBlock)) === null || _a === void 0 ? void 0 : _a.nodeName.toLowerCase()) === firstNode.name;\n        const isPastingInContentEditable = Optional.from(getContentEditableRoot$1(root, parentNode)).forall(isContentEditableTrue$3);\n        return isContentEditable && isPastingInTheSameBlockTag && isPastingInContentEditable;\n      } else {\n        return false;\n      }\n    };\n    const isTableCell = isTableCell$3;\n    const isTableCellContentSelected = (dom, rng, cell) => {\n      if (isNonNullable(cell)) {\n        const endCell = dom.getParent(rng.endContainer, isTableCell);\n        return cell === endCell && hasAllContentsSelected(SugarElement.fromDom(cell), rng);\n      } else {\n        return false;\n      }\n    };\n    const validInsertion = (editor, value, parentNode) => {\n      var _a;\n      if (parentNode.getAttribute('data-mce-bogus') === 'all') {\n        (_a = parentNode.parentNode) === null || _a === void 0 ? void 0 : _a.insertBefore(editor.dom.createFragment(value), parentNode);\n      } else {\n        const node = parentNode.firstChild;\n        const node2 = parentNode.lastChild;\n        if (!node || node === node2 && node.nodeName === 'BR') {\n          editor.dom.setHTML(parentNode, value);\n        } else {\n          editor.selection.setContent(value, { no_events: true });\n        }\n      }\n    };\n    const trimBrsFromTableCell = (dom, elm, schema) => {\n      Optional.from(dom.getParent(elm, 'td,th')).map(SugarElement.fromDom).each(el => trimBlockTrailingBr(el, schema));\n    };\n    const reduceInlineTextElements = (editor, merge) => {\n      const textInlineElements = editor.schema.getTextInlineElements();\n      const dom = editor.dom;\n      if (merge) {\n        const root = editor.getBody();\n        const elementUtils = ElementUtils(editor);\n        const fragmentSelector = '*[data-mce-fragment]';\n        const fragments = dom.select(fragmentSelector);\n        Tools.each(fragments, node => {\n          const isInline = currentNode => isNonNullable(textInlineElements[currentNode.nodeName.toLowerCase()]);\n          const hasOneChild = currentNode => currentNode.childNodes.length === 1;\n          const hasNoNonInheritableStyles = currentNode => !(hasNonInheritableStyles(dom, currentNode) || hasConditionalNonInheritableStyles(dom, currentNode));\n          if (hasNoNonInheritableStyles(node) && isInline(node) && hasOneChild(node)) {\n            const styles = getStyleProps(dom, node);\n            const isOverridden = (oldStyles, newStyles) => forall(oldStyles, style => contains$2(newStyles, style));\n            const overriddenByAllChildren = childNode => hasOneChild(node) && dom.is(childNode, fragmentSelector) && isInline(childNode) && (childNode.nodeName === node.nodeName && isOverridden(styles, getStyleProps(dom, childNode)) || overriddenByAllChildren(childNode.children[0]));\n            const identicalToParent = parentNode => isNonNullable(parentNode) && parentNode !== root && (elementUtils.compare(node, parentNode) || identicalToParent(parentNode.parentElement));\n            const conflictWithInsertedParent = parentNode => isNonNullable(parentNode) && parentNode !== root && dom.is(parentNode, fragmentSelector) && (hasStyleConflict(dom, node, parentNode) || conflictWithInsertedParent(parentNode.parentElement));\n            if (overriddenByAllChildren(node.children[0]) || identicalToParent(node.parentElement) && !conflictWithInsertedParent(node.parentElement)) {\n              dom.remove(node, true);\n            }\n          }\n        });\n      }\n    };\n    const markFragmentElements = fragment => {\n      let node = fragment;\n      while (node = node.walk()) {\n        if (node.type === 1) {\n          node.attr('data-mce-fragment', '1');\n        }\n      }\n    };\n    const unmarkFragmentElements = elm => {\n      Tools.each(elm.getElementsByTagName('*'), elm => {\n        elm.removeAttribute('data-mce-fragment');\n      });\n    };\n    const isPartOfFragment = node => {\n      return !!node.getAttribute('data-mce-fragment');\n    };\n    const canHaveChildren = (editor, node) => {\n      return isNonNullable(node) && !editor.schema.getVoidElements()[node.nodeName];\n    };\n    const moveSelectionToMarker = (editor, marker) => {\n      var _a, _b, _c;\n      let nextRng;\n      const dom = editor.dom;\n      const selection = editor.selection;\n      if (!marker) {\n        return;\n      }\n      selection.scrollIntoView(marker);\n      const parentEditableElm = getContentEditableRoot$1(editor.getBody(), marker);\n      if (parentEditableElm && dom.getContentEditable(parentEditableElm) === 'false') {\n        dom.remove(marker);\n        selection.select(parentEditableElm);\n        return;\n      }\n      let rng = dom.createRng();\n      const node = marker.previousSibling;\n      if (isText$b(node)) {\n        rng.setStart(node, (_b = (_a = node.nodeValue) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0);\n        const node2 = marker.nextSibling;\n        if (isText$b(node2)) {\n          node.appendData(node2.data);\n          (_c = node2.parentNode) === null || _c === void 0 ? void 0 : _c.removeChild(node2);\n        }\n      } else {\n        rng.setStartBefore(marker);\n        rng.setEndBefore(marker);\n      }\n      const findNextCaretRng = rng => {\n        let caretPos = CaretPosition.fromRangeStart(rng);\n        const caretWalker = CaretWalker(editor.getBody());\n        caretPos = caretWalker.next(caretPos);\n        return caretPos === null || caretPos === void 0 ? void 0 : caretPos.toRange();\n      };\n      const parentBlock = dom.getParent(marker, dom.isBlock);\n      dom.remove(marker);\n      if (parentBlock && dom.isEmpty(parentBlock)) {\n        const isCell = isTableCell(parentBlock);\n        empty(SugarElement.fromDom(parentBlock));\n        rng.setStart(parentBlock, 0);\n        rng.setEnd(parentBlock, 0);\n        if (!isCell && !isPartOfFragment(parentBlock) && (nextRng = findNextCaretRng(rng))) {\n          rng = nextRng;\n          dom.remove(parentBlock);\n        } else {\n          dom.add(parentBlock, dom.create('br', isCell ? {} : { 'data-mce-bogus': '1' }));\n        }\n      }\n      selection.setRng(rng);\n    };\n    const deleteSelectedContent = editor => {\n      const dom = editor.dom;\n      const rng = normalize(editor.selection.getRng());\n      editor.selection.setRng(rng);\n      const startCell = dom.getParent(rng.startContainer, isTableCell);\n      if (isTableCellContentSelected(dom, rng, startCell)) {\n        deleteCellContents(editor, rng, SugarElement.fromDom(startCell));\n      } else if (rng.startContainer === rng.endContainer && rng.endOffset - rng.startOffset === 1 && isText$b(rng.startContainer.childNodes[rng.startOffset])) {\n        rng.deleteContents();\n      } else {\n        editor.getDoc().execCommand('Delete', false);\n      }\n    };\n    const findMarkerNode = scope => {\n      for (let markerNode = scope; markerNode; markerNode = markerNode.walk()) {\n        if (markerNode.attr('id') === 'mce_marker') {\n          return Optional.some(markerNode);\n        }\n      }\n      return Optional.none();\n    };\n    const notHeadingsInSummary = (dom, node, fragment) => {\n      var _a;\n      return exists(fragment.children(), isHeading) && ((_a = dom.getParent(node, dom.isBlock)) === null || _a === void 0 ? void 0 : _a.nodeName) === 'SUMMARY';\n    };\n    const insertHtmlAtCaret = (editor, value, details) => {\n      var _a, _b;\n      const selection = editor.selection;\n      const dom = editor.dom;\n      const parser = editor.parser;\n      const merge = details.merge;\n      const serializer = HtmlSerializer({ validate: true }, editor.schema);\n      const bookmarkHtml = '<span id=\"mce_marker\" data-mce-type=\"bookmark\">&#xFEFF;</span>';\n      if (!details.preserve_zwsp) {\n        value = trim$2(value);\n      }\n      if (value.indexOf('{$caret}') === -1) {\n        value += '{$caret}';\n      }\n      value = value.replace(/\\{\\$caret\\}/, bookmarkHtml);\n      let rng = selection.getRng();\n      const caretElement = rng.startContainer;\n      const body = editor.getBody();\n      if (caretElement === body && selection.isCollapsed()) {\n        if (dom.isBlock(body.firstChild) && canHaveChildren(editor, body.firstChild) && dom.isEmpty(body.firstChild)) {\n          rng = dom.createRng();\n          rng.setStart(body.firstChild, 0);\n          rng.setEnd(body.firstChild, 0);\n          selection.setRng(rng);\n        }\n      }\n      if (!selection.isCollapsed()) {\n        deleteSelectedContent(editor);\n      }\n      const parentNode = selection.getNode();\n      const parserArgs = {\n        context: parentNode.nodeName.toLowerCase(),\n        data: details.data,\n        insert: true\n      };\n      const fragment = parser.parse(value, parserArgs);\n      if (details.paste === true && isListFragment(editor.schema, fragment) && isParentBlockLi(dom, parentNode)) {\n        rng = insertAtCaret$1(serializer, dom, selection.getRng(), fragment);\n        if (rng) {\n          selection.setRng(rng);\n        }\n        return value;\n      }\n      if (details.paste === true && shouldPasteContentOnly(dom, fragment, parentNode, editor.getBody())) {\n        (_a = fragment.firstChild) === null || _a === void 0 ? void 0 : _a.unwrap();\n      }\n      markFragmentElements(fragment);\n      let node = fragment.lastChild;\n      if (node && node.attr('id') === 'mce_marker') {\n        const marker = node;\n        for (node = node.prev; node; node = node.walk(true)) {\n          if (node.name === 'table') {\n            break;\n          }\n          if (node.type === 3 || !dom.isBlock(node.name)) {\n            if (node.parent && editor.schema.isValidChild(node.parent.name, 'span')) {\n              node.parent.insert(marker, node, node.name === 'br');\n            }\n            break;\n          }\n        }\n      }\n      editor._selectionOverrides.showBlockCaretContainer(parentNode);\n      if (!parserArgs.invalid && !notHeadingsInSummary(dom, parentNode, fragment)) {\n        value = serializer.serialize(fragment);\n        validInsertion(editor, value, parentNode);\n      } else {\n        editor.selection.setContent(bookmarkHtml);\n        let parentNode = selection.getNode();\n        let tempNode;\n        const rootNode = editor.getBody();\n        if (isDocument$1(parentNode)) {\n          parentNode = tempNode = rootNode;\n        } else {\n          tempNode = parentNode;\n        }\n        while (tempNode && tempNode !== rootNode) {\n          parentNode = tempNode;\n          tempNode = tempNode.parentNode;\n        }\n        value = parentNode === rootNode ? rootNode.innerHTML : dom.getOuterHTML(parentNode);\n        const root = parser.parse(value);\n        const markerNode = findMarkerNode(root);\n        const editingHost = markerNode.bind(findClosestEditingHost).getOr(root);\n        markerNode.each(marker => marker.replace(fragment));\n        const toExtract = fragment.children();\n        const parent = (_b = fragment.parent) !== null && _b !== void 0 ? _b : root;\n        fragment.unwrap();\n        const invalidChildren = filter$5(toExtract, node => isInvalid(editor.schema, node, parent));\n        cleanInvalidNodes(invalidChildren, editor.schema, editingHost);\n        filter$2(parser.getNodeFilters(), parser.getAttributeFilters(), root);\n        value = serializer.serialize(root);\n        if (parentNode === rootNode) {\n          dom.setHTML(rootNode, value);\n        } else {\n          dom.setOuterHTML(parentNode, value);\n        }\n      }\n      reduceInlineTextElements(editor, merge);\n      moveSelectionToMarker(editor, dom.get('mce_marker'));\n      unmarkFragmentElements(editor.getBody());\n      trimBrsFromTableCell(dom, selection.getStart(), editor.schema);\n      updateCaret(editor.schema, editor.getBody(), selection.getStart());\n      return value;\n    };\n\n    const isTreeNode = content => content instanceof AstNode;\n\n    const moveSelection = editor => {\n      if (hasFocus(editor)) {\n        firstPositionIn(editor.getBody()).each(pos => {\n          const node = pos.getNode();\n          const caretPos = isTable$2(node) ? firstPositionIn(node).getOr(pos) : pos;\n          editor.selection.setRng(caretPos.toRange());\n        });\n      }\n    };\n    const setEditorHtml = (editor, html, noSelection) => {\n      editor.dom.setHTML(editor.getBody(), html);\n      if (noSelection !== true) {\n        moveSelection(editor);\n      }\n    };\n    const setContentString = (editor, body, content, args) => {\n      content = trim$2(content);\n      if (content.length === 0 || /^\\s+$/.test(content)) {\n        const padd = '<br data-mce-bogus=\"1\">';\n        if (body.nodeName === 'TABLE') {\n          content = '<tr><td>' + padd + '</td></tr>';\n        } else if (/^(UL|OL)$/.test(body.nodeName)) {\n          content = '<li>' + padd + '</li>';\n        }\n        const forcedRootBlockName = getForcedRootBlock(editor);\n        if (editor.schema.isValidChild(body.nodeName.toLowerCase(), forcedRootBlockName.toLowerCase())) {\n          content = padd;\n          content = editor.dom.createHTML(forcedRootBlockName, getForcedRootBlockAttrs(editor), content);\n        } else if (!content) {\n          content = padd;\n        }\n        setEditorHtml(editor, content, args.no_selection);\n        return {\n          content,\n          html: content\n        };\n      } else {\n        if (args.format !== 'raw') {\n          content = HtmlSerializer({ validate: false }, editor.schema).serialize(editor.parser.parse(content, {\n            isRootContent: true,\n            insert: true\n          }));\n        }\n        const trimmedHtml = isWsPreserveElement(SugarElement.fromDom(body)) ? content : Tools.trim(content);\n        setEditorHtml(editor, trimmedHtml, args.no_selection);\n        return {\n          content: trimmedHtml,\n          html: trimmedHtml\n        };\n      }\n    };\n    const setContentTree = (editor, body, content, args) => {\n      filter$2(editor.parser.getNodeFilters(), editor.parser.getAttributeFilters(), content);\n      const html = HtmlSerializer({ validate: false }, editor.schema).serialize(content);\n      const trimmedHtml = trim$2(isWsPreserveElement(SugarElement.fromDom(body)) ? html : Tools.trim(html));\n      setEditorHtml(editor, trimmedHtml, args.no_selection);\n      return {\n        content,\n        html: trimmedHtml\n      };\n    };\n    const setContentInternal = (editor, content, args) => {\n      return Optional.from(editor.getBody()).map(body => {\n        if (isTreeNode(content)) {\n          return setContentTree(editor, body, content, args);\n        } else {\n          return setContentString(editor, body, content, args);\n        }\n      }).getOr({\n        content,\n        html: isTreeNode(args.content) ? '' : args.content\n      });\n    };\n\n    const ensureIsRoot = isRoot => isFunction(isRoot) ? isRoot : never;\n    const ancestor = (scope, transform, isRoot) => {\n      let element = scope.dom;\n      const stop = ensureIsRoot(isRoot);\n      while (element.parentNode) {\n        element = element.parentNode;\n        const el = SugarElement.fromDom(element);\n        const transformed = transform(el);\n        if (transformed.isSome()) {\n          return transformed;\n        } else if (stop(el)) {\n          break;\n        }\n      }\n      return Optional.none();\n    };\n    const closest$1 = (scope, transform, isRoot) => {\n      const current = transform(scope);\n      const stop = ensureIsRoot(isRoot);\n      return current.orThunk(() => stop(scope) ? Optional.none() : ancestor(scope, transform, stop));\n    };\n\n    const isEq$3 = isEq$5;\n    const matchesUnInheritedFormatSelector = (ed, node, name) => {\n      const formatList = ed.formatter.get(name);\n      if (formatList) {\n        for (let i = 0; i < formatList.length; i++) {\n          const format = formatList[i];\n          if (isSelectorFormat(format) && format.inherit === false && ed.dom.is(node, format.selector)) {\n            return true;\n          }\n        }\n      }\n      return false;\n    };\n    const matchParents = (editor, node, name, vars, similar) => {\n      const root = editor.dom.getRoot();\n      if (node === root) {\n        return false;\n      }\n      const matchedNode = editor.dom.getParent(node, elm => {\n        if (matchesUnInheritedFormatSelector(editor, elm, name)) {\n          return true;\n        }\n        return elm.parentNode === root || !!matchNode(editor, elm, name, vars, true);\n      });\n      return !!matchNode(editor, matchedNode, name, vars, similar);\n    };\n    const matchName = (dom, node, format) => {\n      if (isInlineFormat(format) && isEq$3(node, format.inline)) {\n        return true;\n      }\n      if (isBlockFormat(format) && isEq$3(node, format.block)) {\n        return true;\n      }\n      if (isSelectorFormat(format)) {\n        return isElement$6(node) && dom.is(node, format.selector);\n      }\n      return false;\n    };\n    const matchItems = (dom, node, format, itemName, similar, vars) => {\n      const items = format[itemName];\n      const matchAttributes = itemName === 'attributes';\n      if (isFunction(format.onmatch)) {\n        return format.onmatch(node, format, itemName);\n      }\n      if (items) {\n        if (!isArrayLike(items)) {\n          for (const key in items) {\n            if (has$2(items, key)) {\n              const value = matchAttributes ? dom.getAttrib(node, key) : getStyle(dom, node, key);\n              const expectedValue = replaceVars(items[key], vars);\n              const isEmptyValue = isNullable(value) || isEmpty$3(value);\n              if (isEmptyValue && isNullable(expectedValue)) {\n                continue;\n              }\n              if (similar && isEmptyValue && !format.exact) {\n                return false;\n              }\n              if ((!similar || format.exact) && !isEq$3(value, normalizeStyleValue(expectedValue, key))) {\n                return false;\n              }\n            }\n          }\n        } else {\n          for (let i = 0; i < items.length; i++) {\n            if (matchAttributes ? dom.getAttrib(node, items[i]) : getStyle(dom, node, items[i])) {\n              return true;\n            }\n          }\n        }\n      }\n      return true;\n    };\n    const matchNode = (ed, node, name, vars, similar) => {\n      const formatList = ed.formatter.get(name);\n      const dom = ed.dom;\n      if (formatList && isElement$6(node)) {\n        for (let i = 0; i < formatList.length; i++) {\n          const format = formatList[i];\n          if (matchName(ed.dom, node, format) && matchItems(dom, node, format, 'attributes', similar, vars) && matchItems(dom, node, format, 'styles', similar, vars)) {\n            const classes = format.classes;\n            if (classes) {\n              for (let x = 0; x < classes.length; x++) {\n                if (!ed.dom.hasClass(node, replaceVars(classes[x], vars))) {\n                  return;\n                }\n              }\n            }\n            return format;\n          }\n        }\n      }\n      return undefined;\n    };\n    const match$2 = (editor, name, vars, node, similar) => {\n      if (node) {\n        return matchParents(editor, node, name, vars, similar);\n      }\n      node = editor.selection.getNode();\n      if (matchParents(editor, node, name, vars, similar)) {\n        return true;\n      }\n      const startNode = editor.selection.getStart();\n      if (startNode !== node) {\n        if (matchParents(editor, startNode, name, vars, similar)) {\n          return true;\n        }\n      }\n      return false;\n    };\n    const matchAll = (editor, names, vars) => {\n      const matchedFormatNames = [];\n      const checkedMap = {};\n      const startElement = editor.selection.getStart();\n      editor.dom.getParent(startElement, node => {\n        for (let i = 0; i < names.length; i++) {\n          const name = names[i];\n          if (!checkedMap[name] && matchNode(editor, node, name, vars)) {\n            checkedMap[name] = true;\n            matchedFormatNames.push(name);\n          }\n        }\n      }, editor.dom.getRoot());\n      return matchedFormatNames;\n    };\n    const closest = (editor, names) => {\n      const isRoot = elm => eq(elm, SugarElement.fromDom(editor.getBody()));\n      const match = (elm, name) => matchNode(editor, elm.dom, name) ? Optional.some(name) : Optional.none();\n      return Optional.from(editor.selection.getStart(true)).bind(rawElm => closest$1(SugarElement.fromDom(rawElm), elm => findMap(names, name => match(elm, name)), isRoot)).getOrNull();\n    };\n    const canApply = (editor, name) => {\n      const formatList = editor.formatter.get(name);\n      const dom = editor.dom;\n      if (formatList && editor.selection.isEditable()) {\n        const startNode = editor.selection.getStart();\n        const parents = getParents$2(dom, startNode);\n        for (let x = formatList.length - 1; x >= 0; x--) {\n          const format = formatList[x];\n          if (!isSelectorFormat(format)) {\n            return true;\n          }\n          for (let i = parents.length - 1; i >= 0; i--) {\n            if (dom.is(parents[i], format.selector)) {\n              return true;\n            }\n          }\n        }\n      }\n      return false;\n    };\n    const matchAllOnNode = (editor, node, formatNames) => foldl(formatNames, (acc, name) => {\n      const matchSimilar = isVariableFormatName(editor, name);\n      if (editor.formatter.matchNode(node, name, {}, matchSimilar)) {\n        return acc.concat([name]);\n      } else {\n        return acc;\n      }\n    }, []);\n\n    const ZWSP = ZWSP$1;\n    const importNode = (ownerDocument, node) => {\n      return ownerDocument.importNode(node, true);\n    };\n    const findFirstTextNode = node => {\n      if (node) {\n        const walker = new DomTreeWalker(node, node);\n        for (let tempNode = walker.current(); tempNode; tempNode = walker.next()) {\n          if (isText$b(tempNode)) {\n            return tempNode;\n          }\n        }\n      }\n      return null;\n    };\n    const createCaretContainer = fill => {\n      const caretContainer = SugarElement.fromTag('span');\n      setAll$1(caretContainer, {\n        'id': CARET_ID,\n        'data-mce-bogus': '1',\n        'data-mce-type': 'format-caret'\n      });\n      if (fill) {\n        append$1(caretContainer, SugarElement.fromText(ZWSP));\n      }\n      return caretContainer;\n    };\n    const trimZwspFromCaretContainer = caretContainerNode => {\n      const textNode = findFirstTextNode(caretContainerNode);\n      if (textNode && textNode.data.charAt(0) === ZWSP) {\n        textNode.deleteData(0, 1);\n      }\n      return textNode;\n    };\n    const removeCaretContainerNode = (editor, node, moveCaret) => {\n      const dom = editor.dom, selection = editor.selection;\n      if (isCaretContainerEmpty(node)) {\n        deleteElement$2(editor, false, SugarElement.fromDom(node), moveCaret, true);\n      } else {\n        const rng = selection.getRng();\n        const block = dom.getParent(node, dom.isBlock);\n        const startContainer = rng.startContainer;\n        const startOffset = rng.startOffset;\n        const endContainer = rng.endContainer;\n        const endOffset = rng.endOffset;\n        const textNode = trimZwspFromCaretContainer(node);\n        dom.remove(node, true);\n        if (startContainer === textNode && startOffset > 0) {\n          rng.setStart(textNode, startOffset - 1);\n        }\n        if (endContainer === textNode && endOffset > 0) {\n          rng.setEnd(textNode, endOffset - 1);\n        }\n        if (block && dom.isEmpty(block)) {\n          fillWithPaddingBr(SugarElement.fromDom(block));\n        }\n        selection.setRng(rng);\n      }\n    };\n    const removeCaretContainer = (editor, node, moveCaret) => {\n      const dom = editor.dom, selection = editor.selection;\n      if (!node) {\n        node = getParentCaretContainer(editor.getBody(), selection.getStart());\n        if (!node) {\n          while (node = dom.get(CARET_ID)) {\n            removeCaretContainerNode(editor, node, moveCaret);\n          }\n        }\n      } else {\n        removeCaretContainerNode(editor, node, moveCaret);\n      }\n    };\n    const insertCaretContainerNode = (editor, caretContainer, formatNode) => {\n      var _a, _b;\n      const dom = editor.dom;\n      const block = dom.getParent(formatNode, curry(isTextBlock$1, editor.schema));\n      if (block && dom.isEmpty(block)) {\n        (_a = formatNode.parentNode) === null || _a === void 0 ? void 0 : _a.replaceChild(caretContainer, formatNode);\n      } else {\n        removeTrailingBr(SugarElement.fromDom(formatNode));\n        if (dom.isEmpty(formatNode)) {\n          (_b = formatNode.parentNode) === null || _b === void 0 ? void 0 : _b.replaceChild(caretContainer, formatNode);\n        } else {\n          dom.insertAfter(caretContainer, formatNode);\n        }\n      }\n    };\n    const appendNode = (parentNode, node) => {\n      parentNode.appendChild(node);\n      return node;\n    };\n    const insertFormatNodesIntoCaretContainer = (formatNodes, caretContainer) => {\n      var _a;\n      const innerMostFormatNode = foldr(formatNodes, (parentNode, formatNode) => {\n        return appendNode(parentNode, formatNode.cloneNode(false));\n      }, caretContainer);\n      const doc = (_a = innerMostFormatNode.ownerDocument) !== null && _a !== void 0 ? _a : document;\n      return appendNode(innerMostFormatNode, doc.createTextNode(ZWSP));\n    };\n    const cleanFormatNode = (editor, caretContainer, formatNode, name, vars, similar) => {\n      const formatter = editor.formatter;\n      const dom = editor.dom;\n      const validFormats = filter$5(keys(formatter.get()), formatName => formatName !== name && !contains$1(formatName, 'removeformat'));\n      const matchedFormats = matchAllOnNode(editor, formatNode, validFormats);\n      const uniqueFormats = filter$5(matchedFormats, fmtName => !areSimilarFormats(editor, fmtName, name));\n      if (uniqueFormats.length > 0) {\n        const clonedFormatNode = formatNode.cloneNode(false);\n        dom.add(caretContainer, clonedFormatNode);\n        formatter.remove(name, vars, clonedFormatNode, similar);\n        dom.remove(clonedFormatNode);\n        return Optional.some(clonedFormatNode);\n      } else {\n        return Optional.none();\n      }\n    };\n    const normalizeNbsps = node => set(node, get$3(node).replace(new RegExp(`${ nbsp }$`), ' '));\n    const normalizeNbspsBetween = (editor, caretContainer) => {\n      const handler = () => {\n        if (caretContainer !== null && !editor.dom.isEmpty(caretContainer)) {\n          prevSibling(SugarElement.fromDom(caretContainer)).each(node => {\n            if (isText$c(node)) {\n              normalizeNbsps(node);\n            } else {\n              descendant$2(node, e => isText$c(e)).each(textNode => {\n                if (isText$c(textNode)) {\n                  normalizeNbsps(textNode);\n                }\n              });\n            }\n          });\n        }\n      };\n      editor.once('input', e => {\n        if (e.data && !isWhiteSpace(e.data)) {\n          if (!e.isComposing) {\n            handler();\n          } else {\n            editor.once('compositionend', () => {\n              handler();\n            });\n          }\n        }\n      });\n    };\n    const applyCaretFormat = (editor, name, vars) => {\n      let caretContainer;\n      const selection = editor.selection;\n      const formatList = editor.formatter.get(name);\n      if (!formatList) {\n        return;\n      }\n      const selectionRng = selection.getRng();\n      let offset = selectionRng.startOffset;\n      const container = selectionRng.startContainer;\n      const text = container.nodeValue;\n      caretContainer = getParentCaretContainer(editor.getBody(), selection.getStart());\n      const wordcharRegex = /[^\\s\\u00a0\\u00ad\\u200b\\ufeff]/;\n      if (text && offset > 0 && offset < text.length && wordcharRegex.test(text.charAt(offset)) && wordcharRegex.test(text.charAt(offset - 1))) {\n        const bookmark = selection.getBookmark();\n        selectionRng.collapse(true);\n        let rng = expandRng(editor.dom, selectionRng, formatList);\n        rng = split(rng);\n        editor.formatter.apply(name, vars, rng);\n        selection.moveToBookmark(bookmark);\n      } else {\n        let textNode = caretContainer ? findFirstTextNode(caretContainer) : null;\n        if (!caretContainer || (textNode === null || textNode === void 0 ? void 0 : textNode.data) !== ZWSP) {\n          caretContainer = importNode(editor.getDoc(), createCaretContainer(true).dom);\n          textNode = caretContainer.firstChild;\n          selectionRng.insertNode(caretContainer);\n          offset = 1;\n          normalizeNbspsBetween(editor, caretContainer);\n          editor.formatter.apply(name, vars, caretContainer);\n        } else {\n          editor.formatter.apply(name, vars, caretContainer);\n        }\n        selection.setCursorLocation(textNode, offset);\n      }\n    };\n    const removeCaretFormat = (editor, name, vars, similar) => {\n      const dom = editor.dom;\n      const selection = editor.selection;\n      let hasContentAfter = false;\n      const formatList = editor.formatter.get(name);\n      if (!formatList) {\n        return;\n      }\n      const rng = selection.getRng();\n      const container = rng.startContainer;\n      const offset = rng.startOffset;\n      let node = container;\n      if (isText$b(container)) {\n        if (offset !== container.data.length) {\n          hasContentAfter = true;\n        }\n        node = node.parentNode;\n      }\n      const parents = [];\n      let formatNode;\n      while (node) {\n        if (matchNode(editor, node, name, vars, similar)) {\n          formatNode = node;\n          break;\n        }\n        if (node.nextSibling) {\n          hasContentAfter = true;\n        }\n        parents.push(node);\n        node = node.parentNode;\n      }\n      if (!formatNode) {\n        return;\n      }\n      if (hasContentAfter) {\n        const bookmark = selection.getBookmark();\n        rng.collapse(true);\n        let expandedRng = expandRng(dom, rng, formatList, true);\n        expandedRng = split(expandedRng);\n        editor.formatter.remove(name, vars, expandedRng, similar);\n        selection.moveToBookmark(bookmark);\n      } else {\n        const caretContainer = getParentCaretContainer(editor.getBody(), formatNode);\n        const parentsAfter = isNonNullable(caretContainer) ? dom.getParents(formatNode.parentNode, always, caretContainer) : [];\n        const newCaretContainer = createCaretContainer(false).dom;\n        insertCaretContainerNode(editor, newCaretContainer, caretContainer !== null && caretContainer !== void 0 ? caretContainer : formatNode);\n        const cleanedFormatNode = cleanFormatNode(editor, newCaretContainer, formatNode, name, vars, similar);\n        const caretTextNode = insertFormatNodesIntoCaretContainer([\n          ...parents,\n          ...cleanedFormatNode.toArray(),\n          ...parentsAfter\n        ], newCaretContainer);\n        if (caretContainer) {\n          removeCaretContainerNode(editor, caretContainer, isNonNullable(caretContainer));\n        }\n        selection.setCursorLocation(caretTextNode, 1);\n        normalizeNbspsBetween(editor, newCaretContainer);\n        if (dom.isEmpty(formatNode)) {\n          dom.remove(formatNode);\n        }\n      }\n    };\n    const disableCaretContainer = (editor, keyCode, moveCaret) => {\n      const selection = editor.selection, body = editor.getBody();\n      removeCaretContainer(editor, null, moveCaret);\n      if ((keyCode === 8 || keyCode === 46) && selection.isCollapsed() && selection.getStart().innerHTML === ZWSP) {\n        removeCaretContainer(editor, getParentCaretContainer(body, selection.getStart()), true);\n      }\n      if (keyCode === 37 || keyCode === 39) {\n        removeCaretContainer(editor, getParentCaretContainer(body, selection.getStart()), true);\n      }\n    };\n    const endsWithNbsp = element => isText$b(element) && endsWith(element.data, nbsp);\n    const setup$v = editor => {\n      editor.on('mouseup keydown', e => {\n        disableCaretContainer(editor, e.keyCode, endsWithNbsp(editor.selection.getRng().endContainer));\n      });\n    };\n    const createCaretFormat = formatNodes => {\n      const caretContainer = createCaretContainer(false);\n      const innerMost = insertFormatNodesIntoCaretContainer(formatNodes, caretContainer.dom);\n      return {\n        caretContainer,\n        caretPosition: CaretPosition(innerMost, 0)\n      };\n    };\n    const replaceWithCaretFormat = (targetNode, formatNodes) => {\n      const {caretContainer, caretPosition} = createCaretFormat(formatNodes);\n      before$3(SugarElement.fromDom(targetNode), caretContainer);\n      remove$4(SugarElement.fromDom(targetNode));\n      return caretPosition;\n    };\n    const createCaretFormatAtStart$1 = (rng, formatNodes) => {\n      const {caretContainer, caretPosition} = createCaretFormat(formatNodes);\n      rng.insertNode(caretContainer.dom);\n      return caretPosition;\n    };\n    const isFormatElement = (editor, element) => {\n      if (isCaretNode(element.dom)) {\n        return false;\n      }\n      const inlineElements = editor.schema.getTextInlineElements();\n      return has$2(inlineElements, name(element)) && !isCaretNode(element.dom) && !isBogus$1(element.dom);\n    };\n\n    const postProcessHooks = {};\n    const isPre = matchNodeNames(['pre']);\n    const addPostProcessHook = (name, hook) => {\n      const hooks = postProcessHooks[name];\n      if (!hooks) {\n        postProcessHooks[name] = [];\n      }\n      postProcessHooks[name].push(hook);\n    };\n    const postProcess$1 = (name, editor) => {\n      if (has$2(postProcessHooks, name)) {\n        each$e(postProcessHooks[name], hook => {\n          hook(editor);\n        });\n      }\n    };\n    addPostProcessHook('pre', editor => {\n      const rng = editor.selection.getRng();\n      const hasPreSibling = blocks => pre => {\n        const prev = pre.previousSibling;\n        return isPre(prev) && contains$2(blocks, prev);\n      };\n      const joinPre = (pre1, pre2) => {\n        const sPre2 = SugarElement.fromDom(pre2);\n        const doc = documentOrOwner(sPre2).dom;\n        remove$4(sPre2);\n        append(SugarElement.fromDom(pre1), [\n          SugarElement.fromTag('br', doc),\n          SugarElement.fromTag('br', doc),\n          ...children$1(sPre2)\n        ]);\n      };\n      if (!rng.collapsed) {\n        const blocks = editor.selection.getSelectedBlocks();\n        const preBlocks = filter$5(filter$5(blocks, isPre), hasPreSibling(blocks));\n        each$e(preBlocks, pre => {\n          joinPre(pre.previousSibling, pre);\n        });\n      }\n    });\n\n    const listItemStyles = [\n      'fontWeight',\n      'fontStyle',\n      'color',\n      'fontSize',\n      'fontFamily'\n    ];\n    const hasListStyles = fmt => isObject(fmt.styles) && exists(keys(fmt.styles), name => contains$2(listItemStyles, name));\n    const findExpandedListItemFormat = formats => find$2(formats, fmt => isInlineFormat(fmt) && fmt.inline === 'span' && hasListStyles(fmt));\n    const getExpandedListItemFormat = (formatter, format) => {\n      const formatList = formatter.get(format);\n      return isArray$1(formatList) ? findExpandedListItemFormat(formatList) : Optional.none();\n    };\n    const isRngStartAtStartOfElement = (rng, elm) => prevPosition(elm, CaretPosition.fromRangeStart(rng)).isNone();\n    const isRngEndAtEndOfElement = (rng, elm) => {\n      return nextPosition(elm, CaretPosition.fromRangeEnd(rng)).exists(pos => !isBr$6(pos.getNode()) || nextPosition(elm, pos).isSome()) === false;\n    };\n    const isEditableListItem = dom => elm => isListItem$2(elm) && dom.isEditable(elm);\n    const getFullySelectedBlocks = selection => {\n      const blocks = selection.getSelectedBlocks();\n      const rng = selection.getRng();\n      if (selection.isCollapsed()) {\n        return [];\n      }\n      if (blocks.length === 1) {\n        return isRngStartAtStartOfElement(rng, blocks[0]) && isRngEndAtEndOfElement(rng, blocks[0]) ? blocks : [];\n      } else {\n        const first = head(blocks).filter(elm => isRngStartAtStartOfElement(rng, elm)).toArray();\n        const last = last$2(blocks).filter(elm => isRngEndAtEndOfElement(rng, elm)).toArray();\n        const middle = blocks.slice(1, -1);\n        return first.concat(middle).concat(last);\n      }\n    };\n    const getFullySelectedListItems = selection => filter$5(getFullySelectedBlocks(selection), isEditableListItem(selection.dom));\n    const getPartiallySelectedListItems = selection => filter$5(selection.getSelectedBlocks(), isEditableListItem(selection.dom));\n\n    const each$8 = Tools.each;\n    const isElementNode = node => isElement$6(node) && !isBookmarkNode$1(node) && !isCaretNode(node) && !isBogus$1(node);\n    const findElementSibling = (node, siblingName) => {\n      for (let sibling = node; sibling; sibling = sibling[siblingName]) {\n        if (isText$b(sibling) && isNotEmpty(sibling.data)) {\n          return node;\n        }\n        if (isElement$6(sibling) && !isBookmarkNode$1(sibling)) {\n          return sibling;\n        }\n      }\n      return node;\n    };\n    const mergeSiblingsNodes = (editor, prev, next) => {\n      const elementUtils = ElementUtils(editor);\n      const isPrevEditable = isHTMLElement(prev) && editor.dom.isEditable(prev);\n      const isNextEditable = isHTMLElement(next) && editor.dom.isEditable(next);\n      if (isPrevEditable && isNextEditable) {\n        const prevSibling = findElementSibling(prev, 'previousSibling');\n        const nextSibling = findElementSibling(next, 'nextSibling');\n        if (elementUtils.compare(prevSibling, nextSibling)) {\n          for (let sibling = prevSibling.nextSibling; sibling && sibling !== nextSibling;) {\n            const tmpSibling = sibling;\n            sibling = sibling.nextSibling;\n            prevSibling.appendChild(tmpSibling);\n          }\n          editor.dom.remove(nextSibling);\n          Tools.each(Tools.grep(nextSibling.childNodes), node => {\n            prevSibling.appendChild(node);\n          });\n          return prevSibling;\n        }\n      }\n      return next;\n    };\n    const mergeSiblings = (editor, format, vars, node) => {\n      var _a;\n      if (node && format.merge_siblings !== false) {\n        const newNode = (_a = mergeSiblingsNodes(editor, getNonWhiteSpaceSibling(node), node)) !== null && _a !== void 0 ? _a : node;\n        mergeSiblingsNodes(editor, newNode, getNonWhiteSpaceSibling(newNode, true));\n      }\n    };\n    const clearChildStyles = (dom, format, node) => {\n      if (format.clear_child_styles) {\n        const selector = format.links ? '*:not(a)' : '*';\n        each$8(dom.select(selector, node), childNode => {\n          if (isElementNode(childNode) && dom.isEditable(childNode)) {\n            each$8(format.styles, (_value, name) => {\n              dom.setStyle(childNode, name, '');\n            });\n          }\n        });\n      }\n    };\n    const processChildElements = (node, filter, process) => {\n      each$8(node.childNodes, node => {\n        if (isElementNode(node)) {\n          if (filter(node)) {\n            process(node);\n          }\n          if (node.hasChildNodes()) {\n            processChildElements(node, filter, process);\n          }\n        }\n      });\n    };\n    const unwrapEmptySpan = (dom, node) => {\n      if (node.nodeName === 'SPAN' && dom.getAttribs(node).length === 0) {\n        dom.remove(node, true);\n      }\n    };\n    const hasStyle = (dom, name) => node => !!(node && getStyle(dom, node, name));\n    const applyStyle = (dom, name, value) => node => {\n      dom.setStyle(node, name, value);\n      if (node.getAttribute('style') === '') {\n        node.removeAttribute('style');\n      }\n      unwrapEmptySpan(dom, node);\n    };\n\n    const removeResult = Adt.generate([\n      { keep: [] },\n      { rename: ['name'] },\n      { removed: [] }\n    ]);\n    const MCE_ATTR_RE = /^(src|href|style)$/;\n    const each$7 = Tools.each;\n    const isEq$2 = isEq$5;\n    const isTableCellOrRow = node => /^(TR|TH|TD)$/.test(node.nodeName);\n    const isChildOfInlineParent = (dom, node, parent) => dom.isChildOf(node, parent) && node !== parent && !dom.isBlock(parent);\n    const getContainer = (ed, rng, start) => {\n      let container = rng[start ? 'startContainer' : 'endContainer'];\n      let offset = rng[start ? 'startOffset' : 'endOffset'];\n      if (isElement$6(container)) {\n        const lastIdx = container.childNodes.length - 1;\n        if (!start && offset) {\n          offset--;\n        }\n        container = container.childNodes[offset > lastIdx ? lastIdx : offset];\n      }\n      if (isText$b(container) && start && offset >= container.data.length) {\n        container = new DomTreeWalker(container, ed.getBody()).next() || container;\n      }\n      if (isText$b(container) && !start && offset === 0) {\n        container = new DomTreeWalker(container, ed.getBody()).prev() || container;\n      }\n      return container;\n    };\n    const normalizeTableSelection = (node, start) => {\n      const prop = start ? 'firstChild' : 'lastChild';\n      const childNode = node[prop];\n      if (isTableCellOrRow(node) && childNode) {\n        if (node.nodeName === 'TR') {\n          return childNode[prop] || childNode;\n        } else {\n          return childNode;\n        }\n      }\n      return node;\n    };\n    const wrap$1 = (dom, node, name, attrs) => {\n      var _a;\n      const wrapper = dom.create(name, attrs);\n      (_a = node.parentNode) === null || _a === void 0 ? void 0 : _a.insertBefore(wrapper, node);\n      wrapper.appendChild(node);\n      return wrapper;\n    };\n    const wrapWithSiblings = (dom, node, next, name, attrs) => {\n      const start = SugarElement.fromDom(node);\n      const wrapper = SugarElement.fromDom(dom.create(name, attrs));\n      const siblings = next ? nextSiblings(start) : prevSiblings(start);\n      append(wrapper, siblings);\n      if (next) {\n        before$3(start, wrapper);\n        prepend(wrapper, start);\n      } else {\n        after$4(start, wrapper);\n        append$1(wrapper, start);\n      }\n      return wrapper.dom;\n    };\n    const isColorFormatAndAnchor = (node, format) => format.links && node.nodeName === 'A';\n    const removeNode = (ed, node, format) => {\n      const parentNode = node.parentNode;\n      let rootBlockElm;\n      const dom = ed.dom;\n      const forcedRootBlock = getForcedRootBlock(ed);\n      if (isBlockFormat(format)) {\n        if (parentNode === dom.getRoot()) {\n          if (!format.list_block || !isEq$2(node, format.list_block)) {\n            each$e(from(node.childNodes), node => {\n              if (isValid(ed, forcedRootBlock, node.nodeName.toLowerCase())) {\n                if (!rootBlockElm) {\n                  rootBlockElm = wrap$1(dom, node, forcedRootBlock);\n                  dom.setAttribs(rootBlockElm, getForcedRootBlockAttrs(ed));\n                } else {\n                  rootBlockElm.appendChild(node);\n                }\n              } else {\n                rootBlockElm = null;\n              }\n            });\n          }\n        }\n      }\n      if (isMixedFormat(format) && !isEq$2(format.inline, node)) {\n        return;\n      }\n      dom.remove(node, true);\n    };\n    const processFormatAttrOrStyle = (name, value, vars) => {\n      if (isNumber(name)) {\n        return {\n          name: value,\n          value: null\n        };\n      } else {\n        return {\n          name,\n          value: replaceVars(value, vars)\n        };\n      }\n    };\n    const removeEmptyStyleAttributeIfNeeded = (dom, elm) => {\n      if (dom.getAttrib(elm, 'style') === '') {\n        elm.removeAttribute('style');\n        elm.removeAttribute('data-mce-style');\n      }\n    };\n    const removeStyles = (dom, elm, format, vars, compareNode) => {\n      let stylesModified = false;\n      each$7(format.styles, (value, name) => {\n        const {\n          name: styleName,\n          value: styleValue\n        } = processFormatAttrOrStyle(name, value, vars);\n        const normalizedStyleValue = normalizeStyleValue(styleValue, styleName);\n        if (format.remove_similar || isNull(styleValue) || !isElement$6(compareNode) || isEq$2(getStyle(dom, compareNode, styleName), normalizedStyleValue)) {\n          dom.setStyle(elm, styleName, '');\n        }\n        stylesModified = true;\n      });\n      if (stylesModified) {\n        removeEmptyStyleAttributeIfNeeded(dom, elm);\n      }\n    };\n    const removeListStyleFormats = (editor, name, vars) => {\n      if (name === 'removeformat') {\n        each$e(getPartiallySelectedListItems(editor.selection), li => {\n          each$e(listItemStyles, name => editor.dom.setStyle(li, name, ''));\n          removeEmptyStyleAttributeIfNeeded(editor.dom, li);\n        });\n      } else {\n        getExpandedListItemFormat(editor.formatter, name).each(liFmt => {\n          each$e(getPartiallySelectedListItems(editor.selection), li => removeStyles(editor.dom, li, liFmt, vars, null));\n        });\n      }\n    };\n    const removeNodeFormatInternal = (ed, format, vars, node, compareNode) => {\n      const dom = ed.dom;\n      const elementUtils = ElementUtils(ed);\n      const schema = ed.schema;\n      if (isInlineFormat(format) && isTransparentElementName(schema, format.inline) && isTransparentBlock(schema, node) && node.parentElement === ed.getBody()) {\n        removeNode(ed, node, format);\n        return removeResult.removed();\n      }\n      if (!format.ceFalseOverride && node && dom.getContentEditableParent(node) === 'false') {\n        return removeResult.keep();\n      }\n      if (node && !matchName(dom, node, format) && !isColorFormatAndAnchor(node, format)) {\n        return removeResult.keep();\n      }\n      const elm = node;\n      const preserveAttributes = format.preserve_attributes;\n      if (isInlineFormat(format) && format.remove === 'all' && isArray$1(preserveAttributes)) {\n        const attrsToPreserve = filter$5(dom.getAttribs(elm), attr => contains$2(preserveAttributes, attr.name.toLowerCase()));\n        dom.removeAllAttribs(elm);\n        each$e(attrsToPreserve, attr => dom.setAttrib(elm, attr.name, attr.value));\n        if (attrsToPreserve.length > 0) {\n          return removeResult.rename('span');\n        }\n      }\n      if (format.remove !== 'all') {\n        removeStyles(dom, elm, format, vars, compareNode);\n        each$7(format.attributes, (value, name) => {\n          const {\n            name: attrName,\n            value: attrValue\n          } = processFormatAttrOrStyle(name, value, vars);\n          if (format.remove_similar || isNull(attrValue) || !isElement$6(compareNode) || isEq$2(dom.getAttrib(compareNode, attrName), attrValue)) {\n            if (attrName === 'class') {\n              const currentValue = dom.getAttrib(elm, attrName);\n              if (currentValue) {\n                let valueOut = '';\n                each$e(currentValue.split(/\\s+/), cls => {\n                  if (/mce\\-\\w+/.test(cls)) {\n                    valueOut += (valueOut ? ' ' : '') + cls;\n                  }\n                });\n                if (valueOut) {\n                  dom.setAttrib(elm, attrName, valueOut);\n                  return;\n                }\n              }\n            }\n            if (MCE_ATTR_RE.test(attrName)) {\n              elm.removeAttribute('data-mce-' + attrName);\n            }\n            if (attrName === 'style' && matchNodeNames(['li'])(elm) && dom.getStyle(elm, 'list-style-type') === 'none') {\n              elm.removeAttribute(attrName);\n              dom.setStyle(elm, 'list-style-type', 'none');\n              return;\n            }\n            if (attrName === 'class') {\n              elm.removeAttribute('className');\n            }\n            elm.removeAttribute(attrName);\n          }\n        });\n        each$7(format.classes, value => {\n          value = replaceVars(value, vars);\n          if (!isElement$6(compareNode) || dom.hasClass(compareNode, value)) {\n            dom.removeClass(elm, value);\n          }\n        });\n        const attrs = dom.getAttribs(elm);\n        for (let i = 0; i < attrs.length; i++) {\n          const attrName = attrs[i].nodeName;\n          if (!elementUtils.isAttributeInternal(attrName)) {\n            return removeResult.keep();\n          }\n        }\n      }\n      if (format.remove !== 'none') {\n        removeNode(ed, elm, format);\n        return removeResult.removed();\n      }\n      return removeResult.keep();\n    };\n    const findFormatRoot = (editor, container, name, vars, similar) => {\n      let formatRoot;\n      if (container.parentNode) {\n        each$e(getParents$2(editor.dom, container.parentNode).reverse(), parent => {\n          if (!formatRoot && isElement$6(parent) && parent.id !== '_start' && parent.id !== '_end') {\n            const format = matchNode(editor, parent, name, vars, similar);\n            if (format && format.split !== false) {\n              formatRoot = parent;\n            }\n          }\n        });\n      }\n      return formatRoot;\n    };\n    const removeNodeFormatFromClone = (editor, format, vars, clone) => removeNodeFormatInternal(editor, format, vars, clone, clone).fold(constant(clone), newName => {\n      const fragment = editor.dom.createFragment();\n      fragment.appendChild(clone);\n      return editor.dom.rename(clone, newName);\n    }, constant(null));\n    const wrapAndSplit = (editor, formatList, formatRoot, container, target, split, format, vars) => {\n      var _a, _b;\n      let lastClone;\n      let firstClone;\n      const dom = editor.dom;\n      if (formatRoot) {\n        const formatRootParent = formatRoot.parentNode;\n        for (let parent = container.parentNode; parent && parent !== formatRootParent; parent = parent.parentNode) {\n          let clone = dom.clone(parent, false);\n          for (let i = 0; i < formatList.length; i++) {\n            clone = removeNodeFormatFromClone(editor, formatList[i], vars, clone);\n            if (clone === null) {\n              break;\n            }\n          }\n          if (clone) {\n            if (lastClone) {\n              clone.appendChild(lastClone);\n            }\n            if (!firstClone) {\n              firstClone = clone;\n            }\n            lastClone = clone;\n          }\n        }\n        if (split && (!format.mixed || !dom.isBlock(formatRoot))) {\n          container = (_a = dom.split(formatRoot, container)) !== null && _a !== void 0 ? _a : container;\n        }\n        if (lastClone && firstClone) {\n          (_b = target.parentNode) === null || _b === void 0 ? void 0 : _b.insertBefore(lastClone, target);\n          firstClone.appendChild(target);\n          if (isInlineFormat(format)) {\n            mergeSiblings(editor, format, vars, lastClone);\n          }\n        }\n      }\n      return container;\n    };\n    const removeFormatInternal = (ed, name, vars, node, similar) => {\n      const formatList = ed.formatter.get(name);\n      const format = formatList[0];\n      const dom = ed.dom;\n      const selection = ed.selection;\n      const splitToFormatRoot = container => {\n        const formatRoot = findFormatRoot(ed, container, name, vars, similar);\n        return wrapAndSplit(ed, formatList, formatRoot, container, container, true, format, vars);\n      };\n      const isRemoveBookmarkNode = node => isBookmarkNode$1(node) && isElement$6(node) && (node.id === '_start' || node.id === '_end');\n      const removeFormatOnNode = node => exists(formatList, fmt => removeNodeFormat(ed, fmt, vars, node, node));\n      const process = node => {\n        const children = from(node.childNodes);\n        const removed = removeFormatOnNode(node);\n        const currentNodeMatches = removed || exists(formatList, f => matchName(dom, node, f));\n        const parentNode = node.parentNode;\n        if (!currentNodeMatches && isNonNullable(parentNode) && shouldExpandToSelector(format)) {\n          removeFormatOnNode(parentNode);\n        }\n        if (format.deep) {\n          if (children.length) {\n            for (let i = 0; i < children.length; i++) {\n              process(children[i]);\n            }\n          }\n        }\n        const textDecorations = [\n          'underline',\n          'line-through',\n          'overline'\n        ];\n        each$e(textDecorations, decoration => {\n          if (isElement$6(node) && ed.dom.getStyle(node, 'text-decoration') === decoration && node.parentNode && getTextDecoration(dom, node.parentNode) === decoration) {\n            removeNodeFormat(ed, {\n              deep: false,\n              exact: true,\n              inline: 'span',\n              styles: { textDecoration: decoration }\n            }, undefined, node);\n          }\n        });\n      };\n      const unwrap = start => {\n        const node = dom.get(start ? '_start' : '_end');\n        if (node) {\n          let out = node[start ? 'firstChild' : 'lastChild'];\n          if (isRemoveBookmarkNode(out)) {\n            out = out[start ? 'firstChild' : 'lastChild'];\n          }\n          if (isText$b(out) && out.data.length === 0) {\n            out = start ? node.previousSibling || node.nextSibling : node.nextSibling || node.previousSibling;\n          }\n          dom.remove(node, true);\n          return out;\n        } else {\n          return null;\n        }\n      };\n      const removeRngStyle = rng => {\n        let startContainer;\n        let endContainer;\n        let expandedRng = expandRng(dom, rng, formatList, rng.collapsed);\n        if (format.split) {\n          expandedRng = split(expandedRng);\n          startContainer = getContainer(ed, expandedRng, true);\n          endContainer = getContainer(ed, expandedRng);\n          if (startContainer !== endContainer) {\n            startContainer = normalizeTableSelection(startContainer, true);\n            endContainer = normalizeTableSelection(endContainer, false);\n            if (isChildOfInlineParent(dom, startContainer, endContainer)) {\n              const marker = Optional.from(startContainer.firstChild).getOr(startContainer);\n              splitToFormatRoot(wrapWithSiblings(dom, marker, true, 'span', {\n                'id': '_start',\n                'data-mce-type': 'bookmark'\n              }));\n              unwrap(true);\n              return;\n            }\n            if (isChildOfInlineParent(dom, endContainer, startContainer)) {\n              const marker = Optional.from(endContainer.lastChild).getOr(endContainer);\n              splitToFormatRoot(wrapWithSiblings(dom, marker, false, 'span', {\n                'id': '_end',\n                'data-mce-type': 'bookmark'\n              }));\n              unwrap(false);\n              return;\n            }\n            startContainer = wrap$1(dom, startContainer, 'span', {\n              'id': '_start',\n              'data-mce-type': 'bookmark'\n            });\n            endContainer = wrap$1(dom, endContainer, 'span', {\n              'id': '_end',\n              'data-mce-type': 'bookmark'\n            });\n            const newRng = dom.createRng();\n            newRng.setStartAfter(startContainer);\n            newRng.setEndBefore(endContainer);\n            walk$3(dom, newRng, nodes => {\n              each$e(nodes, n => {\n                if (!isBookmarkNode$1(n) && !isBookmarkNode$1(n.parentNode)) {\n                  splitToFormatRoot(n);\n                }\n              });\n            });\n            splitToFormatRoot(startContainer);\n            splitToFormatRoot(endContainer);\n            startContainer = unwrap(true);\n            endContainer = unwrap();\n          } else {\n            startContainer = endContainer = splitToFormatRoot(startContainer);\n          }\n          expandedRng.startContainer = startContainer.parentNode ? startContainer.parentNode : startContainer;\n          expandedRng.startOffset = dom.nodeIndex(startContainer);\n          expandedRng.endContainer = endContainer.parentNode ? endContainer.parentNode : endContainer;\n          expandedRng.endOffset = dom.nodeIndex(endContainer) + 1;\n        }\n        walk$3(dom, expandedRng, nodes => {\n          each$e(nodes, process);\n        });\n      };\n      if (node) {\n        if (isNode(node)) {\n          const rng = dom.createRng();\n          rng.setStartBefore(node);\n          rng.setEndAfter(node);\n          removeRngStyle(rng);\n        } else {\n          removeRngStyle(node);\n        }\n        fireFormatRemove(ed, name, node, vars);\n        return;\n      }\n      if (!selection.isCollapsed() || !isInlineFormat(format) || getCellsFromEditor(ed).length) {\n        preserveSelection(ed, () => runOnRanges(ed, removeRngStyle), startNode => isInlineFormat(format) && match$2(ed, name, vars, startNode));\n        ed.nodeChanged();\n      } else {\n        removeCaretFormat(ed, name, vars, similar);\n      }\n      removeListStyleFormats(ed, name, vars);\n      fireFormatRemove(ed, name, node, vars);\n    };\n    const removeFormat$1 = (ed, name, vars, node, similar) => {\n      if (node || ed.selection.isEditable()) {\n        removeFormatInternal(ed, name, vars, node, similar);\n      }\n    };\n    const removeNodeFormat = (editor, format, vars, node, compareNode) => {\n      return removeNodeFormatInternal(editor, format, vars, node, compareNode).fold(never, newName => {\n        editor.dom.rename(node, newName);\n        return true;\n      }, always);\n    };\n\n    const each$6 = Tools.each;\n    const mergeTextDecorationsAndColor = (dom, format, vars, node) => {\n      const processTextDecorationsAndColor = n => {\n        if (isHTMLElement(n) && isElement$6(n.parentNode) && dom.isEditable(n)) {\n          const parentTextDecoration = getTextDecoration(dom, n.parentNode);\n          if (dom.getStyle(n, 'color') && parentTextDecoration) {\n            dom.setStyle(n, 'text-decoration', parentTextDecoration);\n          } else if (dom.getStyle(n, 'text-decoration') === parentTextDecoration) {\n            dom.setStyle(n, 'text-decoration', null);\n          }\n        }\n      };\n      if (format.styles && (format.styles.color || format.styles.textDecoration)) {\n        Tools.walk(node, processTextDecorationsAndColor, 'childNodes');\n        processTextDecorationsAndColor(node);\n      }\n    };\n    const mergeBackgroundColorAndFontSize = (dom, format, vars, node) => {\n      if (format.styles && format.styles.backgroundColor) {\n        const hasFontSize = hasStyle(dom, 'fontSize');\n        processChildElements(node, elm => hasFontSize(elm) && dom.isEditable(elm), applyStyle(dom, 'backgroundColor', replaceVars(format.styles.backgroundColor, vars)));\n      }\n    };\n    const mergeSubSup = (dom, format, vars, node) => {\n      if (isInlineFormat(format) && (format.inline === 'sub' || format.inline === 'sup')) {\n        const hasFontSize = hasStyle(dom, 'fontSize');\n        processChildElements(node, elm => hasFontSize(elm) && dom.isEditable(elm), applyStyle(dom, 'fontSize', ''));\n        const inverseTagDescendants = filter$5(dom.select(format.inline === 'sup' ? 'sub' : 'sup', node), dom.isEditable);\n        dom.remove(inverseTagDescendants, true);\n      }\n    };\n    const mergeWithChildren = (editor, formatList, vars, node) => {\n      each$6(formatList, format => {\n        if (isInlineFormat(format)) {\n          each$6(editor.dom.select(format.inline, node), child => {\n            if (isElementNode(child)) {\n              removeNodeFormat(editor, format, vars, child, format.exact ? child : null);\n            }\n          });\n        }\n        clearChildStyles(editor.dom, format, node);\n      });\n    };\n    const mergeWithParents = (editor, format, name, vars, node) => {\n      const parentNode = node.parentNode;\n      if (matchNode(editor, parentNode, name, vars)) {\n        if (removeNodeFormat(editor, format, vars, node)) {\n          return;\n        }\n      }\n      if (format.merge_with_parents && parentNode) {\n        editor.dom.getParent(parentNode, parent => {\n          if (matchNode(editor, parent, name, vars)) {\n            removeNodeFormat(editor, format, vars, node);\n            return true;\n          } else {\n            return false;\n          }\n        });\n      }\n    };\n\n    const each$5 = Tools.each;\n    const canFormatBR = (editor, format, node, parentName) => {\n      if (canFormatEmptyLines(editor) && isInlineFormat(format) && node.parentNode) {\n        const validBRParentElements = getTextRootBlockElements(editor.schema);\n        const hasCaretNodeSibling = sibling(SugarElement.fromDom(node), sibling => isCaretNode(sibling.dom));\n        return hasNonNullableKey(validBRParentElements, parentName) && isEmptyNode(editor.schema, node.parentNode, {\n          skipBogus: false,\n          includeZwsp: true\n        }) && !hasCaretNodeSibling;\n      } else {\n        return false;\n      }\n    };\n    const applyStyles = (dom, elm, format, vars) => {\n      each$5(format.styles, (value, name) => {\n        dom.setStyle(elm, name, replaceVars(value, vars));\n      });\n      if (format.styles) {\n        const styleVal = dom.getAttrib(elm, 'style');\n        if (styleVal) {\n          dom.setAttrib(elm, 'data-mce-style', styleVal);\n        }\n      }\n    };\n    const applyFormatAction = (ed, name, vars, node) => {\n      const formatList = ed.formatter.get(name);\n      const format = formatList[0];\n      const isCollapsed = !node && ed.selection.isCollapsed();\n      const dom = ed.dom;\n      const selection = ed.selection;\n      const setElementFormat = (elm, fmt = format) => {\n        if (isFunction(fmt.onformat)) {\n          fmt.onformat(elm, fmt, vars, node);\n        }\n        applyStyles(dom, elm, fmt, vars);\n        each$5(fmt.attributes, (value, name) => {\n          dom.setAttrib(elm, name, replaceVars(value, vars));\n        });\n        each$5(fmt.classes, value => {\n          const newValue = replaceVars(value, vars);\n          if (!dom.hasClass(elm, newValue)) {\n            dom.addClass(elm, newValue);\n          }\n        });\n      };\n      const applyNodeStyle = (formatList, node) => {\n        let found = false;\n        each$5(formatList, format => {\n          if (!isSelectorFormat(format)) {\n            return false;\n          }\n          if (dom.getContentEditable(node) === 'false' && !format.ceFalseOverride) {\n            return true;\n          }\n          if (isNonNullable(format.collapsed) && format.collapsed !== isCollapsed) {\n            return true;\n          }\n          if (dom.is(node, format.selector) && !isCaretNode(node)) {\n            setElementFormat(node, format);\n            found = true;\n            return false;\n          }\n          return true;\n        });\n        return found;\n      };\n      const createWrapElement = wrapName => {\n        if (isString(wrapName)) {\n          const wrapElm = dom.create(wrapName);\n          setElementFormat(wrapElm);\n          return wrapElm;\n        } else {\n          return null;\n        }\n      };\n      const applyRngStyle = (dom, rng, nodeSpecific) => {\n        const newWrappers = [];\n        let contentEditable = true;\n        const wrapName = format.inline || format.block;\n        const wrapElm = createWrapElement(wrapName);\n        const isMatchingWrappingBlock = node => isWrappingBlockFormat(format) && matchNode(ed, node, name, vars);\n        const canRenameBlock = (node, parentName, isEditableDescendant) => {\n          const isValidBlockFormatForNode = isNonWrappingBlockFormat(format) && isTextBlock$1(ed.schema, node) && isValid(ed, parentName, wrapName);\n          return isEditableDescendant && isValidBlockFormatForNode;\n        };\n        const canWrapNode = (node, parentName, isEditableDescendant, isWrappableNoneditableElm) => {\n          const nodeName = node.nodeName.toLowerCase();\n          const isValidWrapNode = isValid(ed, wrapName, nodeName) && isValid(ed, parentName, wrapName);\n          const isZwsp$1 = !nodeSpecific && isText$b(node) && isZwsp(node.data);\n          const isCaret = isCaretNode(node);\n          const isCorrectFormatForNode = !isInlineFormat(format) || !dom.isBlock(node);\n          return (isEditableDescendant || isWrappableNoneditableElm) && isValidWrapNode && !isZwsp$1 && !isCaret && isCorrectFormatForNode;\n        };\n        walk$3(dom, rng, nodes => {\n          let currentWrapElm;\n          const process = node => {\n            let hasContentEditableState = false;\n            let lastContentEditable = contentEditable;\n            let isWrappableNoneditableElm = false;\n            const parentNode = node.parentNode;\n            const parentName = parentNode.nodeName.toLowerCase();\n            const contentEditableValue = dom.getContentEditable(node);\n            if (isNonNullable(contentEditableValue)) {\n              lastContentEditable = contentEditable;\n              contentEditable = contentEditableValue === 'true';\n              hasContentEditableState = true;\n              isWrappableNoneditableElm = isWrappableNoneditable(ed, node);\n            }\n            const isEditableDescendant = contentEditable && !hasContentEditableState;\n            if (isBr$6(node) && !canFormatBR(ed, format, node, parentName)) {\n              currentWrapElm = null;\n              if (isBlockFormat(format)) {\n                dom.remove(node);\n              }\n              return;\n            }\n            if (isMatchingWrappingBlock(node)) {\n              currentWrapElm = null;\n              return;\n            }\n            if (canRenameBlock(node, parentName, isEditableDescendant)) {\n              const elm = dom.rename(node, wrapName);\n              setElementFormat(elm);\n              newWrappers.push(elm);\n              currentWrapElm = null;\n              return;\n            }\n            if (isSelectorFormat(format)) {\n              let found = applyNodeStyle(formatList, node);\n              if (!found && isNonNullable(parentNode) && shouldExpandToSelector(format)) {\n                found = applyNodeStyle(formatList, parentNode);\n              }\n              if (!isInlineFormat(format) || found) {\n                currentWrapElm = null;\n                return;\n              }\n            }\n            if (isNonNullable(wrapElm) && canWrapNode(node, parentName, isEditableDescendant, isWrappableNoneditableElm)) {\n              if (!currentWrapElm) {\n                currentWrapElm = dom.clone(wrapElm, false);\n                parentNode.insertBefore(currentWrapElm, node);\n                newWrappers.push(currentWrapElm);\n              }\n              if (isWrappableNoneditableElm && hasContentEditableState) {\n                contentEditable = lastContentEditable;\n              }\n              currentWrapElm.appendChild(node);\n            } else {\n              currentWrapElm = null;\n              each$e(from(node.childNodes), process);\n              if (hasContentEditableState) {\n                contentEditable = lastContentEditable;\n              }\n              currentWrapElm = null;\n            }\n          };\n          each$e(nodes, process);\n        });\n        if (format.links === true) {\n          each$e(newWrappers, node => {\n            const process = node => {\n              if (node.nodeName === 'A') {\n                setElementFormat(node, format);\n              }\n              each$e(from(node.childNodes), process);\n            };\n            process(node);\n          });\n        }\n        each$e(newWrappers, node => {\n          const getChildCount = node => {\n            let count = 0;\n            each$e(node.childNodes, node => {\n              if (!isEmptyTextNode$1(node) && !isBookmarkNode$1(node)) {\n                count++;\n              }\n            });\n            return count;\n          };\n          const mergeStyles = node => {\n            const childElement = find$2(node.childNodes, isElementNode$1).filter(child => dom.getContentEditable(child) !== 'false' && matchName(dom, child, format));\n            return childElement.map(child => {\n              const clone = dom.clone(child, false);\n              setElementFormat(clone);\n              dom.replace(clone, node, true);\n              dom.remove(child, true);\n              return clone;\n            }).getOr(node);\n          };\n          const childCount = getChildCount(node);\n          if ((newWrappers.length > 1 || !dom.isBlock(node)) && childCount === 0) {\n            dom.remove(node, true);\n            return;\n          }\n          if (isInlineFormat(format) || isBlockFormat(format) && format.wrapper) {\n            if (!format.exact && childCount === 1) {\n              node = mergeStyles(node);\n            }\n            mergeWithChildren(ed, formatList, vars, node);\n            mergeWithParents(ed, format, name, vars, node);\n            mergeBackgroundColorAndFontSize(dom, format, vars, node);\n            mergeTextDecorationsAndColor(dom, format, vars, node);\n            mergeSubSup(dom, format, vars, node);\n            mergeSiblings(ed, format, vars, node);\n          }\n        });\n      };\n      const targetNode = isNode(node) ? node : selection.getNode();\n      if (dom.getContentEditable(targetNode) === 'false' && !isWrappableNoneditable(ed, targetNode)) {\n        node = targetNode;\n        applyNodeStyle(formatList, node);\n        fireFormatApply(ed, name, node, vars);\n        return;\n      }\n      if (format) {\n        if (node) {\n          if (isNode(node)) {\n            if (!applyNodeStyle(formatList, node)) {\n              const rng = dom.createRng();\n              rng.setStartBefore(node);\n              rng.setEndAfter(node);\n              applyRngStyle(dom, expandRng(dom, rng, formatList), true);\n            }\n          } else {\n            applyRngStyle(dom, node, true);\n          }\n        } else {\n          if (!isCollapsed || !isInlineFormat(format) || getCellsFromEditor(ed).length) {\n            selection.setRng(normalize(selection.getRng()));\n            preserveSelection(ed, () => {\n              runOnRanges(ed, (selectionRng, fake) => {\n                const expandedRng = fake ? selectionRng : expandRng(dom, selectionRng, formatList);\n                applyRngStyle(dom, expandedRng, false);\n              });\n            }, always);\n            ed.nodeChanged();\n          } else {\n            applyCaretFormat(ed, name, vars);\n          }\n          getExpandedListItemFormat(ed.formatter, name).each(liFmt => {\n            each$e(getFullySelectedListItems(ed.selection), li => applyStyles(dom, li, liFmt, vars));\n          });\n        }\n        postProcess$1(name, ed);\n      }\n      fireFormatApply(ed, name, node, vars);\n    };\n    const applyFormat$1 = (editor, name, vars, node) => {\n      if (node || editor.selection.isEditable()) {\n        applyFormatAction(editor, name, vars, node);\n      }\n    };\n\n    const hasVars = value => has$2(value, 'vars');\n    const setup$u = (registeredFormatListeners, editor) => {\n      registeredFormatListeners.set({});\n      editor.on('NodeChange', e => {\n        updateAndFireChangeCallbacks(editor, e.element, registeredFormatListeners.get());\n      });\n      editor.on('FormatApply FormatRemove', e => {\n        const element = Optional.from(e.node).map(nodeOrRange => isNode(nodeOrRange) ? nodeOrRange : nodeOrRange.startContainer).bind(node => isElement$6(node) ? Optional.some(node) : Optional.from(node.parentElement)).getOrThunk(() => fallbackElement(editor));\n        updateAndFireChangeCallbacks(editor, element, registeredFormatListeners.get());\n      });\n    };\n    const fallbackElement = editor => editor.selection.getStart();\n    const matchingNode = (editor, parents, format, similar, vars) => {\n      const isMatchingNode = node => {\n        const matchingFormat = editor.formatter.matchNode(node, format, vars !== null && vars !== void 0 ? vars : {}, similar);\n        return !isUndefined(matchingFormat);\n      };\n      const isUnableToMatch = node => {\n        if (matchesUnInheritedFormatSelector(editor, node, format)) {\n          return true;\n        } else {\n          if (!similar) {\n            return isNonNullable(editor.formatter.matchNode(node, format, vars, true));\n          } else {\n            return false;\n          }\n        }\n      };\n      return findUntil$1(parents, isMatchingNode, isUnableToMatch);\n    };\n    const getParents = (editor, elm) => {\n      const element = elm !== null && elm !== void 0 ? elm : fallbackElement(editor);\n      return filter$5(getParents$2(editor.dom, element), node => isElement$6(node) && !isBogus$1(node));\n    };\n    const updateAndFireChangeCallbacks = (editor, elm, registeredCallbacks) => {\n      const parents = getParents(editor, elm);\n      each$d(registeredCallbacks, (data, format) => {\n        const runIfChanged = spec => {\n          const match = matchingNode(editor, parents, format, spec.similar, hasVars(spec) ? spec.vars : undefined);\n          const isSet = match.isSome();\n          if (spec.state.get() !== isSet) {\n            spec.state.set(isSet);\n            const node = match.getOr(elm);\n            if (hasVars(spec)) {\n              spec.callback(isSet, {\n                node,\n                format,\n                parents\n              });\n            } else {\n              each$e(spec.callbacks, callback => callback(isSet, {\n                node,\n                format,\n                parents\n              }));\n            }\n          }\n        };\n        each$e([\n          data.withSimilar,\n          data.withoutSimilar\n        ], runIfChanged);\n        each$e(data.withVars, runIfChanged);\n      });\n    };\n    const addListeners = (editor, registeredFormatListeners, formats, callback, similar, vars) => {\n      const formatChangeItems = registeredFormatListeners.get();\n      each$e(formats.split(','), format => {\n        const group = get$a(formatChangeItems, format).getOrThunk(() => {\n          const base = {\n            withSimilar: {\n              state: Cell(false),\n              similar: true,\n              callbacks: []\n            },\n            withoutSimilar: {\n              state: Cell(false),\n              similar: false,\n              callbacks: []\n            },\n            withVars: []\n          };\n          formatChangeItems[format] = base;\n          return base;\n        });\n        const getCurrent = () => {\n          const parents = getParents(editor);\n          return matchingNode(editor, parents, format, similar, vars).isSome();\n        };\n        if (isUndefined(vars)) {\n          const toAppendTo = similar ? group.withSimilar : group.withoutSimilar;\n          toAppendTo.callbacks.push(callback);\n          if (toAppendTo.callbacks.length === 1) {\n            toAppendTo.state.set(getCurrent());\n          }\n        } else {\n          group.withVars.push({\n            state: Cell(getCurrent()),\n            similar,\n            vars,\n            callback\n          });\n        }\n      });\n      registeredFormatListeners.set(formatChangeItems);\n    };\n    const removeListeners = (registeredFormatListeners, formats, callback) => {\n      const formatChangeItems = registeredFormatListeners.get();\n      each$e(formats.split(','), format => get$a(formatChangeItems, format).each(group => {\n        formatChangeItems[format] = {\n          withSimilar: {\n            ...group.withSimilar,\n            callbacks: filter$5(group.withSimilar.callbacks, cb => cb !== callback)\n          },\n          withoutSimilar: {\n            ...group.withoutSimilar,\n            callbacks: filter$5(group.withoutSimilar.callbacks, cb => cb !== callback)\n          },\n          withVars: filter$5(group.withVars, item => item.callback !== callback)\n        };\n      }));\n      registeredFormatListeners.set(formatChangeItems);\n    };\n    const formatChangedInternal = (editor, registeredFormatListeners, formats, callback, similar, vars) => {\n      addListeners(editor, registeredFormatListeners, formats, callback, similar, vars);\n      return { unbind: () => removeListeners(registeredFormatListeners, formats, callback) };\n    };\n\n    const toggle = (editor, name, vars, node) => {\n      const fmt = editor.formatter.get(name);\n      if (fmt) {\n        if (match$2(editor, name, vars, node) && (!('toggle' in fmt[0]) || fmt[0].toggle)) {\n          removeFormat$1(editor, name, vars, node);\n        } else {\n          applyFormat$1(editor, name, vars, node);\n        }\n      }\n    };\n\n    const explode$1 = Tools.explode;\n    const create$8 = () => {\n      const filters = {};\n      const addFilter = (name, callback) => {\n        each$e(explode$1(name), name => {\n          if (!has$2(filters, name)) {\n            filters[name] = {\n              name,\n              callbacks: []\n            };\n          }\n          filters[name].callbacks.push(callback);\n        });\n      };\n      const getFilters = () => values(filters);\n      const removeFilter = (name, callback) => {\n        each$e(explode$1(name), name => {\n          if (has$2(filters, name)) {\n            if (isNonNullable(callback)) {\n              const filter = filters[name];\n              const newCallbacks = filter$5(filter.callbacks, c => c !== callback);\n              if (newCallbacks.length > 0) {\n                filter.callbacks = newCallbacks;\n              } else {\n                delete filters[name];\n              }\n            } else {\n              delete filters[name];\n            }\n          }\n        });\n      };\n      return {\n        addFilter,\n        getFilters,\n        removeFilter\n      };\n    };\n\n    const removeAttrs = (node, names) => {\n      each$e(names, name => {\n        node.attr(name, null);\n      });\n    };\n    const addFontToSpansFilter = (domParser, styles, fontSizes) => {\n      domParser.addNodeFilter('font', nodes => {\n        each$e(nodes, node => {\n          const props = styles.parse(node.attr('style'));\n          const color = node.attr('color');\n          const face = node.attr('face');\n          const size = node.attr('size');\n          if (color) {\n            props.color = color;\n          }\n          if (face) {\n            props['font-family'] = face;\n          }\n          if (size) {\n            toInt(size).each(num => {\n              props['font-size'] = fontSizes[num - 1];\n            });\n          }\n          node.name = 'span';\n          node.attr('style', styles.serialize(props));\n          removeAttrs(node, [\n            'color',\n            'face',\n            'size'\n          ]);\n        });\n      });\n    };\n    const addStrikeFilter = (domParser, schema, styles) => {\n      domParser.addNodeFilter('strike', nodes => {\n        const convertToSTag = schema.type !== 'html4';\n        each$e(nodes, node => {\n          if (convertToSTag) {\n            node.name = 's';\n          } else {\n            const props = styles.parse(node.attr('style'));\n            props['text-decoration'] = 'line-through';\n            node.name = 'span';\n            node.attr('style', styles.serialize(props));\n          }\n        });\n      });\n    };\n    const addFilters = (domParser, settings, schema) => {\n      var _a;\n      const styles = Styles();\n      if (settings.convert_fonts_to_spans) {\n        addFontToSpansFilter(domParser, styles, Tools.explode((_a = settings.font_size_legacy_values) !== null && _a !== void 0 ? _a : ''));\n      }\n      addStrikeFilter(domParser, schema, styles);\n    };\n    const register$5 = (domParser, settings, schema) => {\n      if (settings.inline_styles) {\n        addFilters(domParser, settings, schema);\n      }\n    };\n\n    const blobUriToBlob = url => fetch(url).then(res => res.ok ? res.blob() : Promise.reject()).catch(() => Promise.reject({\n      message: `Cannot convert ${ url } to Blob. Resource might not exist or is inaccessible.`,\n      uriType: 'blob'\n    }));\n    const extractBase64Data = data => {\n      const matches = /([a-z0-9+\\/=\\s]+)/i.exec(data);\n      return matches ? matches[1] : '';\n    };\n    const parseDataUri = uri => {\n      const [type, ...rest] = uri.split(',');\n      const data = rest.join(',');\n      const matches = /data:([^/]+\\/[^;]+)(;.+)?/.exec(type);\n      if (matches) {\n        const base64Encoded = matches[2] === ';base64';\n        const extractedData = base64Encoded ? extractBase64Data(data) : decodeURIComponent(data);\n        return Optional.some({\n          type: matches[1],\n          data: extractedData,\n          base64Encoded\n        });\n      } else {\n        return Optional.none();\n      }\n    };\n    const buildBlob = (type, data, base64Encoded = true) => {\n      let str = data;\n      if (base64Encoded) {\n        try {\n          str = atob(data);\n        } catch (e) {\n          return Optional.none();\n        }\n      }\n      const arr = new Uint8Array(str.length);\n      for (let i = 0; i < arr.length; i++) {\n        arr[i] = str.charCodeAt(i);\n      }\n      return Optional.some(new Blob([arr], { type }));\n    };\n    const dataUriToBlob = uri => {\n      return new Promise((resolve, reject) => {\n        parseDataUri(uri).bind(({type, data, base64Encoded}) => buildBlob(type, data, base64Encoded)).fold(() => reject('Invalid data URI'), resolve);\n      });\n    };\n    const uriToBlob = url => {\n      if (startsWith(url, 'blob:')) {\n        return blobUriToBlob(url);\n      } else if (startsWith(url, 'data:')) {\n        return dataUriToBlob(url);\n      } else {\n        return Promise.reject('Unknown URI format');\n      }\n    };\n    const blobToDataUri = blob => {\n      return new Promise((resolve, reject) => {\n        const reader = new FileReader();\n        reader.onloadend = () => {\n          resolve(reader.result);\n        };\n        reader.onerror = () => {\n          var _a;\n          reject((_a = reader.error) === null || _a === void 0 ? void 0 : _a.message);\n        };\n        reader.readAsDataURL(blob);\n      });\n    };\n\n    let count$1 = 0;\n    const uniqueId$1 = prefix => {\n      return (prefix || 'blobid') + count$1++;\n    };\n    const processDataUri = (dataUri, base64Only, generateBlobInfo) => {\n      return parseDataUri(dataUri).bind(({data, type, base64Encoded}) => {\n        if (base64Only && !base64Encoded) {\n          return Optional.none();\n        } else {\n          const base64 = base64Encoded ? data : btoa(data);\n          return generateBlobInfo(base64, type);\n        }\n      });\n    };\n    const createBlobInfo$1 = (blobCache, blob, base64) => {\n      const blobInfo = blobCache.create(uniqueId$1(), blob, base64);\n      blobCache.add(blobInfo);\n      return blobInfo;\n    };\n    const dataUriToBlobInfo = (blobCache, dataUri, base64Only = false) => {\n      return processDataUri(dataUri, base64Only, (base64, type) => Optional.from(blobCache.getByData(base64, type)).orThunk(() => buildBlob(type, base64).map(blob => createBlobInfo$1(blobCache, blob, base64))));\n    };\n    const imageToBlobInfo = (blobCache, imageSrc) => {\n      const invalidDataUri = () => Promise.reject('Invalid data URI');\n      if (startsWith(imageSrc, 'blob:')) {\n        const blobInfo = blobCache.getByUri(imageSrc);\n        if (isNonNullable(blobInfo)) {\n          return Promise.resolve(blobInfo);\n        } else {\n          return uriToBlob(imageSrc).then(blob => {\n            return blobToDataUri(blob).then(dataUri => {\n              return processDataUri(dataUri, false, base64 => {\n                return Optional.some(createBlobInfo$1(blobCache, blob, base64));\n              }).getOrThunk(invalidDataUri);\n            });\n          });\n        }\n      } else if (startsWith(imageSrc, 'data:')) {\n        return dataUriToBlobInfo(blobCache, imageSrc).fold(invalidDataUri, blobInfo => Promise.resolve(blobInfo));\n      } else {\n        return Promise.reject('Unknown image data format');\n      }\n    };\n\n    const hostCaptureRegex = /^(?:(?:(?:[A-Za-z][A-Za-z\\d.+-]{0,14}:\\/\\/(?:[-.~*+=!&;:'%@?^${}(),\\w]+@)?|www\\.|[-;:&=+$,.\\w]+@)([A-Za-z\\d-]+(?:\\.[A-Za-z\\d-]+)*))(?::\\d+)?(?:\\/(?:[-.~*+=!;:'%@$(),\\/\\w]*[-~*+=%@$()\\/\\w])?)?(?:\\?(?:[-.~*+=!&;:'%@?^${}(),\\/\\w]+)?)?(?:#(?:[-.~*+=!&;:'%@?^${}(),\\/\\w]+)?)?)$/;\n    const extractHost = url => Optional.from(url.match(hostCaptureRegex)).bind(ms => get$b(ms, 1)).map(h => startsWith(h, 'www.') ? h.substring(4) : h);\n\n    const sandboxIframe = (iframeNode, exclusions) => {\n      if (Optional.from(iframeNode.attr('src')).bind(extractHost).forall(host => !contains$2(exclusions, host))) {\n        iframeNode.attr('sandbox', '');\n      }\n    };\n    const isMimeType = (mime, type) => startsWith(mime, `${ type }/`);\n    const getEmbedType = type => {\n      if (isUndefined(type)) {\n        return 'iframe';\n      } else if (isMimeType(type, 'image')) {\n        return 'img';\n      } else if (isMimeType(type, 'video')) {\n        return 'video';\n      } else if (isMimeType(type, 'audio')) {\n        return 'audio';\n      } else {\n        return 'iframe';\n      }\n    };\n    const createSafeEmbed = ({type, src, width, height} = {}, sandboxIframes, sandboxIframesExclusions) => {\n      const name = getEmbedType(type);\n      const embed = new AstNode(name, 1);\n      embed.attr(name === 'audio' ? { src } : {\n        src,\n        width,\n        height\n      });\n      if (name === 'audio' || name === 'video') {\n        embed.attr('controls', '');\n      }\n      if (name === 'iframe' && sandboxIframes) {\n        sandboxIframe(embed, sandboxIframesExclusions);\n      }\n      return embed;\n    };\n\n    const isBogusImage = img => isNonNullable(img.attr('data-mce-bogus'));\n    const isInternalImageSource = img => img.attr('src') === Env.transparentSrc || isNonNullable(img.attr('data-mce-placeholder'));\n    const registerBase64ImageFilter = (parser, settings) => {\n      const {blob_cache: blobCache} = settings;\n      if (blobCache) {\n        const processImage = img => {\n          const inputSrc = img.attr('src');\n          if (isInternalImageSource(img) || isBogusImage(img) || isNullable(inputSrc)) {\n            return;\n          }\n          dataUriToBlobInfo(blobCache, inputSrc, true).each(blobInfo => {\n            img.attr('src', blobInfo.blobUri());\n          });\n        };\n        parser.addAttributeFilter('src', nodes => each$e(nodes, processImage));\n      }\n    };\n    const register$4 = (parser, settings) => {\n      var _a, _b;\n      const schema = parser.schema;\n      parser.addAttributeFilter('href', nodes => {\n        let i = nodes.length;\n        const appendRel = rel => {\n          const parts = rel.split(' ').filter(p => p.length > 0);\n          return parts.concat(['noopener']).sort().join(' ');\n        };\n        const addNoOpener = rel => {\n          const newRel = rel ? Tools.trim(rel) : '';\n          if (!/\\b(noopener)\\b/g.test(newRel)) {\n            return appendRel(newRel);\n          } else {\n            return newRel;\n          }\n        };\n        if (!settings.allow_unsafe_link_target) {\n          while (i--) {\n            const node = nodes[i];\n            if (node.name === 'a' && node.attr('target') === '_blank') {\n              node.attr('rel', addNoOpener(node.attr('rel')));\n            }\n          }\n        }\n      });\n      if (!settings.allow_html_in_named_anchor) {\n        parser.addAttributeFilter('id,name', nodes => {\n          let i = nodes.length, sibling, prevSibling, parent, node;\n          while (i--) {\n            node = nodes[i];\n            if (node.name === 'a' && node.firstChild && !node.attr('href')) {\n              parent = node.parent;\n              sibling = node.lastChild;\n              while (sibling && parent) {\n                prevSibling = sibling.prev;\n                parent.insert(sibling, node);\n                sibling = prevSibling;\n              }\n            }\n          }\n        });\n      }\n      if (settings.fix_list_elements) {\n        parser.addNodeFilter('ul,ol', nodes => {\n          let i = nodes.length, node, parentNode;\n          while (i--) {\n            node = nodes[i];\n            parentNode = node.parent;\n            if (parentNode && (parentNode.name === 'ul' || parentNode.name === 'ol')) {\n              if (node.prev && node.prev.name === 'li') {\n                node.prev.append(node);\n              } else {\n                const li = new AstNode('li', 1);\n                li.attr('style', 'list-style-type: none');\n                node.wrap(li);\n              }\n            }\n          }\n        });\n      }\n      const validClasses = schema.getValidClasses();\n      if (settings.validate && validClasses) {\n        parser.addAttributeFilter('class', nodes => {\n          var _a;\n          let i = nodes.length;\n          while (i--) {\n            const node = nodes[i];\n            const clazz = (_a = node.attr('class')) !== null && _a !== void 0 ? _a : '';\n            const classList = Tools.explode(clazz, ' ');\n            let classValue = '';\n            for (let ci = 0; ci < classList.length; ci++) {\n              const className = classList[ci];\n              let valid = false;\n              let validClassesMap = validClasses['*'];\n              if (validClassesMap && validClassesMap[className]) {\n                valid = true;\n              }\n              validClassesMap = validClasses[node.name];\n              if (!valid && validClassesMap && validClassesMap[className]) {\n                valid = true;\n              }\n              if (valid) {\n                if (classValue) {\n                  classValue += ' ';\n                }\n                classValue += className;\n              }\n            }\n            if (!classValue.length) {\n              classValue = null;\n            }\n            node.attr('class', classValue);\n          }\n        });\n      }\n      registerBase64ImageFilter(parser, settings);\n      const shouldSandboxIframes = (_a = settings.sandbox_iframes) !== null && _a !== void 0 ? _a : false;\n      const sandboxIframesExclusions = unique$1((_b = settings.sandbox_iframes_exclusions) !== null && _b !== void 0 ? _b : []);\n      if (settings.convert_unsafe_embeds) {\n        parser.addNodeFilter('object,embed', nodes => each$e(nodes, node => {\n          node.replace(createSafeEmbed({\n            type: node.attr('type'),\n            src: node.name === 'object' ? node.attr('data') : node.attr('src'),\n            width: node.attr('width'),\n            height: node.attr('height')\n          }, shouldSandboxIframes, sandboxIframesExclusions));\n        }));\n      }\n      if (shouldSandboxIframes) {\n        parser.addNodeFilter('iframe', nodes => each$e(nodes, node => sandboxIframe(node, sandboxIframesExclusions)));\n      }\n    };\n\n    /*! @license DOMPurify 3.1.7 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/3.1.7/LICENSE */\n\n    const {\n      entries,\n      setPrototypeOf,\n      isFrozen,\n      getPrototypeOf,\n      getOwnPropertyDescriptor\n    } = Object;\n    let {\n      freeze,\n      seal,\n      create: create$7\n    } = Object; // eslint-disable-line import/no-mutable-exports\n    let {\n      apply,\n      construct\n    } = typeof Reflect !== 'undefined' && Reflect;\n    if (!freeze) {\n      freeze = function freeze(x) {\n        return x;\n      };\n    }\n    if (!seal) {\n      seal = function seal(x) {\n        return x;\n      };\n    }\n    if (!apply) {\n      apply = function apply(fun, thisValue, args) {\n        return fun.apply(thisValue, args);\n      };\n    }\n    if (!construct) {\n      construct = function construct(Func, args) {\n        return new Func(...args);\n      };\n    }\n    const arrayForEach = unapply(Array.prototype.forEach);\n    const arrayPop = unapply(Array.prototype.pop);\n    const arrayPush = unapply(Array.prototype.push);\n    const stringToLowerCase = unapply(String.prototype.toLowerCase);\n    const stringToString = unapply(String.prototype.toString);\n    const stringMatch = unapply(String.prototype.match);\n    const stringReplace = unapply(String.prototype.replace);\n    const stringIndexOf = unapply(String.prototype.indexOf);\n    const stringTrim = unapply(String.prototype.trim);\n    const objectHasOwnProperty = unapply(Object.prototype.hasOwnProperty);\n    const regExpTest = unapply(RegExp.prototype.test);\n    const typeErrorCreate = unconstruct(TypeError);\n\n    /**\n     * Creates a new function that calls the given function with a specified thisArg and arguments.\n     *\n     * @param {Function} func - The function to be wrapped and called.\n     * @returns {Function} A new function that calls the given function with a specified thisArg and arguments.\n     */\n    function unapply(func) {\n      return function (thisArg) {\n        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n          args[_key - 1] = arguments[_key];\n        }\n        return apply(func, thisArg, args);\n      };\n    }\n\n    /**\n     * Creates a new function that constructs an instance of the given constructor function with the provided arguments.\n     *\n     * @param {Function} func - The constructor function to be wrapped and called.\n     * @returns {Function} A new function that constructs an instance of the given constructor function with the provided arguments.\n     */\n    function unconstruct(func) {\n      return function () {\n        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n          args[_key2] = arguments[_key2];\n        }\n        return construct(func, args);\n      };\n    }\n\n    /**\n     * Add properties to a lookup table\n     *\n     * @param {Object} set - The set to which elements will be added.\n     * @param {Array} array - The array containing elements to be added to the set.\n     * @param {Function} transformCaseFunc - An optional function to transform the case of each element before adding to the set.\n     * @returns {Object} The modified set with added elements.\n     */\n    function addToSet(set, array) {\n      let transformCaseFunc = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : stringToLowerCase;\n      if (setPrototypeOf) {\n        // Make 'in' and truthy checks like Boolean(set.constructor)\n        // independent of any properties defined on Object.prototype.\n        // Prevent prototype setters from intercepting set as a this value.\n        setPrototypeOf(set, null);\n      }\n      let l = array.length;\n      while (l--) {\n        let element = array[l];\n        if (typeof element === 'string') {\n          const lcElement = transformCaseFunc(element);\n          if (lcElement !== element) {\n            // Config presets (e.g. tags.js, attrs.js) are immutable.\n            if (!isFrozen(array)) {\n              array[l] = lcElement;\n            }\n            element = lcElement;\n          }\n        }\n        set[element] = true;\n      }\n      return set;\n    }\n\n    /**\n     * Clean up an array to harden against CSPP\n     *\n     * @param {Array} array - The array to be cleaned.\n     * @returns {Array} The cleaned version of the array\n     */\n    function cleanArray(array) {\n      for (let index = 0; index < array.length; index++) {\n        const isPropertyExist = objectHasOwnProperty(array, index);\n        if (!isPropertyExist) {\n          array[index] = null;\n        }\n      }\n      return array;\n    }\n\n    /**\n     * Shallow clone an object\n     *\n     * @param {Object} object - The object to be cloned.\n     * @returns {Object} A new object that copies the original.\n     */\n    function clone(object) {\n      const newObject = create$7(null);\n      for (const [property, value] of entries(object)) {\n        const isPropertyExist = objectHasOwnProperty(object, property);\n        if (isPropertyExist) {\n          if (Array.isArray(value)) {\n            newObject[property] = cleanArray(value);\n          } else if (value && typeof value === 'object' && value.constructor === Object) {\n            newObject[property] = clone(value);\n          } else {\n            newObject[property] = value;\n          }\n        }\n      }\n      return newObject;\n    }\n\n    /**\n     * This method automatically checks if the prop is function or getter and behaves accordingly.\n     *\n     * @param {Object} object - The object to look up the getter function in its prototype chain.\n     * @param {String} prop - The property name for which to find the getter function.\n     * @returns {Function} The getter function found in the prototype chain or a fallback function.\n     */\n    function lookupGetter(object, prop) {\n      while (object !== null) {\n        const desc = getOwnPropertyDescriptor(object, prop);\n        if (desc) {\n          if (desc.get) {\n            return unapply(desc.get);\n          }\n          if (typeof desc.value === 'function') {\n            return unapply(desc.value);\n          }\n        }\n        object = getPrototypeOf(object);\n      }\n      function fallbackValue() {\n        return null;\n      }\n      return fallbackValue;\n    }\n\n    const html$1 = freeze(['a', 'abbr', 'acronym', 'address', 'area', 'article', 'aside', 'audio', 'b', 'bdi', 'bdo', 'big', 'blink', 'blockquote', 'body', 'br', 'button', 'canvas', 'caption', 'center', 'cite', 'code', 'col', 'colgroup', 'content', 'data', 'datalist', 'dd', 'decorator', 'del', 'details', 'dfn', 'dialog', 'dir', 'div', 'dl', 'dt', 'element', 'em', 'fieldset', 'figcaption', 'figure', 'font', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'i', 'img', 'input', 'ins', 'kbd', 'label', 'legend', 'li', 'main', 'map', 'mark', 'marquee', 'menu', 'menuitem', 'meter', 'nav', 'nobr', 'ol', 'optgroup', 'option', 'output', 'p', 'picture', 'pre', 'progress', 'q', 'rp', 'rt', 'ruby', 's', 'samp', 'section', 'select', 'shadow', 'small', 'source', 'spacer', 'span', 'strike', 'strong', 'style', 'sub', 'summary', 'sup', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'time', 'tr', 'track', 'tt', 'u', 'ul', 'var', 'video', 'wbr']);\n\n    // SVG\n    const svg$1 = freeze(['svg', 'a', 'altglyph', 'altglyphdef', 'altglyphitem', 'animatecolor', 'animatemotion', 'animatetransform', 'circle', 'clippath', 'defs', 'desc', 'ellipse', 'filter', 'font', 'g', 'glyph', 'glyphref', 'hkern', 'image', 'line', 'lineargradient', 'marker', 'mask', 'metadata', 'mpath', 'path', 'pattern', 'polygon', 'polyline', 'radialgradient', 'rect', 'stop', 'style', 'switch', 'symbol', 'text', 'textpath', 'title', 'tref', 'tspan', 'view', 'vkern']);\n    const svgFilters = freeze(['feBlend', 'feColorMatrix', 'feComponentTransfer', 'feComposite', 'feConvolveMatrix', 'feDiffuseLighting', 'feDisplacementMap', 'feDistantLight', 'feDropShadow', 'feFlood', 'feFuncA', 'feFuncB', 'feFuncG', 'feFuncR', 'feGaussianBlur', 'feImage', 'feMerge', 'feMergeNode', 'feMorphology', 'feOffset', 'fePointLight', 'feSpecularLighting', 'feSpotLight', 'feTile', 'feTurbulence']);\n\n    // List of SVG elements that are disallowed by default.\n    // We still need to know them so that we can do namespace\n    // checks properly in case one wants to add them to\n    // allow-list.\n    const svgDisallowed = freeze(['animate', 'color-profile', 'cursor', 'discard', 'font-face', 'font-face-format', 'font-face-name', 'font-face-src', 'font-face-uri', 'foreignobject', 'hatch', 'hatchpath', 'mesh', 'meshgradient', 'meshpatch', 'meshrow', 'missing-glyph', 'script', 'set', 'solidcolor', 'unknown', 'use']);\n    const mathMl$1 = freeze(['math', 'menclose', 'merror', 'mfenced', 'mfrac', 'mglyph', 'mi', 'mlabeledtr', 'mmultiscripts', 'mn', 'mo', 'mover', 'mpadded', 'mphantom', 'mroot', 'mrow', 'ms', 'mspace', 'msqrt', 'mstyle', 'msub', 'msup', 'msubsup', 'mtable', 'mtd', 'mtext', 'mtr', 'munder', 'munderover', 'mprescripts']);\n\n    // Similarly to SVG, we want to know all MathML elements,\n    // even those that we disallow by default.\n    const mathMlDisallowed = freeze(['maction', 'maligngroup', 'malignmark', 'mlongdiv', 'mscarries', 'mscarry', 'msgroup', 'mstack', 'msline', 'msrow', 'semantics', 'annotation', 'annotation-xml', 'mprescripts', 'none']);\n    const text = freeze(['#text']);\n\n    const html = freeze(['accept', 'action', 'align', 'alt', 'autocapitalize', 'autocomplete', 'autopictureinpicture', 'autoplay', 'background', 'bgcolor', 'border', 'capture', 'cellpadding', 'cellspacing', 'checked', 'cite', 'class', 'clear', 'color', 'cols', 'colspan', 'controls', 'controlslist', 'coords', 'crossorigin', 'datetime', 'decoding', 'default', 'dir', 'disabled', 'disablepictureinpicture', 'disableremoteplayback', 'download', 'draggable', 'enctype', 'enterkeyhint', 'face', 'for', 'headers', 'height', 'hidden', 'high', 'href', 'hreflang', 'id', 'inputmode', 'integrity', 'ismap', 'kind', 'label', 'lang', 'list', 'loading', 'loop', 'low', 'max', 'maxlength', 'media', 'method', 'min', 'minlength', 'multiple', 'muted', 'name', 'nonce', 'noshade', 'novalidate', 'nowrap', 'open', 'optimum', 'pattern', 'placeholder', 'playsinline', 'popover', 'popovertarget', 'popovertargetaction', 'poster', 'preload', 'pubdate', 'radiogroup', 'readonly', 'rel', 'required', 'rev', 'reversed', 'role', 'rows', 'rowspan', 'spellcheck', 'scope', 'selected', 'shape', 'size', 'sizes', 'span', 'srclang', 'start', 'src', 'srcset', 'step', 'style', 'summary', 'tabindex', 'title', 'translate', 'type', 'usemap', 'valign', 'value', 'width', 'wrap', 'xmlns', 'slot']);\n    const svg = freeze(['accent-height', 'accumulate', 'additive', 'alignment-baseline', 'amplitude', 'ascent', 'attributename', 'attributetype', 'azimuth', 'basefrequency', 'baseline-shift', 'begin', 'bias', 'by', 'class', 'clip', 'clippathunits', 'clip-path', 'clip-rule', 'color', 'color-interpolation', 'color-interpolation-filters', 'color-profile', 'color-rendering', 'cx', 'cy', 'd', 'dx', 'dy', 'diffuseconstant', 'direction', 'display', 'divisor', 'dur', 'edgemode', 'elevation', 'end', 'exponent', 'fill', 'fill-opacity', 'fill-rule', 'filter', 'filterunits', 'flood-color', 'flood-opacity', 'font-family', 'font-size', 'font-size-adjust', 'font-stretch', 'font-style', 'font-variant', 'font-weight', 'fx', 'fy', 'g1', 'g2', 'glyph-name', 'glyphref', 'gradientunits', 'gradienttransform', 'height', 'href', 'id', 'image-rendering', 'in', 'in2', 'intercept', 'k', 'k1', 'k2', 'k3', 'k4', 'kerning', 'keypoints', 'keysplines', 'keytimes', 'lang', 'lengthadjust', 'letter-spacing', 'kernelmatrix', 'kernelunitlength', 'lighting-color', 'local', 'marker-end', 'marker-mid', 'marker-start', 'markerheight', 'markerunits', 'markerwidth', 'maskcontentunits', 'maskunits', 'max', 'mask', 'media', 'method', 'mode', 'min', 'name', 'numoctaves', 'offset', 'operator', 'opacity', 'order', 'orient', 'orientation', 'origin', 'overflow', 'paint-order', 'path', 'pathlength', 'patterncontentunits', 'patterntransform', 'patternunits', 'points', 'preservealpha', 'preserveaspectratio', 'primitiveunits', 'r', 'rx', 'ry', 'radius', 'refx', 'refy', 'repeatcount', 'repeatdur', 'restart', 'result', 'rotate', 'scale', 'seed', 'shape-rendering', 'slope', 'specularconstant', 'specularexponent', 'spreadmethod', 'startoffset', 'stddeviation', 'stitchtiles', 'stop-color', 'stop-opacity', 'stroke-dasharray', 'stroke-dashoffset', 'stroke-linecap', 'stroke-linejoin', 'stroke-miterlimit', 'stroke-opacity', 'stroke', 'stroke-width', 'style', 'surfacescale', 'systemlanguage', 'tabindex', 'tablevalues', 'targetx', 'targety', 'transform', 'transform-origin', 'text-anchor', 'text-decoration', 'text-rendering', 'textlength', 'type', 'u1', 'u2', 'unicode', 'values', 'viewbox', 'visibility', 'version', 'vert-adv-y', 'vert-origin-x', 'vert-origin-y', 'width', 'word-spacing', 'wrap', 'writing-mode', 'xchannelselector', 'ychannelselector', 'x', 'x1', 'x2', 'xmlns', 'y', 'y1', 'y2', 'z', 'zoomandpan']);\n    const mathMl = freeze(['accent', 'accentunder', 'align', 'bevelled', 'close', 'columnsalign', 'columnlines', 'columnspan', 'denomalign', 'depth', 'dir', 'display', 'displaystyle', 'encoding', 'fence', 'frame', 'height', 'href', 'id', 'largeop', 'length', 'linethickness', 'lspace', 'lquote', 'mathbackground', 'mathcolor', 'mathsize', 'mathvariant', 'maxsize', 'minsize', 'movablelimits', 'notation', 'numalign', 'open', 'rowalign', 'rowlines', 'rowspacing', 'rowspan', 'rspace', 'rquote', 'scriptlevel', 'scriptminsize', 'scriptsizemultiplier', 'selection', 'separator', 'separators', 'stretchy', 'subscriptshift', 'supscriptshift', 'symmetric', 'voffset', 'width', 'xmlns']);\n    const xml = freeze(['xlink:href', 'xml:id', 'xlink:title', 'xml:space', 'xmlns:xlink']);\n\n    // eslint-disable-next-line unicorn/better-regex\n    const MUSTACHE_EXPR = seal(/\\{\\{[\\w\\W]*|[\\w\\W]*\\}\\}/gm); // Specify template detection regex for SAFE_FOR_TEMPLATES mode\n    const ERB_EXPR = seal(/<%[\\w\\W]*|[\\w\\W]*%>/gm);\n    const TMPLIT_EXPR = seal(/\\${[\\w\\W]*}/gm);\n    const DATA_ATTR = seal(/^data-[\\-\\w.\\u00B7-\\uFFFF]/); // eslint-disable-line no-useless-escape\n    const ARIA_ATTR = seal(/^aria-[\\-\\w]+$/); // eslint-disable-line no-useless-escape\n    const IS_ALLOWED_URI = seal(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp):|[^a-z]|[a-z+.\\-]+(?:[^a-z+.\\-:]|$))/i // eslint-disable-line no-useless-escape\n    );\n    const IS_SCRIPT_OR_DATA = seal(/^(?:\\w+script|data):/i);\n    const ATTR_WHITESPACE = seal(/[\\u0000-\\u0020\\u00A0\\u1680\\u180E\\u2000-\\u2029\\u205F\\u3000]/g // eslint-disable-line no-control-regex\n    );\n    const DOCTYPE_NAME = seal(/^html$/i);\n    const CUSTOM_ELEMENT = seal(/^[a-z][.\\w]*(-[.\\w]+)+$/i);\n\n    var EXPRESSIONS = /*#__PURE__*/Object.freeze({\n      __proto__: null,\n      MUSTACHE_EXPR: MUSTACHE_EXPR,\n      ERB_EXPR: ERB_EXPR,\n      TMPLIT_EXPR: TMPLIT_EXPR,\n      DATA_ATTR: DATA_ATTR,\n      ARIA_ATTR: ARIA_ATTR,\n      IS_ALLOWED_URI: IS_ALLOWED_URI,\n      IS_SCRIPT_OR_DATA: IS_SCRIPT_OR_DATA,\n      ATTR_WHITESPACE: ATTR_WHITESPACE,\n      DOCTYPE_NAME: DOCTYPE_NAME,\n      CUSTOM_ELEMENT: CUSTOM_ELEMENT\n    });\n\n    // https://developer.mozilla.org/en-US/docs/Web/API/Node/nodeType\n    const NODE_TYPE = {\n      element: 1,\n      attribute: 2,\n      text: 3,\n      cdataSection: 4,\n      entityReference: 5,\n      // Deprecated\n      entityNode: 6,\n      // Deprecated\n      progressingInstruction: 7,\n      comment: 8,\n      document: 9,\n      documentType: 10,\n      documentFragment: 11,\n      notation: 12 // Deprecated\n    };\n    const getGlobal = function getGlobal() {\n      return typeof window === 'undefined' ? null : window;\n    };\n\n    /**\n     * Creates a no-op policy for internal use only.\n     * Don't export this function outside this module!\n     * @param {TrustedTypePolicyFactory} trustedTypes The policy factory.\n     * @param {HTMLScriptElement} purifyHostElement The Script element used to load DOMPurify (to determine policy name suffix).\n     * @return {TrustedTypePolicy} The policy created (or null, if Trusted Types\n     * are not supported or creating the policy failed).\n     */\n    const _createTrustedTypesPolicy = function _createTrustedTypesPolicy(trustedTypes, purifyHostElement) {\n      if (typeof trustedTypes !== 'object' || typeof trustedTypes.createPolicy !== 'function') {\n        return null;\n      }\n\n      // Allow the callers to control the unique policy name\n      // by adding a data-tt-policy-suffix to the script element with the DOMPurify.\n      // Policy creation with duplicate names throws in Trusted Types.\n      let suffix = null;\n      const ATTR_NAME = 'data-tt-policy-suffix';\n      if (purifyHostElement && purifyHostElement.hasAttribute(ATTR_NAME)) {\n        suffix = purifyHostElement.getAttribute(ATTR_NAME);\n      }\n      const policyName = 'dompurify' + (suffix ? '#' + suffix : '');\n      try {\n        return trustedTypes.createPolicy(policyName, {\n          createHTML(html) {\n            return html;\n          },\n          createScriptURL(scriptUrl) {\n            return scriptUrl;\n          }\n        });\n      } catch (_) {\n        // Policy creation failed (most likely another DOMPurify script has\n        // already run). Skip creating the policy, as this will only cause errors\n        // if TT are enforced.\n        console.warn('TrustedTypes policy ' + policyName + ' could not be created.');\n        return null;\n      }\n    };\n    function createDOMPurify() {\n      let window = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getGlobal();\n      const DOMPurify = root => createDOMPurify(root);\n\n      /**\n       * Version label, exposed for easier checks\n       * if DOMPurify is up to date or not\n       */\n      DOMPurify.version = '3.1.7';\n\n      /**\n       * Array of elements that DOMPurify removed during sanitation.\n       * Empty if nothing was removed.\n       */\n      DOMPurify.removed = [];\n      if (!window || !window.document || window.document.nodeType !== NODE_TYPE.document) {\n        // Not running in a browser, provide a factory function\n        // so that you can pass your own Window\n        DOMPurify.isSupported = false;\n        return DOMPurify;\n      }\n      let {\n        document\n      } = window;\n      const originalDocument = document;\n      const currentScript = originalDocument.currentScript;\n      const {\n        DocumentFragment,\n        HTMLTemplateElement,\n        Node,\n        Element,\n        NodeFilter,\n        NamedNodeMap = window.NamedNodeMap || window.MozNamedAttrMap,\n        HTMLFormElement,\n        DOMParser,\n        trustedTypes\n      } = window;\n      const ElementPrototype = Element.prototype;\n      const cloneNode = lookupGetter(ElementPrototype, 'cloneNode');\n      const remove = lookupGetter(ElementPrototype, 'remove');\n      const getNextSibling = lookupGetter(ElementPrototype, 'nextSibling');\n      const getChildNodes = lookupGetter(ElementPrototype, 'childNodes');\n      const getParentNode = lookupGetter(ElementPrototype, 'parentNode');\n\n      // As per issue #47, the web-components registry is inherited by a\n      // new document created via createHTMLDocument. As per the spec\n      // (http://w3c.github.io/webcomponents/spec/custom/#creating-and-passing-registries)\n      // a new empty registry is used when creating a template contents owner\n      // document, so we use that as our parent document to ensure nothing\n      // is inherited.\n      if (typeof HTMLTemplateElement === 'function') {\n        const template = document.createElement('template');\n        if (template.content && template.content.ownerDocument) {\n          document = template.content.ownerDocument;\n        }\n      }\n      let trustedTypesPolicy;\n      let emptyHTML = '';\n      const {\n        implementation,\n        createNodeIterator,\n        createDocumentFragment,\n        getElementsByTagName\n      } = document;\n      const {\n        importNode\n      } = originalDocument;\n      let hooks = {};\n\n      /**\n       * Expose whether this browser supports running the full DOMPurify.\n       */\n      DOMPurify.isSupported = typeof entries === 'function' && typeof getParentNode === 'function' && implementation && implementation.createHTMLDocument !== undefined;\n      const {\n        MUSTACHE_EXPR,\n        ERB_EXPR,\n        TMPLIT_EXPR,\n        DATA_ATTR,\n        ARIA_ATTR,\n        IS_SCRIPT_OR_DATA,\n        ATTR_WHITESPACE,\n        CUSTOM_ELEMENT\n      } = EXPRESSIONS;\n      let {\n        IS_ALLOWED_URI: IS_ALLOWED_URI$1\n      } = EXPRESSIONS;\n\n      /**\n       * We consider the elements and attributes below to be safe. Ideally\n       * don't add any new ones but feel free to remove unwanted ones.\n       */\n\n      /* allowed element names */\n      let ALLOWED_TAGS = null;\n      const DEFAULT_ALLOWED_TAGS = addToSet({}, [...html$1, ...svg$1, ...svgFilters, ...mathMl$1, ...text]);\n\n      /* Allowed attribute names */\n      let ALLOWED_ATTR = null;\n      const DEFAULT_ALLOWED_ATTR = addToSet({}, [...html, ...svg, ...mathMl, ...xml]);\n\n      /*\n       * Configure how DOMPUrify should handle custom elements and their attributes as well as customized built-in elements.\n       * @property {RegExp|Function|null} tagNameCheck one of [null, regexPattern, predicate]. Default: `null` (disallow any custom elements)\n       * @property {RegExp|Function|null} attributeNameCheck one of [null, regexPattern, predicate]. Default: `null` (disallow any attributes not on the allow list)\n       * @property {boolean} allowCustomizedBuiltInElements allow custom elements derived from built-ins if they pass CUSTOM_ELEMENT_HANDLING.tagNameCheck. Default: `false`.\n       */\n      let CUSTOM_ELEMENT_HANDLING = Object.seal(create$7(null, {\n        tagNameCheck: {\n          writable: true,\n          configurable: false,\n          enumerable: true,\n          value: null\n        },\n        attributeNameCheck: {\n          writable: true,\n          configurable: false,\n          enumerable: true,\n          value: null\n        },\n        allowCustomizedBuiltInElements: {\n          writable: true,\n          configurable: false,\n          enumerable: true,\n          value: false\n        }\n      }));\n\n      /* Explicitly forbidden tags (overrides ALLOWED_TAGS/ADD_TAGS) */\n      let FORBID_TAGS = null;\n\n      /* Explicitly forbidden attributes (overrides ALLOWED_ATTR/ADD_ATTR) */\n      let FORBID_ATTR = null;\n\n      /* Decide if ARIA attributes are okay */\n      let ALLOW_ARIA_ATTR = true;\n\n      /* Decide if custom data attributes are okay */\n      let ALLOW_DATA_ATTR = true;\n\n      /* Decide if unknown protocols are okay */\n      let ALLOW_UNKNOWN_PROTOCOLS = false;\n\n      /* Decide if self-closing tags in attributes are allowed.\n       * Usually removed due to a mXSS issue in jQuery 3.0 */\n      let ALLOW_SELF_CLOSE_IN_ATTR = true;\n\n      /* Output should be safe for common template engines.\n       * This means, DOMPurify removes data attributes, mustaches and ERB\n       */\n      let SAFE_FOR_TEMPLATES = false;\n\n      /* Output should be safe even for XML used within HTML and alike.\n       * This means, DOMPurify removes comments when containing risky content.\n       */\n      let SAFE_FOR_XML = true;\n\n      /* Decide if document with <html>... should be returned */\n      let WHOLE_DOCUMENT = false;\n\n      /* Track whether config is already set on this instance of DOMPurify. */\n      let SET_CONFIG = false;\n\n      /* Decide if all elements (e.g. style, script) must be children of\n       * document.body. By default, browsers might move them to document.head */\n      let FORCE_BODY = false;\n\n      /* Decide if a DOM `HTMLBodyElement` should be returned, instead of a html\n       * string (or a TrustedHTML object if Trusted Types are supported).\n       * If `WHOLE_DOCUMENT` is enabled a `HTMLHtmlElement` will be returned instead\n       */\n      let RETURN_DOM = false;\n\n      /* Decide if a DOM `DocumentFragment` should be returned, instead of a html\n       * string  (or a TrustedHTML object if Trusted Types are supported) */\n      let RETURN_DOM_FRAGMENT = false;\n\n      /* Try to return a Trusted Type object instead of a string, return a string in\n       * case Trusted Types are not supported  */\n      let RETURN_TRUSTED_TYPE = false;\n\n      /* Output should be free from DOM clobbering attacks?\n       * This sanitizes markups named with colliding, clobberable built-in DOM APIs.\n       */\n      let SANITIZE_DOM = true;\n\n      /* Achieve full DOM Clobbering protection by isolating the namespace of named\n       * properties and JS variables, mitigating attacks that abuse the HTML/DOM spec rules.\n       *\n       * HTML/DOM spec rules that enable DOM Clobbering:\n       *   - Named Access on Window (§7.3.3)\n       *   - DOM Tree Accessors (§3.1.5)\n       *   - Form Element Parent-Child Relations (§4.10.3)\n       *   - Iframe srcdoc / Nested WindowProxies (§4.8.5)\n       *   - HTMLCollection (§4.2.10.2)\n       *\n       * Namespace isolation is implemented by prefixing `id` and `name` attributes\n       * with a constant string, i.e., `user-content-`\n       */\n      let SANITIZE_NAMED_PROPS = false;\n      const SANITIZE_NAMED_PROPS_PREFIX = 'user-content-';\n\n      /* Keep element content when removing element? */\n      let KEEP_CONTENT = true;\n\n      /* If a `Node` is passed to sanitize(), then performs sanitization in-place instead\n       * of importing it into a new Document and returning a sanitized copy */\n      let IN_PLACE = false;\n\n      /* Allow usage of profiles like html, svg and mathMl */\n      let USE_PROFILES = {};\n\n      /* Tags to ignore content of when KEEP_CONTENT is true */\n      let FORBID_CONTENTS = null;\n      const DEFAULT_FORBID_CONTENTS = addToSet({}, ['annotation-xml', 'audio', 'colgroup', 'desc', 'foreignobject', 'head', 'iframe', 'math', 'mi', 'mn', 'mo', 'ms', 'mtext', 'noembed', 'noframes', 'noscript', 'plaintext', 'script', 'style', 'svg', 'template', 'thead', 'title', 'video', 'xmp']);\n\n      /* Tags that are safe for data: URIs */\n      let DATA_URI_TAGS = null;\n      const DEFAULT_DATA_URI_TAGS = addToSet({}, ['audio', 'video', 'img', 'source', 'image', 'track']);\n\n      /* Attributes safe for values like \"javascript:\" */\n      let URI_SAFE_ATTRIBUTES = null;\n      const DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, ['alt', 'class', 'for', 'id', 'label', 'name', 'pattern', 'placeholder', 'role', 'summary', 'title', 'value', 'style', 'xmlns']);\n      const MATHML_NAMESPACE = 'http://www.w3.org/1998/Math/MathML';\n      const SVG_NAMESPACE = 'http://www.w3.org/2000/svg';\n      const HTML_NAMESPACE = 'http://www.w3.org/1999/xhtml';\n      /* Document namespace */\n      let NAMESPACE = HTML_NAMESPACE;\n      let IS_EMPTY_INPUT = false;\n\n      /* Allowed XHTML+XML namespaces */\n      let ALLOWED_NAMESPACES = null;\n      const DEFAULT_ALLOWED_NAMESPACES = addToSet({}, [MATHML_NAMESPACE, SVG_NAMESPACE, HTML_NAMESPACE], stringToString);\n\n      /* Parsing of strict XHTML documents */\n      let PARSER_MEDIA_TYPE = null;\n      const SUPPORTED_PARSER_MEDIA_TYPES = ['application/xhtml+xml', 'text/html'];\n      const DEFAULT_PARSER_MEDIA_TYPE = 'text/html';\n      let transformCaseFunc = null;\n\n      /* Keep a reference to config to pass to hooks */\n      let CONFIG = null;\n\n      /* Ideally, do not touch anything below this line */\n      /* ______________________________________________ */\n\n      const formElement = document.createElement('form');\n      const isRegexOrFunction = function isRegexOrFunction(testValue) {\n        return testValue instanceof RegExp || testValue instanceof Function;\n      };\n\n      /**\n       * _parseConfig\n       *\n       * @param  {Object} cfg optional config literal\n       */\n      // eslint-disable-next-line complexity\n      const _parseConfig = function _parseConfig() {\n        let cfg = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        if (CONFIG && CONFIG === cfg) {\n          return;\n        }\n\n        /* Shield configuration object from tampering */\n        if (!cfg || typeof cfg !== 'object') {\n          cfg = {};\n        }\n\n        /* Shield configuration object from prototype pollution */\n        cfg = clone(cfg);\n        PARSER_MEDIA_TYPE =\n        // eslint-disable-next-line unicorn/prefer-includes\n        SUPPORTED_PARSER_MEDIA_TYPES.indexOf(cfg.PARSER_MEDIA_TYPE) === -1 ? DEFAULT_PARSER_MEDIA_TYPE : cfg.PARSER_MEDIA_TYPE;\n\n        // HTML tags and attributes are not case-sensitive, converting to lowercase. Keeping XHTML as is.\n        transformCaseFunc = PARSER_MEDIA_TYPE === 'application/xhtml+xml' ? stringToString : stringToLowerCase;\n\n        /* Set configuration parameters */\n        ALLOWED_TAGS = objectHasOwnProperty(cfg, 'ALLOWED_TAGS') ? addToSet({}, cfg.ALLOWED_TAGS, transformCaseFunc) : DEFAULT_ALLOWED_TAGS;\n        ALLOWED_ATTR = objectHasOwnProperty(cfg, 'ALLOWED_ATTR') ? addToSet({}, cfg.ALLOWED_ATTR, transformCaseFunc) : DEFAULT_ALLOWED_ATTR;\n        ALLOWED_NAMESPACES = objectHasOwnProperty(cfg, 'ALLOWED_NAMESPACES') ? addToSet({}, cfg.ALLOWED_NAMESPACES, stringToString) : DEFAULT_ALLOWED_NAMESPACES;\n        URI_SAFE_ATTRIBUTES = objectHasOwnProperty(cfg, 'ADD_URI_SAFE_ATTR') ? addToSet(clone(DEFAULT_URI_SAFE_ATTRIBUTES),\n        // eslint-disable-line indent\n        cfg.ADD_URI_SAFE_ATTR,\n        // eslint-disable-line indent\n        transformCaseFunc // eslint-disable-line indent\n        ) // eslint-disable-line indent\n        : DEFAULT_URI_SAFE_ATTRIBUTES;\n        DATA_URI_TAGS = objectHasOwnProperty(cfg, 'ADD_DATA_URI_TAGS') ? addToSet(clone(DEFAULT_DATA_URI_TAGS),\n        // eslint-disable-line indent\n        cfg.ADD_DATA_URI_TAGS,\n        // eslint-disable-line indent\n        transformCaseFunc // eslint-disable-line indent\n        ) // eslint-disable-line indent\n        : DEFAULT_DATA_URI_TAGS;\n        FORBID_CONTENTS = objectHasOwnProperty(cfg, 'FORBID_CONTENTS') ? addToSet({}, cfg.FORBID_CONTENTS, transformCaseFunc) : DEFAULT_FORBID_CONTENTS;\n        FORBID_TAGS = objectHasOwnProperty(cfg, 'FORBID_TAGS') ? addToSet({}, cfg.FORBID_TAGS, transformCaseFunc) : {};\n        FORBID_ATTR = objectHasOwnProperty(cfg, 'FORBID_ATTR') ? addToSet({}, cfg.FORBID_ATTR, transformCaseFunc) : {};\n        USE_PROFILES = objectHasOwnProperty(cfg, 'USE_PROFILES') ? cfg.USE_PROFILES : false;\n        ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false; // Default true\n        ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false; // Default true\n        ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false; // Default false\n        ALLOW_SELF_CLOSE_IN_ATTR = cfg.ALLOW_SELF_CLOSE_IN_ATTR !== false; // Default true\n        SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false; // Default false\n        SAFE_FOR_XML = cfg.SAFE_FOR_XML !== false; // Default true\n        WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false; // Default false\n        RETURN_DOM = cfg.RETURN_DOM || false; // Default false\n        RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false; // Default false\n        RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false; // Default false\n        FORCE_BODY = cfg.FORCE_BODY || false; // Default false\n        SANITIZE_DOM = cfg.SANITIZE_DOM !== false; // Default true\n        SANITIZE_NAMED_PROPS = cfg.SANITIZE_NAMED_PROPS || false; // Default false\n        KEEP_CONTENT = cfg.KEEP_CONTENT !== false; // Default true\n        IN_PLACE = cfg.IN_PLACE || false; // Default false\n        IS_ALLOWED_URI$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI;\n        NAMESPACE = cfg.NAMESPACE || HTML_NAMESPACE;\n        CUSTOM_ELEMENT_HANDLING = cfg.CUSTOM_ELEMENT_HANDLING || {};\n        if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck)) {\n          CUSTOM_ELEMENT_HANDLING.tagNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck;\n        }\n        if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck)) {\n          CUSTOM_ELEMENT_HANDLING.attributeNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck;\n        }\n        if (cfg.CUSTOM_ELEMENT_HANDLING && typeof cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements === 'boolean') {\n          CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements = cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements;\n        }\n        if (SAFE_FOR_TEMPLATES) {\n          ALLOW_DATA_ATTR = false;\n        }\n        if (RETURN_DOM_FRAGMENT) {\n          RETURN_DOM = true;\n        }\n\n        /* Parse profile info */\n        if (USE_PROFILES) {\n          ALLOWED_TAGS = addToSet({}, text);\n          ALLOWED_ATTR = [];\n          if (USE_PROFILES.html === true) {\n            addToSet(ALLOWED_TAGS, html$1);\n            addToSet(ALLOWED_ATTR, html);\n          }\n          if (USE_PROFILES.svg === true) {\n            addToSet(ALLOWED_TAGS, svg$1);\n            addToSet(ALLOWED_ATTR, svg);\n            addToSet(ALLOWED_ATTR, xml);\n          }\n          if (USE_PROFILES.svgFilters === true) {\n            addToSet(ALLOWED_TAGS, svgFilters);\n            addToSet(ALLOWED_ATTR, svg);\n            addToSet(ALLOWED_ATTR, xml);\n          }\n          if (USE_PROFILES.mathMl === true) {\n            addToSet(ALLOWED_TAGS, mathMl$1);\n            addToSet(ALLOWED_ATTR, mathMl);\n            addToSet(ALLOWED_ATTR, xml);\n          }\n        }\n\n        /* Merge configuration parameters */\n        if (cfg.ADD_TAGS) {\n          if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {\n            ALLOWED_TAGS = clone(ALLOWED_TAGS);\n          }\n          addToSet(ALLOWED_TAGS, cfg.ADD_TAGS, transformCaseFunc);\n        }\n        if (cfg.ADD_ATTR) {\n          if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {\n            ALLOWED_ATTR = clone(ALLOWED_ATTR);\n          }\n          addToSet(ALLOWED_ATTR, cfg.ADD_ATTR, transformCaseFunc);\n        }\n        if (cfg.ADD_URI_SAFE_ATTR) {\n          addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR, transformCaseFunc);\n        }\n        if (cfg.FORBID_CONTENTS) {\n          if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) {\n            FORBID_CONTENTS = clone(FORBID_CONTENTS);\n          }\n          addToSet(FORBID_CONTENTS, cfg.FORBID_CONTENTS, transformCaseFunc);\n        }\n\n        /* Add #text in case KEEP_CONTENT is set to true */\n        if (KEEP_CONTENT) {\n          ALLOWED_TAGS['#text'] = true;\n        }\n\n        /* Add html, head and body to ALLOWED_TAGS in case WHOLE_DOCUMENT is true */\n        if (WHOLE_DOCUMENT) {\n          addToSet(ALLOWED_TAGS, ['html', 'head', 'body']);\n        }\n\n        /* Add tbody to ALLOWED_TAGS in case tables are permitted, see #286, #365 */\n        if (ALLOWED_TAGS.table) {\n          addToSet(ALLOWED_TAGS, ['tbody']);\n          delete FORBID_TAGS.tbody;\n        }\n        if (cfg.TRUSTED_TYPES_POLICY) {\n          if (typeof cfg.TRUSTED_TYPES_POLICY.createHTML !== 'function') {\n            throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a \"createHTML\" hook.');\n          }\n          if (typeof cfg.TRUSTED_TYPES_POLICY.createScriptURL !== 'function') {\n            throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a \"createScriptURL\" hook.');\n          }\n\n          // Overwrite existing TrustedTypes policy.\n          trustedTypesPolicy = cfg.TRUSTED_TYPES_POLICY;\n\n          // Sign local variables required by `sanitize`.\n          emptyHTML = trustedTypesPolicy.createHTML('');\n        } else {\n          // Uninitialized policy, attempt to initialize the internal dompurify policy.\n          if (trustedTypesPolicy === undefined) {\n            trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes, currentScript);\n          }\n\n          // If creating the internal policy succeeded sign internal variables.\n          if (trustedTypesPolicy !== null && typeof emptyHTML === 'string') {\n            emptyHTML = trustedTypesPolicy.createHTML('');\n          }\n        }\n\n        // Prevent further manipulation of configuration.\n        // Not available in IE8, Safari 5, etc.\n        if (freeze) {\n          freeze(cfg);\n        }\n        CONFIG = cfg;\n      };\n      const MATHML_TEXT_INTEGRATION_POINTS = addToSet({}, ['mi', 'mo', 'mn', 'ms', 'mtext']);\n      const HTML_INTEGRATION_POINTS = addToSet({}, ['annotation-xml']);\n\n      // Certain elements are allowed in both SVG and HTML\n      // namespace. We need to specify them explicitly\n      // so that they don't get erroneously deleted from\n      // HTML namespace.\n      const COMMON_SVG_AND_HTML_ELEMENTS = addToSet({}, ['title', 'style', 'font', 'a', 'script']);\n\n      /* Keep track of all possible SVG and MathML tags\n       * so that we can perform the namespace checks\n       * correctly. */\n      const ALL_SVG_TAGS = addToSet({}, [...svg$1, ...svgFilters, ...svgDisallowed]);\n      const ALL_MATHML_TAGS = addToSet({}, [...mathMl$1, ...mathMlDisallowed]);\n\n      /**\n       * @param  {Element} element a DOM element whose namespace is being checked\n       * @returns {boolean} Return false if the element has a\n       *  namespace that a spec-compliant parser would never\n       *  return. Return true otherwise.\n       */\n      const _checkValidNamespace = function _checkValidNamespace(element) {\n        let parent = getParentNode(element);\n\n        // In JSDOM, if we're inside shadow DOM, then parentNode\n        // can be null. We just simulate parent in this case.\n        if (!parent || !parent.tagName) {\n          parent = {\n            namespaceURI: NAMESPACE,\n            tagName: 'template'\n          };\n        }\n        const tagName = stringToLowerCase(element.tagName);\n        const parentTagName = stringToLowerCase(parent.tagName);\n        if (!ALLOWED_NAMESPACES[element.namespaceURI]) {\n          return false;\n        }\n        if (element.namespaceURI === SVG_NAMESPACE) {\n          // The only way to switch from HTML namespace to SVG\n          // is via <svg>. If it happens via any other tag, then\n          // it should be killed.\n          if (parent.namespaceURI === HTML_NAMESPACE) {\n            return tagName === 'svg';\n          }\n\n          // The only way to switch from MathML to SVG is via`\n          // svg if parent is either <annotation-xml> or MathML\n          // text integration points.\n          if (parent.namespaceURI === MATHML_NAMESPACE) {\n            return tagName === 'svg' && (parentTagName === 'annotation-xml' || MATHML_TEXT_INTEGRATION_POINTS[parentTagName]);\n          }\n\n          // We only allow elements that are defined in SVG\n          // spec. All others are disallowed in SVG namespace.\n          return Boolean(ALL_SVG_TAGS[tagName]);\n        }\n        if (element.namespaceURI === MATHML_NAMESPACE) {\n          // The only way to switch from HTML namespace to MathML\n          // is via <math>. If it happens via any other tag, then\n          // it should be killed.\n          if (parent.namespaceURI === HTML_NAMESPACE) {\n            return tagName === 'math';\n          }\n\n          // The only way to switch from SVG to MathML is via\n          // <math> and HTML integration points\n          if (parent.namespaceURI === SVG_NAMESPACE) {\n            return tagName === 'math' && HTML_INTEGRATION_POINTS[parentTagName];\n          }\n\n          // We only allow elements that are defined in MathML\n          // spec. All others are disallowed in MathML namespace.\n          return Boolean(ALL_MATHML_TAGS[tagName]);\n        }\n        if (element.namespaceURI === HTML_NAMESPACE) {\n          // The only way to switch from SVG to HTML is via\n          // HTML integration points, and from MathML to HTML\n          // is via MathML text integration points\n          if (parent.namespaceURI === SVG_NAMESPACE && !HTML_INTEGRATION_POINTS[parentTagName]) {\n            return false;\n          }\n          if (parent.namespaceURI === MATHML_NAMESPACE && !MATHML_TEXT_INTEGRATION_POINTS[parentTagName]) {\n            return false;\n          }\n\n          // We disallow tags that are specific for MathML\n          // or SVG and should never appear in HTML namespace\n          return !ALL_MATHML_TAGS[tagName] && (COMMON_SVG_AND_HTML_ELEMENTS[tagName] || !ALL_SVG_TAGS[tagName]);\n        }\n\n        // For XHTML and XML documents that support custom namespaces\n        if (PARSER_MEDIA_TYPE === 'application/xhtml+xml' && ALLOWED_NAMESPACES[element.namespaceURI]) {\n          return true;\n        }\n\n        // The code should never reach this place (this means\n        // that the element somehow got namespace that is not\n        // HTML, SVG, MathML or allowed via ALLOWED_NAMESPACES).\n        // Return false just in case.\n        return false;\n      };\n\n      /**\n       * _forceRemove\n       *\n       * @param  {Node} node a DOM node\n       */\n      const _forceRemove = function _forceRemove(node) {\n        arrayPush(DOMPurify.removed, {\n          element: node\n        });\n        try {\n          // eslint-disable-next-line unicorn/prefer-dom-node-remove\n          getParentNode(node).removeChild(node);\n        } catch (_) {\n          remove(node);\n        }\n      };\n\n      /**\n       * _removeAttribute\n       *\n       * @param  {String} name an Attribute name\n       * @param  {Node} node a DOM node\n       */\n      const _removeAttribute = function _removeAttribute(name, node) {\n        try {\n          arrayPush(DOMPurify.removed, {\n            attribute: node.getAttributeNode(name),\n            from: node\n          });\n        } catch (_) {\n          arrayPush(DOMPurify.removed, {\n            attribute: null,\n            from: node\n          });\n        }\n        node.removeAttribute(name);\n\n        // We void attribute values for unremovable \"is\"\" attributes\n        if (name === 'is' && !ALLOWED_ATTR[name]) {\n          if (RETURN_DOM || RETURN_DOM_FRAGMENT) {\n            try {\n              _forceRemove(node);\n            } catch (_) {}\n          } else {\n            try {\n              node.setAttribute(name, '');\n            } catch (_) {}\n          }\n        }\n      };\n\n      /**\n       * _initDocument\n       *\n       * @param  {String} dirty a string of dirty markup\n       * @return {Document} a DOM, filled with the dirty markup\n       */\n      const _initDocument = function _initDocument(dirty) {\n        /* Create a HTML document */\n        let doc = null;\n        let leadingWhitespace = null;\n        if (FORCE_BODY) {\n          dirty = '<remove></remove>' + dirty;\n        } else {\n          /* If FORCE_BODY isn't used, leading whitespace needs to be preserved manually */\n          const matches = stringMatch(dirty, /^[\\r\\n\\t ]+/);\n          leadingWhitespace = matches && matches[0];\n        }\n        if (PARSER_MEDIA_TYPE === 'application/xhtml+xml' && NAMESPACE === HTML_NAMESPACE) {\n          // Root of XHTML doc must contain xmlns declaration (see https://www.w3.org/TR/xhtml1/normative.html#strict)\n          dirty = '<html xmlns=\"http://www.w3.org/1999/xhtml\"><head></head><body>' + dirty + '</body></html>';\n        }\n        const dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;\n        /*\n         * Use the DOMParser API by default, fallback later if needs be\n         * DOMParser not work for svg when has multiple root element.\n         */\n        if (NAMESPACE === HTML_NAMESPACE) {\n          try {\n            doc = new DOMParser().parseFromString(dirtyPayload, PARSER_MEDIA_TYPE);\n          } catch (_) {}\n        }\n\n        /* Use createHTMLDocument in case DOMParser is not available */\n        if (!doc || !doc.documentElement) {\n          doc = implementation.createDocument(NAMESPACE, 'template', null);\n          try {\n            doc.documentElement.innerHTML = IS_EMPTY_INPUT ? emptyHTML : dirtyPayload;\n          } catch (_) {\n            // Syntax error if dirtyPayload is invalid xml\n          }\n        }\n        const body = doc.body || doc.documentElement;\n        if (dirty && leadingWhitespace) {\n          body.insertBefore(document.createTextNode(leadingWhitespace), body.childNodes[0] || null);\n        }\n\n        /* Work on whole document or just its body */\n        if (NAMESPACE === HTML_NAMESPACE) {\n          return getElementsByTagName.call(doc, WHOLE_DOCUMENT ? 'html' : 'body')[0];\n        }\n        return WHOLE_DOCUMENT ? doc.documentElement : body;\n      };\n\n      /**\n       * Creates a NodeIterator object that you can use to traverse filtered lists of nodes or elements in a document.\n       *\n       * @param  {Node} root The root element or node to start traversing on.\n       * @return {NodeIterator} The created NodeIterator\n       */\n      const _createNodeIterator = function _createNodeIterator(root) {\n        return createNodeIterator.call(root.ownerDocument || root, root,\n        // eslint-disable-next-line no-bitwise\n        NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT | NodeFilter.SHOW_PROCESSING_INSTRUCTION | NodeFilter.SHOW_CDATA_SECTION, null);\n      };\n\n      /**\n       * _isClobbered\n       *\n       * @param  {Node} elm element to check for clobbering attacks\n       * @return {Boolean} true if clobbered, false if safe\n       */\n      const _isClobbered = function _isClobbered(elm) {\n        return elm instanceof HTMLFormElement && (typeof elm.nodeName !== 'string' || typeof elm.textContent !== 'string' || typeof elm.removeChild !== 'function' || !(elm.attributes instanceof NamedNodeMap) || typeof elm.removeAttribute !== 'function' || typeof elm.setAttribute !== 'function' || typeof elm.namespaceURI !== 'string' || typeof elm.insertBefore !== 'function' || typeof elm.hasChildNodes !== 'function');\n      };\n\n      /**\n       * Checks whether the given object is a DOM node.\n       *\n       * @param  {Node} object object to check whether it's a DOM node\n       * @return {Boolean} true is object is a DOM node\n       */\n      const _isNode = function _isNode(object) {\n        return typeof Node === 'function' && object instanceof Node;\n      };\n\n      /**\n       * _executeHook\n       * Execute user configurable hooks\n       *\n       * @param  {String} entryPoint  Name of the hook's entry point\n       * @param  {Node} currentNode node to work on with the hook\n       * @param  {Object} data additional hook parameters\n       */\n      const _executeHook = function _executeHook(entryPoint, currentNode, data) {\n        if (!hooks[entryPoint]) {\n          return;\n        }\n        arrayForEach(hooks[entryPoint], hook => {\n          hook.call(DOMPurify, currentNode, data, CONFIG);\n        });\n      };\n\n      /**\n       * _sanitizeElements\n       *\n       * @protect nodeName\n       * @protect textContent\n       * @protect removeChild\n       *\n       * @param   {Node} currentNode to check for permission to exist\n       * @return  {Boolean} true if node was killed, false if left alive\n       */\n      const _sanitizeElements = function _sanitizeElements(currentNode) {\n        let content = null;\n\n        /* Execute a hook if present */\n        _executeHook('beforeSanitizeElements', currentNode, null);\n\n        /* Check if element is clobbered or can clobber */\n        if (_isClobbered(currentNode)) {\n          _forceRemove(currentNode);\n          return true;\n        }\n\n        /* Now let's check the element's type and name */\n        const tagName = transformCaseFunc(currentNode.nodeName);\n\n        /* Execute a hook if present */\n        _executeHook('uponSanitizeElement', currentNode, {\n          tagName,\n          allowedTags: ALLOWED_TAGS\n        });\n\n        /* Detect mXSS attempts abusing namespace confusion */\n        if (currentNode.hasChildNodes() && !_isNode(currentNode.firstElementChild) && regExpTest(/<[/\\w]/g, currentNode.innerHTML) && regExpTest(/<[/\\w]/g, currentNode.textContent)) {\n          _forceRemove(currentNode);\n          return true;\n        }\n\n        /* Remove any occurrence of processing instructions */\n        if (currentNode.nodeType === NODE_TYPE.progressingInstruction) {\n          _forceRemove(currentNode);\n          return true;\n        }\n\n        /* Remove any kind of possibly harmful comments */\n        if (SAFE_FOR_XML && currentNode.nodeType === NODE_TYPE.comment && regExpTest(/<[/\\w]/g, currentNode.data)) {\n          _forceRemove(currentNode);\n          return true;\n        }\n\n        /* Remove element if anything forbids its presence */\n        if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {\n          /* Check if we have a custom element to handle */\n          if (!FORBID_TAGS[tagName] && _isBasicCustomElement(tagName)) {\n            if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, tagName)) {\n              return false;\n            }\n            if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(tagName)) {\n              return false;\n            }\n          }\n\n          /* Keep content except for bad-listed elements */\n          if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]) {\n            const parentNode = getParentNode(currentNode) || currentNode.parentNode;\n            const childNodes = getChildNodes(currentNode) || currentNode.childNodes;\n            if (childNodes && parentNode) {\n              const childCount = childNodes.length;\n              for (let i = childCount - 1; i >= 0; --i) {\n                const childClone = cloneNode(childNodes[i], true);\n                childClone.__removalCount = (currentNode.__removalCount || 0) + 1;\n                parentNode.insertBefore(childClone, getNextSibling(currentNode));\n              }\n            }\n          }\n          _forceRemove(currentNode);\n          return true;\n        }\n\n        /* Check whether element has a valid namespace */\n        if (currentNode instanceof Element && !_checkValidNamespace(currentNode)) {\n          _forceRemove(currentNode);\n          return true;\n        }\n\n        /* Make sure that older browsers don't get fallback-tag mXSS */\n        if ((tagName === 'noscript' || tagName === 'noembed' || tagName === 'noframes') && regExpTest(/<\\/no(script|embed|frames)/i, currentNode.innerHTML)) {\n          _forceRemove(currentNode);\n          return true;\n        }\n\n        /* Sanitize element content to be template-safe */\n        if (SAFE_FOR_TEMPLATES && currentNode.nodeType === NODE_TYPE.text) {\n          /* Get the element's text content */\n          content = currentNode.textContent;\n          arrayForEach([MUSTACHE_EXPR, ERB_EXPR, TMPLIT_EXPR], expr => {\n            content = stringReplace(content, expr, ' ');\n          });\n          if (currentNode.textContent !== content) {\n            arrayPush(DOMPurify.removed, {\n              element: currentNode.cloneNode()\n            });\n            currentNode.textContent = content;\n          }\n        }\n\n        /* Execute a hook if present */\n        _executeHook('afterSanitizeElements', currentNode, null);\n        return false;\n      };\n\n      /**\n       * _isValidAttribute\n       *\n       * @param  {string} lcTag Lowercase tag name of containing element.\n       * @param  {string} lcName Lowercase attribute name.\n       * @param  {string} value Attribute value.\n       * @return {Boolean} Returns true if `value` is valid, otherwise false.\n       */\n      // eslint-disable-next-line complexity\n      const _isValidAttribute = function _isValidAttribute(lcTag, lcName, value) {\n        /* Make sure attribute cannot clobber */\n        if (SANITIZE_DOM && (lcName === 'id' || lcName === 'name') && (value in document || value in formElement)) {\n          return false;\n        }\n\n        /* Allow valid data-* attributes: At least one character after \"-\"\n            (https://html.spec.whatwg.org/multipage/dom.html#embedding-custom-non-visible-data-with-the-data-*-attributes)\n            XML-compatible (https://html.spec.whatwg.org/multipage/infrastructure.html#xml-compatible and http://www.w3.org/TR/xml/#d0e804)\n            We don't need to check the value; it's always URI safe. */\n        if (ALLOW_DATA_ATTR && !FORBID_ATTR[lcName] && regExpTest(DATA_ATTR, lcName)) ; else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR, lcName)) ; else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {\n          if (\n          // First condition does a very basic check if a) it's basically a valid custom element tagname AND\n          // b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck\n          // and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck\n          _isBasicCustomElement(lcTag) && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, lcTag) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(lcTag)) && (CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.attributeNameCheck, lcName) || CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.attributeNameCheck(lcName)) ||\n          // Alternative, second condition checks if it's an `is`-attribute, AND\n          // the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck\n          lcName === 'is' && CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, value) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(value))) ; else {\n            return false;\n          }\n          /* Check value is safe. First, is attr inert? If so, is safe */\n        } else if (URI_SAFE_ATTRIBUTES[lcName]) ; else if (regExpTest(IS_ALLOWED_URI$1, stringReplace(value, ATTR_WHITESPACE, ''))) ; else if ((lcName === 'src' || lcName === 'xlink:href' || lcName === 'href') && lcTag !== 'script' && stringIndexOf(value, 'data:') === 0 && DATA_URI_TAGS[lcTag]) ; else if (ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA, stringReplace(value, ATTR_WHITESPACE, ''))) ; else if (value) {\n          return false;\n        } else ;\n        return true;\n      };\n\n      /**\n       * _isBasicCustomElement\n       * checks if at least one dash is included in tagName, and it's not the first char\n       * for more sophisticated checking see https://github.com/sindresorhus/validate-element-name\n       *\n       * @param {string} tagName name of the tag of the node to sanitize\n       * @returns {boolean} Returns true if the tag name meets the basic criteria for a custom element, otherwise false.\n       */\n      const _isBasicCustomElement = function _isBasicCustomElement(tagName) {\n        return tagName !== 'annotation-xml' && stringMatch(tagName, CUSTOM_ELEMENT);\n      };\n\n      /**\n       * _sanitizeAttributes\n       *\n       * @protect attributes\n       * @protect nodeName\n       * @protect removeAttribute\n       * @protect setAttribute\n       *\n       * @param  {Node} currentNode to sanitize\n       */\n      const _sanitizeAttributes = function _sanitizeAttributes(currentNode) {\n        /* Execute a hook if present */\n        _executeHook('beforeSanitizeAttributes', currentNode, null);\n        const {\n          attributes\n        } = currentNode;\n\n        /* Check if we have attributes; if not we might have a text node */\n        if (!attributes) {\n          return;\n        }\n        const hookEvent = {\n          attrName: '',\n          attrValue: '',\n          keepAttr: true,\n          allowedAttributes: ALLOWED_ATTR\n        };\n        let l = attributes.length;\n\n        /* Go backwards over all attributes; safely remove bad ones */\n        while (l--) {\n          const attr = attributes[l];\n          const {\n            name,\n            namespaceURI,\n            value: attrValue\n          } = attr;\n          const lcName = transformCaseFunc(name);\n          let value = name === 'value' ? attrValue : stringTrim(attrValue);\n          const initValue = value;\n\n          /* Execute a hook if present */\n          hookEvent.attrName = lcName;\n          hookEvent.attrValue = value;\n          hookEvent.keepAttr = true;\n          hookEvent.forceKeepAttr = undefined; // Allows developers to see this is a property they can set\n          _executeHook('uponSanitizeAttribute', currentNode, hookEvent);\n          value = hookEvent.attrValue;\n\n          /* Did the hooks approve of the attribute? */\n          if (hookEvent.forceKeepAttr) {\n            continue;\n          }\n\n          /* Remove attribute */\n\n          /* Did the hooks approve of the attribute? */\n          if (!hookEvent.keepAttr) {\n            _removeAttribute(name, currentNode);\n            continue;\n          }\n\n          /* Work around a security issue in jQuery 3.0 */\n          if (!ALLOW_SELF_CLOSE_IN_ATTR && regExpTest(/\\/>/i, value)) {\n            _removeAttribute(name, currentNode);\n            continue;\n          }\n\n          /* Sanitize attribute content to be template-safe */\n          if (SAFE_FOR_TEMPLATES) {\n            arrayForEach([MUSTACHE_EXPR, ERB_EXPR, TMPLIT_EXPR], expr => {\n              value = stringReplace(value, expr, ' ');\n            });\n          }\n\n          /* Is `value` valid for this attribute? */\n          const lcTag = transformCaseFunc(currentNode.nodeName);\n          if (!_isValidAttribute(lcTag, lcName, value)) {\n            _removeAttribute(name, currentNode);\n            continue;\n          }\n\n          /* Full DOM Clobbering protection via namespace isolation,\n           * Prefix id and name attributes with `user-content-`\n           */\n          if (SANITIZE_NAMED_PROPS && (lcName === 'id' || lcName === 'name')) {\n            // Remove the attribute with this value\n            _removeAttribute(name, currentNode);\n\n            // Prefix the value and later re-create the attribute with the sanitized value\n            value = SANITIZE_NAMED_PROPS_PREFIX + value;\n          }\n\n          /* Work around a security issue with comments inside attributes */\n          if (SAFE_FOR_XML && regExpTest(/((--!?|])>)|<\\/(style|title)/i, value)) {\n            _removeAttribute(name, currentNode);\n            continue;\n          }\n\n          /* Handle attributes that require Trusted Types */\n          if (trustedTypesPolicy && typeof trustedTypes === 'object' && typeof trustedTypes.getAttributeType === 'function') {\n            if (namespaceURI) ; else {\n              switch (trustedTypes.getAttributeType(lcTag, lcName)) {\n                case 'TrustedHTML':\n                  {\n                    value = trustedTypesPolicy.createHTML(value);\n                    break;\n                  }\n                case 'TrustedScriptURL':\n                  {\n                    value = trustedTypesPolicy.createScriptURL(value);\n                    break;\n                  }\n              }\n            }\n          }\n\n          /* Handle invalid data-* attribute set by try-catching it */\n          if (value !== initValue) {\n            try {\n              if (namespaceURI) {\n                currentNode.setAttributeNS(namespaceURI, name, value);\n              } else {\n                /* Fallback to setAttribute() for browser-unrecognized namespaces e.g. \"x-schema\". */\n                currentNode.setAttribute(name, value);\n              }\n              if (_isClobbered(currentNode)) {\n                _forceRemove(currentNode);\n              } else {\n                arrayPop(DOMPurify.removed);\n              }\n            } catch (_) {}\n          }\n        }\n\n        /* Execute a hook if present */\n        _executeHook('afterSanitizeAttributes', currentNode, null);\n      };\n\n      /**\n       * _sanitizeShadowDOM\n       *\n       * @param  {DocumentFragment} fragment to iterate over recursively\n       */\n      const _sanitizeShadowDOM = function _sanitizeShadowDOM(fragment) {\n        let shadowNode = null;\n        const shadowIterator = _createNodeIterator(fragment);\n\n        /* Execute a hook if present */\n        _executeHook('beforeSanitizeShadowDOM', fragment, null);\n        while (shadowNode = shadowIterator.nextNode()) {\n          /* Execute a hook if present */\n          _executeHook('uponSanitizeShadowNode', shadowNode, null);\n\n          /* Sanitize tags and elements */\n          if (_sanitizeElements(shadowNode)) {\n            continue;\n          }\n\n          /* Deep shadow DOM detected */\n          if (shadowNode.content instanceof DocumentFragment) {\n            _sanitizeShadowDOM(shadowNode.content);\n          }\n\n          /* Check attributes, sanitize if necessary */\n          _sanitizeAttributes(shadowNode);\n        }\n\n        /* Execute a hook if present */\n        _executeHook('afterSanitizeShadowDOM', fragment, null);\n      };\n\n      /**\n       * Sanitize\n       * Public method providing core sanitation functionality\n       *\n       * @param {String|Node} dirty string or DOM node\n       * @param {Object} cfg object\n       */\n      // eslint-disable-next-line complexity\n      DOMPurify.sanitize = function (dirty) {\n        let cfg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        let body = null;\n        let importedNode = null;\n        let currentNode = null;\n        let returnNode = null;\n        /* Make sure we have a string to sanitize.\n          DO NOT return early, as this will return the wrong type if\n          the user has requested a DOM object rather than a string */\n        IS_EMPTY_INPUT = !dirty;\n        if (IS_EMPTY_INPUT) {\n          dirty = '<!-->';\n        }\n\n        /* Stringify, in case dirty is an object */\n        if (typeof dirty !== 'string' && !_isNode(dirty)) {\n          if (typeof dirty.toString === 'function') {\n            dirty = dirty.toString();\n            if (typeof dirty !== 'string') {\n              throw typeErrorCreate('dirty is not a string, aborting');\n            }\n          } else {\n            throw typeErrorCreate('toString is not a function');\n          }\n        }\n\n        /* Return dirty HTML if DOMPurify cannot run */\n        if (!DOMPurify.isSupported) {\n          return dirty;\n        }\n\n        /* Assign config vars */\n        if (!SET_CONFIG) {\n          _parseConfig(cfg);\n        }\n\n        /* Clean up removed elements */\n        DOMPurify.removed = [];\n\n        /* Check if dirty is correctly typed for IN_PLACE */\n        if (typeof dirty === 'string') {\n          IN_PLACE = false;\n        }\n        if (IN_PLACE) {\n          /* Do some early pre-sanitization to avoid unsafe root nodes */\n          if (dirty.nodeName) {\n            const tagName = transformCaseFunc(dirty.nodeName);\n            if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {\n              throw typeErrorCreate('root node is forbidden and cannot be sanitized in-place');\n            }\n          }\n        } else if (dirty instanceof Node) {\n          /* If dirty is a DOM element, append to an empty document to avoid\n             elements being stripped by the parser */\n          body = _initDocument('<!---->');\n          importedNode = body.ownerDocument.importNode(dirty, true);\n          if (importedNode.nodeType === NODE_TYPE.element && importedNode.nodeName === 'BODY') {\n            /* Node is already a body, use as is */\n            body = importedNode;\n          } else if (importedNode.nodeName === 'HTML') {\n            body = importedNode;\n          } else {\n            // eslint-disable-next-line unicorn/prefer-dom-node-append\n            body.appendChild(importedNode);\n          }\n        } else {\n          /* Exit directly if we have nothing to do */\n          if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT &&\n          // eslint-disable-next-line unicorn/prefer-includes\n          dirty.indexOf('<') === -1) {\n            return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;\n          }\n\n          /* Initialize the document to work on */\n          body = _initDocument(dirty);\n\n          /* Check we have a DOM node from the data */\n          if (!body) {\n            return RETURN_DOM ? null : RETURN_TRUSTED_TYPE ? emptyHTML : '';\n          }\n        }\n\n        /* Remove first element node (ours) if FORCE_BODY is set */\n        if (body && FORCE_BODY) {\n          _forceRemove(body.firstChild);\n        }\n\n        /* Get node iterator */\n        const nodeIterator = _createNodeIterator(IN_PLACE ? dirty : body);\n\n        /* Now start iterating over the created document */\n        while (currentNode = nodeIterator.nextNode()) {\n          /* Sanitize tags and elements */\n          if (_sanitizeElements(currentNode)) {\n            continue;\n          }\n\n          /* Shadow DOM detected, sanitize it */\n          if (currentNode.content instanceof DocumentFragment) {\n            _sanitizeShadowDOM(currentNode.content);\n          }\n\n          /* Check attributes, sanitize if necessary */\n          _sanitizeAttributes(currentNode);\n        }\n\n        /* If we sanitized `dirty` in-place, return it. */\n        if (IN_PLACE) {\n          return dirty;\n        }\n\n        /* Return sanitized string or DOM */\n        if (RETURN_DOM) {\n          if (RETURN_DOM_FRAGMENT) {\n            returnNode = createDocumentFragment.call(body.ownerDocument);\n            while (body.firstChild) {\n              // eslint-disable-next-line unicorn/prefer-dom-node-append\n              returnNode.appendChild(body.firstChild);\n            }\n          } else {\n            returnNode = body;\n          }\n          if (ALLOWED_ATTR.shadowroot || ALLOWED_ATTR.shadowrootmode) {\n            /*\n              AdoptNode() is not used because internal state is not reset\n              (e.g. the past names map of a HTMLFormElement), this is safe\n              in theory but we would rather not risk another attack vector.\n              The state that is cloned by importNode() is explicitly defined\n              by the specs.\n            */\n            returnNode = importNode.call(originalDocument, returnNode, true);\n          }\n          return returnNode;\n        }\n        let serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;\n\n        /* Serialize doctype if allowed */\n        if (WHOLE_DOCUMENT && ALLOWED_TAGS['!doctype'] && body.ownerDocument && body.ownerDocument.doctype && body.ownerDocument.doctype.name && regExpTest(DOCTYPE_NAME, body.ownerDocument.doctype.name)) {\n          serializedHTML = '<!DOCTYPE ' + body.ownerDocument.doctype.name + '>\\n' + serializedHTML;\n        }\n\n        /* Sanitize final string template-safe */\n        if (SAFE_FOR_TEMPLATES) {\n          arrayForEach([MUSTACHE_EXPR, ERB_EXPR, TMPLIT_EXPR], expr => {\n            serializedHTML = stringReplace(serializedHTML, expr, ' ');\n          });\n        }\n        return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;\n      };\n\n      /**\n       * Public method to set the configuration once\n       * setConfig\n       *\n       * @param {Object} cfg configuration object\n       */\n      DOMPurify.setConfig = function () {\n        let cfg = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        _parseConfig(cfg);\n        SET_CONFIG = true;\n      };\n\n      /**\n       * Public method to remove the configuration\n       * clearConfig\n       *\n       */\n      DOMPurify.clearConfig = function () {\n        CONFIG = null;\n        SET_CONFIG = false;\n      };\n\n      /**\n       * Public method to check if an attribute value is valid.\n       * Uses last set config, if any. Otherwise, uses config defaults.\n       * isValidAttribute\n       *\n       * @param  {String} tag Tag name of containing element.\n       * @param  {String} attr Attribute name.\n       * @param  {String} value Attribute value.\n       * @return {Boolean} Returns true if `value` is valid. Otherwise, returns false.\n       */\n      DOMPurify.isValidAttribute = function (tag, attr, value) {\n        /* Initialize shared config vars if necessary. */\n        if (!CONFIG) {\n          _parseConfig({});\n        }\n        const lcTag = transformCaseFunc(tag);\n        const lcName = transformCaseFunc(attr);\n        return _isValidAttribute(lcTag, lcName, value);\n      };\n\n      /**\n       * AddHook\n       * Public method to add DOMPurify hooks\n       *\n       * @param {String} entryPoint entry point for the hook to add\n       * @param {Function} hookFunction function to execute\n       */\n      DOMPurify.addHook = function (entryPoint, hookFunction) {\n        if (typeof hookFunction !== 'function') {\n          return;\n        }\n        hooks[entryPoint] = hooks[entryPoint] || [];\n        arrayPush(hooks[entryPoint], hookFunction);\n      };\n\n      /**\n       * RemoveHook\n       * Public method to remove a DOMPurify hook at a given entryPoint\n       * (pops it from the stack of hooks if more are present)\n       *\n       * @param {String} entryPoint entry point for the hook to remove\n       * @return {Function} removed(popped) hook\n       */\n      DOMPurify.removeHook = function (entryPoint) {\n        if (hooks[entryPoint]) {\n          return arrayPop(hooks[entryPoint]);\n        }\n      };\n\n      /**\n       * RemoveHooks\n       * Public method to remove all DOMPurify hooks at a given entryPoint\n       *\n       * @param  {String} entryPoint entry point for the hooks to remove\n       */\n      DOMPurify.removeHooks = function (entryPoint) {\n        if (hooks[entryPoint]) {\n          hooks[entryPoint] = [];\n        }\n      };\n\n      /**\n       * RemoveAllHooks\n       * Public method to remove all DOMPurify hooks\n       */\n      DOMPurify.removeAllHooks = function () {\n        hooks = {};\n      };\n      return DOMPurify;\n    }\n    var purify = createDOMPurify();\n\n    const each$4 = Tools.each, trim = Tools.trim;\n    const queryParts = [\n      'source',\n      'protocol',\n      'authority',\n      'userInfo',\n      'user',\n      'password',\n      'host',\n      'port',\n      'relative',\n      'path',\n      'directory',\n      'file',\n      'query',\n      'anchor'\n    ];\n    const DEFAULT_PORTS = {\n      ftp: 21,\n      http: 80,\n      https: 443,\n      mailto: 25\n    };\n    const safeSvgDataUrlElements = [\n      'img',\n      'video'\n    ];\n    const blockSvgDataUris = (allowSvgDataUrls, tagName) => {\n      if (isNonNullable(allowSvgDataUrls)) {\n        return !allowSvgDataUrls;\n      } else {\n        return isNonNullable(tagName) ? !contains$2(safeSvgDataUrlElements, tagName) : true;\n      }\n    };\n    const decodeUri = encodedUri => {\n      try {\n        return decodeURIComponent(encodedUri);\n      } catch (ex) {\n        return unescape(encodedUri);\n      }\n    };\n    const isInvalidUri = (settings, uri, tagName) => {\n      const decodedUri = decodeUri(uri).replace(/\\s/g, '');\n      if (settings.allow_script_urls) {\n        return false;\n      } else if (/((java|vb)script|mhtml):/i.test(decodedUri)) {\n        return true;\n      } else if (settings.allow_html_data_urls) {\n        return false;\n      } else if (/^data:image\\//i.test(decodedUri)) {\n        return blockSvgDataUris(settings.allow_svg_data_urls, tagName) && /^data:image\\/svg\\+xml/i.test(decodedUri);\n      } else {\n        return /^data:/i.test(decodedUri);\n      }\n    };\n    class URI {\n      static parseDataUri(uri) {\n        let type;\n        const uriComponents = decodeURIComponent(uri).split(',');\n        const matches = /data:([^;]+)/.exec(uriComponents[0]);\n        if (matches) {\n          type = matches[1];\n        }\n        return {\n          type,\n          data: uriComponents[1]\n        };\n      }\n      static isDomSafe(uri, context, options = {}) {\n        if (options.allow_script_urls) {\n          return true;\n        } else {\n          const decodedUri = Entities.decode(uri).replace(/[\\s\\u0000-\\u001F]+/g, '');\n          return !isInvalidUri(options, decodedUri, context);\n        }\n      }\n      static getDocumentBaseUrl(loc) {\n        var _a;\n        let baseUrl;\n        if (loc.protocol.indexOf('http') !== 0 && loc.protocol !== 'file:') {\n          baseUrl = (_a = loc.href) !== null && _a !== void 0 ? _a : '';\n        } else {\n          baseUrl = loc.protocol + '//' + loc.host + loc.pathname;\n        }\n        if (/^[^:]+:\\/\\/\\/?[^\\/]+\\//.test(baseUrl)) {\n          baseUrl = baseUrl.replace(/[\\?#].*$/, '').replace(/[\\/\\\\][^\\/]+$/, '');\n          if (!/[\\/\\\\]$/.test(baseUrl)) {\n            baseUrl += '/';\n          }\n        }\n        return baseUrl;\n      }\n      constructor(url, settings = {}) {\n        this.path = '';\n        this.directory = '';\n        url = trim(url);\n        this.settings = settings;\n        const baseUri = settings.base_uri;\n        const self = this;\n        if (/^([\\w\\-]+):([^\\/]{2})/i.test(url) || /^\\s*#/.test(url)) {\n          self.source = url;\n          return;\n        }\n        const isProtocolRelative = url.indexOf('//') === 0;\n        if (url.indexOf('/') === 0 && !isProtocolRelative) {\n          url = (baseUri ? baseUri.protocol || 'http' : 'http') + '://mce_host' + url;\n        }\n        if (!/^[\\w\\-]*:?\\/\\//.test(url)) {\n          const baseUrl = baseUri ? baseUri.path : new URI(document.location.href).directory;\n          if ((baseUri === null || baseUri === void 0 ? void 0 : baseUri.protocol) === '') {\n            url = '//mce_host' + self.toAbsPath(baseUrl, url);\n          } else {\n            const match = /([^#?]*)([#?]?.*)/.exec(url);\n            if (match) {\n              url = (baseUri && baseUri.protocol || 'http') + '://mce_host' + self.toAbsPath(baseUrl, match[1]) + match[2];\n            }\n          }\n        }\n        url = url.replace(/@@/g, '(mce_at)');\n        const urlMatch = /^(?:(?![^:@]+:[^:@\\/]*@)([^:\\/?#.]+):)?(?:\\/\\/)?((?:(([^:@\\/]*):?([^:@\\/]*))?@)?(\\[[a-zA-Z0-9:.%]+\\]|[^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/.exec(url);\n        if (urlMatch) {\n          each$4(queryParts, (v, i) => {\n            let part = urlMatch[i];\n            if (part) {\n              part = part.replace(/\\(mce_at\\)/g, '@@');\n            }\n            self[v] = part;\n          });\n        }\n        if (baseUri) {\n          if (!self.protocol) {\n            self.protocol = baseUri.protocol;\n          }\n          if (!self.userInfo) {\n            self.userInfo = baseUri.userInfo;\n          }\n          if (!self.port && self.host === 'mce_host') {\n            self.port = baseUri.port;\n          }\n          if (!self.host || self.host === 'mce_host') {\n            self.host = baseUri.host;\n          }\n          self.source = '';\n        }\n        if (isProtocolRelative) {\n          self.protocol = '';\n        }\n      }\n      setPath(path) {\n        const pathMatch = /^(.*?)\\/?(\\w+)?$/.exec(path);\n        if (pathMatch) {\n          this.path = pathMatch[0];\n          this.directory = pathMatch[1];\n          this.file = pathMatch[2];\n        }\n        this.source = '';\n        this.getURI();\n      }\n      toRelative(uri) {\n        if (uri === './') {\n          return uri;\n        }\n        const relativeUri = new URI(uri, { base_uri: this });\n        if (relativeUri.host !== 'mce_host' && this.host !== relativeUri.host && relativeUri.host || this.port !== relativeUri.port || this.protocol !== relativeUri.protocol && relativeUri.protocol !== '') {\n          return relativeUri.getURI();\n        }\n        const tu = this.getURI(), uu = relativeUri.getURI();\n        if (tu === uu || tu.charAt(tu.length - 1) === '/' && tu.substr(0, tu.length - 1) === uu) {\n          return tu;\n        }\n        let output = this.toRelPath(this.path, relativeUri.path);\n        if (relativeUri.query) {\n          output += '?' + relativeUri.query;\n        }\n        if (relativeUri.anchor) {\n          output += '#' + relativeUri.anchor;\n        }\n        return output;\n      }\n      toAbsolute(uri, noHost) {\n        const absoluteUri = new URI(uri, { base_uri: this });\n        return absoluteUri.getURI(noHost && this.isSameOrigin(absoluteUri));\n      }\n      isSameOrigin(uri) {\n        if (this.host == uri.host && this.protocol == uri.protocol) {\n          if (this.port == uri.port) {\n            return true;\n          }\n          const defaultPort = this.protocol ? DEFAULT_PORTS[this.protocol] : null;\n          if (defaultPort && (this.port || defaultPort) == (uri.port || defaultPort)) {\n            return true;\n          }\n        }\n        return false;\n      }\n      toRelPath(base, path) {\n        let breakPoint = 0, out = '', i, l;\n        const normalizedBase = base.substring(0, base.lastIndexOf('/')).split('/');\n        const items = path.split('/');\n        if (normalizedBase.length >= items.length) {\n          for (i = 0, l = normalizedBase.length; i < l; i++) {\n            if (i >= items.length || normalizedBase[i] !== items[i]) {\n              breakPoint = i + 1;\n              break;\n            }\n          }\n        }\n        if (normalizedBase.length < items.length) {\n          for (i = 0, l = items.length; i < l; i++) {\n            if (i >= normalizedBase.length || normalizedBase[i] !== items[i]) {\n              breakPoint = i + 1;\n              break;\n            }\n          }\n        }\n        if (breakPoint === 1) {\n          return path;\n        }\n        for (i = 0, l = normalizedBase.length - (breakPoint - 1); i < l; i++) {\n          out += '../';\n        }\n        for (i = breakPoint - 1, l = items.length; i < l; i++) {\n          if (i !== breakPoint - 1) {\n            out += '/' + items[i];\n          } else {\n            out += items[i];\n          }\n        }\n        return out;\n      }\n      toAbsPath(base, path) {\n        let nb = 0;\n        const tr = /\\/$/.test(path) ? '/' : '';\n        const normalizedBase = base.split('/');\n        const normalizedPath = path.split('/');\n        const baseParts = [];\n        each$4(normalizedBase, k => {\n          if (k) {\n            baseParts.push(k);\n          }\n        });\n        const pathParts = [];\n        for (let i = normalizedPath.length - 1; i >= 0; i--) {\n          if (normalizedPath[i].length === 0 || normalizedPath[i] === '.') {\n            continue;\n          }\n          if (normalizedPath[i] === '..') {\n            nb++;\n            continue;\n          }\n          if (nb > 0) {\n            nb--;\n            continue;\n          }\n          pathParts.push(normalizedPath[i]);\n        }\n        const i = baseParts.length - nb;\n        let outPath;\n        if (i <= 0) {\n          outPath = reverse(pathParts).join('/');\n        } else {\n          outPath = baseParts.slice(0, i).join('/') + '/' + reverse(pathParts).join('/');\n        }\n        if (outPath.indexOf('/') !== 0) {\n          outPath = '/' + outPath;\n        }\n        if (tr && outPath.lastIndexOf('/') !== outPath.length - 1) {\n          outPath += tr;\n        }\n        return outPath;\n      }\n      getURI(noProtoHost = false) {\n        let s;\n        if (!this.source || noProtoHost) {\n          s = '';\n          if (!noProtoHost) {\n            if (this.protocol) {\n              s += this.protocol + '://';\n            } else {\n              s += '//';\n            }\n            if (this.userInfo) {\n              s += this.userInfo + '@';\n            }\n            if (this.host) {\n              s += this.host;\n            }\n            if (this.port) {\n              s += ':' + this.port;\n            }\n          }\n          if (this.path) {\n            s += this.path;\n          }\n          if (this.query) {\n            s += '?' + this.query;\n          }\n          if (this.anchor) {\n            s += '#' + this.anchor;\n          }\n          this.source = s;\n        }\n        return this.source;\n      }\n    }\n\n    const filteredUrlAttrs = Tools.makeMap('src,href,data,background,action,formaction,poster,xlink:href');\n    const internalElementAttr = 'data-mce-type';\n    let uid = 0;\n    const processNode = (node, settings, schema, scope, evt) => {\n      var _a, _b, _c, _d;\n      const validate = settings.validate;\n      const specialElements = schema.getSpecialElements();\n      if (node.nodeType === COMMENT && !settings.allow_conditional_comments && /^\\[if/i.test((_a = node.nodeValue) !== null && _a !== void 0 ? _a : '')) {\n        node.nodeValue = ' ' + node.nodeValue;\n      }\n      const lcTagName = (_b = evt === null || evt === void 0 ? void 0 : evt.tagName) !== null && _b !== void 0 ? _b : node.nodeName.toLowerCase();\n      if (scope !== 'html' && schema.isValid(scope)) {\n        if (isNonNullable(evt)) {\n          evt.allowedTags[lcTagName] = true;\n        }\n        return;\n      }\n      if (node.nodeType !== ELEMENT || lcTagName === 'body') {\n        return;\n      }\n      const element = SugarElement.fromDom(node);\n      const isInternalElement = has$1(element, internalElementAttr);\n      const bogus = get$9(element, 'data-mce-bogus');\n      if (!isInternalElement && isString(bogus)) {\n        if (bogus === 'all') {\n          remove$4(element);\n        } else {\n          unwrap(element);\n        }\n        return;\n      }\n      const rule = schema.getElementRule(lcTagName);\n      if (validate && !rule) {\n        if (has$2(specialElements, lcTagName)) {\n          remove$4(element);\n        } else {\n          unwrap(element);\n        }\n        return;\n      } else {\n        if (isNonNullable(evt)) {\n          evt.allowedTags[lcTagName] = true;\n        }\n      }\n      if (validate && rule && !isInternalElement) {\n        each$e((_c = rule.attributesForced) !== null && _c !== void 0 ? _c : [], attr => {\n          set$3(element, attr.name, attr.value === '{$uid}' ? `mce_${ uid++ }` : attr.value);\n        });\n        each$e((_d = rule.attributesDefault) !== null && _d !== void 0 ? _d : [], attr => {\n          if (!has$1(element, attr.name)) {\n            set$3(element, attr.name, attr.value === '{$uid}' ? `mce_${ uid++ }` : attr.value);\n          }\n        });\n        if (rule.attributesRequired && !exists(rule.attributesRequired, attr => has$1(element, attr))) {\n          unwrap(element);\n          return;\n        }\n        if (rule.removeEmptyAttrs && hasNone(element)) {\n          unwrap(element);\n          return;\n        }\n        if (rule.outputName && rule.outputName !== lcTagName) {\n          mutate(element, rule.outputName);\n        }\n      }\n    };\n    const processAttr = (ele, settings, schema, scope, evt) => {\n      const tagName = ele.tagName.toLowerCase();\n      const {attrName, attrValue} = evt;\n      evt.keepAttr = shouldKeepAttribute(settings, schema, scope, tagName, attrName, attrValue);\n      if (evt.keepAttr) {\n        evt.allowedAttributes[attrName] = true;\n        if (isBooleanAttribute(attrName, schema)) {\n          evt.attrValue = attrName;\n        }\n        if (settings.allow_svg_data_urls && startsWith(attrValue, 'data:image/svg+xml')) {\n          evt.forceKeepAttr = true;\n        }\n      } else if (isRequiredAttributeOfInternalElement(ele, attrName)) {\n        evt.forceKeepAttr = true;\n      }\n    };\n    const shouldKeepAttribute = (settings, schema, scope, tagName, attrName, attrValue) => {\n      if (scope !== 'html' && !isNonHtmlElementRootName(tagName)) {\n        return true;\n      }\n      return !(attrName in filteredUrlAttrs && isInvalidUri(settings, attrValue, tagName)) && (!settings.validate || schema.isValid(tagName, attrName) || startsWith(attrName, 'data-') || startsWith(attrName, 'aria-'));\n    };\n    const isRequiredAttributeOfInternalElement = (ele, attrName) => ele.hasAttribute(internalElementAttr) && (attrName === 'id' || attrName === 'class' || attrName === 'style');\n    const isBooleanAttribute = (attrName, schema) => attrName in schema.getBoolAttrs();\n    const filterAttributes = (ele, settings, schema, scope) => {\n      const {attributes} = ele;\n      for (let i = attributes.length - 1; i >= 0; i--) {\n        const attr = attributes[i];\n        const attrName = attr.name;\n        const attrValue = attr.value;\n        if (!shouldKeepAttribute(settings, schema, scope, ele.tagName.toLowerCase(), attrName, attrValue) && !isRequiredAttributeOfInternalElement(ele, attrName)) {\n          ele.removeAttribute(attrName);\n        } else if (isBooleanAttribute(attrName, schema)) {\n          ele.setAttribute(attrName, attrName);\n        }\n      }\n    };\n    const setupPurify = (settings, schema, namespaceTracker) => {\n      const purify$1 = purify();\n      purify$1.addHook('uponSanitizeElement', (ele, evt) => {\n        processNode(ele, settings, schema, namespaceTracker.track(ele), evt);\n      });\n      purify$1.addHook('uponSanitizeAttribute', (ele, evt) => {\n        processAttr(ele, settings, schema, namespaceTracker.current(), evt);\n      });\n      return purify$1;\n    };\n    const getPurifyConfig = (settings, mimeType) => {\n      const basePurifyConfig = {\n        IN_PLACE: true,\n        ALLOW_UNKNOWN_PROTOCOLS: true,\n        ALLOWED_TAGS: [\n          '#comment',\n          '#cdata-section',\n          'body'\n        ],\n        ALLOWED_ATTR: [],\n        SAFE_FOR_XML: false\n      };\n      const config = { ...basePurifyConfig };\n      config.PARSER_MEDIA_TYPE = mimeType;\n      if (settings.allow_script_urls) {\n        config.ALLOWED_URI_REGEXP = /.*/;\n      } else if (settings.allow_html_data_urls) {\n        config.ALLOWED_URI_REGEXP = /^(?!(\\w+script|mhtml):)/i;\n      }\n      return config;\n    };\n    const sanitizeSvgElement = ele => {\n      const xlinkAttrs = [\n        'type',\n        'href',\n        'role',\n        'arcrole',\n        'title',\n        'show',\n        'actuate',\n        'label',\n        'from',\n        'to'\n      ].map(name => `xlink:${ name }`);\n      const config = {\n        IN_PLACE: true,\n        USE_PROFILES: {\n          html: true,\n          svg: true,\n          svgFilters: true\n        },\n        ALLOWED_ATTR: xlinkAttrs\n      };\n      purify().sanitize(ele, config);\n    };\n    const sanitizeMathmlElement = (node, settings) => {\n      const config = {\n        IN_PLACE: true,\n        USE_PROFILES: { mathMl: true }\n      };\n      const purify$1 = purify();\n      purify$1.addHook('uponSanitizeElement', (node, evt) => {\n        var _a;\n        const lcTagName = (_a = evt.tagName) !== null && _a !== void 0 ? _a : node.nodeName.toLowerCase();\n        const allowedEncodings = settings.allow_mathml_annotation_encodings;\n        if (lcTagName === 'annotation' && isArray$1(allowedEncodings) && allowedEncodings.length > 0) {\n          const encoding = node.getAttribute('encoding');\n          if (isString(encoding) && contains$2(allowedEncodings, encoding)) {\n            evt.allowedTags[lcTagName] = true;\n          }\n        }\n      });\n      purify$1.sanitize(node, config);\n    };\n    const mkSanitizeNamespaceElement = settings => ele => {\n      const namespaceType = toScopeType(ele);\n      if (namespaceType === 'svg') {\n        sanitizeSvgElement(ele);\n      } else if (namespaceType === 'math') {\n        sanitizeMathmlElement(ele, settings);\n      } else {\n        throw new Error('Not a namespace element');\n      }\n    };\n    const getSanitizer = (settings, schema) => {\n      const namespaceTracker = createNamespaceTracker();\n      if (settings.sanitize) {\n        const purify = setupPurify(settings, schema, namespaceTracker);\n        const sanitizeHtmlElement = (body, mimeType) => {\n          purify.sanitize(body, getPurifyConfig(settings, mimeType));\n          purify.removed = [];\n          namespaceTracker.reset();\n        };\n        return {\n          sanitizeHtmlElement,\n          sanitizeNamespaceElement: mkSanitizeNamespaceElement(settings)\n        };\n      } else {\n        const sanitizeHtmlElement = (body, _mimeType) => {\n          const nodeIterator = document.createNodeIterator(body, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT);\n          let node;\n          while (node = nodeIterator.nextNode()) {\n            const currentScope = namespaceTracker.track(node);\n            processNode(node, settings, schema, currentScope);\n            if (isElement$6(node)) {\n              filterAttributes(node, settings, schema, currentScope);\n            }\n          }\n          namespaceTracker.reset();\n        };\n        const sanitizeNamespaceElement = noop;\n        return {\n          sanitizeHtmlElement,\n          sanitizeNamespaceElement\n        };\n      }\n    };\n\n    const makeMap = Tools.makeMap, extend$1 = Tools.extend;\n    const transferChildren = (parent, nativeParent, specialElements, nsSanitizer) => {\n      const parentName = parent.name;\n      const isSpecial = parentName in specialElements && parentName !== 'title' && parentName !== 'textarea' && parentName !== 'noscript';\n      const childNodes = nativeParent.childNodes;\n      for (let ni = 0, nl = childNodes.length; ni < nl; ni++) {\n        const nativeChild = childNodes[ni];\n        const child = new AstNode(nativeChild.nodeName.toLowerCase(), nativeChild.nodeType);\n        if (isElement$6(nativeChild)) {\n          const attributes = nativeChild.attributes;\n          for (let ai = 0, al = attributes.length; ai < al; ai++) {\n            const attr = attributes[ai];\n            child.attr(attr.name, attr.value);\n          }\n          if (isNonHtmlElementRootName(child.name)) {\n            nsSanitizer(nativeChild);\n            child.value = nativeChild.innerHTML;\n          }\n        } else if (isText$b(nativeChild)) {\n          child.value = nativeChild.data;\n          if (isSpecial) {\n            child.raw = true;\n          }\n        } else if (isComment(nativeChild) || isCData(nativeChild) || isPi(nativeChild)) {\n          child.value = nativeChild.data;\n        }\n        if (!isNonHtmlElementRootName(child.name)) {\n          transferChildren(child, nativeChild, specialElements, nsSanitizer);\n        }\n        parent.append(child);\n      }\n    };\n    const walkTree = (root, preprocessors, postprocessors) => {\n      const traverseOrder = [];\n      for (let node = root, lastNode = node; node; lastNode = node, node = node.walk()) {\n        const tempNode = node;\n        each$e(preprocessors, preprocess => preprocess(tempNode));\n        if (isNullable(tempNode.parent) && tempNode !== root) {\n          node = lastNode;\n        } else {\n          traverseOrder.push(tempNode);\n        }\n      }\n      for (let i = traverseOrder.length - 1; i >= 0; i--) {\n        const node = traverseOrder[i];\n        each$e(postprocessors, postprocess => postprocess(node));\n      }\n    };\n    const whitespaceCleaner = (root, schema, settings, args) => {\n      const validate = settings.validate;\n      const nonEmptyElements = schema.getNonEmptyElements();\n      const whitespaceElements = schema.getWhitespaceElements();\n      const blockElements = extend$1(makeMap('script,style,head,html,body,title,meta,param'), schema.getBlockElements());\n      const textRootBlockElements = getTextRootBlockElements(schema);\n      const allWhiteSpaceRegExp = /[ \\t\\r\\n]+/g;\n      const startWhiteSpaceRegExp = /^[ \\t\\r\\n]+/;\n      const endWhiteSpaceRegExp = /[ \\t\\r\\n]+$/;\n      const hasWhitespaceParent = node => {\n        let tempNode = node.parent;\n        while (isNonNullable(tempNode)) {\n          if (tempNode.name in whitespaceElements) {\n            return true;\n          } else {\n            tempNode = tempNode.parent;\n          }\n        }\n        return false;\n      };\n      const isTextRootBlockEmpty = node => {\n        let tempNode = node;\n        while (isNonNullable(tempNode)) {\n          if (tempNode.name in textRootBlockElements) {\n            return isEmpty(schema, nonEmptyElements, whitespaceElements, tempNode);\n          } else {\n            tempNode = tempNode.parent;\n          }\n        }\n        return false;\n      };\n      const isBlock = node => node.name in blockElements || isTransparentAstBlock(schema, node) || isNonHtmlElementRootName(node.name) && node.parent === root;\n      const isAtEdgeOfBlock = (node, start) => {\n        const neighbour = start ? node.prev : node.next;\n        if (isNonNullable(neighbour) || isNullable(node.parent)) {\n          return false;\n        }\n        return isBlock(node.parent) && (node.parent !== root || args.isRootContent === true);\n      };\n      const preprocess = node => {\n        var _a;\n        if (node.type === 3) {\n          if (!hasWhitespaceParent(node)) {\n            let text = (_a = node.value) !== null && _a !== void 0 ? _a : '';\n            text = text.replace(allWhiteSpaceRegExp, ' ');\n            if (isLineBreakNode(node.prev, isBlock) || isAtEdgeOfBlock(node, true)) {\n              text = text.replace(startWhiteSpaceRegExp, '');\n            }\n            if (text.length === 0) {\n              node.remove();\n            } else if (text === ' ' && node.prev && node.prev.type === COMMENT && node.next && node.next.type === COMMENT) {\n              node.remove();\n            } else {\n              node.value = text;\n            }\n          }\n        }\n      };\n      const postprocess = node => {\n        var _a;\n        if (node.type === 1) {\n          const elementRule = schema.getElementRule(node.name);\n          if (validate && elementRule) {\n            const isNodeEmpty = isEmpty(schema, nonEmptyElements, whitespaceElements, node);\n            if (elementRule.paddInEmptyBlock && isNodeEmpty && isTextRootBlockEmpty(node)) {\n              paddEmptyNode(settings, args, isBlock, node);\n            } else if (elementRule.removeEmpty && isNodeEmpty) {\n              if (isBlock(node)) {\n                node.remove();\n              } else {\n                node.unwrap();\n              }\n            } else if (elementRule.paddEmpty && (isNodeEmpty || isPaddedWithNbsp(node))) {\n              paddEmptyNode(settings, args, isBlock, node);\n            }\n          }\n        } else if (node.type === 3) {\n          if (!hasWhitespaceParent(node)) {\n            let text = (_a = node.value) !== null && _a !== void 0 ? _a : '';\n            if (node.next && isBlock(node.next) || isAtEdgeOfBlock(node, false)) {\n              text = text.replace(endWhiteSpaceRegExp, '');\n            }\n            if (text.length === 0) {\n              node.remove();\n            } else {\n              node.value = text;\n            }\n          }\n        }\n      };\n      return [\n        preprocess,\n        postprocess\n      ];\n    };\n    const getRootBlockName = (settings, args) => {\n      var _a;\n      const name = (_a = args.forced_root_block) !== null && _a !== void 0 ? _a : settings.forced_root_block;\n      if (name === false) {\n        return '';\n      } else if (name === true) {\n        return 'p';\n      } else {\n        return name;\n      }\n    };\n    const DomParser = (settings = {}, schema = Schema()) => {\n      const nodeFilterRegistry = create$8();\n      const attributeFilterRegistry = create$8();\n      const defaultedSettings = {\n        validate: true,\n        root_name: 'body',\n        sanitize: true,\n        ...settings\n      };\n      const parser = new DOMParser();\n      const sanitizer = getSanitizer(defaultedSettings, schema);\n      const parseAndSanitizeWithContext = (html, rootName, format = 'html') => {\n        const mimeType = format === 'xhtml' ? 'application/xhtml+xml' : 'text/html';\n        const isSpecialRoot = has$2(schema.getSpecialElements(), rootName.toLowerCase());\n        const content = isSpecialRoot ? `<${ rootName }>${ html }</${ rootName }>` : html;\n        const makeWrap = () => {\n          if (format === 'xhtml') {\n            return `<html xmlns=\"http://www.w3.org/1999/xhtml\"><head></head><body>${ content }</body></html>`;\n          } else if (/^[\\s]*<head/i.test(html) || /^[\\s]*<html/i.test(html) || /^[\\s]*<!DOCTYPE/i.test(html)) {\n            return `<html>${ content }</html>`;\n          } else {\n            return `<body>${ content }</body>`;\n          }\n        };\n        const body = parser.parseFromString(makeWrap(), mimeType).body;\n        sanitizer.sanitizeHtmlElement(body, mimeType);\n        return isSpecialRoot ? body.firstChild : body;\n      };\n      const addNodeFilter = nodeFilterRegistry.addFilter;\n      const getNodeFilters = nodeFilterRegistry.getFilters;\n      const removeNodeFilter = nodeFilterRegistry.removeFilter;\n      const addAttributeFilter = attributeFilterRegistry.addFilter;\n      const getAttributeFilters = attributeFilterRegistry.getFilters;\n      const removeAttributeFilter = attributeFilterRegistry.removeFilter;\n      const findInvalidChildren = (node, invalidChildren) => {\n        if (isInvalid(schema, node)) {\n          invalidChildren.push(node);\n        }\n      };\n      const isWrappableNode = (blockElements, node) => {\n        const isInternalElement = isString(node.attr(internalElementAttr));\n        const isInlineElement = node.type === 1 && (!has$2(blockElements, node.name) && !isTransparentAstBlock(schema, node)) && !isNonHtmlElementRootName(node.name);\n        return node.type === 3 || isInlineElement && !isInternalElement;\n      };\n      const addRootBlocks = (rootNode, rootBlockName) => {\n        const blockElements = extend$1(makeMap('script,style,head,html,body,title,meta,param'), schema.getBlockElements());\n        const startWhiteSpaceRegExp = /^[ \\t\\r\\n]+/;\n        const endWhiteSpaceRegExp = /[ \\t\\r\\n]+$/;\n        let node = rootNode.firstChild, rootBlockNode = null;\n        const trim = rootBlock => {\n          var _a, _b;\n          if (rootBlock) {\n            node = rootBlock.firstChild;\n            if (node && node.type === 3) {\n              node.value = (_a = node.value) === null || _a === void 0 ? void 0 : _a.replace(startWhiteSpaceRegExp, '');\n            }\n            node = rootBlock.lastChild;\n            if (node && node.type === 3) {\n              node.value = (_b = node.value) === null || _b === void 0 ? void 0 : _b.replace(endWhiteSpaceRegExp, '');\n            }\n          }\n        };\n        if (!schema.isValidChild(rootNode.name, rootBlockName.toLowerCase())) {\n          return;\n        }\n        while (node) {\n          const next = node.next;\n          if (isWrappableNode(blockElements, node)) {\n            if (!rootBlockNode) {\n              rootBlockNode = new AstNode(rootBlockName, 1);\n              rootBlockNode.attr(defaultedSettings.forced_root_block_attrs);\n              rootNode.insert(rootBlockNode, node);\n              rootBlockNode.append(node);\n            } else {\n              rootBlockNode.append(node);\n            }\n          } else {\n            trim(rootBlockNode);\n            rootBlockNode = null;\n          }\n          node = next;\n        }\n        trim(rootBlockNode);\n      };\n      const parse = (html, args = {}) => {\n        var _a;\n        const validate = defaultedSettings.validate;\n        const rootName = (_a = args.context) !== null && _a !== void 0 ? _a : defaultedSettings.root_name;\n        const element = parseAndSanitizeWithContext(html, rootName, args.format);\n        updateChildren(schema, element);\n        const rootNode = new AstNode(rootName, 11);\n        transferChildren(rootNode, element, schema.getSpecialElements(), sanitizer.sanitizeNamespaceElement);\n        element.innerHTML = '';\n        const [whitespacePre, whitespacePost] = whitespaceCleaner(rootNode, schema, defaultedSettings, args);\n        const invalidChildren = [];\n        const invalidFinder = validate ? node => findInvalidChildren(node, invalidChildren) : noop;\n        const matches = {\n          nodes: {},\n          attributes: {}\n        };\n        const matchFinder = node => matchNode$1(getNodeFilters(), getAttributeFilters(), node, matches);\n        walkTree(rootNode, [\n          whitespacePre,\n          matchFinder\n        ], [\n          whitespacePost,\n          invalidFinder\n        ]);\n        invalidChildren.reverse();\n        if (validate && invalidChildren.length > 0) {\n          if (args.context) {\n            const {\n              pass: topLevelChildren,\n              fail: otherChildren\n            } = partition$2(invalidChildren, child => child.parent === rootNode);\n            cleanInvalidNodes(otherChildren, schema, rootNode, matchFinder);\n            args.invalid = topLevelChildren.length > 0;\n          } else {\n            cleanInvalidNodes(invalidChildren, schema, rootNode, matchFinder);\n          }\n        }\n        const rootBlockName = getRootBlockName(defaultedSettings, args);\n        if (rootBlockName && (rootNode.name === 'body' || args.isRootContent)) {\n          addRootBlocks(rootNode, rootBlockName);\n        }\n        if (!args.invalid) {\n          runFilters(matches, args);\n        }\n        return rootNode;\n      };\n      const exports = {\n        schema,\n        addAttributeFilter,\n        getAttributeFilters,\n        removeAttributeFilter,\n        addNodeFilter,\n        getNodeFilters,\n        removeNodeFilter,\n        parse\n      };\n      register$4(exports, defaultedSettings);\n      register$5(exports, defaultedSettings, schema);\n      return exports;\n    };\n\n    const serializeContent = content => isTreeNode(content) ? HtmlSerializer({ validate: false }).serialize(content) : content;\n    const withSerializedContent = (content, fireEvent, parserSettings) => {\n      const serializedContent = serializeContent(content);\n      const eventArgs = fireEvent(serializedContent);\n      if (eventArgs.isDefaultPrevented()) {\n        return eventArgs;\n      } else if (isTreeNode(content)) {\n        if (eventArgs.content !== serializedContent) {\n          const rootNode = DomParser({\n            validate: false,\n            forced_root_block: false,\n            ...parserSettings\n          }).parse(eventArgs.content, { context: content.name });\n          return {\n            ...eventArgs,\n            content: rootNode\n          };\n        } else {\n          return {\n            ...eventArgs,\n            content\n          };\n        }\n      } else {\n        return eventArgs;\n      }\n    };\n    const makeParserSettings = editor => ({\n      sanitize: shouldSanitizeXss(editor),\n      sandbox_iframes: shouldSandboxIframes(editor),\n      sandbox_iframes_exclusions: getSandboxIframesExclusions(editor)\n    });\n    const preProcessGetContent = (editor, args) => {\n      if (args.no_events) {\n        return Result.value(args);\n      } else {\n        const eventArgs = fireBeforeGetContent(editor, args);\n        if (eventArgs.isDefaultPrevented()) {\n          return Result.error(fireGetContent(editor, {\n            content: '',\n            ...eventArgs\n          }).content);\n        } else {\n          return Result.value(eventArgs);\n        }\n      }\n    };\n    const postProcessGetContent = (editor, content, args) => {\n      if (args.no_events) {\n        return content;\n      } else {\n        const processedEventArgs = withSerializedContent(content, content => fireGetContent(editor, {\n          ...args,\n          content\n        }), makeParserSettings(editor));\n        return processedEventArgs.content;\n      }\n    };\n    const preProcessSetContent = (editor, args) => {\n      if (args.no_events) {\n        return Result.value(args);\n      } else {\n        const processedEventArgs = withSerializedContent(args.content, content => fireBeforeSetContent(editor, {\n          ...args,\n          content\n        }), makeParserSettings(editor));\n        if (processedEventArgs.isDefaultPrevented()) {\n          fireSetContent(editor, processedEventArgs);\n          return Result.error(undefined);\n        } else {\n          return Result.value(processedEventArgs);\n        }\n      }\n    };\n    const postProcessSetContent = (editor, content, args) => {\n      if (!args.no_events) {\n        fireSetContent(editor, {\n          ...args,\n          content\n        });\n      }\n    };\n\n    const tableModel = (element, width, rows) => ({\n      element,\n      width,\n      rows\n    });\n    const tableRow = (element, cells) => ({\n      element,\n      cells\n    });\n    const cellPosition = (x, y) => ({\n      x,\n      y\n    });\n    const getSpan = (td, key) => {\n      return getOpt(td, key).bind(toInt).getOr(1);\n    };\n    const fillout = (table, x, y, tr, td) => {\n      const rowspan = getSpan(td, 'rowspan');\n      const colspan = getSpan(td, 'colspan');\n      const rows = table.rows;\n      for (let y2 = y; y2 < y + rowspan; y2++) {\n        if (!rows[y2]) {\n          rows[y2] = tableRow(deep$1(tr), []);\n        }\n        for (let x2 = x; x2 < x + colspan; x2++) {\n          const cells = rows[y2].cells;\n          cells[x2] = y2 === y && x2 === x ? td : shallow$1(td);\n        }\n      }\n    };\n    const cellExists = (table, x, y) => {\n      const rows = table.rows;\n      const cells = rows[y] ? rows[y].cells : [];\n      return !!cells[x];\n    };\n    const skipCellsX = (table, x, y) => {\n      while (cellExists(table, x, y)) {\n        x++;\n      }\n      return x;\n    };\n    const getWidth = rows => {\n      return foldl(rows, (acc, row) => {\n        return row.cells.length > acc ? row.cells.length : acc;\n      }, 0);\n    };\n    const findElementPos = (table, element) => {\n      const rows = table.rows;\n      for (let y = 0; y < rows.length; y++) {\n        const cells = rows[y].cells;\n        for (let x = 0; x < cells.length; x++) {\n          if (eq(cells[x], element)) {\n            return Optional.some(cellPosition(x, y));\n          }\n        }\n      }\n      return Optional.none();\n    };\n    const extractRows = (table, sx, sy, ex, ey) => {\n      const newRows = [];\n      const rows = table.rows;\n      for (let y = sy; y <= ey; y++) {\n        const cells = rows[y].cells;\n        const slice = sx < ex ? cells.slice(sx, ex + 1) : cells.slice(ex, sx + 1);\n        newRows.push(tableRow(rows[y].element, slice));\n      }\n      return newRows;\n    };\n    const subTable = (table, startPos, endPos) => {\n      const sx = startPos.x, sy = startPos.y;\n      const ex = endPos.x, ey = endPos.y;\n      const newRows = sy < ey ? extractRows(table, sx, sy, ex, ey) : extractRows(table, sx, ey, ex, sy);\n      return tableModel(table.element, getWidth(newRows), newRows);\n    };\n    const createDomTable = (table, rows) => {\n      const tableElement = shallow$1(table.element);\n      const tableBody = SugarElement.fromTag('tbody');\n      append(tableBody, rows);\n      append$1(tableElement, tableBody);\n      return tableElement;\n    };\n    const modelRowsToDomRows = table => {\n      return map$3(table.rows, row => {\n        const cells = map$3(row.cells, cell => {\n          const td = deep$1(cell);\n          remove$9(td, 'colspan');\n          remove$9(td, 'rowspan');\n          return td;\n        });\n        const tr = shallow$1(row.element);\n        append(tr, cells);\n        return tr;\n      });\n    };\n    const fromDom = tableElm => {\n      const table = tableModel(shallow$1(tableElm), 0, []);\n      each$e(descendants(tableElm, 'tr'), (tr, y) => {\n        each$e(descendants(tr, 'td,th'), (td, x) => {\n          fillout(table, skipCellsX(table, x, y), y, tr, td);\n        });\n      });\n      return tableModel(table.element, getWidth(table.rows), table.rows);\n    };\n    const toDom = table => {\n      return createDomTable(table, modelRowsToDomRows(table));\n    };\n    const subsection = (table, startElement, endElement) => {\n      return findElementPos(table, startElement).bind(startPos => {\n        return findElementPos(table, endElement).map(endPos => {\n          return subTable(table, startPos, endPos);\n        });\n      });\n    };\n\n    const findParentListContainer = parents => find$2(parents, elm => name(elm) === 'ul' || name(elm) === 'ol');\n    const getFullySelectedListWrappers = (parents, rng) => find$2(parents, elm => name(elm) === 'li' && hasAllContentsSelected(elm, rng)).fold(constant([]), _li => findParentListContainer(parents).map(listCont => {\n      const listElm = SugarElement.fromTag(name(listCont));\n      const listStyles = filter$4(getAllRaw(listCont), (_style, name) => startsWith(name, 'list-style'));\n      setAll(listElm, listStyles);\n      return [\n        SugarElement.fromTag('li'),\n        listElm\n      ];\n    }).getOr([]));\n    const wrap = (innerElm, elms) => {\n      const wrapped = foldl(elms, (acc, elm) => {\n        append$1(elm, acc);\n        return elm;\n      }, innerElm);\n      return elms.length > 0 ? fromElements([wrapped]) : wrapped;\n    };\n    const directListWrappers = commonAnchorContainer => {\n      if (isListItem$1(commonAnchorContainer)) {\n        return parent(commonAnchorContainer).filter(isList).fold(constant([]), listElm => [\n          commonAnchorContainer,\n          listElm\n        ]);\n      } else {\n        return isList(commonAnchorContainer) ? [commonAnchorContainer] : [];\n      }\n    };\n    const getWrapElements = (rootNode, rng, schema) => {\n      const commonAnchorContainer = SugarElement.fromDom(rng.commonAncestorContainer);\n      const parents = parentsAndSelf(commonAnchorContainer, rootNode);\n      const wrapElements = filter$5(parents, el => schema.isWrapper(name(el)));\n      const listWrappers = getFullySelectedListWrappers(parents, rng);\n      const allWrappers = wrapElements.concat(listWrappers.length ? listWrappers : directListWrappers(commonAnchorContainer));\n      return map$3(allWrappers, shallow$1);\n    };\n    const emptyFragment = () => fromElements([]);\n    const getFragmentFromRange = (rootNode, rng, schema) => wrap(SugarElement.fromDom(rng.cloneContents()), getWrapElements(rootNode, rng, schema));\n    const getParentTable = (rootElm, cell) => ancestor$3(cell, 'table', curry(eq, rootElm));\n    const getTableFragment = (rootNode, selectedTableCells) => getParentTable(rootNode, selectedTableCells[0]).bind(tableElm => {\n      const firstCell = selectedTableCells[0];\n      const lastCell = selectedTableCells[selectedTableCells.length - 1];\n      const fullTableModel = fromDom(tableElm);\n      return subsection(fullTableModel, firstCell, lastCell).map(sectionedTableModel => fromElements([toDom(sectionedTableModel)]));\n    }).getOrThunk(emptyFragment);\n    const getSelectionFragment = (rootNode, ranges, schema) => ranges.length > 0 && ranges[0].collapsed ? emptyFragment() : getFragmentFromRange(rootNode, ranges[0], schema);\n    const read$3 = (rootNode, ranges, schema) => {\n      const selectedCells = getCellsFromElementOrRanges(ranges, rootNode);\n      return selectedCells.length > 0 ? getTableFragment(rootNode, selectedCells) : getSelectionFragment(rootNode, ranges, schema);\n    };\n\n    const isCollapsibleWhitespace = (text, index) => index >= 0 && index < text.length && isWhiteSpace(text.charAt(index));\n    const getInnerText = bin => {\n      return trim$2(bin.innerText);\n    };\n    const getContextNodeName = parentBlockOpt => parentBlockOpt.map(block => block.nodeName).getOr('div').toLowerCase();\n    const getTextContent = editor => Optional.from(editor.selection.getRng()).map(rng => {\n      var _a;\n      const parentBlockOpt = Optional.from(editor.dom.getParent(rng.commonAncestorContainer, editor.dom.isBlock));\n      const body = editor.getBody();\n      const contextNodeName = getContextNodeName(parentBlockOpt);\n      const rangeContentClone = SugarElement.fromDom(rng.cloneContents());\n      cleanupBogusElements(rangeContentClone);\n      cleanupInputNames(rangeContentClone);\n      const bin = editor.dom.add(body, contextNodeName, {\n        'data-mce-bogus': 'all',\n        'style': 'overflow: hidden; opacity: 0;'\n      }, rangeContentClone.dom);\n      const text = getInnerText(bin);\n      const nonRenderedText = trim$2((_a = bin.textContent) !== null && _a !== void 0 ? _a : '');\n      editor.dom.remove(bin);\n      if (isCollapsibleWhitespace(nonRenderedText, 0) || isCollapsibleWhitespace(nonRenderedText, nonRenderedText.length - 1)) {\n        const parentBlock = parentBlockOpt.getOr(body);\n        const parentBlockText = getInnerText(parentBlock);\n        const textIndex = parentBlockText.indexOf(text);\n        if (textIndex === -1) {\n          return text;\n        } else {\n          const hasProceedingSpace = isCollapsibleWhitespace(parentBlockText, textIndex - 1);\n          const hasTrailingSpace = isCollapsibleWhitespace(parentBlockText, textIndex + text.length);\n          return (hasProceedingSpace ? ' ' : '') + text + (hasTrailingSpace ? ' ' : '');\n        }\n      } else {\n        return text;\n      }\n    }).getOr('');\n    const getSerializedContent = (editor, args) => {\n      const rng = editor.selection.getRng(), tmpElm = editor.dom.create('body');\n      const sel = editor.selection.getSel();\n      const ranges = processRanges(editor, getRanges$1(sel));\n      const fragment = args.contextual ? read$3(SugarElement.fromDom(editor.getBody()), ranges, editor.schema).dom : rng.cloneContents();\n      if (fragment) {\n        tmpElm.appendChild(fragment);\n      }\n      return editor.selection.serializer.serialize(tmpElm, args);\n    };\n    const extractSelectedContent = (editor, args) => {\n      if (args.format === 'text') {\n        return getTextContent(editor);\n      } else {\n        const content = getSerializedContent(editor, args);\n        if (args.format === 'tree') {\n          return content;\n        } else {\n          return editor.selection.isCollapsed() ? '' : content;\n        }\n      }\n    };\n    const setupArgs$3 = (args, format) => ({\n      ...args,\n      format,\n      get: true,\n      selection: true,\n      getInner: true\n    });\n    const getSelectedContentInternal = (editor, format, args = {}) => {\n      const defaultedArgs = setupArgs$3(args, format);\n      return preProcessGetContent(editor, defaultedArgs).fold(identity, updatedArgs => {\n        const content = extractSelectedContent(editor, updatedArgs);\n        return postProcessGetContent(editor, content, updatedArgs);\n      });\n    };\n\n    const KEEP = 0, INSERT = 1, DELETE = 2;\n    const diff = (left, right) => {\n      const size = left.length + right.length + 2;\n      const vDown = new Array(size);\n      const vUp = new Array(size);\n      const snake = (start, end, diag) => {\n        return {\n          start,\n          end,\n          diag\n        };\n      };\n      const buildScript = (start1, end1, start2, end2, script) => {\n        const middle = getMiddleSnake(start1, end1, start2, end2);\n        if (middle === null || middle.start === end1 && middle.diag === end1 - end2 || middle.end === start1 && middle.diag === start1 - start2) {\n          let i = start1;\n          let j = start2;\n          while (i < end1 || j < end2) {\n            if (i < end1 && j < end2 && left[i] === right[j]) {\n              script.push([\n                KEEP,\n                left[i]\n              ]);\n              ++i;\n              ++j;\n            } else {\n              if (end1 - start1 > end2 - start2) {\n                script.push([\n                  DELETE,\n                  left[i]\n                ]);\n                ++i;\n              } else {\n                script.push([\n                  INSERT,\n                  right[j]\n                ]);\n                ++j;\n              }\n            }\n          }\n        } else {\n          buildScript(start1, middle.start, start2, middle.start - middle.diag, script);\n          for (let i2 = middle.start; i2 < middle.end; ++i2) {\n            script.push([\n              KEEP,\n              left[i2]\n            ]);\n          }\n          buildScript(middle.end, end1, middle.end - middle.diag, end2, script);\n        }\n      };\n      const buildSnake = (start, diag, end1, end2) => {\n        let end = start;\n        while (end - diag < end2 && end < end1 && left[end] === right[end - diag]) {\n          ++end;\n        }\n        return snake(start, end, diag);\n      };\n      const getMiddleSnake = (start1, end1, start2, end2) => {\n        const m = end1 - start1;\n        const n = end2 - start2;\n        if (m === 0 || n === 0) {\n          return null;\n        }\n        const delta = m - n;\n        const sum = n + m;\n        const offset = (sum % 2 === 0 ? sum : sum + 1) / 2;\n        vDown[1 + offset] = start1;\n        vUp[1 + offset] = end1 + 1;\n        let d, k, i, x, y;\n        for (d = 0; d <= offset; ++d) {\n          for (k = -d; k <= d; k += 2) {\n            i = k + offset;\n            if (k === -d || k !== d && vDown[i - 1] < vDown[i + 1]) {\n              vDown[i] = vDown[i + 1];\n            } else {\n              vDown[i] = vDown[i - 1] + 1;\n            }\n            x = vDown[i];\n            y = x - start1 + start2 - k;\n            while (x < end1 && y < end2 && left[x] === right[y]) {\n              vDown[i] = ++x;\n              ++y;\n            }\n            if (delta % 2 !== 0 && delta - d <= k && k <= delta + d) {\n              if (vUp[i - delta] <= vDown[i]) {\n                return buildSnake(vUp[i - delta], k + start1 - start2, end1, end2);\n              }\n            }\n          }\n          for (k = delta - d; k <= delta + d; k += 2) {\n            i = k + offset - delta;\n            if (k === delta - d || k !== delta + d && vUp[i + 1] <= vUp[i - 1]) {\n              vUp[i] = vUp[i + 1] - 1;\n            } else {\n              vUp[i] = vUp[i - 1];\n            }\n            x = vUp[i] - 1;\n            y = x - start1 + start2 - k;\n            while (x >= start1 && y >= start2 && left[x] === right[y]) {\n              vUp[i] = x--;\n              y--;\n            }\n            if (delta % 2 === 0 && -d <= k && k <= d) {\n              if (vUp[i] <= vDown[i + delta]) {\n                return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n              }\n            }\n          }\n        }\n        return null;\n      };\n      const script = [];\n      buildScript(0, left.length, 0, right.length, script);\n      return script;\n    };\n\n    const getOuterHtml = elm => {\n      if (isElement$6(elm)) {\n        return elm.outerHTML;\n      } else if (isText$b(elm)) {\n        return Entities.encodeRaw(elm.data, false);\n      } else if (isComment(elm)) {\n        return '<!--' + elm.data + '-->';\n      }\n      return '';\n    };\n    const createFragment = html => {\n      let node;\n      const container = document.createElement('div');\n      const frag = document.createDocumentFragment();\n      if (html) {\n        container.innerHTML = html;\n      }\n      while (node = container.firstChild) {\n        frag.appendChild(node);\n      }\n      return frag;\n    };\n    const insertAt = (elm, html, index) => {\n      const fragment = createFragment(html);\n      if (elm.hasChildNodes() && index < elm.childNodes.length) {\n        const target = elm.childNodes[index];\n        elm.insertBefore(fragment, target);\n      } else {\n        elm.appendChild(fragment);\n      }\n    };\n    const removeAt = (elm, index) => {\n      if (elm.hasChildNodes() && index < elm.childNodes.length) {\n        const target = elm.childNodes[index];\n        elm.removeChild(target);\n      }\n    };\n    const applyDiff = (diff, elm) => {\n      let index = 0;\n      each$e(diff, action => {\n        if (action[0] === KEEP) {\n          index++;\n        } else if (action[0] === INSERT) {\n          insertAt(elm, action[1], index);\n          index++;\n        } else if (action[0] === DELETE) {\n          removeAt(elm, index);\n        }\n      });\n    };\n    const read$2 = (elm, trimZwsp) => filter$5(map$3(from(elm.childNodes), trimZwsp ? compose(trim$2, getOuterHtml) : getOuterHtml), item => {\n      return item.length > 0;\n    });\n    const write = (fragments, elm) => {\n      const currentFragments = map$3(from(elm.childNodes), getOuterHtml);\n      applyDiff(diff(currentFragments, fragments), elm);\n      return elm;\n    };\n\n    const lazyTempDocument = cached(() => document.implementation.createHTMLDocument('undo'));\n    const hasIframes = body => body.querySelector('iframe') !== null;\n    const createFragmentedLevel = fragments => {\n      return {\n        type: 'fragmented',\n        fragments,\n        content: '',\n        bookmark: null,\n        beforeBookmark: null\n      };\n    };\n    const createCompleteLevel = content => {\n      return {\n        type: 'complete',\n        fragments: null,\n        content,\n        bookmark: null,\n        beforeBookmark: null\n      };\n    };\n    const createFromEditor = editor => {\n      const tempAttrs = editor.serializer.getTempAttrs();\n      const body = trim$1(editor.getBody(), tempAttrs);\n      return hasIframes(body) ? createFragmentedLevel(read$2(body, true)) : createCompleteLevel(trim$2(body.innerHTML));\n    };\n    const applyToEditor = (editor, level, before) => {\n      const bookmark = before ? level.beforeBookmark : level.bookmark;\n      if (level.type === 'fragmented') {\n        write(level.fragments, editor.getBody());\n      } else {\n        editor.setContent(level.content, {\n          format: 'raw',\n          no_selection: isNonNullable(bookmark) && isPathBookmark(bookmark) ? !bookmark.isFakeCaret : true\n        });\n      }\n      if (bookmark) {\n        editor.selection.moveToBookmark(bookmark);\n        editor.selection.scrollIntoView();\n      }\n    };\n    const getLevelContent = level => {\n      return level.type === 'fragmented' ? level.fragments.join('') : level.content;\n    };\n    const getCleanLevelContent = level => {\n      const elm = SugarElement.fromTag('body', lazyTempDocument());\n      set$1(elm, getLevelContent(level));\n      each$e(descendants(elm, '*[data-mce-bogus]'), unwrap);\n      return get$6(elm);\n    };\n    const hasEqualContent = (level1, level2) => getLevelContent(level1) === getLevelContent(level2);\n    const hasEqualCleanedContent = (level1, level2) => getCleanLevelContent(level1) === getCleanLevelContent(level2);\n    const isEq$1 = (level1, level2) => {\n      if (!level1 || !level2) {\n        return false;\n      } else if (hasEqualContent(level1, level2)) {\n        return true;\n      } else {\n        return hasEqualCleanedContent(level1, level2);\n      }\n    };\n\n    const isUnlocked = locks => locks.get() === 0;\n\n    const setTyping = (undoManager, typing, locks) => {\n      if (isUnlocked(locks)) {\n        undoManager.typing = typing;\n      }\n    };\n    const endTyping = (undoManager, locks) => {\n      if (undoManager.typing) {\n        setTyping(undoManager, false, locks);\n        undoManager.add();\n      }\n    };\n    const endTypingLevelIgnoreLocks = undoManager => {\n      if (undoManager.typing) {\n        undoManager.typing = false;\n        undoManager.add();\n      }\n    };\n\n    const beforeChange$1 = (editor, locks, beforeBookmark) => {\n      if (isUnlocked(locks)) {\n        beforeBookmark.set(getUndoBookmark(editor.selection));\n      }\n    };\n    const addUndoLevel$1 = (editor, undoManager, index, locks, beforeBookmark, level, event) => {\n      const currentLevel = createFromEditor(editor);\n      const newLevel = Tools.extend(level || {}, currentLevel);\n      if (!isUnlocked(locks) || editor.removed) {\n        return null;\n      }\n      const lastLevel = undoManager.data[index.get()];\n      if (editor.dispatch('BeforeAddUndo', {\n          level: newLevel,\n          lastLevel,\n          originalEvent: event\n        }).isDefaultPrevented()) {\n        return null;\n      }\n      if (lastLevel && isEq$1(lastLevel, newLevel)) {\n        return null;\n      }\n      if (undoManager.data[index.get()]) {\n        beforeBookmark.get().each(bm => {\n          undoManager.data[index.get()].beforeBookmark = bm;\n        });\n      }\n      const customUndoRedoLevels = getCustomUndoRedoLevels(editor);\n      if (customUndoRedoLevels) {\n        if (undoManager.data.length > customUndoRedoLevels) {\n          for (let i = 0; i < undoManager.data.length - 1; i++) {\n            undoManager.data[i] = undoManager.data[i + 1];\n          }\n          undoManager.data.length--;\n          index.set(undoManager.data.length);\n        }\n      }\n      newLevel.bookmark = getUndoBookmark(editor.selection);\n      if (index.get() < undoManager.data.length - 1) {\n        undoManager.data.length = index.get() + 1;\n      }\n      undoManager.data.push(newLevel);\n      index.set(undoManager.data.length - 1);\n      const args = {\n        level: newLevel,\n        lastLevel,\n        originalEvent: event\n      };\n      if (index.get() > 0) {\n        editor.setDirty(true);\n        editor.dispatch('AddUndo', args);\n        editor.dispatch('change', args);\n      } else {\n        editor.dispatch('AddUndo', args);\n      }\n      return newLevel;\n    };\n    const clear$1 = (editor, undoManager, index) => {\n      undoManager.data = [];\n      index.set(0);\n      undoManager.typing = false;\n      editor.dispatch('ClearUndos');\n    };\n    const extra$1 = (editor, undoManager, index, callback1, callback2) => {\n      if (undoManager.transact(callback1)) {\n        const bookmark = undoManager.data[index.get()].bookmark;\n        const lastLevel = undoManager.data[index.get() - 1];\n        applyToEditor(editor, lastLevel, true);\n        if (undoManager.transact(callback2)) {\n          undoManager.data[index.get() - 1].beforeBookmark = bookmark;\n        }\n      }\n    };\n    const redo$1 = (editor, index, data) => {\n      let level;\n      if (index.get() < data.length - 1) {\n        index.set(index.get() + 1);\n        level = data[index.get()];\n        applyToEditor(editor, level, false);\n        editor.setDirty(true);\n        editor.dispatch('Redo', { level });\n      }\n      return level;\n    };\n    const undo$1 = (editor, undoManager, locks, index) => {\n      let level;\n      if (undoManager.typing) {\n        undoManager.add();\n        undoManager.typing = false;\n        setTyping(undoManager, false, locks);\n      }\n      if (index.get() > 0) {\n        index.set(index.get() - 1);\n        level = undoManager.data[index.get()];\n        applyToEditor(editor, level, true);\n        editor.setDirty(true);\n        editor.dispatch('Undo', { level });\n      }\n      return level;\n    };\n    const reset$1 = undoManager => {\n      undoManager.clear();\n      undoManager.add();\n    };\n    const hasUndo$1 = (editor, undoManager, index) => index.get() > 0 || undoManager.typing && undoManager.data[0] && !isEq$1(createFromEditor(editor), undoManager.data[0]);\n    const hasRedo$1 = (undoManager, index) => index.get() < undoManager.data.length - 1 && !undoManager.typing;\n    const transact$1 = (undoManager, locks, callback) => {\n      endTyping(undoManager, locks);\n      undoManager.beforeChange();\n      undoManager.ignore(callback);\n      return undoManager.add();\n    };\n    const ignore$1 = (locks, callback) => {\n      try {\n        locks.set(locks.get() + 1);\n        callback();\n      } finally {\n        locks.set(locks.get() - 1);\n      }\n    };\n\n    const addVisualInternal = (editor, elm) => {\n      const dom = editor.dom;\n      const scope = isNonNullable(elm) ? elm : editor.getBody();\n      each$e(dom.select('table,a', scope), matchedElm => {\n        switch (matchedElm.nodeName) {\n        case 'TABLE':\n          const cls = getVisualAidsTableClass(editor);\n          const value = dom.getAttrib(matchedElm, 'border');\n          if ((!value || value === '0') && editor.hasVisual) {\n            dom.addClass(matchedElm, cls);\n          } else {\n            dom.removeClass(matchedElm, cls);\n          }\n          break;\n        case 'A':\n          if (!dom.getAttrib(matchedElm, 'href')) {\n            const value = dom.getAttrib(matchedElm, 'name') || matchedElm.id;\n            const cls = getVisualAidsAnchorClass(editor);\n            if (value && editor.hasVisual) {\n              dom.addClass(matchedElm, cls);\n            } else {\n              dom.removeClass(matchedElm, cls);\n            }\n          }\n          break;\n        }\n      });\n      editor.dispatch('VisualAid', {\n        element: elm,\n        hasVisual: editor.hasVisual\n      });\n    };\n\n    const makePlainAdaptor = editor => ({\n      init: { bindEvents: noop },\n      undoManager: {\n        beforeChange: (locks, beforeBookmark) => beforeChange$1(editor, locks, beforeBookmark),\n        add: (undoManager, index, locks, beforeBookmark, level, event) => addUndoLevel$1(editor, undoManager, index, locks, beforeBookmark, level, event),\n        undo: (undoManager, locks, index) => undo$1(editor, undoManager, locks, index),\n        redo: (index, data) => redo$1(editor, index, data),\n        clear: (undoManager, index) => clear$1(editor, undoManager, index),\n        reset: undoManager => reset$1(undoManager),\n        hasUndo: (undoManager, index) => hasUndo$1(editor, undoManager, index),\n        hasRedo: (undoManager, index) => hasRedo$1(undoManager, index),\n        transact: (undoManager, locks, callback) => transact$1(undoManager, locks, callback),\n        ignore: (locks, callback) => ignore$1(locks, callback),\n        extra: (undoManager, index, callback1, callback2) => extra$1(editor, undoManager, index, callback1, callback2)\n      },\n      formatter: {\n        match: (name, vars, node, similar) => match$2(editor, name, vars, node, similar),\n        matchAll: (names, vars) => matchAll(editor, names, vars),\n        matchNode: (node, name, vars, similar) => matchNode(editor, node, name, vars, similar),\n        canApply: name => canApply(editor, name),\n        closest: names => closest(editor, names),\n        apply: (name, vars, node) => applyFormat$1(editor, name, vars, node),\n        remove: (name, vars, node, similar) => removeFormat$1(editor, name, vars, node, similar),\n        toggle: (name, vars, node) => toggle(editor, name, vars, node),\n        formatChanged: (registeredFormatListeners, formats, callback, similar, vars) => formatChangedInternal(editor, registeredFormatListeners, formats, callback, similar, vars)\n      },\n      editor: {\n        getContent: args => getContentInternal(editor, args),\n        setContent: (content, args) => setContentInternal(editor, content, args),\n        insertContent: (value, details) => insertHtmlAtCaret(editor, value, details),\n        addVisual: elm => addVisualInternal(editor, elm)\n      },\n      selection: { getContent: (format, args) => getSelectedContentInternal(editor, format, args) },\n      autocompleter: {\n        addDecoration: noop,\n        removeDecoration: noop\n      },\n      raw: { getModel: () => Optional.none() }\n    });\n    const makeRtcAdaptor = rtcEditor => {\n      const defaultVars = vars => isObject(vars) ? vars : {};\n      const {init, undoManager, formatter, editor, selection, autocompleter, raw} = rtcEditor;\n      return {\n        init: { bindEvents: init.bindEvents },\n        undoManager: {\n          beforeChange: undoManager.beforeChange,\n          add: undoManager.add,\n          undo: undoManager.undo,\n          redo: undoManager.redo,\n          clear: undoManager.clear,\n          reset: undoManager.reset,\n          hasUndo: undoManager.hasUndo,\n          hasRedo: undoManager.hasRedo,\n          transact: (_undoManager, _locks, fn) => undoManager.transact(fn),\n          ignore: (_locks, callback) => undoManager.ignore(callback),\n          extra: (_undoManager, _index, callback1, callback2) => undoManager.extra(callback1, callback2)\n        },\n        formatter: {\n          match: (name, vars, _node, similar) => formatter.match(name, defaultVars(vars), similar),\n          matchAll: formatter.matchAll,\n          matchNode: formatter.matchNode,\n          canApply: name => formatter.canApply(name),\n          closest: names => formatter.closest(names),\n          apply: (name, vars, _node) => formatter.apply(name, defaultVars(vars)),\n          remove: (name, vars, _node, _similar) => formatter.remove(name, defaultVars(vars)),\n          toggle: (name, vars, _node) => formatter.toggle(name, defaultVars(vars)),\n          formatChanged: (_rfl, formats, callback, similar, vars) => formatter.formatChanged(formats, callback, similar, vars)\n        },\n        editor: {\n          getContent: args => editor.getContent(args),\n          setContent: (content, args) => {\n            return {\n              content: editor.setContent(content, args),\n              html: ''\n            };\n          },\n          insertContent: (content, _details) => {\n            editor.insertContent(content);\n            return '';\n          },\n          addVisual: editor.addVisual\n        },\n        selection: { getContent: (_format, args) => selection.getContent(args) },\n        autocompleter: {\n          addDecoration: autocompleter.addDecoration,\n          removeDecoration: autocompleter.removeDecoration\n        },\n        raw: { getModel: () => Optional.some(raw.getRawModel()) }\n      };\n    };\n    const makeNoopAdaptor = () => {\n      const nul = constant(null);\n      const empty = constant('');\n      return {\n        init: { bindEvents: noop },\n        undoManager: {\n          beforeChange: noop,\n          add: nul,\n          undo: nul,\n          redo: nul,\n          clear: noop,\n          reset: noop,\n          hasUndo: never,\n          hasRedo: never,\n          transact: nul,\n          ignore: noop,\n          extra: noop\n        },\n        formatter: {\n          match: never,\n          matchAll: constant([]),\n          matchNode: constant(undefined),\n          canApply: never,\n          closest: empty,\n          apply: noop,\n          remove: noop,\n          toggle: noop,\n          formatChanged: constant({ unbind: noop })\n        },\n        editor: {\n          getContent: empty,\n          setContent: constant({\n            content: '',\n            html: ''\n          }),\n          insertContent: constant(''),\n          addVisual: noop\n        },\n        selection: { getContent: empty },\n        autocompleter: {\n          addDecoration: noop,\n          removeDecoration: noop\n        },\n        raw: { getModel: constant(Optional.none()) }\n      };\n    };\n    const isRtc = editor => has$2(editor.plugins, 'rtc');\n    const getRtcSetup = editor => get$a(editor.plugins, 'rtc').bind(rtcPlugin => Optional.from(rtcPlugin.setup));\n    const setup$t = editor => {\n      const editorCast = editor;\n      return getRtcSetup(editor).fold(() => {\n        editorCast.rtcInstance = makePlainAdaptor(editor);\n        return Optional.none();\n      }, setup => {\n        editorCast.rtcInstance = makeNoopAdaptor();\n        return Optional.some(() => setup().then(rtcEditor => {\n          editorCast.rtcInstance = makeRtcAdaptor(rtcEditor);\n          return rtcEditor.rtc.isRemote;\n        }));\n      });\n    };\n    const getRtcInstanceWithFallback = editor => editor.rtcInstance ? editor.rtcInstance : makePlainAdaptor(editor);\n    const getRtcInstanceWithError = editor => {\n      const rtcInstance = editor.rtcInstance;\n      if (!rtcInstance) {\n        throw new Error('Failed to get RTC instance not yet initialized.');\n      } else {\n        return rtcInstance;\n      }\n    };\n    const beforeChange = (editor, locks, beforeBookmark) => {\n      getRtcInstanceWithError(editor).undoManager.beforeChange(locks, beforeBookmark);\n    };\n    const addUndoLevel = (editor, undoManager, index, locks, beforeBookmark, level, event) => getRtcInstanceWithError(editor).undoManager.add(undoManager, index, locks, beforeBookmark, level, event);\n    const undo = (editor, undoManager, locks, index) => getRtcInstanceWithError(editor).undoManager.undo(undoManager, locks, index);\n    const redo = (editor, index, data) => getRtcInstanceWithError(editor).undoManager.redo(index, data);\n    const clear = (editor, undoManager, index) => {\n      getRtcInstanceWithError(editor).undoManager.clear(undoManager, index);\n    };\n    const reset = (editor, undoManager) => {\n      getRtcInstanceWithError(editor).undoManager.reset(undoManager);\n    };\n    const hasUndo = (editor, undoManager, index) => getRtcInstanceWithError(editor).undoManager.hasUndo(undoManager, index);\n    const hasRedo = (editor, undoManager, index) => getRtcInstanceWithError(editor).undoManager.hasRedo(undoManager, index);\n    const transact = (editor, undoManager, locks, callback) => getRtcInstanceWithError(editor).undoManager.transact(undoManager, locks, callback);\n    const ignore = (editor, locks, callback) => {\n      getRtcInstanceWithError(editor).undoManager.ignore(locks, callback);\n    };\n    const extra = (editor, undoManager, index, callback1, callback2) => {\n      getRtcInstanceWithError(editor).undoManager.extra(undoManager, index, callback1, callback2);\n    };\n    const matchFormat = (editor, name, vars, node, similar) => getRtcInstanceWithError(editor).formatter.match(name, vars, node, similar);\n    const matchAllFormats = (editor, names, vars) => getRtcInstanceWithError(editor).formatter.matchAll(names, vars);\n    const matchNodeFormat = (editor, node, name, vars, similar) => getRtcInstanceWithError(editor).formatter.matchNode(node, name, vars, similar);\n    const canApplyFormat = (editor, name) => getRtcInstanceWithError(editor).formatter.canApply(name);\n    const closestFormat = (editor, names) => getRtcInstanceWithError(editor).formatter.closest(names);\n    const applyFormat = (editor, name, vars, node) => {\n      getRtcInstanceWithError(editor).formatter.apply(name, vars, node);\n    };\n    const removeFormat = (editor, name, vars, node, similar) => {\n      getRtcInstanceWithError(editor).formatter.remove(name, vars, node, similar);\n    };\n    const toggleFormat = (editor, name, vars, node) => {\n      getRtcInstanceWithError(editor).formatter.toggle(name, vars, node);\n    };\n    const formatChanged = (editor, registeredFormatListeners, formats, callback, similar, vars) => getRtcInstanceWithError(editor).formatter.formatChanged(registeredFormatListeners, formats, callback, similar, vars);\n    const getContent$2 = (editor, args) => getRtcInstanceWithFallback(editor).editor.getContent(args);\n    const setContent$2 = (editor, content, args) => getRtcInstanceWithFallback(editor).editor.setContent(content, args);\n    const insertContent$1 = (editor, value, details) => getRtcInstanceWithFallback(editor).editor.insertContent(value, details);\n    const getSelectedContent = (editor, format, args) => getRtcInstanceWithError(editor).selection.getContent(format, args);\n    const addVisual$1 = (editor, elm) => getRtcInstanceWithError(editor).editor.addVisual(elm);\n    const bindEvents = editor => getRtcInstanceWithError(editor).init.bindEvents();\n\n    const getContent$1 = (editor, args = {}) => {\n      const format = args.format ? args.format : 'html';\n      return getSelectedContent(editor, format, args);\n    };\n\n    const removeEmpty = text => {\n      if (text.dom.length === 0) {\n        remove$4(text);\n        return Optional.none();\n      } else {\n        return Optional.some(text);\n      }\n    };\n    const walkPastBookmark = (node, start) => node.filter(elm => BookmarkManager.isBookmarkNode(elm.dom)).bind(start ? nextSibling : prevSibling);\n    const merge$1 = (outer, inner, rng, start, schema) => {\n      const outerElm = outer.dom;\n      const innerElm = inner.dom;\n      const oldLength = start ? outerElm.length : innerElm.length;\n      if (start) {\n        mergeTextNodes(outerElm, innerElm, schema, false, !start);\n        rng.setStart(innerElm, oldLength);\n      } else {\n        mergeTextNodes(innerElm, outerElm, schema, false, !start);\n        rng.setEnd(innerElm, oldLength);\n      }\n    };\n    const normalizeTextIfRequired = (inner, start, schema) => {\n      parent(inner).each(root => {\n        const text = inner.dom;\n        if (start && needsToBeNbspLeft(root, CaretPosition(text, 0), schema)) {\n          normalizeWhitespaceAfter(text, 0, schema);\n        } else if (!start && needsToBeNbspRight(root, CaretPosition(text, text.length), schema)) {\n          normalizeWhitespaceBefore(text, text.length, schema);\n        }\n      });\n    };\n    const mergeAndNormalizeText = (outerNode, innerNode, rng, start, schema) => {\n      outerNode.bind(outer => {\n        const normalizer = start ? normalizeWhitespaceBefore : normalizeWhitespaceAfter;\n        normalizer(outer.dom, start ? outer.dom.length : 0, schema);\n        return innerNode.filter(isText$c).map(inner => merge$1(outer, inner, rng, start, schema));\n      }).orThunk(() => {\n        const innerTextNode = walkPastBookmark(innerNode, start).or(innerNode).filter(isText$c);\n        return innerTextNode.map(inner => normalizeTextIfRequired(inner, start, schema));\n      });\n    };\n    const rngSetContent = (rng, fragment, schema) => {\n      const firstChild = Optional.from(fragment.firstChild).map(SugarElement.fromDom);\n      const lastChild = Optional.from(fragment.lastChild).map(SugarElement.fromDom);\n      rng.deleteContents();\n      rng.insertNode(fragment);\n      const prevText = firstChild.bind(prevSibling).filter(isText$c).bind(removeEmpty);\n      const nextText = lastChild.bind(nextSibling).filter(isText$c).bind(removeEmpty);\n      mergeAndNormalizeText(prevText, firstChild, rng, true, schema);\n      mergeAndNormalizeText(nextText, lastChild, rng, false, schema);\n      rng.collapse(false);\n    };\n    const setupArgs$2 = (args, content) => ({\n      format: 'html',\n      ...args,\n      set: true,\n      selection: true,\n      content\n    });\n    const cleanContent = (editor, args) => {\n      if (args.format !== 'raw') {\n        const rng = editor.selection.getRng();\n        const contextBlock = editor.dom.getParent(rng.commonAncestorContainer, editor.dom.isBlock);\n        const contextArgs = contextBlock ? { context: contextBlock.nodeName.toLowerCase() } : {};\n        const node = editor.parser.parse(args.content, {\n          forced_root_block: false,\n          ...contextArgs,\n          ...args\n        });\n        return HtmlSerializer({ validate: false }, editor.schema).serialize(node);\n      } else {\n        return args.content;\n      }\n    };\n    const setContent$1 = (editor, content, args = {}) => {\n      const defaultedArgs = setupArgs$2(args, content);\n      preProcessSetContent(editor, defaultedArgs).each(updatedArgs => {\n        const cleanedContent = cleanContent(editor, updatedArgs);\n        const rng = editor.selection.getRng();\n        rngSetContent(rng, rng.createContextualFragment(cleanedContent), editor.schema);\n        editor.selection.setRng(rng);\n        scrollRangeIntoView(editor, rng);\n        postProcessSetContent(editor, cleanedContent, updatedArgs);\n      });\n    };\n\n    const deleteFromCallbackMap = (callbackMap, selector, callback) => {\n      if (has$2(callbackMap, selector)) {\n        const newCallbacks = filter$5(callbackMap[selector], cb => cb !== callback);\n        if (newCallbacks.length === 0) {\n          delete callbackMap[selector];\n        } else {\n          callbackMap[selector] = newCallbacks;\n        }\n      }\n    };\n    var SelectorChanged = (dom, editor) => {\n      let selectorChangedData;\n      let currentSelectors;\n      const findMatchingNode = (selector, nodes) => find$2(nodes, node => dom.is(node, selector));\n      const getParents = elem => dom.getParents(elem, undefined, dom.getRoot());\n      const setup = () => {\n        selectorChangedData = {};\n        currentSelectors = {};\n        editor.on('NodeChange', e => {\n          const node = e.element;\n          const parents = getParents(node);\n          const matchedSelectors = {};\n          each$d(selectorChangedData, (callbacks, selector) => {\n            findMatchingNode(selector, parents).each(node => {\n              if (!currentSelectors[selector]) {\n                each$e(callbacks, callback => {\n                  callback(true, {\n                    node,\n                    selector,\n                    parents\n                  });\n                });\n                currentSelectors[selector] = callbacks;\n              }\n              matchedSelectors[selector] = callbacks;\n            });\n          });\n          each$d(currentSelectors, (callbacks, selector) => {\n            if (!matchedSelectors[selector]) {\n              delete currentSelectors[selector];\n              each$e(callbacks, callback => {\n                callback(false, {\n                  node,\n                  selector,\n                  parents\n                });\n              });\n            }\n          });\n        });\n      };\n      return {\n        selectorChangedWithUnbind: (selector, callback) => {\n          if (!selectorChangedData) {\n            setup();\n          }\n          if (!selectorChangedData[selector]) {\n            selectorChangedData[selector] = [];\n          }\n          selectorChangedData[selector].push(callback);\n          findMatchingNode(selector, getParents(editor.selection.getStart())).each(() => {\n            currentSelectors[selector] = selectorChangedData[selector];\n          });\n          return {\n            unbind: () => {\n              deleteFromCallbackMap(selectorChangedData, selector, callback);\n              deleteFromCallbackMap(currentSelectors, selector, callback);\n            }\n          };\n        }\n      };\n    };\n\n    const isAttachedToDom = node => {\n      return !!(node && node.ownerDocument) && contains(SugarElement.fromDom(node.ownerDocument), SugarElement.fromDom(node));\n    };\n    const isValidRange = rng => {\n      if (!rng) {\n        return false;\n      } else {\n        return isAttachedToDom(rng.startContainer) && isAttachedToDom(rng.endContainer);\n      }\n    };\n    const EditorSelection = (dom, win, serializer, editor) => {\n      let selectedRange;\n      let explicitRange;\n      const {selectorChangedWithUnbind} = SelectorChanged(dom, editor);\n      const setCursorLocation = (node, offset) => {\n        const rng = dom.createRng();\n        if (isNonNullable(node) && isNonNullable(offset)) {\n          rng.setStart(node, offset);\n          rng.setEnd(node, offset);\n          setRng(rng);\n          collapse(false);\n        } else {\n          moveEndPoint(dom, rng, editor.getBody(), true);\n          setRng(rng);\n        }\n      };\n      const getContent = args => getContent$1(editor, args);\n      const setContent = (content, args) => setContent$1(editor, content, args);\n      const getStart$1 = real => getStart(editor.getBody(), getRng$1(), real);\n      const getEnd$1 = real => getEnd(editor.getBody(), getRng$1(), real);\n      const getBookmark = (type, normalized) => bookmarkManager.getBookmark(type, normalized);\n      const moveToBookmark = bookmark => bookmarkManager.moveToBookmark(bookmark);\n      const select$1 = (node, content) => {\n        select(dom, node, content).each(setRng);\n        return node;\n      };\n      const isCollapsed = () => {\n        const rng = getRng$1(), sel = getSel();\n        if (!rng || rng.item) {\n          return false;\n        }\n        if (rng.compareEndPoints) {\n          return rng.compareEndPoints('StartToEnd', rng) === 0;\n        }\n        return !sel || rng.collapsed;\n      };\n      const isEditable = () => {\n        if (editor.mode.isReadOnly()) {\n          return false;\n        }\n        const rng = getRng$1();\n        const fakeSelectedElements = editor.getBody().querySelectorAll('[data-mce-selected=\"1\"]');\n        if (fakeSelectedElements.length > 0) {\n          return forall(fakeSelectedElements, el => dom.isEditable(el.parentElement));\n        } else {\n          return isEditableRange(dom, rng);\n        }\n      };\n      const collapse = toStart => {\n        const rng = getRng$1();\n        rng.collapse(!!toStart);\n        setRng(rng);\n      };\n      const getSel = () => win.getSelection ? win.getSelection() : win.document.selection;\n      const getRng$1 = () => {\n        let rng;\n        const tryCompareBoundaryPoints = (how, sourceRange, destinationRange) => {\n          try {\n            return sourceRange.compareBoundaryPoints(how, destinationRange);\n          } catch (ex) {\n            return -1;\n          }\n        };\n        const doc = win.document;\n        if (isNonNullable(editor.bookmark) && !hasFocus(editor)) {\n          const bookmark = getRng(editor);\n          if (bookmark.isSome()) {\n            return bookmark.map(r => processRanges(editor, [r])[0]).getOr(doc.createRange());\n          }\n        }\n        try {\n          const selection = getSel();\n          if (selection && !isRestrictedNode(selection.anchorNode)) {\n            if (selection.rangeCount > 0) {\n              rng = selection.getRangeAt(0);\n            } else {\n              rng = doc.createRange();\n            }\n            rng = processRanges(editor, [rng])[0];\n          }\n        } catch (ex) {\n        }\n        if (!rng) {\n          rng = doc.createRange();\n        }\n        if (isDocument$1(rng.startContainer) && rng.collapsed) {\n          const elm = dom.getRoot();\n          rng.setStart(elm, 0);\n          rng.setEnd(elm, 0);\n        }\n        if (selectedRange && explicitRange) {\n          if (tryCompareBoundaryPoints(rng.START_TO_START, rng, selectedRange) === 0 && tryCompareBoundaryPoints(rng.END_TO_END, rng, selectedRange) === 0) {\n            rng = explicitRange;\n          } else {\n            selectedRange = null;\n            explicitRange = null;\n          }\n        }\n        return rng;\n      };\n      const setRng = (rng, forward) => {\n        if (!isValidRange(rng)) {\n          return;\n        }\n        const sel = getSel();\n        const evt = editor.dispatch('SetSelectionRange', {\n          range: rng,\n          forward\n        });\n        rng = evt.range;\n        if (sel) {\n          explicitRange = rng;\n          try {\n            sel.removeAllRanges();\n            sel.addRange(rng);\n          } catch (ex) {\n          }\n          if (forward === false && sel.extend) {\n            sel.collapse(rng.endContainer, rng.endOffset);\n            sel.extend(rng.startContainer, rng.startOffset);\n          }\n          selectedRange = sel.rangeCount > 0 ? sel.getRangeAt(0) : null;\n        }\n        if (!rng.collapsed && rng.startContainer === rng.endContainer && (sel === null || sel === void 0 ? void 0 : sel.setBaseAndExtent)) {\n          if (rng.endOffset - rng.startOffset < 2) {\n            if (rng.startContainer.hasChildNodes()) {\n              const node = rng.startContainer.childNodes[rng.startOffset];\n              if (node && node.nodeName === 'IMG') {\n                sel.setBaseAndExtent(rng.startContainer, rng.startOffset, rng.endContainer, rng.endOffset);\n                if (sel.anchorNode !== rng.startContainer || sel.focusNode !== rng.endContainer) {\n                  sel.setBaseAndExtent(node, 0, node, 1);\n                }\n              }\n            }\n          }\n        }\n        editor.dispatch('AfterSetSelectionRange', {\n          range: rng,\n          forward\n        });\n      };\n      const setNode = elm => {\n        setContent(dom.getOuterHTML(elm));\n        return elm;\n      };\n      const getNode$1 = () => getNode(editor.getBody(), getRng$1());\n      const getSelectedBlocks$1 = (startElm, endElm) => getSelectedBlocks(dom, getRng$1(), startElm, endElm);\n      const isForward = () => {\n        const sel = getSel();\n        const anchorNode = sel === null || sel === void 0 ? void 0 : sel.anchorNode;\n        const focusNode = sel === null || sel === void 0 ? void 0 : sel.focusNode;\n        if (!sel || !anchorNode || !focusNode || isRestrictedNode(anchorNode) || isRestrictedNode(focusNode)) {\n          return true;\n        }\n        const anchorRange = dom.createRng();\n        const focusRange = dom.createRng();\n        try {\n          anchorRange.setStart(anchorNode, sel.anchorOffset);\n          anchorRange.collapse(true);\n          focusRange.setStart(focusNode, sel.focusOffset);\n          focusRange.collapse(true);\n        } catch (e) {\n          return true;\n        }\n        return anchorRange.compareBoundaryPoints(anchorRange.START_TO_START, focusRange) <= 0;\n      };\n      const normalize = () => {\n        const rng = getRng$1();\n        const sel = getSel();\n        if (!hasMultipleRanges(sel) && hasAnyRanges(editor)) {\n          const normRng = normalize$2(dom, rng);\n          normRng.each(normRng => {\n            setRng(normRng, isForward());\n          });\n          return normRng.getOr(rng);\n        }\n        return rng;\n      };\n      const selectorChanged = (selector, callback) => {\n        selectorChangedWithUnbind(selector, callback);\n        return exports;\n      };\n      const getScrollContainer = () => {\n        let scrollContainer;\n        let node = dom.getRoot();\n        while (node && node.nodeName !== 'BODY') {\n          if (node.scrollHeight > node.clientHeight) {\n            scrollContainer = node;\n            break;\n          }\n          node = node.parentNode;\n        }\n        return scrollContainer;\n      };\n      const scrollIntoView = (elm, alignToTop) => {\n        if (isNonNullable(elm)) {\n          scrollElementIntoView(editor, elm, alignToTop);\n        } else {\n          scrollRangeIntoView(editor, getRng$1(), alignToTop);\n        }\n      };\n      const placeCaretAt = (clientX, clientY) => setRng(fromPoint(clientX, clientY, editor.getDoc()));\n      const getBoundingClientRect = () => {\n        const rng = getRng$1();\n        return rng.collapsed ? CaretPosition.fromRangeStart(rng).getClientRects()[0] : rng.getBoundingClientRect();\n      };\n      const destroy = () => {\n        win = selectedRange = explicitRange = null;\n        controlSelection.destroy();\n      };\n      const expand = (options = { type: 'word' }) => setRng(RangeUtils(dom).expand(getRng$1(), options));\n      const exports = {\n        dom,\n        win,\n        serializer,\n        editor,\n        expand,\n        collapse,\n        setCursorLocation,\n        getContent,\n        setContent,\n        getBookmark,\n        moveToBookmark,\n        select: select$1,\n        isCollapsed,\n        isEditable,\n        isForward,\n        setNode,\n        getNode: getNode$1,\n        getSel,\n        setRng,\n        getRng: getRng$1,\n        getStart: getStart$1,\n        getEnd: getEnd$1,\n        getSelectedBlocks: getSelectedBlocks$1,\n        normalize,\n        selectorChanged,\n        selectorChangedWithUnbind,\n        getScrollContainer,\n        scrollIntoView,\n        placeCaretAt,\n        getBoundingClientRect,\n        destroy\n      };\n      const bookmarkManager = BookmarkManager(exports);\n      const controlSelection = ControlSelection(exports, editor);\n      exports.bookmarkManager = bookmarkManager;\n      exports.controlSelection = controlSelection;\n      return exports;\n    };\n\n    const addNodeFilter = (settings, htmlParser, schema) => {\n      htmlParser.addNodeFilter('br', (nodes, _, args) => {\n        const blockElements = Tools.extend({}, schema.getBlockElements());\n        const nonEmptyElements = schema.getNonEmptyElements();\n        const whitespaceElements = schema.getWhitespaceElements();\n        blockElements.body = 1;\n        const isBlock = node => node.name in blockElements || isTransparentAstBlock(schema, node);\n        for (let i = 0, l = nodes.length; i < l; i++) {\n          let node = nodes[i];\n          let parent = node.parent;\n          if (parent && isBlock(parent) && node === parent.lastChild) {\n            let prev = node.prev;\n            while (prev) {\n              const prevName = prev.name;\n              if (prevName !== 'span' || prev.attr('data-mce-type') !== 'bookmark') {\n                if (prevName === 'br') {\n                  node = null;\n                }\n                break;\n              }\n              prev = prev.prev;\n            }\n            if (node) {\n              node.remove();\n              if (isEmpty(schema, nonEmptyElements, whitespaceElements, parent)) {\n                const elementRule = schema.getElementRule(parent.name);\n                if (elementRule) {\n                  if (elementRule.removeEmpty) {\n                    parent.remove();\n                  } else if (elementRule.paddEmpty) {\n                    paddEmptyNode(settings, args, isBlock, parent);\n                  }\n                }\n              }\n            }\n          } else {\n            let lastParent = node;\n            while (parent && parent.firstChild === lastParent && parent.lastChild === lastParent) {\n              lastParent = parent;\n              if (blockElements[parent.name]) {\n                break;\n              }\n              parent = parent.parent;\n            }\n            if (lastParent === parent) {\n              const textNode = new AstNode('#text', 3);\n              textNode.value = nbsp;\n              node.replace(textNode);\n            }\n          }\n        }\n      });\n    };\n\n    const register$3 = (htmlParser, settings, dom) => {\n      htmlParser.addAttributeFilter('data-mce-tabindex', (nodes, name) => {\n        let i = nodes.length;\n        while (i--) {\n          const node = nodes[i];\n          node.attr('tabindex', node.attr('data-mce-tabindex'));\n          node.attr(name, null);\n        }\n      });\n      htmlParser.addAttributeFilter('src,href,style', (nodes, name) => {\n        const internalName = 'data-mce-' + name;\n        const urlConverter = settings.url_converter;\n        const urlConverterScope = settings.url_converter_scope;\n        let i = nodes.length;\n        while (i--) {\n          const node = nodes[i];\n          let value = node.attr(internalName);\n          if (value !== undefined) {\n            node.attr(name, value.length > 0 ? value : null);\n            node.attr(internalName, null);\n          } else {\n            value = node.attr(name);\n            if (name === 'style') {\n              value = dom.serializeStyle(dom.parseStyle(value), node.name);\n            } else if (urlConverter) {\n              value = urlConverter.call(urlConverterScope, value, name, node.name);\n            }\n            node.attr(name, value.length > 0 ? value : null);\n          }\n        }\n      });\n      htmlParser.addAttributeFilter('class', nodes => {\n        let i = nodes.length;\n        while (i--) {\n          const node = nodes[i];\n          let value = node.attr('class');\n          if (value) {\n            value = value.replace(/(?:^|\\s)mce-item-\\w+(?!\\S)/g, '');\n            node.attr('class', value.length > 0 ? value : null);\n          }\n        }\n      });\n      htmlParser.addAttributeFilter('data-mce-type', (nodes, name, args) => {\n        let i = nodes.length;\n        while (i--) {\n          const node = nodes[i];\n          if (node.attr('data-mce-type') === 'bookmark' && !args.cleanup) {\n            const hasChildren = Optional.from(node.firstChild).exists(firstChild => {\n              var _a;\n              return !isZwsp((_a = firstChild.value) !== null && _a !== void 0 ? _a : '');\n            });\n            if (hasChildren) {\n              node.unwrap();\n            } else {\n              node.remove();\n            }\n          }\n        }\n      });\n      htmlParser.addNodeFilter('script,style', (nodes, name) => {\n        var _a;\n        const trim = value => {\n          return value.replace(/(<!--\\[CDATA\\[|\\]\\]-->)/g, '\\n').replace(/^[\\r\\n]*|[\\r\\n]*$/g, '').replace(/^\\s*((<!--)?(\\s*\\/\\/)?\\s*<!\\[CDATA\\[|(<!--\\s*)?\\/\\*\\s*<!\\[CDATA\\[\\s*\\*\\/|(\\/\\/)?\\s*<!--|\\/\\*\\s*<!--\\s*\\*\\/)\\s*[\\r\\n]*/gi, '').replace(/\\s*(\\/\\*\\s*\\]\\]>\\s*\\*\\/(-->)?|\\s*\\/\\/\\s*\\]\\]>(-->)?|\\/\\/\\s*(-->)?|\\]\\]>|\\/\\*\\s*-->\\s*\\*\\/|\\s*-->\\s*)\\s*$/g, '');\n        };\n        let i = nodes.length;\n        while (i--) {\n          const node = nodes[i];\n          const firstChild = node.firstChild;\n          const value = (_a = firstChild === null || firstChild === void 0 ? void 0 : firstChild.value) !== null && _a !== void 0 ? _a : '';\n          if (name === 'script') {\n            const type = node.attr('type');\n            if (type) {\n              node.attr('type', type === 'mce-no/type' ? null : type.replace(/^mce\\-/, ''));\n            }\n            if (settings.element_format === 'xhtml' && firstChild && value.length > 0) {\n              firstChild.value = '// <![CDATA[\\n' + trim(value) + '\\n// ]]>';\n            }\n          } else {\n            if (settings.element_format === 'xhtml' && firstChild && value.length > 0) {\n              firstChild.value = '<!--\\n' + trim(value) + '\\n-->';\n            }\n          }\n        }\n      });\n      htmlParser.addNodeFilter('#comment', nodes => {\n        let i = nodes.length;\n        while (i--) {\n          const node = nodes[i];\n          const value = node.value;\n          if (settings.preserve_cdata && (value === null || value === void 0 ? void 0 : value.indexOf('[CDATA[')) === 0) {\n            node.name = '#cdata';\n            node.type = 4;\n            node.value = dom.decode(value.replace(/^\\[CDATA\\[|\\]\\]$/g, ''));\n          } else if ((value === null || value === void 0 ? void 0 : value.indexOf('mce:protected ')) === 0) {\n            node.name = '#text';\n            node.type = 3;\n            node.raw = true;\n            node.value = unescape(value).substr(14);\n          }\n        }\n      });\n      htmlParser.addNodeFilter('xml:namespace,input', (nodes, name) => {\n        let i = nodes.length;\n        while (i--) {\n          const node = nodes[i];\n          if (node.type === 7) {\n            node.remove();\n          } else if (node.type === 1) {\n            if (name === 'input' && !node.attr('type')) {\n              node.attr('type', 'text');\n            }\n          }\n        }\n      });\n      htmlParser.addAttributeFilter('data-mce-type', nodes => {\n        each$e(nodes, node => {\n          if (node.attr('data-mce-type') === 'format-caret') {\n            if (node.isEmpty(htmlParser.schema.getNonEmptyElements())) {\n              node.remove();\n            } else {\n              node.unwrap();\n            }\n          }\n        });\n      });\n      htmlParser.addAttributeFilter('data-mce-src,data-mce-href,data-mce-style,' + 'data-mce-selected,data-mce-expando,data-mce-block,' + 'data-mce-type,data-mce-resize,data-mce-placeholder', (nodes, name) => {\n        let i = nodes.length;\n        while (i--) {\n          nodes[i].attr(name, null);\n        }\n      });\n      if (settings.remove_trailing_brs) {\n        addNodeFilter(settings, htmlParser, htmlParser.schema);\n      }\n    };\n    const trimTrailingBr = rootNode => {\n      const isBr = node => {\n        return (node === null || node === void 0 ? void 0 : node.name) === 'br';\n      };\n      const brNode1 = rootNode.lastChild;\n      if (isBr(brNode1)) {\n        const brNode2 = brNode1.prev;\n        if (isBr(brNode2)) {\n          brNode1.remove();\n          brNode2.remove();\n        }\n      }\n    };\n\n    const preProcess$1 = (editor, node, args) => {\n      let oldDoc;\n      const dom = editor.dom;\n      let clonedNode = node.cloneNode(true);\n      const impl = document.implementation;\n      if (impl.createHTMLDocument) {\n        const doc = impl.createHTMLDocument('');\n        Tools.each(clonedNode.nodeName === 'BODY' ? clonedNode.childNodes : [clonedNode], node => {\n          doc.body.appendChild(doc.importNode(node, true));\n        });\n        if (clonedNode.nodeName !== 'BODY') {\n          clonedNode = doc.body.firstChild;\n        } else {\n          clonedNode = doc.body;\n        }\n        oldDoc = dom.doc;\n        dom.doc = doc;\n      }\n      firePreProcess(editor, {\n        ...args,\n        node: clonedNode\n      });\n      if (oldDoc) {\n        dom.doc = oldDoc;\n      }\n      return clonedNode;\n    };\n    const shouldFireEvent = (editor, args) => {\n      return isNonNullable(editor) && editor.hasEventListeners('PreProcess') && !args.no_events;\n    };\n    const process$1 = (editor, node, args) => {\n      return shouldFireEvent(editor, args) ? preProcess$1(editor, node, args) : node;\n    };\n\n    const addTempAttr = (htmlParser, tempAttrs, name) => {\n      if (Tools.inArray(tempAttrs, name) === -1) {\n        htmlParser.addAttributeFilter(name, (nodes, name) => {\n          let i = nodes.length;\n          while (i--) {\n            nodes[i].attr(name, null);\n          }\n        });\n        tempAttrs.push(name);\n      }\n    };\n    const postProcess = (editor, args, content) => {\n      if (!args.no_events && editor) {\n        const outArgs = firePostProcess(editor, {\n          ...args,\n          content\n        });\n        return outArgs.content;\n      } else {\n        return content;\n      }\n    };\n    const getHtmlFromNode = (dom, node, args) => {\n      const html = trim$2(args.getInner ? node.innerHTML : dom.getOuterHTML(node));\n      return args.selection || isWsPreserveElement(SugarElement.fromDom(node)) ? html : Tools.trim(html);\n    };\n    const parseHtml = (htmlParser, html, args) => {\n      const parserArgs = args.selection ? {\n        forced_root_block: false,\n        ...args\n      } : args;\n      const rootNode = htmlParser.parse(html, parserArgs);\n      trimTrailingBr(rootNode);\n      return rootNode;\n    };\n    const serializeNode = (settings, schema, node) => {\n      const htmlSerializer = HtmlSerializer(settings, schema);\n      return htmlSerializer.serialize(node);\n    };\n    const toHtml = (editor, settings, schema, rootNode, args) => {\n      const content = serializeNode(settings, schema, rootNode);\n      return postProcess(editor, args, content);\n    };\n    const DomSerializerImpl = (settings, editor) => {\n      const tempAttrs = ['data-mce-selected'];\n      const defaultedSettings = {\n        entity_encoding: 'named',\n        remove_trailing_brs: true,\n        pad_empty_with_br: false,\n        ...settings\n      };\n      const dom = editor && editor.dom ? editor.dom : DOMUtils.DOM;\n      const schema = editor && editor.schema ? editor.schema : Schema(defaultedSettings);\n      const htmlParser = DomParser(defaultedSettings, schema);\n      register$3(htmlParser, defaultedSettings, dom);\n      const serialize = (node, parserArgs = {}) => {\n        const args = {\n          format: 'html',\n          ...parserArgs\n        };\n        const targetNode = process$1(editor, node, args);\n        const html = getHtmlFromNode(dom, targetNode, args);\n        const rootNode = parseHtml(htmlParser, html, args);\n        return args.format === 'tree' ? rootNode : toHtml(editor, defaultedSettings, schema, rootNode, args);\n      };\n      return {\n        schema,\n        addNodeFilter: htmlParser.addNodeFilter,\n        addAttributeFilter: htmlParser.addAttributeFilter,\n        serialize: serialize,\n        addRules: schema.addValidElements,\n        setRules: schema.setValidElements,\n        addTempAttr: curry(addTempAttr, htmlParser, tempAttrs),\n        getTempAttrs: constant(tempAttrs),\n        getNodeFilters: htmlParser.getNodeFilters,\n        getAttributeFilters: htmlParser.getAttributeFilters,\n        removeNodeFilter: htmlParser.removeNodeFilter,\n        removeAttributeFilter: htmlParser.removeAttributeFilter\n      };\n    };\n\n    const DomSerializer = (settings, editor) => {\n      const domSerializer = DomSerializerImpl(settings, editor);\n      return {\n        schema: domSerializer.schema,\n        addNodeFilter: domSerializer.addNodeFilter,\n        addAttributeFilter: domSerializer.addAttributeFilter,\n        serialize: domSerializer.serialize,\n        addRules: domSerializer.addRules,\n        setRules: domSerializer.setRules,\n        addTempAttr: domSerializer.addTempAttr,\n        getTempAttrs: domSerializer.getTempAttrs,\n        getNodeFilters: domSerializer.getNodeFilters,\n        getAttributeFilters: domSerializer.getAttributeFilters,\n        removeNodeFilter: domSerializer.removeNodeFilter,\n        removeAttributeFilter: domSerializer.removeAttributeFilter\n      };\n    };\n\n    const defaultFormat$1 = 'html';\n    const setupArgs$1 = (args, format) => ({\n      ...args,\n      format,\n      get: true,\n      getInner: true\n    });\n    const getContent = (editor, args = {}) => {\n      const format = args.format ? args.format : defaultFormat$1;\n      const defaultedArgs = setupArgs$1(args, format);\n      return preProcessGetContent(editor, defaultedArgs).fold(identity, updatedArgs => {\n        const content = getContent$2(editor, updatedArgs);\n        return postProcessGetContent(editor, content, updatedArgs);\n      });\n    };\n\n    const defaultFormat = 'html';\n    const setupArgs = (args, content) => ({\n      format: defaultFormat,\n      ...args,\n      set: true,\n      content\n    });\n    const setContent = (editor, content, args = {}) => {\n      const defaultedArgs = setupArgs(args, content);\n      return preProcessSetContent(editor, defaultedArgs).map(updatedArgs => {\n        const result = setContent$2(editor, updatedArgs.content, updatedArgs);\n        postProcessSetContent(editor, result.html, updatedArgs);\n        return result.content;\n      }).getOr(content);\n    };\n\n    const removedOptions = ('autoresize_on_init,content_editable_state,padd_empty_with_br,block_elements,' + 'boolean_attributes,editor_deselector,editor_selector,elements,file_browser_callback_types,filepicker_validator_handler,' + 'force_hex_style_colors,force_p_newlines,gecko_spellcheck,images_dataimg_filter,media_scripts,mode,move_caret_before_on_enter_elements,' + 'non_empty_elements,self_closing_elements,short_ended_elements,special,spellchecker_select_languages,spellchecker_whitelist,' + 'tab_focus,tabfocus_elements,table_responsive_width,text_block_elements,text_inline_elements,toolbar_drawer,types,validate,whitespace_elements,' + 'paste_enable_default_filters,paste_filter_drop,paste_word_valid_elements,paste_retain_style_properties,paste_convert_word_fake_lists,' + 'template_cdate_classes,template_mdate_classes,template_selected_content_classes,template_preview_replace_values,template_replace_values,templates,template_cdate_format,template_mdate_format').split(',');\n    const deprecatedOptions = [];\n    const removedPlugins = 'bbcode,colorpicker,contextmenu,fullpage,legacyoutput,spellchecker,template,textcolor,rtc'.split(',');\n    const deprecatedPlugins = [];\n    const getMatchingOptions = (options, searchingFor) => {\n      const settingNames = filter$5(searchingFor, setting => has$2(options, setting));\n      return sort(settingNames);\n    };\n    const getRemovedOptions = options => {\n      const settingNames = getMatchingOptions(options, removedOptions);\n      const forcedRootBlock = options.forced_root_block;\n      if (forcedRootBlock === false || forcedRootBlock === '') {\n        settingNames.push('forced_root_block (false only)');\n      }\n      return sort(settingNames);\n    };\n    const getDeprecatedOptions = options => getMatchingOptions(options, deprecatedOptions);\n    const getMatchingPlugins = (options, searchingFor) => {\n      const plugins = Tools.makeMap(options.plugins, ' ');\n      const hasPlugin = plugin => has$2(plugins, plugin);\n      const pluginNames = filter$5(searchingFor, hasPlugin);\n      return sort(pluginNames);\n    };\n    const getRemovedPlugins = options => getMatchingPlugins(options, removedPlugins);\n    const getDeprecatedPlugins = options => getMatchingPlugins(options, deprecatedPlugins.map(entry => entry.name));\n    const logRemovedWarnings = (rawOptions, normalizedOptions) => {\n      const removedOptions = getRemovedOptions(rawOptions);\n      const removedPlugins = getRemovedPlugins(normalizedOptions);\n      const hasRemovedPlugins = removedPlugins.length > 0;\n      const hasRemovedOptions = removedOptions.length > 0;\n      const isLegacyMobileTheme = normalizedOptions.theme === 'mobile';\n      if (hasRemovedPlugins || hasRemovedOptions || isLegacyMobileTheme) {\n        const listJoiner = '\\n- ';\n        const themesMessage = isLegacyMobileTheme ? `\\n\\nThemes:${ listJoiner }mobile` : '';\n        const pluginsMessage = hasRemovedPlugins ? `\\n\\nPlugins:${ listJoiner }${ removedPlugins.join(listJoiner) }` : '';\n        const optionsMessage = hasRemovedOptions ? `\\n\\nOptions:${ listJoiner }${ removedOptions.join(listJoiner) }` : '';\n        console.warn('The following deprecated features are currently enabled and have been removed in TinyMCE 7.0. These features will no longer work and should be removed from the TinyMCE configuration. ' + 'See https://www.tiny.cloud/docs/tinymce/7/migration-from-6x/ for more information.' + themesMessage + pluginsMessage + optionsMessage);\n      }\n    };\n    const getPluginDescription = name => find$2(deprecatedPlugins, entry => entry.name === name).fold(() => name, entry => {\n      if (entry.replacedWith) {\n        return `${ name }, replaced by ${ entry.replacedWith }`;\n      } else {\n        return name;\n      }\n    });\n    const logDeprecatedWarnings = (rawOptions, normalizedOptions) => {\n      const deprecatedOptions = getDeprecatedOptions(rawOptions);\n      const deprecatedPlugins = getDeprecatedPlugins(normalizedOptions);\n      const hasDeprecatedPlugins = deprecatedPlugins.length > 0;\n      const hasDeprecatedOptions = deprecatedOptions.length > 0;\n      if (hasDeprecatedPlugins || hasDeprecatedOptions) {\n        const listJoiner = '\\n- ';\n        const pluginsMessage = hasDeprecatedPlugins ? `\\n\\nPlugins:${ listJoiner }${ deprecatedPlugins.map(getPluginDescription).join(listJoiner) }` : '';\n        const optionsMessage = hasDeprecatedOptions ? `\\n\\nOptions:${ listJoiner }${ deprecatedOptions.join(listJoiner) }` : '';\n        console.warn('The following deprecated features are currently enabled but will be removed soon.' + pluginsMessage + optionsMessage);\n      }\n    };\n    const logWarnings = (rawOptions, normalizedOptions) => {\n      logRemovedWarnings(rawOptions, normalizedOptions);\n      logDeprecatedWarnings(rawOptions, normalizedOptions);\n    };\n\n    const DOM$8 = DOMUtils.DOM;\n    const restoreOriginalStyles = editor => {\n      DOM$8.setStyle(editor.id, 'display', editor.orgDisplay);\n    };\n    const safeDestroy = x => Optional.from(x).each(x => x.destroy());\n    const clearDomReferences = editor => {\n      const ed = editor;\n      ed.contentAreaContainer = ed.formElement = ed.container = ed.editorContainer = null;\n      ed.bodyElement = ed.contentDocument = ed.contentWindow = null;\n      ed.iframeElement = ed.targetElm = null;\n      const selection = editor.selection;\n      if (selection) {\n        const dom = selection.dom;\n        ed.selection = selection.win = selection.dom = dom.doc = null;\n      }\n    };\n    const restoreForm = editor => {\n      const form = editor.formElement;\n      if (form) {\n        if (form._mceOldSubmit) {\n          form.submit = form._mceOldSubmit;\n          delete form._mceOldSubmit;\n        }\n        DOM$8.unbind(form, 'submit reset', editor.formEventDelegate);\n      }\n    };\n    const remove$1 = editor => {\n      if (!editor.removed) {\n        const {_selectionOverrides, editorUpload} = editor;\n        const body = editor.getBody();\n        const element = editor.getElement();\n        if (body) {\n          editor.save({ is_removing: true });\n        }\n        editor.removed = true;\n        editor.unbindAllNativeEvents();\n        if (editor.hasHiddenInput && isNonNullable(element === null || element === void 0 ? void 0 : element.nextSibling)) {\n          DOM$8.remove(element.nextSibling);\n        }\n        fireRemove(editor);\n        editor.editorManager.remove(editor);\n        if (!editor.inline && body) {\n          restoreOriginalStyles(editor);\n        }\n        fireDetach(editor);\n        DOM$8.remove(editor.getContainer());\n        safeDestroy(_selectionOverrides);\n        safeDestroy(editorUpload);\n        editor.destroy();\n      }\n    };\n    const destroy = (editor, automatic) => {\n      const {selection, dom} = editor;\n      if (editor.destroyed) {\n        return;\n      }\n      if (!automatic && !editor.removed) {\n        editor.remove();\n        return;\n      }\n      if (!automatic) {\n        editor.editorManager.off('beforeunload', editor._beforeUnload);\n        if (editor.theme && editor.theme.destroy) {\n          editor.theme.destroy();\n        }\n        safeDestroy(selection);\n        safeDestroy(dom);\n      }\n      restoreForm(editor);\n      clearDomReferences(editor);\n      editor.destroyed = true;\n    };\n\n    const CreateIconManager = () => {\n      const lookup = {};\n      const add = (id, iconPack) => {\n        lookup[id] = iconPack;\n      };\n      const get = id => {\n        if (lookup[id]) {\n          return lookup[id];\n        } else {\n          return { icons: {} };\n        }\n      };\n      const has = id => has$2(lookup, id);\n      return {\n        add,\n        get,\n        has\n      };\n    };\n    const IconManager = CreateIconManager();\n\n    const ModelManager = AddOnManager.ModelManager;\n\n    const getProp = (propName, elm) => {\n      const rawElm = elm.dom;\n      return rawElm[propName];\n    };\n    const getComputedSizeProp = (propName, elm) => parseInt(get$7(elm, propName), 10);\n    const getClientWidth = curry(getProp, 'clientWidth');\n    const getClientHeight = curry(getProp, 'clientHeight');\n    const getMarginTop = curry(getComputedSizeProp, 'margin-top');\n    const getMarginLeft = curry(getComputedSizeProp, 'margin-left');\n    const getBoundingClientRect = elm => elm.dom.getBoundingClientRect();\n    const isInsideElementContentArea = (bodyElm, clientX, clientY) => {\n      const clientWidth = getClientWidth(bodyElm);\n      const clientHeight = getClientHeight(bodyElm);\n      return clientX >= 0 && clientY >= 0 && clientX <= clientWidth && clientY <= clientHeight;\n    };\n    const transpose = (inline, elm, clientX, clientY) => {\n      const clientRect = getBoundingClientRect(elm);\n      const deltaX = inline ? clientRect.left + elm.dom.clientLeft + getMarginLeft(elm) : 0;\n      const deltaY = inline ? clientRect.top + elm.dom.clientTop + getMarginTop(elm) : 0;\n      const x = clientX - deltaX;\n      const y = clientY - deltaY;\n      return {\n        x,\n        y\n      };\n    };\n    const isXYInContentArea = (editor, clientX, clientY) => {\n      const bodyElm = SugarElement.fromDom(editor.getBody());\n      const targetElm = editor.inline ? bodyElm : documentElement(bodyElm);\n      const transposedPoint = transpose(editor.inline, targetElm, clientX, clientY);\n      return isInsideElementContentArea(targetElm, transposedPoint.x, transposedPoint.y);\n    };\n    const fromDomSafe = node => Optional.from(node).map(SugarElement.fromDom);\n    const isEditorAttachedToDom = editor => {\n      const rawContainer = editor.inline ? editor.getBody() : editor.getContentAreaContainer();\n      return fromDomSafe(rawContainer).map(inBody).getOr(false);\n    };\n\n    var NotificationManagerImpl = () => {\n      const unimplemented = () => {\n        throw new Error('Theme did not provide a NotificationManager implementation.');\n      };\n      return {\n        open: unimplemented,\n        close: unimplemented,\n        getArgs: unimplemented\n      };\n    };\n\n    const NotificationManager = editor => {\n      const notifications = [];\n      const getImplementation = () => {\n        const theme = editor.theme;\n        return theme && theme.getNotificationManagerImpl ? theme.getNotificationManagerImpl() : NotificationManagerImpl();\n      };\n      const getTopNotification = () => {\n        return Optional.from(notifications[0]);\n      };\n      const isEqual = (a, b) => {\n        return a.type === b.type && a.text === b.text && !a.progressBar && !a.timeout && !b.progressBar && !b.timeout;\n      };\n      const reposition = () => {\n        getTopNotification().each(notification => {\n          notification.reposition();\n        });\n      };\n      const addNotification = notification => {\n        notifications.push(notification);\n      };\n      const closeNotification = notification => {\n        findIndex$2(notifications, otherNotification => {\n          return otherNotification === notification;\n        }).each(index => {\n          notifications.splice(index, 1);\n        });\n      };\n      const open = (spec, fireEvent = true) => {\n        if (editor.removed || !isEditorAttachedToDom(editor)) {\n          return {};\n        }\n        if (fireEvent) {\n          editor.dispatch('BeforeOpenNotification', { notification: spec });\n        }\n        return find$2(notifications, notification => {\n          return isEqual(getImplementation().getArgs(notification), spec);\n        }).getOrThunk(() => {\n          editor.editorManager.setActive(editor);\n          const notification = getImplementation().open(spec, () => {\n            closeNotification(notification);\n          }, () => hasEditorOrUiFocus(editor));\n          addNotification(notification);\n          reposition();\n          editor.dispatch('OpenNotification', { notification: { ...notification } });\n          return notification;\n        });\n      };\n      const close = () => {\n        getTopNotification().each(notification => {\n          getImplementation().close(notification);\n          closeNotification(notification);\n          reposition();\n        });\n      };\n      const getNotifications = constant(notifications);\n      const registerEvents = editor => {\n        editor.on('SkinLoaded', () => {\n          const serviceMessage = getServiceMessage(editor);\n          if (serviceMessage) {\n            open({\n              text: serviceMessage,\n              type: 'warning',\n              timeout: 0\n            }, false);\n          }\n          reposition();\n        });\n        editor.on('show ResizeEditor ResizeWindow NodeChange ToggleView FullscreenStateChanged', () => {\n          requestAnimationFrame(reposition);\n        });\n        editor.on('remove', () => {\n          each$e(notifications.slice(), notification => {\n            getImplementation().close(notification);\n          });\n        });\n        editor.on('keydown', e => {\n          var _a;\n          const isF12 = ((_a = e.key) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === 'f12' || e.keyCode === 123;\n          if (e.altKey && isF12) {\n            e.preventDefault();\n            getTopNotification().map(notificationApi => SugarElement.fromDom(notificationApi.getEl())).each(elm => focus$1(elm));\n          }\n        });\n      };\n      registerEvents(editor);\n      return {\n        open,\n        close,\n        getNotifications\n      };\n    };\n\n    const PluginManager = AddOnManager.PluginManager;\n\n    const ThemeManager = AddOnManager.ThemeManager;\n\n    var WindowManagerImpl = () => {\n      const unimplemented = () => {\n        throw new Error('Theme did not provide a WindowManager implementation.');\n      };\n      return {\n        open: unimplemented,\n        openUrl: unimplemented,\n        alert: unimplemented,\n        confirm: unimplemented,\n        close: unimplemented\n      };\n    };\n\n    const WindowManager = editor => {\n      let dialogs = [];\n      const getImplementation = () => {\n        const theme = editor.theme;\n        return theme && theme.getWindowManagerImpl ? theme.getWindowManagerImpl() : WindowManagerImpl();\n      };\n      const funcBind = (scope, f) => {\n        return (...args) => {\n          return f ? f.apply(scope, args) : undefined;\n        };\n      };\n      const fireOpenEvent = dialog => {\n        editor.dispatch('OpenWindow', { dialog });\n      };\n      const fireCloseEvent = dialog => {\n        editor.dispatch('CloseWindow', { dialog });\n      };\n      const addDialog = dialog => {\n        dialogs.push(dialog);\n        fireOpenEvent(dialog);\n      };\n      const closeDialog = dialog => {\n        fireCloseEvent(dialog);\n        dialogs = filter$5(dialogs, otherDialog => {\n          return otherDialog !== dialog;\n        });\n        if (dialogs.length === 0) {\n          editor.focus();\n        }\n      };\n      const getTopDialog = () => {\n        return Optional.from(dialogs[dialogs.length - 1]);\n      };\n      const storeSelectionAndOpenDialog = openDialog => {\n        editor.editorManager.setActive(editor);\n        store(editor);\n        editor.ui.show();\n        const dialog = openDialog();\n        addDialog(dialog);\n        return dialog;\n      };\n      const open = (args, params) => {\n        return storeSelectionAndOpenDialog(() => getImplementation().open(args, params, closeDialog));\n      };\n      const openUrl = args => {\n        return storeSelectionAndOpenDialog(() => getImplementation().openUrl(args, closeDialog));\n      };\n      const alert = (message, callback, scope) => {\n        const windowManagerImpl = getImplementation();\n        windowManagerImpl.alert(message, funcBind(scope ? scope : windowManagerImpl, callback));\n      };\n      const confirm = (message, callback, scope) => {\n        const windowManagerImpl = getImplementation();\n        windowManagerImpl.confirm(message, funcBind(scope ? scope : windowManagerImpl, callback));\n      };\n      const close = () => {\n        getTopDialog().each(dialog => {\n          getImplementation().close(dialog);\n          closeDialog(dialog);\n        });\n      };\n      editor.on('remove', () => {\n        each$e(dialogs, dialog => {\n          getImplementation().close(dialog);\n        });\n      });\n      return {\n        open,\n        openUrl,\n        alert,\n        confirm,\n        close\n      };\n    };\n\n    const displayNotification = (editor, message) => {\n      editor.notificationManager.open({\n        type: 'error',\n        text: message\n      });\n    };\n    const displayError = (editor, message) => {\n      if (editor._skinLoaded) {\n        displayNotification(editor, message);\n      } else {\n        editor.on('SkinLoaded', () => {\n          displayNotification(editor, message);\n        });\n      }\n    };\n    const uploadError = (editor, message) => {\n      displayError(editor, I18n.translate([\n        'Failed to upload image: {0}',\n        message\n      ]));\n    };\n    const logError = (editor, errorType, msg) => {\n      fireError(editor, errorType, { message: msg });\n      console.error(msg);\n    };\n    const createLoadError = (type, url, name) => name ? `Failed to load ${ type }: ${ name } from url ${ url }` : `Failed to load ${ type } url: ${ url }`;\n    const pluginLoadError = (editor, url, name) => {\n      logError(editor, 'PluginLoadError', createLoadError('plugin', url, name));\n    };\n    const iconsLoadError = (editor, url, name) => {\n      logError(editor, 'IconsLoadError', createLoadError('icons', url, name));\n    };\n    const languageLoadError = (editor, url, name) => {\n      logError(editor, 'LanguageLoadError', createLoadError('language', url, name));\n    };\n    const themeLoadError = (editor, url, name) => {\n      logError(editor, 'ThemeLoadError', createLoadError('theme', url, name));\n    };\n    const modelLoadError = (editor, url, name) => {\n      logError(editor, 'ModelLoadError', createLoadError('model', url, name));\n    };\n    const pluginInitError = (editor, name, err) => {\n      const message = I18n.translate([\n        'Failed to initialize plugin: {0}',\n        name\n      ]);\n      fireError(editor, 'PluginLoadError', { message });\n      initError(message, err);\n      displayError(editor, message);\n    };\n    const initError = (message, ...x) => {\n      const console = window.console;\n      if (console) {\n        if (console.error) {\n          console.error(message, ...x);\n        } else {\n          console.log(message, ...x);\n        }\n      }\n    };\n\n    const isContentCssSkinName = url => /^[a-z0-9\\-]+$/i.test(url);\n    const toContentSkinResourceName = url => 'content/' + url + '/content.css';\n    const isBundledCssSkinName = url => tinymce.Resource.has(toContentSkinResourceName(url));\n    const getContentCssUrls = editor => {\n      return transformToUrls(editor, getContentCss(editor));\n    };\n    const getFontCssUrls = editor => {\n      return transformToUrls(editor, getFontCss(editor));\n    };\n    const transformToUrls = (editor, cssLinks) => {\n      const skinUrl = editor.editorManager.baseURL + '/skins/content';\n      const suffix = editor.editorManager.suffix;\n      const contentCssFile = `content${ suffix }.css`;\n      return map$3(cssLinks, url => {\n        if (isBundledCssSkinName(url)) {\n          return url;\n        } else if (isContentCssSkinName(url) && !editor.inline) {\n          return `${ skinUrl }/${ url }/${ contentCssFile }`;\n        } else {\n          return editor.documentBaseURI.toAbsolute(url);\n        }\n      });\n    };\n    const appendContentCssFromSettings = editor => {\n      editor.contentCSS = editor.contentCSS.concat(getContentCssUrls(editor), getFontCssUrls(editor));\n    };\n\n    const getAllImages = elm => {\n      return elm ? from(elm.getElementsByTagName('img')) : [];\n    };\n    const ImageScanner = (uploadStatus, blobCache) => {\n      const cachedPromises = {};\n      const findAll = (elm, predicate = always) => {\n        const images = filter$5(getAllImages(elm), img => {\n          const src = img.src;\n          if (img.hasAttribute('data-mce-bogus')) {\n            return false;\n          }\n          if (img.hasAttribute('data-mce-placeholder')) {\n            return false;\n          }\n          if (!src || src === Env.transparentSrc) {\n            return false;\n          }\n          if (startsWith(src, 'blob:')) {\n            return !uploadStatus.isUploaded(src) && predicate(img);\n          }\n          if (startsWith(src, 'data:')) {\n            return predicate(img);\n          }\n          return false;\n        });\n        const promises = map$3(images, img => {\n          const imageSrc = img.src;\n          if (has$2(cachedPromises, imageSrc)) {\n            return cachedPromises[imageSrc].then(imageInfo => {\n              if (isString(imageInfo)) {\n                return imageInfo;\n              } else {\n                return {\n                  image: img,\n                  blobInfo: imageInfo.blobInfo\n                };\n              }\n            });\n          } else {\n            const newPromise = imageToBlobInfo(blobCache, imageSrc).then(blobInfo => {\n              delete cachedPromises[imageSrc];\n              return {\n                image: img,\n                blobInfo\n              };\n            }).catch(error => {\n              delete cachedPromises[imageSrc];\n              return error;\n            });\n            cachedPromises[imageSrc] = newPromise;\n            return newPromise;\n          }\n        });\n        return Promise.all(promises);\n      };\n      return { findAll };\n    };\n\n    const UploadStatus = () => {\n      const PENDING = 1, UPLOADED = 2;\n      let blobUriStatuses = {};\n      const createStatus = (status, resultUri) => {\n        return {\n          status,\n          resultUri\n        };\n      };\n      const hasBlobUri = blobUri => {\n        return blobUri in blobUriStatuses;\n      };\n      const getResultUri = blobUri => {\n        const result = blobUriStatuses[blobUri];\n        return result ? result.resultUri : null;\n      };\n      const isPending = blobUri => {\n        return hasBlobUri(blobUri) ? blobUriStatuses[blobUri].status === PENDING : false;\n      };\n      const isUploaded = blobUri => {\n        return hasBlobUri(blobUri) ? blobUriStatuses[blobUri].status === UPLOADED : false;\n      };\n      const markPending = blobUri => {\n        blobUriStatuses[blobUri] = createStatus(PENDING, null);\n      };\n      const markUploaded = (blobUri, resultUri) => {\n        blobUriStatuses[blobUri] = createStatus(UPLOADED, resultUri);\n      };\n      const removeFailed = blobUri => {\n        delete blobUriStatuses[blobUri];\n      };\n      const destroy = () => {\n        blobUriStatuses = {};\n      };\n      return {\n        hasBlobUri,\n        getResultUri,\n        isPending,\n        isUploaded,\n        markPending,\n        markUploaded,\n        removeFailed,\n        destroy\n      };\n    };\n\n    let count = 0;\n    const seed = () => {\n      const rnd = () => {\n        return Math.round(random() * 4294967295).toString(36);\n      };\n      const now = new Date().getTime();\n      return 's' + now.toString(36) + rnd() + rnd() + rnd();\n    };\n    const uuid = prefix => {\n      return prefix + count++ + seed();\n    };\n\n    const BlobCache = () => {\n      let cache = [];\n      const mimeToExt = mime => {\n        const mimes = {\n          'image/jpeg': 'jpg',\n          'image/jpg': 'jpg',\n          'image/gif': 'gif',\n          'image/png': 'png',\n          'image/apng': 'apng',\n          'image/avif': 'avif',\n          'image/svg+xml': 'svg',\n          'image/webp': 'webp',\n          'image/bmp': 'bmp',\n          'image/tiff': 'tiff'\n        };\n        return mimes[mime.toLowerCase()] || 'dat';\n      };\n      const create = (o, blob, base64, name, filename) => {\n        if (isString(o)) {\n          const id = o;\n          return toBlobInfo({\n            id,\n            name,\n            filename,\n            blob: blob,\n            base64: base64\n          });\n        } else if (isObject(o)) {\n          return toBlobInfo(o);\n        } else {\n          throw new Error('Unknown input type');\n        }\n      };\n      const toBlobInfo = o => {\n        if (!o.blob || !o.base64) {\n          throw new Error('blob and base64 representations of the image are required for BlobInfo to be created');\n        }\n        const id = o.id || uuid('blobid');\n        const name = o.name || id;\n        const blob = o.blob;\n        return {\n          id: constant(id),\n          name: constant(name),\n          filename: constant(o.filename || name + '.' + mimeToExt(blob.type)),\n          blob: constant(blob),\n          base64: constant(o.base64),\n          blobUri: constant(o.blobUri || URL.createObjectURL(blob)),\n          uri: constant(o.uri)\n        };\n      };\n      const add = blobInfo => {\n        if (!get(blobInfo.id())) {\n          cache.push(blobInfo);\n        }\n      };\n      const findFirst = predicate => find$2(cache, predicate).getOrUndefined();\n      const get = id => findFirst(cachedBlobInfo => cachedBlobInfo.id() === id);\n      const getByUri = blobUri => findFirst(blobInfo => blobInfo.blobUri() === blobUri);\n      const getByData = (base64, type) => findFirst(blobInfo => blobInfo.base64() === base64 && blobInfo.blob().type === type);\n      const removeByUri = blobUri => {\n        cache = filter$5(cache, blobInfo => {\n          if (blobInfo.blobUri() === blobUri) {\n            URL.revokeObjectURL(blobInfo.blobUri());\n            return false;\n          }\n          return true;\n        });\n      };\n      const destroy = () => {\n        each$e(cache, cachedBlobInfo => {\n          URL.revokeObjectURL(cachedBlobInfo.blobUri());\n        });\n        cache = [];\n      };\n      return {\n        create,\n        add,\n        get,\n        getByUri,\n        getByData,\n        findFirst,\n        removeByUri,\n        destroy\n      };\n    };\n\n    const Uploader = (uploadStatus, settings) => {\n      const pendingPromises = {};\n      const pathJoin = (path1, path2) => {\n        if (path1) {\n          return path1.replace(/\\/$/, '') + '/' + path2.replace(/^\\//, '');\n        }\n        return path2;\n      };\n      const defaultHandler = (blobInfo, progress) => new Promise((success, failure) => {\n        const xhr = new XMLHttpRequest();\n        xhr.open('POST', settings.url);\n        xhr.withCredentials = settings.credentials;\n        xhr.upload.onprogress = e => {\n          progress(e.loaded / e.total * 100);\n        };\n        xhr.onerror = () => {\n          failure('Image upload failed due to a XHR Transport error. Code: ' + xhr.status);\n        };\n        xhr.onload = () => {\n          if (xhr.status < 200 || xhr.status >= 300) {\n            failure('HTTP Error: ' + xhr.status);\n            return;\n          }\n          const json = JSON.parse(xhr.responseText);\n          if (!json || !isString(json.location)) {\n            failure('Invalid JSON: ' + xhr.responseText);\n            return;\n          }\n          success(pathJoin(settings.basePath, json.location));\n        };\n        const formData = new FormData();\n        formData.append('file', blobInfo.blob(), blobInfo.filename());\n        xhr.send(formData);\n      });\n      const uploadHandler = isFunction(settings.handler) ? settings.handler : defaultHandler;\n      const noUpload = () => new Promise(resolve => {\n        resolve([]);\n      });\n      const handlerSuccess = (blobInfo, url) => ({\n        url,\n        blobInfo,\n        status: true\n      });\n      const handlerFailure = (blobInfo, error) => ({\n        url: '',\n        blobInfo,\n        status: false,\n        error\n      });\n      const resolvePending = (blobUri, result) => {\n        Tools.each(pendingPromises[blobUri], resolve => {\n          resolve(result);\n        });\n        delete pendingPromises[blobUri];\n      };\n      const uploadBlobInfo = (blobInfo, handler, openNotification) => {\n        uploadStatus.markPending(blobInfo.blobUri());\n        return new Promise(resolve => {\n          let notification;\n          let progress;\n          try {\n            const closeNotification = () => {\n              if (notification) {\n                notification.close();\n                progress = noop;\n              }\n            };\n            const success = url => {\n              closeNotification();\n              uploadStatus.markUploaded(blobInfo.blobUri(), url);\n              resolvePending(blobInfo.blobUri(), handlerSuccess(blobInfo, url));\n              resolve(handlerSuccess(blobInfo, url));\n            };\n            const failure = error => {\n              closeNotification();\n              uploadStatus.removeFailed(blobInfo.blobUri());\n              resolvePending(blobInfo.blobUri(), handlerFailure(blobInfo, error));\n              resolve(handlerFailure(blobInfo, error));\n            };\n            progress = percent => {\n              if (percent < 0 || percent > 100) {\n                return;\n              }\n              Optional.from(notification).orThunk(() => Optional.from(openNotification).map(apply$1)).each(n => {\n                notification = n;\n                n.progressBar.value(percent);\n              });\n            };\n            handler(blobInfo, progress).then(success, err => {\n              failure(isString(err) ? { message: err } : err);\n            });\n          } catch (ex) {\n            resolve(handlerFailure(blobInfo, ex));\n          }\n        });\n      };\n      const isDefaultHandler = handler => handler === defaultHandler;\n      const pendingUploadBlobInfo = blobInfo => {\n        const blobUri = blobInfo.blobUri();\n        return new Promise(resolve => {\n          pendingPromises[blobUri] = pendingPromises[blobUri] || [];\n          pendingPromises[blobUri].push(resolve);\n        });\n      };\n      const uploadBlobs = (blobInfos, openNotification) => {\n        blobInfos = Tools.grep(blobInfos, blobInfo => !uploadStatus.isUploaded(blobInfo.blobUri()));\n        return Promise.all(Tools.map(blobInfos, blobInfo => uploadStatus.isPending(blobInfo.blobUri()) ? pendingUploadBlobInfo(blobInfo) : uploadBlobInfo(blobInfo, uploadHandler, openNotification)));\n      };\n      const upload = (blobInfos, openNotification) => !settings.url && isDefaultHandler(uploadHandler) ? noUpload() : uploadBlobs(blobInfos, openNotification);\n      return { upload };\n    };\n\n    const openNotification = editor => () => editor.notificationManager.open({\n      text: editor.translate('Image uploading...'),\n      type: 'info',\n      timeout: -1,\n      progressBar: true\n    });\n    const createUploader = (editor, uploadStatus) => Uploader(uploadStatus, {\n      url: getImageUploadUrl(editor),\n      basePath: getImageUploadBasePath(editor),\n      credentials: getImagesUploadCredentials(editor),\n      handler: getImagesUploadHandler(editor)\n    });\n    const ImageUploader = editor => {\n      const uploadStatus = UploadStatus();\n      const uploader = createUploader(editor, uploadStatus);\n      return { upload: (blobInfos, showNotification = true) => uploader.upload(blobInfos, showNotification ? openNotification(editor) : undefined) };\n    };\n\n    const isEmptyForPadding = (editor, element) => editor.dom.isEmpty(element.dom) && isNonNullable(editor.schema.getTextBlockElements()[name(element)]);\n    const addPaddingToEmpty = editor => element => {\n      if (isEmptyForPadding(editor, element)) {\n        append$1(element, SugarElement.fromHtml('<br data-mce-bogus=\"1\" />'));\n      }\n    };\n    const EditorUpload = editor => {\n      const blobCache = BlobCache();\n      let uploader, imageScanner;\n      const uploadStatus = UploadStatus();\n      const urlFilters = [];\n      const aliveGuard = callback => {\n        return result => {\n          if (editor.selection) {\n            return callback(result);\n          }\n          return [];\n        };\n      };\n      const cacheInvalidator = url => url + (url.indexOf('?') === -1 ? '?' : '&') + new Date().getTime();\n      const replaceString = (content, search, replace) => {\n        let index = 0;\n        do {\n          index = content.indexOf(search, index);\n          if (index !== -1) {\n            content = content.substring(0, index) + replace + content.substr(index + search.length);\n            index += replace.length - search.length + 1;\n          }\n        } while (index !== -1);\n        return content;\n      };\n      const replaceImageUrl = (content, targetUrl, replacementUrl) => {\n        const replacementString = `src=\"${ replacementUrl }\"${ replacementUrl === Env.transparentSrc ? ' data-mce-placeholder=\"1\"' : '' }`;\n        content = replaceString(content, `src=\"${ targetUrl }\"`, replacementString);\n        content = replaceString(content, 'data-mce-src=\"' + targetUrl + '\"', 'data-mce-src=\"' + replacementUrl + '\"');\n        return content;\n      };\n      const replaceUrlInUndoStack = (targetUrl, replacementUrl) => {\n        each$e(editor.undoManager.data, level => {\n          if (level.type === 'fragmented') {\n            level.fragments = map$3(level.fragments, fragment => replaceImageUrl(fragment, targetUrl, replacementUrl));\n          } else {\n            level.content = replaceImageUrl(level.content, targetUrl, replacementUrl);\n          }\n        });\n      };\n      const replaceImageUriInView = (image, resultUri) => {\n        const src = editor.convertURL(resultUri, 'src');\n        replaceUrlInUndoStack(image.src, resultUri);\n        setAll$1(SugarElement.fromDom(image), {\n          'src': shouldReuseFileName(editor) ? cacheInvalidator(resultUri) : resultUri,\n          'data-mce-src': src\n        });\n      };\n      const uploadImages = () => {\n        if (!uploader) {\n          uploader = createUploader(editor, uploadStatus);\n        }\n        return scanForImages().then(aliveGuard(imageInfos => {\n          const blobInfos = map$3(imageInfos, imageInfo => imageInfo.blobInfo);\n          return uploader.upload(blobInfos, openNotification(editor)).then(aliveGuard(result => {\n            const imagesToRemove = [];\n            let shouldDispatchChange = false;\n            const filteredResult = map$3(result, (uploadInfo, index) => {\n              const {blobInfo, image} = imageInfos[index];\n              let removed = false;\n              if (uploadInfo.status && shouldReplaceBlobUris(editor)) {\n                if (uploadInfo.url && !contains$1(image.src, uploadInfo.url)) {\n                  shouldDispatchChange = true;\n                }\n                blobCache.removeByUri(image.src);\n                if (isRtc(editor)) ; else {\n                  replaceImageUriInView(image, uploadInfo.url);\n                }\n              } else if (uploadInfo.error) {\n                if (uploadInfo.error.remove) {\n                  replaceUrlInUndoStack(image.src, Env.transparentSrc);\n                  imagesToRemove.push(image);\n                  removed = true;\n                }\n                uploadError(editor, uploadInfo.error.message);\n              }\n              return {\n                element: image,\n                status: uploadInfo.status,\n                uploadUri: uploadInfo.url,\n                blobInfo,\n                removed\n              };\n            });\n            if (imagesToRemove.length > 0 && !isRtc(editor)) {\n              editor.undoManager.transact(() => {\n                each$e(fromDom$1(imagesToRemove), sugarElement => {\n                  const parentOpt = parent(sugarElement);\n                  remove$4(sugarElement);\n                  parentOpt.each(addPaddingToEmpty(editor));\n                  blobCache.removeByUri(sugarElement.dom.src);\n                });\n              });\n            } else if (shouldDispatchChange) {\n              editor.undoManager.dispatchChange();\n            }\n            return filteredResult;\n          }));\n        }));\n      };\n      const uploadImagesAuto = () => isAutomaticUploadsEnabled(editor) ? uploadImages() : Promise.resolve([]);\n      const isValidDataUriImage = imgElm => forall(urlFilters, filter => filter(imgElm));\n      const addFilter = filter => {\n        urlFilters.push(filter);\n      };\n      const scanForImages = () => {\n        if (!imageScanner) {\n          imageScanner = ImageScanner(uploadStatus, blobCache);\n        }\n        return imageScanner.findAll(editor.getBody(), isValidDataUriImage).then(aliveGuard(result => {\n          const filteredResult = filter$5(result, resultItem => {\n            if (isString(resultItem)) {\n              displayError(editor, resultItem);\n              return false;\n            } else if (resultItem.uriType === 'blob') {\n              return false;\n            } else {\n              return true;\n            }\n          });\n          if (isRtc(editor)) ; else {\n            each$e(filteredResult, resultItem => {\n              replaceUrlInUndoStack(resultItem.image.src, resultItem.blobInfo.blobUri());\n              resultItem.image.src = resultItem.blobInfo.blobUri();\n              resultItem.image.removeAttribute('data-mce-src');\n            });\n          }\n          return filteredResult;\n        }));\n      };\n      const destroy = () => {\n        blobCache.destroy();\n        uploadStatus.destroy();\n        imageScanner = uploader = null;\n      };\n      const replaceBlobUris = content => {\n        return content.replace(/src=\"(blob:[^\"]+)\"/g, (match, blobUri) => {\n          const resultUri = uploadStatus.getResultUri(blobUri);\n          if (resultUri) {\n            return 'src=\"' + resultUri + '\"';\n          }\n          let blobInfo = blobCache.getByUri(blobUri);\n          if (!blobInfo) {\n            blobInfo = foldl(editor.editorManager.get(), (result, editor) => {\n              return result || editor.editorUpload && editor.editorUpload.blobCache.getByUri(blobUri);\n            }, undefined);\n          }\n          if (blobInfo) {\n            const blob = blobInfo.blob();\n            return 'src=\"data:' + blob.type + ';base64,' + blobInfo.base64() + '\"';\n          }\n          return match;\n        });\n      };\n      editor.on('SetContent', () => {\n        if (isAutomaticUploadsEnabled(editor)) {\n          uploadImagesAuto();\n        } else {\n          scanForImages();\n        }\n      });\n      editor.on('RawSaveContent', e => {\n        e.content = replaceBlobUris(e.content);\n      });\n      editor.on('GetContent', e => {\n        if (e.source_view || e.format === 'raw' || e.format === 'tree') {\n          return;\n        }\n        e.content = replaceBlobUris(e.content);\n      });\n      editor.on('PostRender', () => {\n        editor.parser.addNodeFilter('img', images => {\n          each$e(images, img => {\n            const src = img.attr('src');\n            if (!src || blobCache.getByUri(src)) {\n              return;\n            }\n            const resultUri = uploadStatus.getResultUri(src);\n            if (resultUri) {\n              img.attr('src', resultUri);\n            }\n          });\n        });\n      });\n      return {\n        blobCache,\n        addFilter,\n        uploadImages,\n        uploadImagesAuto,\n        scanForImages,\n        destroy\n      };\n    };\n\n    const get$1 = editor => {\n      const dom = editor.dom;\n      const schemaType = editor.schema.type;\n      const formats = {\n        valigntop: [{\n            selector: 'td,th',\n            styles: { verticalAlign: 'top' }\n          }],\n        valignmiddle: [{\n            selector: 'td,th',\n            styles: { verticalAlign: 'middle' }\n          }],\n        valignbottom: [{\n            selector: 'td,th',\n            styles: { verticalAlign: 'bottom' }\n          }],\n        alignleft: [\n          {\n            selector: 'figure.image',\n            collapsed: false,\n            classes: 'align-left',\n            ceFalseOverride: true,\n            preview: 'font-family font-size'\n          },\n          {\n            selector: 'figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li,pre',\n            styles: { textAlign: 'left' },\n            inherit: false,\n            preview: false\n          },\n          {\n            selector: 'img,audio,video',\n            collapsed: false,\n            styles: { float: 'left' },\n            preview: 'font-family font-size'\n          },\n          {\n            selector: 'table',\n            collapsed: false,\n            styles: {\n              marginLeft: '0px',\n              marginRight: 'auto'\n            },\n            onformat: table => {\n              dom.setStyle(table, 'float', null);\n            },\n            preview: 'font-family font-size'\n          },\n          {\n            selector: '.mce-preview-object,[data-ephox-embed-iri]',\n            ceFalseOverride: true,\n            styles: { float: 'left' }\n          }\n        ],\n        aligncenter: [\n          {\n            selector: 'figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li,pre',\n            styles: { textAlign: 'center' },\n            inherit: false,\n            preview: 'font-family font-size'\n          },\n          {\n            selector: 'figure.image',\n            collapsed: false,\n            classes: 'align-center',\n            ceFalseOverride: true,\n            preview: 'font-family font-size'\n          },\n          {\n            selector: 'img,audio,video',\n            collapsed: false,\n            styles: {\n              display: 'block',\n              marginLeft: 'auto',\n              marginRight: 'auto'\n            },\n            preview: false\n          },\n          {\n            selector: 'table',\n            collapsed: false,\n            styles: {\n              marginLeft: 'auto',\n              marginRight: 'auto'\n            },\n            preview: 'font-family font-size'\n          },\n          {\n            selector: '.mce-preview-object',\n            ceFalseOverride: true,\n            styles: {\n              display: 'table',\n              marginLeft: 'auto',\n              marginRight: 'auto'\n            },\n            preview: false\n          },\n          {\n            selector: '[data-ephox-embed-iri]',\n            ceFalseOverride: true,\n            styles: {\n              marginLeft: 'auto',\n              marginRight: 'auto'\n            },\n            preview: false\n          }\n        ],\n        alignright: [\n          {\n            selector: 'figure.image',\n            collapsed: false,\n            classes: 'align-right',\n            ceFalseOverride: true,\n            preview: 'font-family font-size'\n          },\n          {\n            selector: 'figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li,pre',\n            styles: { textAlign: 'right' },\n            inherit: false,\n            preview: 'font-family font-size'\n          },\n          {\n            selector: 'img,audio,video',\n            collapsed: false,\n            styles: { float: 'right' },\n            preview: 'font-family font-size'\n          },\n          {\n            selector: 'table',\n            collapsed: false,\n            styles: {\n              marginRight: '0px',\n              marginLeft: 'auto'\n            },\n            onformat: table => {\n              dom.setStyle(table, 'float', null);\n            },\n            preview: 'font-family font-size'\n          },\n          {\n            selector: '.mce-preview-object,[data-ephox-embed-iri]',\n            ceFalseOverride: true,\n            styles: { float: 'right' },\n            preview: false\n          }\n        ],\n        alignjustify: [{\n            selector: 'figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li,pre',\n            styles: { textAlign: 'justify' },\n            inherit: false,\n            preview: 'font-family font-size'\n          }],\n        bold: [\n          {\n            inline: 'strong',\n            remove: 'all',\n            preserve_attributes: [\n              'class',\n              'style'\n            ]\n          },\n          {\n            inline: 'span',\n            styles: { fontWeight: 'bold' }\n          },\n          {\n            inline: 'b',\n            remove: 'all',\n            preserve_attributes: [\n              'class',\n              'style'\n            ]\n          }\n        ],\n        italic: [\n          {\n            inline: 'em',\n            remove: 'all',\n            preserve_attributes: [\n              'class',\n              'style'\n            ]\n          },\n          {\n            inline: 'span',\n            styles: { fontStyle: 'italic' }\n          },\n          {\n            inline: 'i',\n            remove: 'all',\n            preserve_attributes: [\n              'class',\n              'style'\n            ]\n          }\n        ],\n        underline: [\n          {\n            inline: 'span',\n            styles: { textDecoration: 'underline' },\n            exact: true\n          },\n          {\n            inline: 'u',\n            remove: 'all',\n            preserve_attributes: [\n              'class',\n              'style'\n            ]\n          }\n        ],\n        strikethrough: (() => {\n          const span = {\n            inline: 'span',\n            styles: { textDecoration: 'line-through' },\n            exact: true\n          };\n          const strike = {\n            inline: 'strike',\n            remove: 'all',\n            preserve_attributes: [\n              'class',\n              'style'\n            ]\n          };\n          const s = {\n            inline: 's',\n            remove: 'all',\n            preserve_attributes: [\n              'class',\n              'style'\n            ]\n          };\n          return schemaType !== 'html4' ? [\n            s,\n            span,\n            strike\n          ] : [\n            span,\n            s,\n            strike\n          ];\n        })(),\n        forecolor: {\n          inline: 'span',\n          styles: { color: '%value' },\n          links: true,\n          remove_similar: true,\n          clear_child_styles: true\n        },\n        hilitecolor: {\n          inline: 'span',\n          styles: { backgroundColor: '%value' },\n          links: true,\n          remove_similar: true,\n          clear_child_styles: true\n        },\n        fontname: {\n          inline: 'span',\n          toggle: false,\n          styles: { fontFamily: '%value' },\n          clear_child_styles: true\n        },\n        fontsize: {\n          inline: 'span',\n          toggle: false,\n          styles: { fontSize: '%value' },\n          clear_child_styles: true\n        },\n        lineheight: {\n          selector: 'h1,h2,h3,h4,h5,h6,p,li,td,th,div',\n          styles: { lineHeight: '%value' }\n        },\n        fontsize_class: {\n          inline: 'span',\n          attributes: { class: '%value' }\n        },\n        blockquote: {\n          block: 'blockquote',\n          wrapper: true,\n          remove: 'all'\n        },\n        subscript: { inline: 'sub' },\n        superscript: { inline: 'sup' },\n        code: { inline: 'code' },\n        link: {\n          inline: 'a',\n          selector: 'a',\n          remove: 'all',\n          split: true,\n          deep: true,\n          onmatch: (node, _fmt, _itemName) => {\n            return isElement$6(node) && node.hasAttribute('href');\n          },\n          onformat: (elm, _fmt, vars) => {\n            Tools.each(vars, (value, key) => {\n              dom.setAttrib(elm, key, value);\n            });\n          }\n        },\n        lang: {\n          inline: 'span',\n          clear_child_styles: true,\n          remove_similar: true,\n          attributes: {\n            'lang': '%value',\n            'data-mce-lang': vars => {\n              var _a;\n              return (_a = vars === null || vars === void 0 ? void 0 : vars.customValue) !== null && _a !== void 0 ? _a : null;\n            }\n          }\n        },\n        removeformat: [\n          {\n            selector: 'b,strong,em,i,font,u,strike,s,sub,sup,dfn,code,samp,kbd,var,cite,mark,q,del,ins,small',\n            remove: 'all',\n            split: true,\n            expand: false,\n            block_expand: true,\n            deep: true\n          },\n          {\n            selector: 'span',\n            attributes: [\n              'style',\n              'class'\n            ],\n            remove: 'empty',\n            split: true,\n            expand: false,\n            deep: true\n          },\n          {\n            selector: '*',\n            attributes: [\n              'style',\n              'class'\n            ],\n            split: false,\n            expand: false,\n            deep: true\n          }\n        ]\n      };\n      Tools.each('p h1 h2 h3 h4 h5 h6 div address pre dt dd samp'.split(/\\s/), name => {\n        formats[name] = {\n          block: name,\n          remove: 'all'\n        };\n      });\n      return formats;\n    };\n\n    const genericBase = {\n      remove_similar: true,\n      inherit: false\n    };\n    const cellBase = {\n      selector: 'td,th',\n      ...genericBase\n    };\n    const cellFormats = {\n      tablecellbackgroundcolor: {\n        styles: { backgroundColor: '%value' },\n        ...cellBase\n      },\n      tablecellverticalalign: {\n        styles: { 'vertical-align': '%value' },\n        ...cellBase\n      },\n      tablecellbordercolor: {\n        styles: { borderColor: '%value' },\n        ...cellBase\n      },\n      tablecellclass: {\n        classes: ['%value'],\n        ...cellBase\n      },\n      tableclass: {\n        selector: 'table',\n        classes: ['%value'],\n        ...genericBase\n      },\n      tablecellborderstyle: {\n        styles: { borderStyle: '%value' },\n        ...cellBase\n      },\n      tablecellborderwidth: {\n        styles: { borderWidth: '%value' },\n        ...cellBase\n      }\n    };\n    const get = constant(cellFormats);\n\n    const FormatRegistry = editor => {\n      const formats = {};\n      const get$2 = name => isNonNullable(name) ? formats[name] : formats;\n      const has = name => has$2(formats, name);\n      const register = (name, format) => {\n        if (name) {\n          if (!isString(name)) {\n            each$d(name, (format, name) => {\n              register(name, format);\n            });\n          } else {\n            if (!isArray$1(format)) {\n              format = [format];\n            }\n            each$e(format, format => {\n              if (isUndefined(format.deep)) {\n                format.deep = !isSelectorFormat(format);\n              }\n              if (isUndefined(format.split)) {\n                format.split = !isSelectorFormat(format) || isInlineFormat(format);\n              }\n              if (isUndefined(format.remove) && isSelectorFormat(format) && !isInlineFormat(format)) {\n                format.remove = 'none';\n              }\n              if (isSelectorFormat(format) && isInlineFormat(format)) {\n                format.mixed = true;\n                format.block_expand = true;\n              }\n              if (isString(format.classes)) {\n                format.classes = format.classes.split(/\\s+/);\n              }\n            });\n            formats[name] = format;\n          }\n        }\n      };\n      const unregister = name => {\n        if (name && formats[name]) {\n          delete formats[name];\n        }\n        return formats;\n      };\n      register(get$1(editor));\n      register(get());\n      register(getFormats(editor));\n      return {\n        get: get$2,\n        has,\n        register,\n        unregister\n      };\n    };\n\n    const each$3 = Tools.each;\n    const dom = DOMUtils.DOM;\n    const isPreviewItem = item => isNonNullable(item) && isObject(item);\n    const parsedSelectorToHtml = (ancestry, editor) => {\n      const schema = editor && editor.schema || Schema({});\n      const decorate = (elm, item) => {\n        if (item.classes.length > 0) {\n          dom.addClass(elm, item.classes.join(' '));\n        }\n        dom.setAttribs(elm, item.attrs);\n      };\n      const createElement = sItem => {\n        const item = isString(sItem) ? {\n          name: sItem,\n          classes: [],\n          attrs: {}\n        } : sItem;\n        const elm = dom.create(item.name);\n        decorate(elm, item);\n        return elm;\n      };\n      const getRequiredParent = (elm, candidate) => {\n        const elmRule = schema.getElementRule(elm.nodeName.toLowerCase());\n        const parentsRequired = elmRule === null || elmRule === void 0 ? void 0 : elmRule.parentsRequired;\n        if (parentsRequired && parentsRequired.length) {\n          return candidate && contains$2(parentsRequired, candidate) ? candidate : parentsRequired[0];\n        } else {\n          return false;\n        }\n      };\n      const wrapInHtml = (elm, ancestors, siblings) => {\n        let parentCandidate;\n        const ancestor = ancestors[0];\n        const ancestorName = isPreviewItem(ancestor) ? ancestor.name : undefined;\n        const parentRequired = getRequiredParent(elm, ancestorName);\n        if (parentRequired) {\n          if (ancestorName === parentRequired) {\n            parentCandidate = ancestor;\n            ancestors = ancestors.slice(1);\n          } else {\n            parentCandidate = parentRequired;\n          }\n        } else if (ancestor) {\n          parentCandidate = ancestor;\n          ancestors = ancestors.slice(1);\n        } else if (!siblings) {\n          return elm;\n        }\n        const parent = parentCandidate ? createElement(parentCandidate) : dom.create('div');\n        parent.appendChild(elm);\n        if (siblings) {\n          Tools.each(siblings, sibling => {\n            const siblingElm = createElement(sibling);\n            parent.insertBefore(siblingElm, elm);\n          });\n        }\n        const parentSiblings = isPreviewItem(parentCandidate) ? parentCandidate.siblings : undefined;\n        return wrapInHtml(parent, ancestors, parentSiblings);\n      };\n      const fragment = dom.create('div');\n      if (ancestry.length > 0) {\n        const item = ancestry[0];\n        const elm = createElement(item);\n        const siblings = isPreviewItem(item) ? item.siblings : undefined;\n        fragment.appendChild(wrapInHtml(elm, ancestry.slice(1), siblings));\n      }\n      return fragment;\n    };\n    const parseSelectorItem = item => {\n      item = Tools.trim(item);\n      let tagName = 'div';\n      const obj = {\n        name: tagName,\n        classes: [],\n        attrs: {},\n        selector: item\n      };\n      if (item !== '*') {\n        tagName = item.replace(/(?:([#\\.]|::?)([\\w\\-]+)|(\\[)([^\\]]+)\\]?)/g, ($0, $1, $2, $3, $4) => {\n          switch ($1) {\n          case '#':\n            obj.attrs.id = $2;\n            break;\n          case '.':\n            obj.classes.push($2);\n            break;\n          case ':':\n            if (Tools.inArray('checked disabled enabled read-only required'.split(' '), $2) !== -1) {\n              obj.attrs[$2] = $2;\n            }\n            break;\n          }\n          if ($3 === '[') {\n            const m = $4.match(/([\\w\\-]+)(?:\\=\\\"([^\\\"]+))?/);\n            if (m) {\n              obj.attrs[m[1]] = m[2];\n            }\n          }\n          return '';\n        });\n      }\n      obj.name = tagName || 'div';\n      return obj;\n    };\n    const parseSelector = selector => {\n      if (!isString(selector)) {\n        return [];\n      }\n      selector = selector.split(/\\s*,\\s*/)[0];\n      selector = selector.replace(/\\s*(~\\+|~|\\+|>)\\s*/g, '$1');\n      return Tools.map(selector.split(/(?:>|\\s+(?![^\\[\\]]+\\]))/), item => {\n        const siblings = Tools.map(item.split(/(?:~\\+|~|\\+)/), parseSelectorItem);\n        const obj = siblings.pop();\n        if (siblings.length) {\n          obj.siblings = siblings;\n        }\n        return obj;\n      }).reverse();\n    };\n    const getCssText = (editor, format) => {\n      let previewCss = '';\n      let previewStyles = getPreviewStyles(editor);\n      if (previewStyles === '') {\n        return '';\n      }\n      const removeVars = val => {\n        return isString(val) ? val.replace(/%(\\w+)/g, '') : '';\n      };\n      const getComputedStyle = (name, elm) => {\n        return dom.getStyle(elm !== null && elm !== void 0 ? elm : editor.getBody(), name, true);\n      };\n      if (isString(format)) {\n        const formats = editor.formatter.get(format);\n        if (!formats) {\n          return '';\n        }\n        format = formats[0];\n      }\n      if ('preview' in format) {\n        const preview = format.preview;\n        if (preview === false) {\n          return '';\n        } else {\n          previewStyles = preview || previewStyles;\n        }\n      }\n      let name = format.block || format.inline || 'span';\n      let previewFrag;\n      const items = parseSelector(format.selector);\n      if (items.length > 0) {\n        if (!items[0].name) {\n          items[0].name = name;\n        }\n        name = format.selector;\n        previewFrag = parsedSelectorToHtml(items, editor);\n      } else {\n        previewFrag = parsedSelectorToHtml([name], editor);\n      }\n      const previewElm = dom.select(name, previewFrag)[0] || previewFrag.firstChild;\n      each$3(format.styles, (value, name) => {\n        const newValue = removeVars(value);\n        if (newValue) {\n          dom.setStyle(previewElm, name, newValue);\n        }\n      });\n      each$3(format.attributes, (value, name) => {\n        const newValue = removeVars(value);\n        if (newValue) {\n          dom.setAttrib(previewElm, name, newValue);\n        }\n      });\n      each$3(format.classes, value => {\n        const newValue = removeVars(value);\n        if (!dom.hasClass(previewElm, newValue)) {\n          dom.addClass(previewElm, newValue);\n        }\n      });\n      editor.dispatch('PreviewFormats');\n      dom.setStyles(previewFrag, {\n        position: 'absolute',\n        left: -65535\n      });\n      editor.getBody().appendChild(previewFrag);\n      const rawParentFontSize = getComputedStyle('fontSize');\n      const parentFontSize = /px$/.test(rawParentFontSize) ? parseInt(rawParentFontSize, 10) : 0;\n      each$3(previewStyles.split(' '), name => {\n        let value = getComputedStyle(name, previewElm);\n        if (name === 'background-color' && /transparent|rgba\\s*\\([^)]+,\\s*0\\)/.test(value)) {\n          value = getComputedStyle(name);\n          if (rgbaToHexString(value).toLowerCase() === '#ffffff') {\n            return;\n          }\n        }\n        if (name === 'color') {\n          if (rgbaToHexString(value).toLowerCase() === '#000000') {\n            return;\n          }\n        }\n        if (name === 'font-size') {\n          if (/em|%$/.test(value)) {\n            if (parentFontSize === 0) {\n              return;\n            }\n            const numValue = parseFloat(value) / (/%$/.test(value) ? 100 : 1);\n            value = numValue * parentFontSize + 'px';\n          }\n        }\n        if (name === 'border' && value) {\n          previewCss += 'padding:0 2px;';\n        }\n        previewCss += name + ':' + value + ';';\n      });\n      editor.dispatch('AfterPreviewFormats');\n      dom.remove(previewFrag);\n      return previewCss;\n    };\n\n    const setup$s = editor => {\n      editor.addShortcut('meta+b', '', 'Bold');\n      editor.addShortcut('meta+i', '', 'Italic');\n      editor.addShortcut('meta+u', '', 'Underline');\n      for (let i = 1; i <= 6; i++) {\n        editor.addShortcut('access+' + i, '', [\n          'FormatBlock',\n          false,\n          'h' + i\n        ]);\n      }\n      editor.addShortcut('access+7', '', [\n        'FormatBlock',\n        false,\n        'p'\n      ]);\n      editor.addShortcut('access+8', '', [\n        'FormatBlock',\n        false,\n        'div'\n      ]);\n      editor.addShortcut('access+9', '', [\n        'FormatBlock',\n        false,\n        'address'\n      ]);\n    };\n\n    const Formatter = editor => {\n      const formats = FormatRegistry(editor);\n      const formatChangeState = Cell({});\n      setup$s(editor);\n      setup$v(editor);\n      if (!isRtc(editor)) {\n        setup$u(formatChangeState, editor);\n      }\n      return {\n        get: formats.get,\n        has: formats.has,\n        register: formats.register,\n        unregister: formats.unregister,\n        apply: (name, vars, node) => {\n          applyFormat(editor, name, vars, node);\n        },\n        remove: (name, vars, node, similar) => {\n          removeFormat(editor, name, vars, node, similar);\n        },\n        toggle: (name, vars, node) => {\n          toggleFormat(editor, name, vars, node);\n        },\n        match: (name, vars, node, similar) => matchFormat(editor, name, vars, node, similar),\n        closest: names => closestFormat(editor, names),\n        matchAll: (names, vars) => matchAllFormats(editor, names, vars),\n        matchNode: (node, name, vars, similar) => matchNodeFormat(editor, node, name, vars, similar),\n        canApply: name => canApplyFormat(editor, name),\n        formatChanged: (formats, callback, similar, vars) => formatChanged(editor, formatChangeState, formats, callback, similar, vars),\n        getCssText: curry(getCssText, editor)\n      };\n    };\n\n    const shouldIgnoreCommand = cmd => {\n      switch (cmd.toLowerCase()) {\n      case 'undo':\n      case 'redo':\n      case 'mcefocus':\n        return true;\n      default:\n        return false;\n      }\n    };\n    const registerEvents = (editor, undoManager, locks) => {\n      const isFirstTypedCharacter = Cell(false);\n      const addNonTypingUndoLevel = e => {\n        setTyping(undoManager, false, locks);\n        undoManager.add({}, e);\n      };\n      editor.on('init', () => {\n        undoManager.add();\n      });\n      editor.on('BeforeExecCommand', e => {\n        const cmd = e.command;\n        if (!shouldIgnoreCommand(cmd)) {\n          endTyping(undoManager, locks);\n          undoManager.beforeChange();\n        }\n      });\n      editor.on('ExecCommand', e => {\n        const cmd = e.command;\n        if (!shouldIgnoreCommand(cmd)) {\n          addNonTypingUndoLevel(e);\n        }\n      });\n      editor.on('ObjectResizeStart cut', () => {\n        undoManager.beforeChange();\n      });\n      editor.on('SaveContent ObjectResized blur', addNonTypingUndoLevel);\n      editor.on('dragend', addNonTypingUndoLevel);\n      editor.on('keyup', e => {\n        const keyCode = e.keyCode;\n        if (e.isDefaultPrevented()) {\n          return;\n        }\n        const isMeta = Env.os.isMacOS() && e.key === 'Meta';\n        if (keyCode >= 33 && keyCode <= 36 || keyCode >= 37 && keyCode <= 40 || keyCode === 45 || e.ctrlKey || isMeta) {\n          addNonTypingUndoLevel();\n          editor.nodeChanged();\n        }\n        if (keyCode === 46 || keyCode === 8) {\n          editor.nodeChanged();\n        }\n        if (isFirstTypedCharacter.get() && undoManager.typing && !isEq$1(createFromEditor(editor), undoManager.data[0])) {\n          if (!editor.isDirty()) {\n            editor.setDirty(true);\n          }\n          editor.dispatch('TypingUndo');\n          isFirstTypedCharacter.set(false);\n          editor.nodeChanged();\n        }\n      });\n      editor.on('keydown', e => {\n        const keyCode = e.keyCode;\n        if (e.isDefaultPrevented()) {\n          return;\n        }\n        if (keyCode >= 33 && keyCode <= 36 || keyCode >= 37 && keyCode <= 40 || keyCode === 45) {\n          if (undoManager.typing) {\n            addNonTypingUndoLevel(e);\n          }\n          return;\n        }\n        const modKey = e.ctrlKey && !e.altKey || e.metaKey;\n        if ((keyCode < 16 || keyCode > 20) && keyCode !== 224 && keyCode !== 91 && !undoManager.typing && !modKey) {\n          undoManager.beforeChange();\n          setTyping(undoManager, true, locks);\n          undoManager.add({}, e);\n          isFirstTypedCharacter.set(true);\n          return;\n        }\n        const hasOnlyMetaOrCtrlModifier = Env.os.isMacOS() ? e.metaKey : e.ctrlKey && !e.altKey;\n        if (hasOnlyMetaOrCtrlModifier) {\n          undoManager.beforeChange();\n        }\n      });\n      editor.on('mousedown', e => {\n        if (undoManager.typing) {\n          addNonTypingUndoLevel(e);\n        }\n      });\n      const isInsertReplacementText = event => event.inputType === 'insertReplacementText';\n      const isInsertTextDataNull = event => event.inputType === 'insertText' && event.data === null;\n      const isInsertFromPasteOrDrop = event => event.inputType === 'insertFromPaste' || event.inputType === 'insertFromDrop';\n      editor.on('input', e => {\n        if (e.inputType && (isInsertReplacementText(e) || isInsertTextDataNull(e) || isInsertFromPasteOrDrop(e))) {\n          addNonTypingUndoLevel(e);\n        }\n      });\n      editor.on('AddUndo Undo Redo ClearUndos', e => {\n        if (!e.isDefaultPrevented()) {\n          editor.nodeChanged();\n        }\n      });\n    };\n    const addKeyboardShortcuts = editor => {\n      editor.addShortcut('meta+z', '', 'Undo');\n      editor.addShortcut('meta+y,meta+shift+z', '', 'Redo');\n    };\n\n    const UndoManager = editor => {\n      const beforeBookmark = value$2();\n      const locks = Cell(0);\n      const index = Cell(0);\n      const undoManager = {\n        data: [],\n        typing: false,\n        beforeChange: () => {\n          beforeChange(editor, locks, beforeBookmark);\n        },\n        add: (level, event) => {\n          return addUndoLevel(editor, undoManager, index, locks, beforeBookmark, level, event);\n        },\n        dispatchChange: () => {\n          editor.setDirty(true);\n          const level = createFromEditor(editor);\n          level.bookmark = getUndoBookmark(editor.selection);\n          editor.dispatch('change', {\n            level,\n            lastLevel: get$b(undoManager.data, index.get()).getOrUndefined()\n          });\n        },\n        undo: () => {\n          return undo(editor, undoManager, locks, index);\n        },\n        redo: () => {\n          return redo(editor, index, undoManager.data);\n        },\n        clear: () => {\n          clear(editor, undoManager, index);\n        },\n        reset: () => {\n          reset(editor, undoManager);\n        },\n        hasUndo: () => {\n          return hasUndo(editor, undoManager, index);\n        },\n        hasRedo: () => {\n          return hasRedo(editor, undoManager, index);\n        },\n        transact: callback => {\n          return transact(editor, undoManager, locks, callback);\n        },\n        ignore: callback => {\n          ignore(editor, locks, callback);\n        },\n        extra: (callback1, callback2) => {\n          extra(editor, undoManager, index, callback1, callback2);\n        }\n      };\n      if (!isRtc(editor)) {\n        registerEvents(editor, undoManager, locks);\n      }\n      addKeyboardShortcuts(editor);\n      return undoManager;\n    };\n\n    const nonTypingKeycodes = [\n      9,\n      27,\n      VK.HOME,\n      VK.END,\n      19,\n      20,\n      44,\n      144,\n      145,\n      33,\n      34,\n      45,\n      16,\n      17,\n      18,\n      91,\n      92,\n      93,\n      VK.DOWN,\n      VK.UP,\n      VK.LEFT,\n      VK.RIGHT\n    ].concat(Env.browser.isFirefox() ? [224] : []);\n    const placeholderAttr = 'data-mce-placeholder';\n    const isKeyboardEvent = e => e.type === 'keydown' || e.type === 'keyup';\n    const isDeleteEvent = e => {\n      const keyCode = e.keyCode;\n      return keyCode === VK.BACKSPACE || keyCode === VK.DELETE;\n    };\n    const isNonTypingKeyboardEvent = e => {\n      if (isKeyboardEvent(e)) {\n        const keyCode = e.keyCode;\n        return !isDeleteEvent(e) && (VK.metaKeyPressed(e) || e.altKey || keyCode >= 112 && keyCode <= 123 || contains$2(nonTypingKeycodes, keyCode));\n      } else {\n        return false;\n      }\n    };\n    const isTypingKeyboardEvent = e => isKeyboardEvent(e) && !(isDeleteEvent(e) || e.type === 'keyup' && e.keyCode === 229);\n    const isVisuallyEmpty = (dom, rootElm, forcedRootBlock) => {\n      if (dom.isEmpty(rootElm, undefined, {\n          skipBogus: false,\n          includeZwsp: true\n        })) {\n        const firstElement = rootElm.firstElementChild;\n        if (!firstElement) {\n          return true;\n        } else if (dom.getStyle(rootElm.firstElementChild, 'padding-left') || dom.getStyle(rootElm.firstElementChild, 'padding-right')) {\n          return false;\n        } else {\n          return forcedRootBlock === firstElement.nodeName.toLowerCase();\n        }\n      } else {\n        return false;\n      }\n    };\n    const setup$r = editor => {\n      var _a;\n      const dom = editor.dom;\n      const rootBlock = getForcedRootBlock(editor);\n      const placeholder = (_a = getPlaceholder(editor)) !== null && _a !== void 0 ? _a : '';\n      const updatePlaceholder = (e, initial) => {\n        if (isNonTypingKeyboardEvent(e)) {\n          return;\n        }\n        const body = editor.getBody();\n        const showPlaceholder = isTypingKeyboardEvent(e) ? false : isVisuallyEmpty(dom, body, rootBlock);\n        const isPlaceholderShown = dom.getAttrib(body, placeholderAttr) !== '';\n        if (isPlaceholderShown !== showPlaceholder || initial) {\n          dom.setAttrib(body, placeholderAttr, showPlaceholder ? placeholder : null);\n          firePlaceholderToggle(editor, showPlaceholder);\n          editor.on(showPlaceholder ? 'keydown' : 'keyup', updatePlaceholder);\n          editor.off(showPlaceholder ? 'keyup' : 'keydown', updatePlaceholder);\n        }\n      };\n      if (isNotEmpty(placeholder)) {\n        editor.on('init', e => {\n          updatePlaceholder(e, true);\n          editor.on('change SetContent ExecCommand', updatePlaceholder);\n          editor.on('paste', e => Delay.setEditorTimeout(editor, () => updatePlaceholder(e)));\n        });\n      }\n    };\n\n    const blockPosition = (block, position) => ({\n      block,\n      position\n    });\n    const blockBoundary = (from, to) => ({\n      from,\n      to\n    });\n    const getBlockPosition = (rootNode, pos) => {\n      const rootElm = SugarElement.fromDom(rootNode);\n      const containerElm = SugarElement.fromDom(pos.container());\n      return getParentBlock$2(rootElm, containerElm).map(block => blockPosition(block, pos));\n    };\n    const isNotAncestorial = blockBoundary => !(contains(blockBoundary.to.block, blockBoundary.from.block) || contains(blockBoundary.from.block, blockBoundary.to.block));\n    const isDifferentBlocks = blockBoundary => !eq(blockBoundary.from.block, blockBoundary.to.block);\n    const getClosestHost = (root, scope) => {\n      const isRoot = node => eq(node, root);\n      const isHost = node => isTableCell$2(node) || isContentEditableTrue$3(node.dom);\n      return closest$4(scope, isHost, isRoot).filter(isElement$7).getOr(root);\n    };\n    const hasSameHost = (rootNode, blockBoundary) => {\n      const root = SugarElement.fromDom(rootNode);\n      return eq(getClosestHost(root, blockBoundary.from.block), getClosestHost(root, blockBoundary.to.block));\n    };\n    const isEditable$1 = blockBoundary => isContentEditableFalse$b(blockBoundary.from.block.dom) === false && isContentEditableFalse$b(blockBoundary.to.block.dom) === false;\n    const hasValidBlocks = blockBoundary => {\n      const isValidBlock = block => isTextBlock$2(block) || hasBlockAttr(block.dom) || isListItem$1(block);\n      return isValidBlock(blockBoundary.from.block) && isValidBlock(blockBoundary.to.block);\n    };\n    const skipLastBr = (schema, rootNode, forward, blockPosition) => {\n      if (isBr$6(blockPosition.position.getNode()) && !isEmpty$2(schema, blockPosition.block)) {\n        return positionIn(false, blockPosition.block.dom).bind(lastPositionInBlock => {\n          if (lastPositionInBlock.isEqual(blockPosition.position)) {\n            return fromPosition(forward, rootNode, lastPositionInBlock).bind(to => getBlockPosition(rootNode, to));\n          } else {\n            return Optional.some(blockPosition);\n          }\n        }).getOr(blockPosition);\n      } else {\n        return blockPosition;\n      }\n    };\n    const readFromRange = (schema, rootNode, forward, rng) => {\n      const fromBlockPos = getBlockPosition(rootNode, CaretPosition.fromRangeStart(rng));\n      const toBlockPos = fromBlockPos.bind(blockPos => fromPosition(forward, rootNode, blockPos.position).bind(to => getBlockPosition(rootNode, to).map(blockPos => skipLastBr(schema, rootNode, forward, blockPos))));\n      return lift2(fromBlockPos, toBlockPos, blockBoundary).filter(blockBoundary => isDifferentBlocks(blockBoundary) && hasSameHost(rootNode, blockBoundary) && isEditable$1(blockBoundary) && hasValidBlocks(blockBoundary) && isNotAncestorial(blockBoundary));\n    };\n    const read$1 = (schema, rootNode, forward, rng) => rng.collapsed ? readFromRange(schema, rootNode, forward, rng) : Optional.none();\n\n    const getChildrenUntilBlockBoundary = (block, schema) => {\n      const children = children$1(block);\n      return findIndex$2(children, el => schema.isBlock(name(el))).fold(constant(children), index => children.slice(0, index));\n    };\n    const extractChildren = (block, schema) => {\n      const children = getChildrenUntilBlockBoundary(block, schema);\n      each$e(children, remove$4);\n      return children;\n    };\n    const removeEmptyRoot = (schema, rootNode, block) => {\n      const parents = parentsAndSelf(block, rootNode);\n      return find$2(parents.reverse(), element => isEmpty$2(schema, element)).each(remove$4);\n    };\n    const isEmptyBefore = (schema, el) => filter$5(prevSiblings(el), el => !isEmpty$2(schema, el)).length === 0;\n    const nestedBlockMerge = (rootNode, fromBlock, toBlock, schema, insertionPoint) => {\n      if (isEmpty$2(schema, toBlock)) {\n        fillWithPaddingBr(toBlock);\n        return firstPositionIn(toBlock.dom);\n      }\n      if (isEmptyBefore(schema, insertionPoint) && isEmpty$2(schema, fromBlock)) {\n        before$3(insertionPoint, SugarElement.fromTag('br'));\n      }\n      const position = prevPosition(toBlock.dom, CaretPosition.before(insertionPoint.dom));\n      each$e(extractChildren(fromBlock, schema), child => {\n        before$3(insertionPoint, child);\n      });\n      removeEmptyRoot(schema, rootNode, fromBlock);\n      return position;\n    };\n    const isInline = (schema, node) => schema.isInline(name(node));\n    const sidelongBlockMerge = (rootNode, fromBlock, toBlock, schema) => {\n      if (isEmpty$2(schema, toBlock)) {\n        if (isEmpty$2(schema, fromBlock)) {\n          const getInlineToBlockDescendants = el => {\n            const helper = (node, elements) => firstChild(node).fold(() => elements, child => isInline(schema, child) ? helper(child, elements.concat(shallow$1(child))) : elements);\n            return helper(el, []);\n          };\n          const newFromBlockDescendants = foldr(getInlineToBlockDescendants(toBlock), (element, descendant) => {\n            wrap$2(element, descendant);\n            return descendant;\n          }, createPaddingBr());\n          empty(fromBlock);\n          append$1(fromBlock, newFromBlockDescendants);\n        }\n        remove$4(toBlock);\n        return firstPositionIn(fromBlock.dom);\n      }\n      const position = lastPositionIn(toBlock.dom);\n      each$e(extractChildren(fromBlock, schema), child => {\n        append$1(toBlock, child);\n      });\n      removeEmptyRoot(schema, rootNode, fromBlock);\n      return position;\n    };\n    const findInsertionPoint = (toBlock, block) => {\n      const parentsAndSelf$1 = parentsAndSelf(block, toBlock);\n      return Optional.from(parentsAndSelf$1[parentsAndSelf$1.length - 1]);\n    };\n    const getInsertionPoint = (fromBlock, toBlock) => contains(toBlock, fromBlock) ? findInsertionPoint(toBlock, fromBlock) : Optional.none();\n    const trimBr = (first, block) => {\n      positionIn(first, block.dom).bind(position => Optional.from(position.getNode())).map(SugarElement.fromDom).filter(isBr$5).each(remove$4);\n    };\n    const mergeBlockInto = (rootNode, fromBlock, toBlock, schema) => {\n      trimBr(true, fromBlock);\n      trimBr(false, toBlock);\n      return getInsertionPoint(fromBlock, toBlock).fold(curry(sidelongBlockMerge, rootNode, fromBlock, toBlock, schema), curry(nestedBlockMerge, rootNode, fromBlock, toBlock, schema));\n    };\n    const mergeBlocks = (rootNode, forward, block1, block2, schema) => forward ? mergeBlockInto(rootNode, block2, block1, schema) : mergeBlockInto(rootNode, block1, block2, schema);\n\n    const backspaceDelete$a = (editor, forward) => {\n      const rootNode = SugarElement.fromDom(editor.getBody());\n      const position = read$1(editor.schema, rootNode.dom, forward, editor.selection.getRng()).map(blockBoundary => () => {\n        mergeBlocks(rootNode, forward, blockBoundary.from.block, blockBoundary.to.block, editor.schema).each(pos => {\n          editor.selection.setRng(pos.toRange());\n        });\n      });\n      return position;\n    };\n\n    const deleteRangeMergeBlocks = (rootNode, selection, schema) => {\n      const rng = selection.getRng();\n      return lift2(getParentBlock$2(rootNode, SugarElement.fromDom(rng.startContainer)), getParentBlock$2(rootNode, SugarElement.fromDom(rng.endContainer)), (block1, block2) => {\n        if (!eq(block1, block2)) {\n          return Optional.some(() => {\n            rng.deleteContents();\n            mergeBlocks(rootNode, true, block1, block2, schema).each(pos => {\n              selection.setRng(pos.toRange());\n            });\n          });\n        } else {\n          return Optional.none();\n        }\n      }).getOr(Optional.none());\n    };\n    const isRawNodeInTable = (root, rawNode) => {\n      const node = SugarElement.fromDom(rawNode);\n      const isRoot = curry(eq, root);\n      return ancestor$4(node, isTableCell$2, isRoot).isSome();\n    };\n    const isSelectionInTable = (root, rng) => isRawNodeInTable(root, rng.startContainer) || isRawNodeInTable(root, rng.endContainer);\n    const isEverythingSelected = (root, rng) => {\n      const noPrevious = prevPosition(root.dom, CaretPosition.fromRangeStart(rng)).isNone();\n      const noNext = nextPosition(root.dom, CaretPosition.fromRangeEnd(rng)).isNone();\n      return !isSelectionInTable(root, rng) && noPrevious && noNext;\n    };\n    const emptyEditor = editor => {\n      return Optional.some(() => {\n        editor.setContent('');\n        editor.selection.setCursorLocation();\n      });\n    };\n    const deleteRange$2 = editor => {\n      const rootNode = SugarElement.fromDom(editor.getBody());\n      const rng = editor.selection.getRng();\n      return isEverythingSelected(rootNode, rng) ? emptyEditor(editor) : deleteRangeMergeBlocks(rootNode, editor.selection, editor.schema);\n    };\n    const backspaceDelete$9 = (editor, _forward) => editor.selection.isCollapsed() ? Optional.none() : deleteRange$2(editor);\n\n    const showCaret = (direction, editor, node, before, scrollIntoView) => Optional.from(editor._selectionOverrides.showCaret(direction, node, before, scrollIntoView));\n    const getNodeRange = node => {\n      const rng = node.ownerDocument.createRange();\n      rng.selectNode(node);\n      return rng;\n    };\n    const selectNode = (editor, node) => {\n      const e = editor.dispatch('BeforeObjectSelected', { target: node });\n      if (e.isDefaultPrevented()) {\n        return Optional.none();\n      }\n      return Optional.some(getNodeRange(node));\n    };\n    const renderCaretAtRange = (editor, range, scrollIntoView) => {\n      const normalizedRange = normalizeRange(1, editor.getBody(), range);\n      const caretPosition = CaretPosition.fromRangeStart(normalizedRange);\n      const caretPositionNode = caretPosition.getNode();\n      if (isInlineFakeCaretTarget(caretPositionNode)) {\n        return showCaret(1, editor, caretPositionNode, !caretPosition.isAtEnd(), false);\n      }\n      const caretPositionBeforeNode = caretPosition.getNode(true);\n      if (isInlineFakeCaretTarget(caretPositionBeforeNode)) {\n        return showCaret(1, editor, caretPositionBeforeNode, false, false);\n      }\n      const ceRoot = getContentEditableRoot$1(editor.dom.getRoot(), caretPosition.getNode());\n      if (isInlineFakeCaretTarget(ceRoot)) {\n        return showCaret(1, editor, ceRoot, false, scrollIntoView);\n      }\n      return Optional.none();\n    };\n    const renderRangeCaret = (editor, range, scrollIntoView) => range.collapsed ? renderCaretAtRange(editor, range, scrollIntoView).getOr(range) : range;\n\n    const isBeforeBoundary = pos => isBeforeContentEditableFalse(pos) || isBeforeMedia(pos);\n    const isAfterBoundary = pos => isAfterContentEditableFalse(pos) || isAfterMedia(pos);\n    const trimEmptyTextNode = (dom, node) => {\n      if (isText$b(node) && node.data.length === 0) {\n        dom.remove(node);\n      }\n    };\n    const deleteContentAndShowCaret = (editor, range, node, direction, forward, peekCaretPosition) => {\n      showCaret(direction, editor, peekCaretPosition.getNode(!forward), forward, true).each(caretRange => {\n        if (range.collapsed) {\n          const deleteRange = range.cloneRange();\n          if (forward) {\n            deleteRange.setEnd(caretRange.startContainer, caretRange.startOffset);\n          } else {\n            deleteRange.setStart(caretRange.endContainer, caretRange.endOffset);\n          }\n          deleteRange.deleteContents();\n        } else {\n          range.deleteContents();\n        }\n        editor.selection.setRng(caretRange);\n      });\n      trimEmptyTextNode(editor.dom, node);\n    };\n    const deleteBoundaryText = (editor, forward) => {\n      const range = editor.selection.getRng();\n      if (!isText$b(range.commonAncestorContainer)) {\n        return Optional.none();\n      }\n      const direction = forward ? HDirection.Forwards : HDirection.Backwards;\n      const caretWalker = CaretWalker(editor.getBody());\n      const getNextPosFn = curry(getVisualCaretPosition, forward ? caretWalker.next : caretWalker.prev);\n      const isBeforeFn = forward ? isBeforeBoundary : isAfterBoundary;\n      const caretPosition = getNormalizedRangeEndPoint(direction, editor.getBody(), range);\n      const nextCaretPosition = getNextPosFn(caretPosition);\n      const normalizedNextCaretPosition = nextCaretPosition ? normalizePosition(forward, nextCaretPosition) : nextCaretPosition;\n      if (!normalizedNextCaretPosition || !isMoveInsideSameBlock(caretPosition, normalizedNextCaretPosition)) {\n        return Optional.none();\n      } else if (isBeforeFn(normalizedNextCaretPosition)) {\n        return Optional.some(() => deleteContentAndShowCaret(editor, range, caretPosition.getNode(), direction, forward, normalizedNextCaretPosition));\n      }\n      const peekCaretPosition = getNextPosFn(normalizedNextCaretPosition);\n      if (peekCaretPosition && isBeforeFn(peekCaretPosition)) {\n        if (isMoveInsideSameBlock(normalizedNextCaretPosition, peekCaretPosition)) {\n          return Optional.some(() => deleteContentAndShowCaret(editor, range, caretPosition.getNode(), direction, forward, peekCaretPosition));\n        }\n      }\n      return Optional.none();\n    };\n    const backspaceDelete$8 = (editor, forward) => deleteBoundaryText(editor, forward);\n\n    const getEdgeCefPosition = (editor, atStart) => {\n      const root = editor.getBody();\n      return atStart ? firstPositionIn(root).filter(isBeforeContentEditableFalse) : lastPositionIn(root).filter(isAfterContentEditableFalse);\n    };\n    const isCefAtEdgeSelected = editor => {\n      const rng = editor.selection.getRng();\n      return !rng.collapsed && (getEdgeCefPosition(editor, true).exists(pos => pos.isEqual(CaretPosition.fromRangeStart(rng))) || getEdgeCefPosition(editor, false).exists(pos => pos.isEqual(CaretPosition.fromRangeEnd(rng))));\n    };\n\n    const isCompoundElement = node => isNonNullable(node) && (isTableCell$2(SugarElement.fromDom(node)) || isListItem$1(SugarElement.fromDom(node)));\n    const DeleteAction = Adt.generate([\n      { remove: ['element'] },\n      { moveToElement: ['element'] },\n      { moveToPosition: ['position'] }\n    ]);\n    const isAtContentEditableBlockCaret = (forward, from) => {\n      const elm = from.getNode(!forward);\n      const caretLocation = forward ? 'after' : 'before';\n      return isElement$6(elm) && elm.getAttribute('data-mce-caret') === caretLocation;\n    };\n    const isDeleteFromCefDifferentBlocks = (root, forward, from, to, schema) => {\n      const inSameBlock = elm => schema.isInline(elm.nodeName.toLowerCase()) && !isInSameBlock(from, to, root);\n      return getRelativeCefElm(!forward, from).fold(() => getRelativeCefElm(forward, to).fold(never, inSameBlock), inSameBlock);\n    };\n    const deleteEmptyBlockOrMoveToCef = (schema, root, forward, from, to) => {\n      const toCefElm = to.getNode(!forward);\n      return getParentBlock$2(SugarElement.fromDom(root), SugarElement.fromDom(from.getNode())).map(blockElm => isEmpty$2(schema, blockElm) ? DeleteAction.remove(blockElm.dom) : DeleteAction.moveToElement(toCefElm)).orThunk(() => Optional.some(DeleteAction.moveToElement(toCefElm)));\n    };\n    const findCefPosition = (root, forward, from, schema) => fromPosition(forward, root, from).bind(to => {\n      if (isCompoundElement(to.getNode())) {\n        return Optional.none();\n      } else if (isDeleteFromCefDifferentBlocks(root, forward, from, to, schema)) {\n        return Optional.none();\n      } else if (forward && isContentEditableFalse$b(to.getNode())) {\n        return deleteEmptyBlockOrMoveToCef(schema, root, forward, from, to);\n      } else if (!forward && isContentEditableFalse$b(to.getNode(true))) {\n        return deleteEmptyBlockOrMoveToCef(schema, root, forward, from, to);\n      } else if (forward && isAfterContentEditableFalse(from)) {\n        return Optional.some(DeleteAction.moveToPosition(to));\n      } else if (!forward && isBeforeContentEditableFalse(from)) {\n        return Optional.some(DeleteAction.moveToPosition(to));\n      } else {\n        return Optional.none();\n      }\n    });\n    const getContentEditableBlockAction = (forward, elm) => {\n      if (isNullable(elm)) {\n        return Optional.none();\n      } else if (forward && isContentEditableFalse$b(elm.nextSibling)) {\n        return Optional.some(DeleteAction.moveToElement(elm.nextSibling));\n      } else if (!forward && isContentEditableFalse$b(elm.previousSibling)) {\n        return Optional.some(DeleteAction.moveToElement(elm.previousSibling));\n      } else {\n        return Optional.none();\n      }\n    };\n    const skipMoveToActionFromInlineCefToContent = (root, from, deleteAction) => deleteAction.fold(elm => Optional.some(DeleteAction.remove(elm)), elm => Optional.some(DeleteAction.moveToElement(elm)), to => {\n      if (isInSameBlock(from, to, root)) {\n        return Optional.none();\n      } else {\n        return Optional.some(DeleteAction.moveToPosition(to));\n      }\n    });\n    const getContentEditableAction = (root, forward, from, schema) => {\n      if (isAtContentEditableBlockCaret(forward, from)) {\n        return getContentEditableBlockAction(forward, from.getNode(!forward)).orThunk(() => findCefPosition(root, forward, from, schema));\n      } else {\n        return findCefPosition(root, forward, from, schema).bind(deleteAction => skipMoveToActionFromInlineCefToContent(root, from, deleteAction));\n      }\n    };\n    const read = (root, forward, rng, schema) => {\n      const normalizedRange = normalizeRange(forward ? 1 : -1, root, rng);\n      const from = CaretPosition.fromRangeStart(normalizedRange);\n      const rootElement = SugarElement.fromDom(root);\n      if (!forward && isAfterContentEditableFalse(from)) {\n        return Optional.some(DeleteAction.remove(from.getNode(true)));\n      } else if (forward && isBeforeContentEditableFalse(from)) {\n        return Optional.some(DeleteAction.remove(from.getNode()));\n      } else if (!forward && isBeforeContentEditableFalse(from) && isAfterBr(rootElement, from, schema)) {\n        return findPreviousBr(rootElement, from, schema).map(br => DeleteAction.remove(br.getNode()));\n      } else if (forward && isAfterContentEditableFalse(from) && isBeforeBr$1(rootElement, from, schema)) {\n        return findNextBr(rootElement, from, schema).map(br => DeleteAction.remove(br.getNode()));\n      } else {\n        return getContentEditableAction(root, forward, from, schema);\n      }\n    };\n\n    const deleteElement$1 = (editor, forward) => element => {\n      editor._selectionOverrides.hideFakeCaret();\n      deleteElement$2(editor, forward, SugarElement.fromDom(element));\n      return true;\n    };\n    const moveToElement = (editor, forward) => element => {\n      const pos = forward ? CaretPosition.before(element) : CaretPosition.after(element);\n      editor.selection.setRng(pos.toRange());\n      return true;\n    };\n    const moveToPosition = editor => pos => {\n      editor.selection.setRng(pos.toRange());\n      return true;\n    };\n    const getAncestorCe = (editor, node) => Optional.from(getContentEditableRoot$1(editor.getBody(), node));\n    const backspaceDeleteCaret = (editor, forward) => {\n      const selectedNode = editor.selection.getNode();\n      return getAncestorCe(editor, selectedNode).filter(isContentEditableFalse$b).fold(() => read(editor.getBody(), forward, editor.selection.getRng(), editor.schema).map(deleteAction => () => deleteAction.fold(deleteElement$1(editor, forward), moveToElement(editor, forward), moveToPosition(editor))), () => Optional.some(noop));\n    };\n    const deleteOffscreenSelection = rootElement => {\n      each$e(descendants(rootElement, '.mce-offscreen-selection'), remove$4);\n    };\n    const backspaceDeleteRange = (editor, forward) => {\n      const selectedNode = editor.selection.getNode();\n      if (isContentEditableFalse$b(selectedNode) && !isTableCell$3(selectedNode)) {\n        const hasCefAncestor = getAncestorCe(editor, selectedNode.parentNode).filter(isContentEditableFalse$b);\n        return hasCefAncestor.fold(() => Optional.some(() => {\n          deleteOffscreenSelection(SugarElement.fromDom(editor.getBody()));\n          deleteElement$2(editor, forward, SugarElement.fromDom(editor.selection.getNode()));\n          paddEmptyBody(editor);\n        }), () => Optional.some(noop));\n      }\n      if (isCefAtEdgeSelected(editor)) {\n        return Optional.some(() => {\n          deleteRangeContents(editor, editor.selection.getRng(), SugarElement.fromDom(editor.getBody()));\n        });\n      }\n      return Optional.none();\n    };\n    const paddEmptyElement = editor => {\n      const dom = editor.dom, selection = editor.selection;\n      const ceRoot = getContentEditableRoot$1(editor.getBody(), selection.getNode());\n      if (isContentEditableTrue$3(ceRoot) && dom.isBlock(ceRoot) && dom.isEmpty(ceRoot)) {\n        const br = dom.create('br', { 'data-mce-bogus': '1' });\n        dom.setHTML(ceRoot, '');\n        ceRoot.appendChild(br);\n        selection.setRng(CaretPosition.before(br).toRange());\n      }\n      return true;\n    };\n    const backspaceDelete$7 = (editor, forward) => {\n      if (editor.selection.isCollapsed()) {\n        return backspaceDeleteCaret(editor, forward);\n      } else {\n        return backspaceDeleteRange(editor, forward);\n      }\n    };\n\n    const isTextEndpoint = endpoint => endpoint.hasOwnProperty('text');\n    const isElementEndpoint = endpoint => endpoint.hasOwnProperty('marker');\n    const getBookmark = (range, createMarker) => {\n      const getEndpoint = (container, offset) => {\n        if (isText$b(container)) {\n          return {\n            text: container,\n            offset\n          };\n        } else {\n          const marker = createMarker();\n          const children = container.childNodes;\n          if (offset < children.length) {\n            container.insertBefore(marker, children[offset]);\n            return {\n              marker,\n              before: true\n            };\n          } else {\n            container.appendChild(marker);\n            return {\n              marker,\n              before: false\n            };\n          }\n        }\n      };\n      const end = getEndpoint(range.endContainer, range.endOffset);\n      const start = getEndpoint(range.startContainer, range.startOffset);\n      return {\n        start,\n        end\n      };\n    };\n    const resolveBookmark = bm => {\n      var _a, _b;\n      const {start, end} = bm;\n      const rng = new window.Range();\n      if (isTextEndpoint(start)) {\n        rng.setStart(start.text, start.offset);\n      } else {\n        if (isElementEndpoint(start)) {\n          if (start.before) {\n            rng.setStartBefore(start.marker);\n          } else {\n            rng.setStartAfter(start.marker);\n          }\n          (_a = start.marker.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(start.marker);\n        }\n      }\n      if (isTextEndpoint(end)) {\n        rng.setEnd(end.text, end.offset);\n      } else {\n        if (isElementEndpoint(end)) {\n          if (end.before) {\n            rng.setEndBefore(end.marker);\n          } else {\n            rng.setEndAfter(end.marker);\n          }\n          (_b = end.marker.parentNode) === null || _b === void 0 ? void 0 : _b.removeChild(end.marker);\n        }\n      }\n      return rng;\n    };\n\n    const backspaceDelete$6 = (editor, forward) => {\n      var _a;\n      const dom = editor.dom;\n      const startBlock = dom.getParent(editor.selection.getStart(), dom.isBlock);\n      const endBlock = dom.getParent(editor.selection.getEnd(), dom.isBlock);\n      const body = editor.getBody();\n      const startBlockName = (_a = startBlock === null || startBlock === void 0 ? void 0 : startBlock.nodeName) === null || _a === void 0 ? void 0 : _a.toLowerCase();\n      if (startBlockName === 'div' && startBlock && endBlock && startBlock === body.firstChild && endBlock === body.lastChild && !dom.isEmpty(body)) {\n        const wrapper = startBlock.cloneNode(false);\n        const deleteAction = () => {\n          if (forward) {\n            execNativeForwardDeleteCommand(editor);\n          } else {\n            execNativeDeleteCommand(editor);\n          }\n          if (body.firstChild !== startBlock) {\n            const bookmark = getBookmark(editor.selection.getRng(), () => document.createElement('span'));\n            Array.from(body.childNodes).forEach(node => wrapper.appendChild(node));\n            body.appendChild(wrapper);\n            editor.selection.setRng(resolveBookmark(bookmark));\n          }\n        };\n        return Optional.some(deleteAction);\n      }\n      return Optional.none();\n    };\n\n    const deleteCaret$2 = (editor, forward) => {\n      const fromPos = CaretPosition.fromRangeStart(editor.selection.getRng());\n      return fromPosition(forward, editor.getBody(), fromPos).filter(pos => forward ? isBeforeImageBlock(pos) : isAfterImageBlock(pos)).bind(pos => getChildNodeAtRelativeOffset(forward ? 0 : -1, pos)).map(elm => () => editor.selection.select(elm));\n    };\n    const backspaceDelete$5 = (editor, forward) => editor.selection.isCollapsed() ? deleteCaret$2(editor, forward) : Optional.none();\n\n    const isText$2 = isText$b;\n    const startsWithCaretContainer = node => isText$2(node) && node.data[0] === ZWSP$1;\n    const endsWithCaretContainer = node => isText$2(node) && node.data[node.data.length - 1] === ZWSP$1;\n    const createZwsp = node => {\n      var _a;\n      const doc = (_a = node.ownerDocument) !== null && _a !== void 0 ? _a : document;\n      return doc.createTextNode(ZWSP$1);\n    };\n    const insertBefore$1 = node => {\n      var _a;\n      if (isText$2(node.previousSibling)) {\n        if (endsWithCaretContainer(node.previousSibling)) {\n          return node.previousSibling;\n        } else {\n          node.previousSibling.appendData(ZWSP$1);\n          return node.previousSibling;\n        }\n      } else if (isText$2(node)) {\n        if (startsWithCaretContainer(node)) {\n          return node;\n        } else {\n          node.insertData(0, ZWSP$1);\n          return node;\n        }\n      } else {\n        const newNode = createZwsp(node);\n        (_a = node.parentNode) === null || _a === void 0 ? void 0 : _a.insertBefore(newNode, node);\n        return newNode;\n      }\n    };\n    const insertAfter$1 = node => {\n      var _a, _b;\n      if (isText$2(node.nextSibling)) {\n        if (startsWithCaretContainer(node.nextSibling)) {\n          return node.nextSibling;\n        } else {\n          node.nextSibling.insertData(0, ZWSP$1);\n          return node.nextSibling;\n        }\n      } else if (isText$2(node)) {\n        if (endsWithCaretContainer(node)) {\n          return node;\n        } else {\n          node.appendData(ZWSP$1);\n          return node;\n        }\n      } else {\n        const newNode = createZwsp(node);\n        if (node.nextSibling) {\n          (_a = node.parentNode) === null || _a === void 0 ? void 0 : _a.insertBefore(newNode, node.nextSibling);\n        } else {\n          (_b = node.parentNode) === null || _b === void 0 ? void 0 : _b.appendChild(newNode);\n        }\n        return newNode;\n      }\n    };\n    const insertInline = (before, node) => before ? insertBefore$1(node) : insertAfter$1(node);\n    const insertInlineBefore = curry(insertInline, true);\n    const insertInlineAfter = curry(insertInline, false);\n\n    const insertInlinePos = (pos, before) => {\n      if (isText$b(pos.container())) {\n        return insertInline(before, pos.container());\n      } else {\n        return insertInline(before, pos.getNode());\n      }\n    };\n    const isPosCaretContainer = (pos, caret) => {\n      const caretNode = caret.get();\n      return caretNode && pos.container() === caretNode && isCaretContainerInline(caretNode);\n    };\n    const renderCaret = (caret, location) => location.fold(element => {\n      remove$2(caret.get());\n      const text = insertInlineBefore(element);\n      caret.set(text);\n      return Optional.some(CaretPosition(text, text.length - 1));\n    }, element => firstPositionIn(element).map(pos => {\n      if (!isPosCaretContainer(pos, caret)) {\n        remove$2(caret.get());\n        const text = insertInlinePos(pos, true);\n        caret.set(text);\n        return CaretPosition(text, 1);\n      } else {\n        const node = caret.get();\n        return CaretPosition(node, 1);\n      }\n    }), element => lastPositionIn(element).map(pos => {\n      if (!isPosCaretContainer(pos, caret)) {\n        remove$2(caret.get());\n        const text = insertInlinePos(pos, false);\n        caret.set(text);\n        return CaretPosition(text, text.length - 1);\n      } else {\n        const node = caret.get();\n        return CaretPosition(node, node.length - 1);\n      }\n    }), element => {\n      remove$2(caret.get());\n      const text = insertInlineAfter(element);\n      caret.set(text);\n      return Optional.some(CaretPosition(text, 1));\n    });\n\n    const evaluateUntil = (fns, args) => {\n      for (let i = 0; i < fns.length; i++) {\n        const result = fns[i].apply(null, args);\n        if (result.isSome()) {\n          return result;\n        }\n      }\n      return Optional.none();\n    };\n\n    const Location = Adt.generate([\n      { before: ['element'] },\n      { start: ['element'] },\n      { end: ['element'] },\n      { after: ['element'] }\n    ]);\n    const rescope$1 = (rootNode, node) => {\n      const parentBlock = getParentBlock$3(node, rootNode);\n      return parentBlock ? parentBlock : rootNode;\n    };\n    const before = (isInlineTarget, rootNode, pos) => {\n      const nPos = normalizeForwards(pos);\n      const scope = rescope$1(rootNode, nPos.container());\n      return findRootInline(isInlineTarget, scope, nPos).fold(() => nextPosition(scope, nPos).bind(curry(findRootInline, isInlineTarget, scope)).map(inline => Location.before(inline)), Optional.none);\n    };\n    const isNotInsideFormatCaretContainer = (rootNode, elm) => getParentCaretContainer(rootNode, elm) === null;\n    const findInsideRootInline = (isInlineTarget, rootNode, pos) => findRootInline(isInlineTarget, rootNode, pos).filter(curry(isNotInsideFormatCaretContainer, rootNode));\n    const start$1 = (isInlineTarget, rootNode, pos) => {\n      const nPos = normalizeBackwards(pos);\n      return findInsideRootInline(isInlineTarget, rootNode, nPos).bind(inline => {\n        const prevPos = prevPosition(inline, nPos);\n        return prevPos.isNone() ? Optional.some(Location.start(inline)) : Optional.none();\n      });\n    };\n    const end = (isInlineTarget, rootNode, pos) => {\n      const nPos = normalizeForwards(pos);\n      return findInsideRootInline(isInlineTarget, rootNode, nPos).bind(inline => {\n        const nextPos = nextPosition(inline, nPos);\n        return nextPos.isNone() ? Optional.some(Location.end(inline)) : Optional.none();\n      });\n    };\n    const after = (isInlineTarget, rootNode, pos) => {\n      const nPos = normalizeBackwards(pos);\n      const scope = rescope$1(rootNode, nPos.container());\n      return findRootInline(isInlineTarget, scope, nPos).fold(() => prevPosition(scope, nPos).bind(curry(findRootInline, isInlineTarget, scope)).map(inline => Location.after(inline)), Optional.none);\n    };\n    const isValidLocation = location => !isRtl(getElement(location));\n    const readLocation = (isInlineTarget, rootNode, pos) => {\n      const location = evaluateUntil([\n        before,\n        start$1,\n        end,\n        after\n      ], [\n        isInlineTarget,\n        rootNode,\n        pos\n      ]);\n      return location.filter(isValidLocation);\n    };\n    const getElement = location => location.fold(identity, identity, identity, identity);\n    const getName = location => location.fold(constant('before'), constant('start'), constant('end'), constant('after'));\n    const outside = location => location.fold(Location.before, Location.before, Location.after, Location.after);\n    const inside = location => location.fold(Location.start, Location.start, Location.end, Location.end);\n    const isEq = (location1, location2) => getName(location1) === getName(location2) && getElement(location1) === getElement(location2);\n    const betweenInlines = (forward, isInlineTarget, rootNode, from, to, location) => lift2(findRootInline(isInlineTarget, rootNode, from), findRootInline(isInlineTarget, rootNode, to), (fromInline, toInline) => {\n      if (fromInline !== toInline && hasSameParentBlock(rootNode, fromInline, toInline)) {\n        return Location.after(forward ? fromInline : toInline);\n      } else {\n        return location;\n      }\n    }).getOr(location);\n    const skipNoMovement = (fromLocation, toLocation) => fromLocation.fold(always, fromLocation => !isEq(fromLocation, toLocation));\n    const findLocationTraverse = (forward, isInlineTarget, rootNode, fromLocation, pos) => {\n      const from = normalizePosition(forward, pos);\n      const to = fromPosition(forward, rootNode, from).map(curry(normalizePosition, forward));\n      const location = to.fold(() => fromLocation.map(outside), to => readLocation(isInlineTarget, rootNode, to).map(curry(betweenInlines, forward, isInlineTarget, rootNode, from, to)).filter(curry(skipNoMovement, fromLocation)));\n      return location.filter(isValidLocation);\n    };\n    const findLocationSimple = (forward, location) => {\n      if (forward) {\n        return location.fold(compose(Optional.some, Location.start), Optional.none, compose(Optional.some, Location.after), Optional.none);\n      } else {\n        return location.fold(Optional.none, compose(Optional.some, Location.before), Optional.none, compose(Optional.some, Location.end));\n      }\n    };\n    const findLocation$1 = (forward, isInlineTarget, rootNode, pos) => {\n      const from = normalizePosition(forward, pos);\n      const fromLocation = readLocation(isInlineTarget, rootNode, from);\n      return readLocation(isInlineTarget, rootNode, from).bind(curry(findLocationSimple, forward)).orThunk(() => findLocationTraverse(forward, isInlineTarget, rootNode, fromLocation, pos));\n    };\n\n    const hasSelectionModifyApi = editor => {\n      return isFunction(editor.selection.getSel().modify);\n    };\n    const moveRel = (forward, selection, pos) => {\n      const delta = forward ? 1 : -1;\n      selection.setRng(CaretPosition(pos.container(), pos.offset() + delta).toRange());\n      selection.getSel().modify('move', forward ? 'forward' : 'backward', 'word');\n      return true;\n    };\n    const moveByWord = (forward, editor) => {\n      const rng = editor.selection.getRng();\n      const pos = forward ? CaretPosition.fromRangeEnd(rng) : CaretPosition.fromRangeStart(rng);\n      if (!hasSelectionModifyApi(editor)) {\n        return false;\n      } else if (forward && isBeforeInline(pos)) {\n        return moveRel(true, editor.selection, pos);\n      } else if (!forward && isAfterInline(pos)) {\n        return moveRel(false, editor.selection, pos);\n      } else {\n        return false;\n      }\n    };\n\n    var BreakType;\n    (function (BreakType) {\n      BreakType[BreakType['Br'] = 0] = 'Br';\n      BreakType[BreakType['Block'] = 1] = 'Block';\n      BreakType[BreakType['Wrap'] = 2] = 'Wrap';\n      BreakType[BreakType['Eol'] = 3] = 'Eol';\n    }(BreakType || (BreakType = {})));\n    const flip = (direction, positions) => direction === HDirection.Backwards ? reverse(positions) : positions;\n    const walk$1 = (direction, caretWalker, pos) => direction === HDirection.Forwards ? caretWalker.next(pos) : caretWalker.prev(pos);\n    const getBreakType = (scope, direction, currentPos, nextPos) => {\n      if (isBr$6(nextPos.getNode(direction === HDirection.Forwards))) {\n        return BreakType.Br;\n      } else if (isInSameBlock(currentPos, nextPos) === false) {\n        return BreakType.Block;\n      } else {\n        return BreakType.Wrap;\n      }\n    };\n    const getPositionsUntil = (predicate, direction, scope, start) => {\n      const caretWalker = CaretWalker(scope);\n      let currentPos = start;\n      const positions = [];\n      while (currentPos) {\n        const nextPos = walk$1(direction, caretWalker, currentPos);\n        if (!nextPos) {\n          break;\n        }\n        if (isBr$6(nextPos.getNode(false))) {\n          if (direction === HDirection.Forwards) {\n            return {\n              positions: flip(direction, positions).concat([nextPos]),\n              breakType: BreakType.Br,\n              breakAt: Optional.some(nextPos)\n            };\n          } else {\n            return {\n              positions: flip(direction, positions),\n              breakType: BreakType.Br,\n              breakAt: Optional.some(nextPos)\n            };\n          }\n        }\n        if (!nextPos.isVisible()) {\n          currentPos = nextPos;\n          continue;\n        }\n        if (predicate(currentPos, nextPos)) {\n          const breakType = getBreakType(scope, direction, currentPos, nextPos);\n          return {\n            positions: flip(direction, positions),\n            breakType,\n            breakAt: Optional.some(nextPos)\n          };\n        }\n        positions.push(nextPos);\n        currentPos = nextPos;\n      }\n      return {\n        positions: flip(direction, positions),\n        breakType: BreakType.Eol,\n        breakAt: Optional.none()\n      };\n    };\n    const getAdjacentLinePositions = (direction, getPositionsUntilBreak, scope, start) => getPositionsUntilBreak(scope, start).breakAt.map(pos => {\n      const positions = getPositionsUntilBreak(scope, pos).positions;\n      return direction === HDirection.Backwards ? positions.concat(pos) : [pos].concat(positions);\n    }).getOr([]);\n    const findClosestHorizontalPositionFromPoint = (positions, x) => foldl(positions, (acc, newPos) => acc.fold(() => Optional.some(newPos), lastPos => lift2(head(lastPos.getClientRects()), head(newPos.getClientRects()), (lastRect, newRect) => {\n      const lastDist = Math.abs(x - lastRect.left);\n      const newDist = Math.abs(x - newRect.left);\n      return newDist <= lastDist ? newPos : lastPos;\n    }).or(acc)), Optional.none());\n    const findClosestHorizontalPosition = (positions, pos) => head(pos.getClientRects()).bind(targetRect => findClosestHorizontalPositionFromPoint(positions, targetRect.left));\n    const getPositionsUntilPreviousLine = curry(getPositionsUntil, CaretPosition.isAbove, -1);\n    const getPositionsUntilNextLine = curry(getPositionsUntil, CaretPosition.isBelow, 1);\n    const getPositionsAbove = curry(getAdjacentLinePositions, -1, getPositionsUntilPreviousLine);\n    const getPositionsBelow = curry(getAdjacentLinePositions, 1, getPositionsUntilNextLine);\n    const isAtFirstLine = (scope, pos) => getPositionsUntilPreviousLine(scope, pos).breakAt.isNone();\n    const isAtLastLine = (scope, pos) => getPositionsUntilNextLine(scope, pos).breakAt.isNone();\n    const getFirstLinePositions = scope => firstPositionIn(scope).map(pos => [pos].concat(getPositionsUntilNextLine(scope, pos).positions)).getOr([]);\n    const getLastLinePositions = scope => lastPositionIn(scope).map(pos => getPositionsUntilPreviousLine(scope, pos).positions.concat(pos)).getOr([]);\n    const getClosestPositionAbove = (scope, pos) => findClosestHorizontalPosition(getPositionsAbove(scope, pos), pos);\n    const getClosestPositionBelow = (scope, pos) => findClosestHorizontalPosition(getPositionsBelow(scope, pos), pos);\n\n    const isContentEditableFalse$5 = isContentEditableFalse$b;\n    const distanceToRectLeft$1 = (clientRect, clientX) => Math.abs(clientRect.left - clientX);\n    const distanceToRectRight$1 = (clientRect, clientX) => Math.abs(clientRect.right - clientX);\n    const isNodeClientRect = rect => hasNonNullableKey(rect, 'node');\n    const findClosestClientRect = (clientRects, clientX) => reduce(clientRects, (oldClientRect, clientRect) => {\n      const oldDistance = Math.min(distanceToRectLeft$1(oldClientRect, clientX), distanceToRectRight$1(oldClientRect, clientX));\n      const newDistance = Math.min(distanceToRectLeft$1(clientRect, clientX), distanceToRectRight$1(clientRect, clientX));\n      if (newDistance === oldDistance && isNodeClientRect(clientRect) && isContentEditableFalse$5(clientRect.node)) {\n        return clientRect;\n      }\n      if (newDistance < oldDistance) {\n        return clientRect;\n      }\n      return oldClientRect;\n    });\n\n    const getNodeClientRects = node => {\n      const toArrayWithNode = clientRects => {\n        return map$3(clientRects, rect => {\n          const clientRect = clone$1(rect);\n          clientRect.node = node;\n          return clientRect;\n        });\n      };\n      if (isElement$6(node)) {\n        return toArrayWithNode(node.getClientRects());\n      } else if (isText$b(node)) {\n        const rng = node.ownerDocument.createRange();\n        rng.setStart(node, 0);\n        rng.setEnd(node, node.data.length);\n        return toArrayWithNode(rng.getClientRects());\n      } else {\n        return [];\n      }\n    };\n    const getClientRects = nodes => bind$3(nodes, getNodeClientRects);\n\n    var VDirection;\n    (function (VDirection) {\n      VDirection[VDirection['Up'] = -1] = 'Up';\n      VDirection[VDirection['Down'] = 1] = 'Down';\n    }(VDirection || (VDirection = {})));\n    const findUntil = (direction, root, predicateFn, node) => {\n      let currentNode = node;\n      while (currentNode = findNode(currentNode, direction, isEditableCaretCandidate$1, root)) {\n        if (predicateFn(currentNode)) {\n          return;\n        }\n      }\n    };\n    const walkUntil = (direction, isAboveFn, isBeflowFn, root, predicateFn, caretPosition) => {\n      let line = 0;\n      const result = [];\n      const add = node => {\n        let clientRects = getClientRects([node]);\n        if (direction === -1) {\n          clientRects = clientRects.reverse();\n        }\n        for (let i = 0; i < clientRects.length; i++) {\n          const clientRect = clientRects[i];\n          if (isBeflowFn(clientRect, targetClientRect)) {\n            continue;\n          }\n          if (result.length > 0 && isAboveFn(clientRect, last$1(result))) {\n            line++;\n          }\n          clientRect.line = line;\n          if (predicateFn(clientRect)) {\n            return true;\n          }\n          result.push(clientRect);\n        }\n        return false;\n      };\n      const targetClientRect = last$1(caretPosition.getClientRects());\n      if (!targetClientRect) {\n        return result;\n      }\n      const node = caretPosition.getNode();\n      if (node) {\n        add(node);\n        findUntil(direction, root, add, node);\n      }\n      return result;\n    };\n    const aboveLineNumber = (lineNumber, clientRect) => clientRect.line > lineNumber;\n    const isLineNumber = (lineNumber, clientRect) => clientRect.line === lineNumber;\n    const upUntil = curry(walkUntil, VDirection.Up, isAbove$1, isBelow$1);\n    const downUntil = curry(walkUntil, VDirection.Down, isBelow$1, isAbove$1);\n    const getLastClientRect = caretPosition => {\n      return last$1(caretPosition.getClientRects());\n    };\n    const positionsUntil = (direction, root, predicateFn, node) => {\n      const caretWalker = CaretWalker(root);\n      let walkFn;\n      let isBelowFn;\n      let isAboveFn;\n      let caretPosition;\n      const result = [];\n      let line = 0;\n      if (direction === 1) {\n        walkFn = caretWalker.next;\n        isBelowFn = isBelow$1;\n        isAboveFn = isAbove$1;\n        caretPosition = CaretPosition.after(node);\n      } else {\n        walkFn = caretWalker.prev;\n        isBelowFn = isAbove$1;\n        isAboveFn = isBelow$1;\n        caretPosition = CaretPosition.before(node);\n      }\n      const targetClientRect = getLastClientRect(caretPosition);\n      do {\n        if (!caretPosition.isVisible()) {\n          continue;\n        }\n        const rect = getLastClientRect(caretPosition);\n        if (isAboveFn(rect, targetClientRect)) {\n          continue;\n        }\n        if (result.length > 0 && isBelowFn(rect, last$1(result))) {\n          line++;\n        }\n        const clientRect = clone$1(rect);\n        clientRect.position = caretPosition;\n        clientRect.line = line;\n        if (predicateFn(clientRect)) {\n          return result;\n        }\n        result.push(clientRect);\n      } while (caretPosition = walkFn(caretPosition));\n      return result;\n    };\n    const isAboveLine = lineNumber => clientRect => aboveLineNumber(lineNumber, clientRect);\n    const isLine = lineNumber => clientRect => isLineNumber(lineNumber, clientRect);\n\n    const moveToRange = (editor, rng) => {\n      editor.selection.setRng(rng);\n      scrollRangeIntoView(editor, editor.selection.getRng());\n    };\n    const renderRangeCaretOpt = (editor, range, scrollIntoView) => Optional.some(renderRangeCaret(editor, range, scrollIntoView));\n    const moveHorizontally = (editor, direction, range, isBefore, isAfter, isElement) => {\n      const forwards = direction === HDirection.Forwards;\n      const caretWalker = CaretWalker(editor.getBody());\n      const getNextPosFn = curry(getVisualCaretPosition, forwards ? caretWalker.next : caretWalker.prev);\n      const isBeforeFn = forwards ? isBefore : isAfter;\n      if (!range.collapsed) {\n        const node = getSelectedNode(range);\n        if (isElement(node)) {\n          return showCaret(direction, editor, node, direction === HDirection.Backwards, false);\n        } else if (isCefAtEdgeSelected(editor)) {\n          const newRange = range.cloneRange();\n          newRange.collapse(direction === HDirection.Backwards);\n          return Optional.from(newRange);\n        }\n      }\n      const caretPosition = getNormalizedRangeEndPoint(direction, editor.getBody(), range);\n      if (isBeforeFn(caretPosition)) {\n        return selectNode(editor, caretPosition.getNode(!forwards));\n      }\n      let nextCaretPosition = getNextPosFn(caretPosition);\n      const rangeIsInContainerBlock = isRangeInCaretContainerBlock(range);\n      if (!nextCaretPosition) {\n        return rangeIsInContainerBlock ? Optional.some(range) : Optional.none();\n      } else {\n        nextCaretPosition = normalizePosition(forwards, nextCaretPosition);\n      }\n      if (isBeforeFn(nextCaretPosition)) {\n        return showCaret(direction, editor, nextCaretPosition.getNode(!forwards), forwards, false);\n      }\n      const peekCaretPosition = getNextPosFn(nextCaretPosition);\n      if (peekCaretPosition && isBeforeFn(peekCaretPosition)) {\n        if (isMoveInsideSameBlock(nextCaretPosition, peekCaretPosition)) {\n          return showCaret(direction, editor, peekCaretPosition.getNode(!forwards), forwards, false);\n        }\n      }\n      if (rangeIsInContainerBlock) {\n        return renderRangeCaretOpt(editor, nextCaretPosition.toRange(), false);\n      }\n      return Optional.none();\n    };\n    const moveVertically = (editor, direction, range, isBefore, isAfter, isElement) => {\n      const caretPosition = getNormalizedRangeEndPoint(direction, editor.getBody(), range);\n      const caretClientRect = last$1(caretPosition.getClientRects());\n      const forwards = direction === VDirection.Down;\n      const root = editor.getBody();\n      if (!caretClientRect) {\n        return Optional.none();\n      }\n      if (isCefAtEdgeSelected(editor)) {\n        const caretPosition = forwards ? CaretPosition.fromRangeEnd(range) : CaretPosition.fromRangeStart(range);\n        const getClosestFn = !forwards ? getClosestPositionAbove : getClosestPositionBelow;\n        return getClosestFn(root, caretPosition).orThunk(() => Optional.from(caretPosition)).map(pos => pos.toRange());\n      }\n      const walkerFn = forwards ? downUntil : upUntil;\n      const linePositions = walkerFn(root, isAboveLine(1), caretPosition);\n      const nextLinePositions = filter$5(linePositions, isLine(1));\n      const clientX = caretClientRect.left;\n      const nextLineRect = findClosestClientRect(nextLinePositions, clientX);\n      if (nextLineRect && isElement(nextLineRect.node)) {\n        const dist1 = Math.abs(clientX - nextLineRect.left);\n        const dist2 = Math.abs(clientX - nextLineRect.right);\n        return showCaret(direction, editor, nextLineRect.node, dist1 < dist2, false);\n      }\n      let currentNode;\n      if (isBefore(caretPosition)) {\n        currentNode = caretPosition.getNode();\n      } else if (isAfter(caretPosition)) {\n        currentNode = caretPosition.getNode(true);\n      } else {\n        currentNode = getSelectedNode(range);\n      }\n      if (currentNode) {\n        const caretPositions = positionsUntil(direction, root, isAboveLine(1), currentNode);\n        let closestNextLineRect = findClosestClientRect(filter$5(caretPositions, isLine(1)), clientX);\n        if (closestNextLineRect) {\n          return renderRangeCaretOpt(editor, closestNextLineRect.position.toRange(), false);\n        }\n        closestNextLineRect = last$1(filter$5(caretPositions, isLine(0)));\n        if (closestNextLineRect) {\n          return renderRangeCaretOpt(editor, closestNextLineRect.position.toRange(), false);\n        }\n      }\n      if (nextLinePositions.length === 0) {\n        return getLineEndPoint(editor, forwards).filter(forwards ? isAfter : isBefore).map(pos => renderRangeCaret(editor, pos.toRange(), false));\n      }\n      return Optional.none();\n    };\n    const getLineEndPoint = (editor, forward) => {\n      const rng = editor.selection.getRng();\n      const from = forward ? CaretPosition.fromRangeEnd(rng) : CaretPosition.fromRangeStart(rng);\n      const host = getEditingHost(from.container(), editor.getBody());\n      if (forward) {\n        const lineInfo = getPositionsUntilNextLine(host, from);\n        return last$2(lineInfo.positions);\n      } else {\n        const lineInfo = getPositionsUntilPreviousLine(host, from);\n        return head(lineInfo.positions);\n      }\n    };\n    const moveToLineEndPoint$3 = (editor, forward, isElementPosition) => getLineEndPoint(editor, forward).filter(isElementPosition).exists(pos => {\n      editor.selection.setRng(pos.toRange());\n      return true;\n    });\n\n    const setCaretPosition = (editor, pos) => {\n      const rng = editor.dom.createRng();\n      rng.setStart(pos.container(), pos.offset());\n      rng.setEnd(pos.container(), pos.offset());\n      editor.selection.setRng(rng);\n    };\n    const setSelected = (state, elm) => {\n      if (state) {\n        elm.setAttribute('data-mce-selected', 'inline-boundary');\n      } else {\n        elm.removeAttribute('data-mce-selected');\n      }\n    };\n    const renderCaretLocation = (editor, caret, location) => renderCaret(caret, location).map(pos => {\n      setCaretPosition(editor, pos);\n      return location;\n    });\n    const getPositionFromRange = (range, root, forward) => {\n      const start = CaretPosition.fromRangeStart(range);\n      if (range.collapsed) {\n        return start;\n      } else {\n        const end = CaretPosition.fromRangeEnd(range);\n        return forward ? prevPosition(root, end).getOr(end) : nextPosition(root, start).getOr(start);\n      }\n    };\n    const findLocation = (editor, caret, forward) => {\n      const rootNode = editor.getBody();\n      const from = getPositionFromRange(editor.selection.getRng(), rootNode, forward);\n      const isInlineTarget$1 = curry(isInlineTarget, editor);\n      const location = findLocation$1(forward, isInlineTarget$1, rootNode, from);\n      return location.bind(location => renderCaretLocation(editor, caret, location));\n    };\n    const toggleInlines = (isInlineTarget, dom, elms) => {\n      const inlineBoundaries = map$3(descendants(SugarElement.fromDom(dom.getRoot()), '*[data-mce-selected=\"inline-boundary\"]'), e => e.dom);\n      const selectedInlines = filter$5(inlineBoundaries, isInlineTarget);\n      const targetInlines = filter$5(elms, isInlineTarget);\n      each$e(difference(selectedInlines, targetInlines), curry(setSelected, false));\n      each$e(difference(targetInlines, selectedInlines), curry(setSelected, true));\n    };\n    const safeRemoveCaretContainer = (editor, caret) => {\n      const caretValue = caret.get();\n      if (editor.selection.isCollapsed() && !editor.composing && caretValue) {\n        const pos = CaretPosition.fromRangeStart(editor.selection.getRng());\n        if (CaretPosition.isTextPosition(pos) && !isAtZwsp(pos)) {\n          setCaretPosition(editor, removeAndReposition(caretValue, pos));\n          caret.set(null);\n        }\n      }\n    };\n    const renderInsideInlineCaret = (isInlineTarget, editor, caret, elms) => {\n      if (editor.selection.isCollapsed()) {\n        const inlines = filter$5(elms, isInlineTarget);\n        each$e(inlines, _inline => {\n          const pos = CaretPosition.fromRangeStart(editor.selection.getRng());\n          readLocation(isInlineTarget, editor.getBody(), pos).bind(location => renderCaretLocation(editor, caret, location));\n        });\n      }\n    };\n    const move$3 = (editor, caret, forward) => isInlineBoundariesEnabled(editor) ? findLocation(editor, caret, forward).isSome() : false;\n    const moveWord = (forward, editor, _caret) => isInlineBoundariesEnabled(editor) ? moveByWord(forward, editor) : false;\n    const setupSelectedState = editor => {\n      const caret = Cell(null);\n      const isInlineTarget$1 = curry(isInlineTarget, editor);\n      editor.on('NodeChange', e => {\n        if (isInlineBoundariesEnabled(editor)) {\n          toggleInlines(isInlineTarget$1, editor.dom, e.parents);\n          safeRemoveCaretContainer(editor, caret);\n          renderInsideInlineCaret(isInlineTarget$1, editor, caret, e.parents);\n        }\n      });\n      return caret;\n    };\n    const moveNextWord = curry(moveWord, true);\n    const movePrevWord = curry(moveWord, false);\n    const moveToLineEndPoint$2 = (editor, forward, caret) => {\n      if (isInlineBoundariesEnabled(editor)) {\n        const linePoint = getLineEndPoint(editor, forward).getOrThunk(() => {\n          const rng = editor.selection.getRng();\n          return forward ? CaretPosition.fromRangeEnd(rng) : CaretPosition.fromRangeStart(rng);\n        });\n        return readLocation(curry(isInlineTarget, editor), editor.getBody(), linePoint).exists(loc => {\n          const outsideLoc = outside(loc);\n          return renderCaret(caret, outsideLoc).exists(pos => {\n            setCaretPosition(editor, pos);\n            return true;\n          });\n        });\n      } else {\n        return false;\n      }\n    };\n\n    const rangeFromPositions = (from, to) => {\n      const range = document.createRange();\n      range.setStart(from.container(), from.offset());\n      range.setEnd(to.container(), to.offset());\n      return range;\n    };\n    const hasOnlyTwoOrLessPositionsLeft = elm => lift2(firstPositionIn(elm), lastPositionIn(elm), (firstPos, lastPos) => {\n      const normalizedFirstPos = normalizePosition(true, firstPos);\n      const normalizedLastPos = normalizePosition(false, lastPos);\n      return nextPosition(elm, normalizedFirstPos).forall(pos => pos.isEqual(normalizedLastPos));\n    }).getOr(true);\n    const setCaretLocation = (editor, caret) => location => renderCaret(caret, location).map(pos => () => setCaretPosition(editor, pos));\n    const deleteFromTo = (editor, caret, from, to) => {\n      const rootNode = editor.getBody();\n      const isInlineTarget$1 = curry(isInlineTarget, editor);\n      editor.undoManager.ignore(() => {\n        editor.selection.setRng(rangeFromPositions(from, to));\n        execNativeDeleteCommand(editor);\n        readLocation(isInlineTarget$1, rootNode, CaretPosition.fromRangeStart(editor.selection.getRng())).map(inside).bind(setCaretLocation(editor, caret)).each(call);\n      });\n      editor.nodeChanged();\n    };\n    const rescope = (rootNode, node) => {\n      const parentBlock = getParentBlock$3(node, rootNode);\n      return parentBlock ? parentBlock : rootNode;\n    };\n    const backspaceDeleteCollapsed = (editor, caret, forward, from) => {\n      const rootNode = rescope(editor.getBody(), from.container());\n      const isInlineTarget$1 = curry(isInlineTarget, editor);\n      const fromLocation = readLocation(isInlineTarget$1, rootNode, from);\n      const location = fromLocation.bind(location => {\n        if (forward) {\n          return location.fold(constant(Optional.some(inside(location))), Optional.none, constant(Optional.some(outside(location))), Optional.none);\n        } else {\n          return location.fold(Optional.none, constant(Optional.some(outside(location))), Optional.none, constant(Optional.some(inside(location))));\n        }\n      });\n      return location.map(setCaretLocation(editor, caret)).getOrThunk(() => {\n        const toPosition = navigate(forward, rootNode, from);\n        const toLocation = toPosition.bind(pos => readLocation(isInlineTarget$1, rootNode, pos));\n        return lift2(fromLocation, toLocation, () => findRootInline(isInlineTarget$1, rootNode, from).bind(elm => {\n          if (hasOnlyTwoOrLessPositionsLeft(elm)) {\n            return Optional.some(() => {\n              deleteElement$2(editor, forward, SugarElement.fromDom(elm));\n            });\n          } else {\n            return Optional.none();\n          }\n        })).getOrThunk(() => toLocation.bind(() => toPosition.map(to => {\n          return () => {\n            if (forward) {\n              deleteFromTo(editor, caret, from, to);\n            } else {\n              deleteFromTo(editor, caret, to, from);\n            }\n          };\n        })));\n      });\n    };\n    const backspaceDelete$4 = (editor, caret, forward) => {\n      if (editor.selection.isCollapsed() && isInlineBoundariesEnabled(editor)) {\n        const from = CaretPosition.fromRangeStart(editor.selection.getRng());\n        return backspaceDeleteCollapsed(editor, caret, forward, from);\n      }\n      return Optional.none();\n    };\n\n    const hasMultipleChildren = elm => childNodesCount(elm) > 1;\n    const getParentsUntil = (editor, pred) => {\n      const rootElm = SugarElement.fromDom(editor.getBody());\n      const startElm = SugarElement.fromDom(editor.selection.getStart());\n      const parents = parentsAndSelf(startElm, rootElm);\n      return findIndex$2(parents, pred).fold(constant(parents), index => parents.slice(0, index));\n    };\n    const hasOnlyOneChild = elm => childNodesCount(elm) === 1;\n    const getParentInlinesUntilMultichildInline = editor => getParentsUntil(editor, elm => editor.schema.isBlock(name(elm)) || hasMultipleChildren(elm));\n    const getParentInlines = editor => getParentsUntil(editor, el => editor.schema.isBlock(name(el)));\n    const getFormatNodes = (editor, parentInlines) => {\n      const isFormatElement$1 = curry(isFormatElement, editor);\n      return bind$3(parentInlines, elm => isFormatElement$1(elm) ? [elm.dom] : []);\n    };\n    const getFormatNodesAtStart = editor => {\n      const parentInlines = getParentInlines(editor);\n      return getFormatNodes(editor, parentInlines);\n    };\n    const deleteLastPosition = (forward, editor, target, parentInlines) => {\n      const formatNodes = getFormatNodes(editor, parentInlines);\n      if (formatNodes.length === 0) {\n        deleteElement$2(editor, forward, target);\n      } else {\n        const pos = replaceWithCaretFormat(target.dom, formatNodes);\n        editor.selection.setRng(pos.toRange());\n      }\n    };\n    const deleteCaret$1 = (editor, forward) => {\n      const parentInlines = filter$5(getParentInlinesUntilMultichildInline(editor), hasOnlyOneChild);\n      return last$2(parentInlines).bind(target => {\n        const fromPos = CaretPosition.fromRangeStart(editor.selection.getRng());\n        if (willDeleteLastPositionInElement(forward, fromPos, target.dom) && !isEmptyCaretFormatElement(target)) {\n          return Optional.some(() => deleteLastPosition(forward, editor, target, parentInlines));\n        } else {\n          return Optional.none();\n        }\n      });\n    };\n    const isBrInEmptyElement = (editor, elm) => {\n      const parentElm = elm.parentElement;\n      return isBr$6(elm) && !isNull(parentElm) && editor.dom.isEmpty(parentElm);\n    };\n    const isEmptyCaret = elm => isEmptyCaretFormatElement(SugarElement.fromDom(elm));\n    const createCaretFormatAtStart = (editor, formatNodes) => {\n      const startElm = editor.selection.getStart();\n      const pos = isBrInEmptyElement(editor, startElm) || isEmptyCaret(startElm) ? replaceWithCaretFormat(startElm, formatNodes) : createCaretFormatAtStart$1(editor.selection.getRng(), formatNodes);\n      editor.selection.setRng(pos.toRange());\n    };\n    const updateCaretFormat = (editor, updateFormats) => {\n      const missingFormats = difference(updateFormats, getFormatNodesAtStart(editor));\n      if (missingFormats.length > 0) {\n        createCaretFormatAtStart(editor, missingFormats);\n      }\n    };\n    const rangeStartsAtTextContainer = rng => isText$b(rng.startContainer);\n    const rangeStartsAtStartOfTextContainer = rng => rng.startOffset === 0 && rangeStartsAtTextContainer(rng);\n    const rangeStartParentIsFormatElement = (editor, rng) => {\n      const startParent = rng.startContainer.parentElement;\n      return !isNull(startParent) && isFormatElement(editor, SugarElement.fromDom(startParent));\n    };\n    const rangeStartAndEndHaveSameParent = rng => {\n      const startParent = rng.startContainer.parentNode;\n      const endParent = rng.endContainer.parentNode;\n      return !isNull(startParent) && !isNull(endParent) && startParent.isEqualNode(endParent);\n    };\n    const rangeEndsAtEndOfEndContainer = rng => {\n      const endContainer = rng.endContainer;\n      return rng.endOffset === (isText$b(endContainer) ? endContainer.length : endContainer.childNodes.length);\n    };\n    const rangeEndsAtEndOfStartContainer = rng => rangeStartAndEndHaveSameParent(rng) && rangeEndsAtEndOfEndContainer(rng);\n    const rangeEndsAfterEndOfStartContainer = rng => !rng.endContainer.isEqualNode(rng.commonAncestorContainer);\n    const rangeEndsAtOrAfterEndOfStartContainer = rng => rangeEndsAtEndOfStartContainer(rng) || rangeEndsAfterEndOfStartContainer(rng);\n    const requiresDeleteRangeOverride = editor => {\n      const rng = editor.selection.getRng();\n      return rangeStartsAtStartOfTextContainer(rng) && rangeStartParentIsFormatElement(editor, rng) && rangeEndsAtOrAfterEndOfStartContainer(rng);\n    };\n    const deleteRange$1 = editor => {\n      if (requiresDeleteRangeOverride(editor)) {\n        const formatNodes = getFormatNodesAtStart(editor);\n        return Optional.some(() => {\n          execNativeDeleteCommand(editor);\n          updateCaretFormat(editor, formatNodes);\n        });\n      } else {\n        return Optional.none();\n      }\n    };\n    const backspaceDelete$3 = (editor, forward) => editor.selection.isCollapsed() ? deleteCaret$1(editor, forward) : deleteRange$1(editor);\n    const hasAncestorInlineCaret = (elm, schema) => ancestor$2(elm, node => isCaretNode(node.dom), el => schema.isBlock(name(el)));\n    const hasAncestorInlineCaretAtStart = editor => hasAncestorInlineCaret(SugarElement.fromDom(editor.selection.getStart()), editor.schema);\n    const requiresRefreshCaretOverride = editor => {\n      const rng = editor.selection.getRng();\n      return rng.collapsed && (rangeStartsAtTextContainer(rng) || editor.dom.isEmpty(rng.startContainer)) && !hasAncestorInlineCaretAtStart(editor);\n    };\n    const refreshCaret = editor => {\n      if (requiresRefreshCaretOverride(editor)) {\n        createCaretFormatAtStart(editor, []);\n      }\n      return true;\n    };\n\n    const deleteElement = (editor, forward, element) => {\n      if (isNonNullable(element)) {\n        return Optional.some(() => {\n          editor._selectionOverrides.hideFakeCaret();\n          deleteElement$2(editor, forward, SugarElement.fromDom(element));\n        });\n      } else {\n        return Optional.none();\n      }\n    };\n    const deleteCaret = (editor, forward) => {\n      const isNearMedia = forward ? isBeforeMedia : isAfterMedia;\n      const direction = forward ? HDirection.Forwards : HDirection.Backwards;\n      const fromPos = getNormalizedRangeEndPoint(direction, editor.getBody(), editor.selection.getRng());\n      if (isNearMedia(fromPos)) {\n        return deleteElement(editor, forward, fromPos.getNode(!forward));\n      } else {\n        return Optional.from(normalizePosition(forward, fromPos)).filter(pos => isNearMedia(pos) && isMoveInsideSameBlock(fromPos, pos)).bind(pos => deleteElement(editor, forward, pos.getNode(!forward)));\n      }\n    };\n    const deleteRange = (editor, forward) => {\n      const selectedNode = editor.selection.getNode();\n      return isMedia$2(selectedNode) ? deleteElement(editor, forward, selectedNode) : Optional.none();\n    };\n    const backspaceDelete$2 = (editor, forward) => editor.selection.isCollapsed() ? deleteCaret(editor, forward) : deleteRange(editor, forward);\n\n    const isEditable = target => closest$4(target, elm => isContentEditableTrue$3(elm.dom) || isContentEditableFalse$b(elm.dom)).exists(elm => isContentEditableTrue$3(elm.dom));\n    const parseIndentValue = value => toInt(value !== null && value !== void 0 ? value : '').getOr(0);\n    const getIndentStyleName = (useMargin, element) => {\n      const indentStyleName = useMargin || isTable$1(element) ? 'margin' : 'padding';\n      const suffix = get$7(element, 'direction') === 'rtl' ? '-right' : '-left';\n      return indentStyleName + suffix;\n    };\n    const indentElement = (dom, command, useMargin, value, unit, element) => {\n      const indentStyleName = getIndentStyleName(useMargin, SugarElement.fromDom(element));\n      const parsedValue = parseIndentValue(dom.getStyle(element, indentStyleName));\n      if (command === 'outdent') {\n        const styleValue = Math.max(0, parsedValue - value);\n        dom.setStyle(element, indentStyleName, styleValue ? styleValue + unit : '');\n      } else {\n        const styleValue = parsedValue + value + unit;\n        dom.setStyle(element, indentStyleName, styleValue);\n      }\n    };\n    const validateBlocks = (editor, blocks) => forall(blocks, block => {\n      const indentStyleName = getIndentStyleName(shouldIndentUseMargin(editor), block);\n      const intentValue = getRaw(block, indentStyleName).map(parseIndentValue).getOr(0);\n      const contentEditable = editor.dom.getContentEditable(block.dom);\n      return contentEditable !== 'false' && intentValue > 0;\n    });\n    const canOutdent = editor => {\n      const blocks = getBlocksToIndent(editor);\n      return !editor.mode.isReadOnly() && (blocks.length > 1 || validateBlocks(editor, blocks));\n    };\n    const isListComponent = el => isList(el) || isListItem$1(el);\n    const parentIsListComponent = el => parent(el).exists(isListComponent);\n    const getBlocksToIndent = editor => filter$5(fromDom$1(editor.selection.getSelectedBlocks()), el => !isListComponent(el) && !parentIsListComponent(el) && isEditable(el));\n    const handle = (editor, command) => {\n      var _a, _b;\n      if (editor.mode.isReadOnly()) {\n        return;\n      }\n      const {dom} = editor;\n      const indentation = getIndentation(editor);\n      const indentUnit = (_b = (_a = /[a-z%]+$/i.exec(indentation)) === null || _a === void 0 ? void 0 : _a[0]) !== null && _b !== void 0 ? _b : 'px';\n      const indentValue = parseIndentValue(indentation);\n      const useMargin = shouldIndentUseMargin(editor);\n      each$e(getBlocksToIndent(editor), block => {\n        indentElement(dom, command, useMargin, indentValue, indentUnit, block.dom);\n      });\n    };\n    const indent = editor => handle(editor, 'indent');\n    const outdent = editor => handle(editor, 'outdent');\n\n    const backspaceDelete$1 = editor => {\n      if (editor.selection.isCollapsed() && canOutdent(editor)) {\n        const dom = editor.dom;\n        const rng = editor.selection.getRng();\n        const pos = CaretPosition.fromRangeStart(rng);\n        const block = dom.getParent(rng.startContainer, dom.isBlock);\n        if (block !== null && isAtStartOfBlock(SugarElement.fromDom(block), pos, editor.schema)) {\n          return Optional.some(() => outdent(editor));\n        }\n      }\n      return Optional.none();\n    };\n\n    const findAction = (editor, caret, forward) => findMap([\n      backspaceDelete$1,\n      backspaceDelete$7,\n      backspaceDelete$8,\n      (editor, forward) => backspaceDelete$4(editor, caret, forward),\n      backspaceDelete$a,\n      backspaceDelete$b,\n      backspaceDelete$5,\n      backspaceDelete$2,\n      backspaceDelete$9,\n      backspaceDelete$3,\n      backspaceDelete$6\n    ], item => item(editor, forward)).filter(_ => editor.selection.isEditable());\n    const deleteCommand = (editor, caret) => {\n      const result = findAction(editor, caret, false);\n      result.fold(() => {\n        if (editor.selection.isEditable()) {\n          execNativeDeleteCommand(editor);\n          paddEmptyBody(editor);\n        }\n      }, call);\n    };\n    const forwardDeleteCommand = (editor, caret) => {\n      const result = findAction(editor, caret, true);\n      result.fold(() => {\n        if (editor.selection.isEditable()) {\n          execNativeForwardDeleteCommand(editor);\n        }\n      }, call);\n    };\n    const setup$q = (editor, caret) => {\n      editor.addCommand('delete', () => {\n        deleteCommand(editor, caret);\n      });\n      editor.addCommand('forwardDelete', () => {\n        forwardDeleteCommand(editor, caret);\n      });\n    };\n\n    const SIGNIFICANT_MOVE = 5;\n    const LONGPRESS_DELAY = 400;\n    const getTouch = event => {\n      if (event.touches === undefined || event.touches.length !== 1) {\n        return Optional.none();\n      }\n      return Optional.some(event.touches[0]);\n    };\n    const isFarEnough = (touch, data) => {\n      const distX = Math.abs(touch.clientX - data.x);\n      const distY = Math.abs(touch.clientY - data.y);\n      return distX > SIGNIFICANT_MOVE || distY > SIGNIFICANT_MOVE;\n    };\n    const setup$p = editor => {\n      const startData = value$2();\n      const longpressFired = Cell(false);\n      const debounceLongpress = last(e => {\n        editor.dispatch('longpress', {\n          ...e,\n          type: 'longpress'\n        });\n        longpressFired.set(true);\n      }, LONGPRESS_DELAY);\n      editor.on('touchstart', e => {\n        getTouch(e).each(touch => {\n          debounceLongpress.cancel();\n          const data = {\n            x: touch.clientX,\n            y: touch.clientY,\n            target: e.target\n          };\n          debounceLongpress.throttle(e);\n          longpressFired.set(false);\n          startData.set(data);\n        });\n      }, true);\n      editor.on('touchmove', e => {\n        debounceLongpress.cancel();\n        getTouch(e).each(touch => {\n          startData.on(data => {\n            if (isFarEnough(touch, data)) {\n              startData.clear();\n              longpressFired.set(false);\n              editor.dispatch('longpresscancel');\n            }\n          });\n        });\n      }, true);\n      editor.on('touchend touchcancel', e => {\n        debounceLongpress.cancel();\n        if (e.type === 'touchcancel') {\n          return;\n        }\n        startData.get().filter(data => data.target.isEqualNode(e.target)).each(() => {\n          if (longpressFired.get()) {\n            e.preventDefault();\n          } else {\n            editor.dispatch('tap', {\n              ...e,\n              type: 'tap'\n            });\n          }\n        });\n      }, true);\n    };\n\n    const isBlockElement = (blockElements, node) => has$2(blockElements, node.nodeName);\n    const isValidTarget = (schema, node) => {\n      if (isText$b(node)) {\n        return true;\n      } else if (isElement$6(node)) {\n        return !isBlockElement(schema.getBlockElements(), node) && !isBookmarkNode$1(node) && !isTransparentBlock(schema, node) && !isNonHtmlElementRoot(node);\n      } else {\n        return false;\n      }\n    };\n    const hasBlockParent = (blockElements, root, node) => {\n      return exists(parents(SugarElement.fromDom(node), SugarElement.fromDom(root)), elm => {\n        return isBlockElement(blockElements, elm.dom);\n      });\n    };\n    const shouldRemoveTextNode = (blockElements, node) => {\n      if (isText$b(node)) {\n        if (node.data.length === 0) {\n          return true;\n        } else if (/^\\s+$/.test(node.data)) {\n          return !node.nextSibling || isBlockElement(blockElements, node.nextSibling) || isNonHtmlElementRoot(node.nextSibling);\n        }\n      }\n      return false;\n    };\n    const createRootBlock = editor => editor.dom.create(getForcedRootBlock(editor), getForcedRootBlockAttrs(editor));\n    const addRootBlocks = editor => {\n      const dom = editor.dom, selection = editor.selection;\n      const schema = editor.schema;\n      const blockElements = schema.getBlockElements();\n      const startNode = selection.getStart();\n      const rootNode = editor.getBody();\n      let rootBlockNode;\n      let tempNode;\n      let bm = null;\n      const forcedRootBlock = getForcedRootBlock(editor);\n      if (!startNode || !isElement$6(startNode)) {\n        return;\n      }\n      const rootNodeName = rootNode.nodeName.toLowerCase();\n      if (!schema.isValidChild(rootNodeName, forcedRootBlock.toLowerCase()) || hasBlockParent(blockElements, rootNode, startNode)) {\n        return;\n      }\n      if (rootNode.firstChild === rootNode.lastChild && isBr$6(rootNode.firstChild)) {\n        rootBlockNode = createRootBlock(editor);\n        rootBlockNode.appendChild(createPaddingBr().dom);\n        rootNode.replaceChild(rootBlockNode, rootNode.firstChild);\n        editor.selection.setCursorLocation(rootBlockNode, 0);\n        editor.nodeChanged();\n        return;\n      }\n      let node = rootNode.firstChild;\n      while (node) {\n        if (isElement$6(node)) {\n          updateElement(schema, node);\n        }\n        if (isValidTarget(schema, node)) {\n          if (shouldRemoveTextNode(blockElements, node)) {\n            tempNode = node;\n            node = node.nextSibling;\n            dom.remove(tempNode);\n            continue;\n          }\n          if (!rootBlockNode) {\n            if (!bm && editor.hasFocus()) {\n              bm = getBookmark(editor.selection.getRng(), () => document.createElement('span'));\n            }\n            if (!node.parentNode) {\n              node = null;\n              break;\n            }\n            rootBlockNode = createRootBlock(editor);\n            rootNode.insertBefore(rootBlockNode, node);\n          }\n          tempNode = node;\n          node = node.nextSibling;\n          rootBlockNode.appendChild(tempNode);\n        } else {\n          rootBlockNode = null;\n          node = node.nextSibling;\n        }\n      }\n      if (bm) {\n        editor.selection.setRng(resolveBookmark(bm));\n        editor.nodeChanged();\n      }\n    };\n    const insertEmptyLine = (editor, root, insertBlock) => {\n      const block = SugarElement.fromDom(createRootBlock(editor));\n      const br = createPaddingBr();\n      append$1(block, br);\n      insertBlock(root, block);\n      const rng = document.createRange();\n      rng.setStartBefore(br.dom);\n      rng.setEndBefore(br.dom);\n      return rng;\n    };\n    const setup$o = editor => {\n      editor.on('NodeChange', () => addRootBlocks(editor));\n    };\n\n    const hasClass = checkClassName => node => (' ' + node.attr('class') + ' ').indexOf(checkClassName) !== -1;\n    const replaceMatchWithSpan = (editor, content, cls) => {\n      return function (match) {\n        const args = arguments, index = args[args.length - 2];\n        const prevChar = index > 0 ? content.charAt(index - 1) : '';\n        if (prevChar === '\"') {\n          return match;\n        }\n        if (prevChar === '>') {\n          const findStartTagIndex = content.lastIndexOf('<', index);\n          if (findStartTagIndex !== -1) {\n            const tagHtml = content.substring(findStartTagIndex, index);\n            if (tagHtml.indexOf('contenteditable=\"false\"') !== -1) {\n              return match;\n            }\n          }\n        }\n        return '<span class=\"' + cls + '\" data-mce-content=\"' + editor.dom.encode(args[0]) + '\">' + editor.dom.encode(typeof args[1] === 'string' ? args[1] : args[0]) + '</span>';\n      };\n    };\n    const convertRegExpsToNonEditable = (editor, nonEditableRegExps, e) => {\n      let i = nonEditableRegExps.length, content = e.content;\n      if (e.format === 'raw') {\n        return;\n      }\n      while (i--) {\n        content = content.replace(nonEditableRegExps[i], replaceMatchWithSpan(editor, content, getNonEditableClass(editor)));\n      }\n      e.content = content;\n    };\n    const isValidContent = (nonEditableRegExps, content) => {\n      return forall(nonEditableRegExps, re => {\n        const matches = content.match(re);\n        return matches !== null && matches[0].length === content.length;\n      });\n    };\n    const setup$n = editor => {\n      const contentEditableAttrName = 'contenteditable';\n      const editClass = ' ' + Tools.trim(getEditableClass(editor)) + ' ';\n      const nonEditClass = ' ' + Tools.trim(getNonEditableClass(editor)) + ' ';\n      const hasEditClass = hasClass(editClass);\n      const hasNonEditClass = hasClass(nonEditClass);\n      const nonEditableRegExps = getNonEditableRegExps(editor);\n      if (nonEditableRegExps.length > 0) {\n        editor.on('BeforeSetContent', e => {\n          convertRegExpsToNonEditable(editor, nonEditableRegExps, e);\n        });\n      }\n      editor.parser.addAttributeFilter('class', nodes => {\n        let i = nodes.length;\n        while (i--) {\n          const node = nodes[i];\n          if (hasEditClass(node)) {\n            node.attr(contentEditableAttrName, 'true');\n          } else if (hasNonEditClass(node)) {\n            node.attr(contentEditableAttrName, 'false');\n          }\n        }\n      });\n      editor.serializer.addAttributeFilter(contentEditableAttrName, nodes => {\n        let i = nodes.length;\n        while (i--) {\n          const node = nodes[i];\n          if (!hasEditClass(node) && !hasNonEditClass(node)) {\n            continue;\n          }\n          const content = node.attr('data-mce-content');\n          if (nonEditableRegExps.length > 0 && content) {\n            if (isValidContent(nonEditableRegExps, content)) {\n              node.name = '#text';\n              node.type = 3;\n              node.raw = true;\n              node.value = content;\n            } else {\n              node.remove();\n            }\n          } else {\n            node.attr(contentEditableAttrName, null);\n          }\n        }\n      });\n    };\n\n    const findBlockCaretContainer = editor => descendant$1(SugarElement.fromDom(editor.getBody()), '*[data-mce-caret]').map(elm => elm.dom).getOrNull();\n    const showBlockCaretContainer = (editor, blockCaretContainer) => {\n      if (blockCaretContainer.hasAttribute('data-mce-caret')) {\n        showCaretContainerBlock(blockCaretContainer);\n        editor.selection.setRng(editor.selection.getRng());\n        editor.selection.scrollIntoView(blockCaretContainer);\n      }\n    };\n    const handleBlockContainer = (editor, e) => {\n      const blockCaretContainer = findBlockCaretContainer(editor);\n      if (!blockCaretContainer) {\n        return;\n      }\n      if (e.type === 'compositionstart') {\n        e.preventDefault();\n        e.stopPropagation();\n        showBlockCaretContainer(editor, blockCaretContainer);\n        return;\n      }\n      if (hasContent(blockCaretContainer)) {\n        showBlockCaretContainer(editor, blockCaretContainer);\n        editor.undoManager.add();\n      }\n    };\n    const setup$m = editor => {\n      editor.on('keyup compositionstart', curry(handleBlockContainer, editor));\n    };\n\n    const isContentEditableFalse$4 = isContentEditableFalse$b;\n    const moveToCeFalseHorizontally = (direction, editor, range) => moveHorizontally(editor, direction, range, isBeforeContentEditableFalse, isAfterContentEditableFalse, isContentEditableFalse$4);\n    const moveToCeFalseVertically = (direction, editor, range) => {\n      const isBefore = caretPosition => isBeforeContentEditableFalse(caretPosition) || isBeforeTable(caretPosition);\n      const isAfter = caretPosition => isAfterContentEditableFalse(caretPosition) || isAfterTable(caretPosition);\n      return moveVertically(editor, direction, range, isBefore, isAfter, isContentEditableFalse$4);\n    };\n    const createTextBlock = editor => {\n      const textBlock = editor.dom.create(getForcedRootBlock(editor));\n      textBlock.innerHTML = '<br data-mce-bogus=\"1\">';\n      return textBlock;\n    };\n    const exitPreBlock = (editor, direction, range) => {\n      const caretWalker = CaretWalker(editor.getBody());\n      const getVisualCaretPosition$1 = curry(getVisualCaretPosition, direction === 1 ? caretWalker.next : caretWalker.prev);\n      if (range.collapsed) {\n        const pre = editor.dom.getParent(range.startContainer, 'PRE');\n        if (!pre) {\n          return;\n        }\n        const caretPos = getVisualCaretPosition$1(CaretPosition.fromRangeStart(range));\n        if (!caretPos) {\n          const newBlock = SugarElement.fromDom(createTextBlock(editor));\n          if (direction === 1) {\n            after$4(SugarElement.fromDom(pre), newBlock);\n          } else {\n            before$3(SugarElement.fromDom(pre), newBlock);\n          }\n          editor.selection.select(newBlock.dom, true);\n          editor.selection.collapse();\n        }\n      }\n    };\n    const getHorizontalRange = (editor, forward) => {\n      const direction = forward ? HDirection.Forwards : HDirection.Backwards;\n      const range = editor.selection.getRng();\n      return moveToCeFalseHorizontally(direction, editor, range).orThunk(() => {\n        exitPreBlock(editor, direction, range);\n        return Optional.none();\n      });\n    };\n    const getVerticalRange = (editor, down) => {\n      const direction = down ? 1 : -1;\n      const range = editor.selection.getRng();\n      return moveToCeFalseVertically(direction, editor, range).orThunk(() => {\n        exitPreBlock(editor, direction, range);\n        return Optional.none();\n      });\n    };\n    const flipDirection = (selection, forward) => {\n      const elm = forward ? selection.getEnd(true) : selection.getStart(true);\n      return isRtl(elm) ? !forward : forward;\n    };\n    const moveH$2 = (editor, forward) => getHorizontalRange(editor, flipDirection(editor.selection, forward)).exists(newRange => {\n      moveToRange(editor, newRange);\n      return true;\n    });\n    const moveV$4 = (editor, down) => getVerticalRange(editor, down).exists(newRange => {\n      moveToRange(editor, newRange);\n      return true;\n    });\n    const moveToLineEndPoint$1 = (editor, forward) => {\n      const isCefPosition = forward ? isAfterContentEditableFalse : isBeforeContentEditableFalse;\n      return moveToLineEndPoint$3(editor, forward, isCefPosition);\n    };\n    const selectToEndPoint = (editor, forward) => getEdgeCefPosition(editor, !forward).map(pos => {\n      const rng = pos.toRange();\n      const curRng = editor.selection.getRng();\n      if (forward) {\n        rng.setStart(curRng.startContainer, curRng.startOffset);\n      } else {\n        rng.setEnd(curRng.endContainer, curRng.endOffset);\n      }\n      return rng;\n    }).exists(rng => {\n      moveToRange(editor, rng);\n      return true;\n    });\n\n    const isTarget = node => contains$2(['figcaption'], name(node));\n    const getClosestTargetBlock = (pos, root, schema) => {\n      const isRoot = curry(eq, root);\n      return closest$4(SugarElement.fromDom(pos.container()), el => schema.isBlock(name(el)), isRoot).filter(isTarget);\n    };\n    const isAtFirstOrLastLine = (root, forward, pos) => forward ? isAtLastLine(root.dom, pos) : isAtFirstLine(root.dom, pos);\n    const moveCaretToNewEmptyLine = (editor, forward) => {\n      const root = SugarElement.fromDom(editor.getBody());\n      const pos = CaretPosition.fromRangeStart(editor.selection.getRng());\n      return getClosestTargetBlock(pos, root, editor.schema).exists(() => {\n        if (isAtFirstOrLastLine(root, forward, pos)) {\n          const insertFn = forward ? append$1 : prepend;\n          const rng = insertEmptyLine(editor, root, insertFn);\n          editor.selection.setRng(rng);\n          return true;\n        } else {\n          return false;\n        }\n      });\n    };\n    const moveV$3 = (editor, forward) => {\n      if (editor.selection.isCollapsed()) {\n        return moveCaretToNewEmptyLine(editor, forward);\n      } else {\n        return false;\n      }\n    };\n\n    const moveUp = (editor, details, summary) => {\n      const rng = editor.selection.getRng();\n      const pos = CaretPosition.fromRangeStart(rng);\n      const root = editor.getBody();\n      if (root.firstChild === details && isAtFirstLine(summary, pos)) {\n        editor.execCommand('InsertNewBlockBefore');\n        return true;\n      } else {\n        return false;\n      }\n    };\n    const moveDown = (editor, details) => {\n      const rng = editor.selection.getRng();\n      const pos = CaretPosition.fromRangeStart(rng);\n      const root = editor.getBody();\n      if (root.lastChild === details && isAtLastLine(details, pos)) {\n        editor.execCommand('InsertNewBlockAfter');\n        return true;\n      } else {\n        return false;\n      }\n    };\n    const move$2 = (editor, forward) => {\n      if (forward) {\n        return Optional.from(editor.dom.getParent(editor.selection.getNode(), 'details')).map(details => moveDown(editor, details)).getOr(false);\n      } else {\n        return Optional.from(editor.dom.getParent(editor.selection.getNode(), 'summary')).bind(summary => Optional.from(editor.dom.getParent(summary, 'details')).map(details => moveUp(editor, details, summary))).getOr(false);\n      }\n    };\n    const moveV$2 = (editor, forward) => move$2(editor, forward);\n\n    const baseKeyPattern = {\n      shiftKey: false,\n      altKey: false,\n      ctrlKey: false,\n      metaKey: false,\n      keyCode: 0\n    };\n    const defaultPatterns = patterns => map$3(patterns, pattern => ({\n      ...baseKeyPattern,\n      ...pattern\n    }));\n    const defaultDelayedPatterns = patterns => map$3(patterns, pattern => ({\n      ...baseKeyPattern,\n      ...pattern\n    }));\n    const matchesEvent = (pattern, evt) => evt.keyCode === pattern.keyCode && evt.shiftKey === pattern.shiftKey && evt.altKey === pattern.altKey && evt.ctrlKey === pattern.ctrlKey && evt.metaKey === pattern.metaKey;\n    const match$1 = (patterns, evt) => bind$3(defaultPatterns(patterns), pattern => matchesEvent(pattern, evt) ? [pattern] : []);\n    const matchDelayed = (patterns, evt) => bind$3(defaultDelayedPatterns(patterns), pattern => matchesEvent(pattern, evt) ? [pattern] : []);\n    const action = (f, ...x) => () => f.apply(null, x);\n    const execute = (patterns, evt) => find$2(match$1(patterns, evt), pattern => pattern.action());\n    const executeWithDelayedAction = (patterns, evt) => findMap(matchDelayed(patterns, evt), pattern => pattern.action());\n\n    const moveH$1 = (editor, forward) => {\n      const direction = forward ? HDirection.Forwards : HDirection.Backwards;\n      const range = editor.selection.getRng();\n      return moveHorizontally(editor, direction, range, isBeforeMedia, isAfterMedia, isMedia$2).exists(newRange => {\n        moveToRange(editor, newRange);\n        return true;\n      });\n    };\n    const moveV$1 = (editor, down) => {\n      const direction = down ? 1 : -1;\n      const range = editor.selection.getRng();\n      return moveVertically(editor, direction, range, isBeforeMedia, isAfterMedia, isMedia$2).exists(newRange => {\n        moveToRange(editor, newRange);\n        return true;\n      });\n    };\n    const moveToLineEndPoint = (editor, forward) => {\n      const isNearMedia = forward ? isAfterMedia : isBeforeMedia;\n      return moveToLineEndPoint$3(editor, forward, isNearMedia);\n    };\n\n    const adt = Adt.generate([\n      { none: ['current'] },\n      { first: ['current'] },\n      {\n        middle: [\n          'current',\n          'target'\n        ]\n      },\n      { last: ['current'] }\n    ]);\n    const none = current => adt.none(current);\n    const CellLocation = {\n      ...adt,\n      none\n    };\n\n    const firstLayer = (scope, selector) => {\n      return filterFirstLayer(scope, selector, always);\n    };\n    const filterFirstLayer = (scope, selector, predicate) => {\n      return bind$3(children$1(scope), x => {\n        if (is$1(x, selector)) {\n          return predicate(x) ? [x] : [];\n        } else {\n          return filterFirstLayer(x, selector, predicate);\n        }\n      });\n    };\n\n    const lookup$1 = (tags, element, isRoot = never) => {\n      if (isRoot(element)) {\n        return Optional.none();\n      }\n      if (contains$2(tags, name(element))) {\n        return Optional.some(element);\n      }\n      const isRootOrUpperTable = elm => is$1(elm, 'table') || isRoot(elm);\n      return ancestor$3(element, tags.join(','), isRootOrUpperTable);\n    };\n    const cell = (element, isRoot) => lookup$1([\n      'td',\n      'th'\n    ], element, isRoot);\n    const cells = ancestor => firstLayer(ancestor, 'th,td');\n    const table = (element, isRoot) => closest$3(element, 'table', isRoot);\n\n    const walk = (all, current, index, direction, isEligible = always) => {\n      const forwards = direction === 1;\n      if (!forwards && index <= 0) {\n        return CellLocation.first(all[0]);\n      } else if (forwards && index >= all.length - 1) {\n        return CellLocation.last(all[all.length - 1]);\n      } else {\n        const newIndex = index + direction;\n        const elem = all[newIndex];\n        return isEligible(elem) ? CellLocation.middle(current, elem) : walk(all, current, newIndex, direction, isEligible);\n      }\n    };\n    const detect = (current, isRoot) => {\n      return table(current, isRoot).bind(table => {\n        const all = cells(table);\n        const index = findIndex$2(all, x => eq(current, x));\n        return index.map(index => ({\n          index,\n          all\n        }));\n      });\n    };\n    const next = (current, isEligible, isRoot) => {\n      const detection = detect(current, isRoot);\n      return detection.fold(() => {\n        return CellLocation.none(current);\n      }, info => {\n        return walk(info.all, current, info.index, 1, isEligible);\n      });\n    };\n    const prev = (current, isEligible, isRoot) => {\n      const detection = detect(current, isRoot);\n      return detection.fold(() => {\n        return CellLocation.none();\n      }, info => {\n        return walk(info.all, current, info.index, -1, isEligible);\n      });\n    };\n\n    const isTextNodeWithCursorPosition = el => getOption(el).filter(text => text.trim().length !== 0 || text.indexOf(nbsp) > -1).isSome();\n    const isContentEditableFalse$3 = elem => isHTMLElement$1(elem) && get$9(elem, 'contenteditable') === 'false';\n    const elementsWithCursorPosition = [\n      'img',\n      'br'\n    ];\n    const isCursorPosition = elem => {\n      const hasCursorPosition = isTextNodeWithCursorPosition(elem);\n      return hasCursorPosition || contains$2(elementsWithCursorPosition, name(elem)) || isContentEditableFalse$3(elem);\n    };\n\n    const first = element => descendant$2(element, isCursorPosition);\n\n    const deflate = (rect, delta) => ({\n      left: rect.left - delta,\n      top: rect.top - delta,\n      right: rect.right + delta * 2,\n      bottom: rect.bottom + delta * 2,\n      width: rect.width + delta,\n      height: rect.height + delta\n    });\n    const getCorners = (getYAxisValue, tds) => bind$3(tds, td => {\n      const rect = deflate(clone$1(td.getBoundingClientRect()), -1);\n      return [\n        {\n          x: rect.left,\n          y: getYAxisValue(rect),\n          cell: td\n        },\n        {\n          x: rect.right,\n          y: getYAxisValue(rect),\n          cell: td\n        }\n      ];\n    });\n    const findClosestCorner = (corners, x, y) => foldl(corners, (acc, newCorner) => acc.fold(() => Optional.some(newCorner), oldCorner => {\n      const oldDist = Math.sqrt(Math.abs(oldCorner.x - x) + Math.abs(oldCorner.y - y));\n      const newDist = Math.sqrt(Math.abs(newCorner.x - x) + Math.abs(newCorner.y - y));\n      return Optional.some(newDist < oldDist ? newCorner : oldCorner);\n    }), Optional.none());\n    const getClosestCell = (getYAxisValue, isTargetCorner, table, x, y) => {\n      const cells = descendants(SugarElement.fromDom(table), 'td,th,caption').map(e => e.dom);\n      const corners = filter$5(getCorners(getYAxisValue, cells), corner => isTargetCorner(corner, y));\n      return findClosestCorner(corners, x, y).map(corner => corner.cell);\n    };\n    const getBottomValue = rect => rect.bottom;\n    const getTopValue = rect => rect.top;\n    const isAbove = (corner, y) => corner.y < y;\n    const isBelow = (corner, y) => corner.y > y;\n    const getClosestCellAbove = curry(getClosestCell, getBottomValue, isAbove);\n    const getClosestCellBelow = curry(getClosestCell, getTopValue, isBelow);\n    const findClosestPositionInAboveCell = (table, pos) => head(pos.getClientRects()).bind(rect => getClosestCellAbove(table, rect.left, rect.top)).bind(cell => findClosestHorizontalPosition(getLastLinePositions(cell), pos));\n    const findClosestPositionInBelowCell = (table, pos) => last$2(pos.getClientRects()).bind(rect => getClosestCellBelow(table, rect.left, rect.top)).bind(cell => findClosestHorizontalPosition(getFirstLinePositions(cell), pos));\n\n    const hasNextBreak = (getPositionsUntil, scope, lineInfo) => lineInfo.breakAt.exists(breakPos => getPositionsUntil(scope, breakPos).breakAt.isSome());\n    const startsWithWrapBreak = lineInfo => lineInfo.breakType === BreakType.Wrap && lineInfo.positions.length === 0;\n    const startsWithBrBreak = lineInfo => lineInfo.breakType === BreakType.Br && lineInfo.positions.length === 1;\n    const isAtTableCellLine = (getPositionsUntil, scope, pos) => {\n      const lineInfo = getPositionsUntil(scope, pos);\n      if (startsWithWrapBreak(lineInfo) || !isBr$6(pos.getNode()) && startsWithBrBreak(lineInfo)) {\n        return !hasNextBreak(getPositionsUntil, scope, lineInfo);\n      } else {\n        return lineInfo.breakAt.isNone();\n      }\n    };\n    const isAtFirstTableCellLine = curry(isAtTableCellLine, getPositionsUntilPreviousLine);\n    const isAtLastTableCellLine = curry(isAtTableCellLine, getPositionsUntilNextLine);\n    const isCaretAtStartOrEndOfTable = (forward, rng, table) => {\n      const caretPos = CaretPosition.fromRangeStart(rng);\n      return positionIn(!forward, table).exists(pos => pos.isEqual(caretPos));\n    };\n    const navigateHorizontally = (editor, forward, table, _td) => {\n      const rng = editor.selection.getRng();\n      const direction = forward ? 1 : -1;\n      if (isFakeCaretTableBrowser() && isCaretAtStartOrEndOfTable(forward, rng, table)) {\n        showCaret(direction, editor, table, !forward, false).each(newRng => {\n          moveToRange(editor, newRng);\n        });\n        return true;\n      }\n      return false;\n    };\n    const getClosestAbovePosition = (root, table, start) => findClosestPositionInAboveCell(table, start).orThunk(() => head(start.getClientRects()).bind(rect => findClosestHorizontalPositionFromPoint(getPositionsAbove(root, CaretPosition.before(table)), rect.left))).getOr(CaretPosition.before(table));\n    const getClosestBelowPosition = (root, table, start) => findClosestPositionInBelowCell(table, start).orThunk(() => head(start.getClientRects()).bind(rect => findClosestHorizontalPositionFromPoint(getPositionsBelow(root, CaretPosition.after(table)), rect.left))).getOr(CaretPosition.after(table));\n    const getTable = (previous, pos) => {\n      const node = pos.getNode(previous);\n      return isTable$2(node) ? Optional.some(node) : Optional.none();\n    };\n    const renderBlock = (down, editor, table) => {\n      editor.undoManager.transact(() => {\n        const insertFn = down ? after$4 : before$3;\n        const rng = insertEmptyLine(editor, SugarElement.fromDom(table), insertFn);\n        moveToRange(editor, rng);\n      });\n    };\n    const moveCaret = (editor, down, pos) => {\n      const table = down ? getTable(true, pos) : getTable(false, pos);\n      const last = down === false;\n      table.fold(() => moveToRange(editor, pos.toRange()), table => positionIn(last, editor.getBody()).filter(lastPos => lastPos.isEqual(pos)).fold(() => moveToRange(editor, pos.toRange()), _ => renderBlock(down, editor, table)));\n    };\n    const navigateVertically = (editor, down, table, td) => {\n      const rng = editor.selection.getRng();\n      const pos = CaretPosition.fromRangeStart(rng);\n      const root = editor.getBody();\n      if (!down && isAtFirstTableCellLine(td, pos)) {\n        const newPos = getClosestAbovePosition(root, table, pos);\n        moveCaret(editor, down, newPos);\n        return true;\n      } else if (down && isAtLastTableCellLine(td, pos)) {\n        const newPos = getClosestBelowPosition(root, table, pos);\n        moveCaret(editor, down, newPos);\n        return true;\n      } else {\n        return false;\n      }\n    };\n    const move$1 = (editor, forward, mover) => Optional.from(editor.dom.getParent(editor.selection.getNode(), 'td,th')).bind(td => Optional.from(editor.dom.getParent(td, 'table')).map(table => mover(editor, forward, table, td))).getOr(false);\n    const moveH = (editor, forward) => move$1(editor, forward, navigateHorizontally);\n    const moveV = (editor, forward) => move$1(editor, forward, navigateVertically);\n    const getCellFirstCursorPosition = cell => {\n      const selection = SimSelection.exact(cell, 0, cell, 0);\n      return toNative(selection);\n    };\n    const tabGo = (editor, isRoot, cell) => {\n      return cell.fold(Optional.none, Optional.none, (_current, next) => {\n        return first(next).map(cell => {\n          return getCellFirstCursorPosition(cell);\n        });\n      }, current => {\n        if (editor.mode.isReadOnly()) {\n          return Optional.none();\n        }\n        editor.execCommand('mceTableInsertRowAfter');\n        return tabForward(editor, isRoot, current);\n      });\n    };\n    const tabForward = (editor, isRoot, cell) => tabGo(editor, isRoot, next(cell, isEditable$2));\n    const tabBackward = (editor, isRoot, cell) => tabGo(editor, isRoot, prev(cell, isEditable$2));\n    const handleTab = (editor, forward) => {\n      const rootElements = [\n        'table',\n        'li',\n        'dl'\n      ];\n      const body = SugarElement.fromDom(editor.getBody());\n      const isRoot = element => {\n        const name$1 = name(element);\n        return eq(element, body) || contains$2(rootElements, name$1);\n      };\n      const rng = editor.selection.getRng();\n      const container = SugarElement.fromDom(!forward ? rng.startContainer : rng.endContainer);\n      return cell(container, isRoot).map(cell => {\n        table(cell, isRoot).each(table => {\n          editor.model.table.clearSelectedCells(table.dom);\n        });\n        editor.selection.collapse(!forward);\n        const navigation = !forward ? tabBackward : tabForward;\n        const rng = navigation(editor, isRoot, cell);\n        rng.each(range => {\n          editor.selection.setRng(range);\n        });\n        return true;\n      }).getOr(false);\n    };\n\n    const executeKeydownOverride$4 = (editor, caret, evt) => {\n      const isMac = Env.os.isMacOS() || Env.os.isiOS();\n      execute([\n        {\n          keyCode: VK.RIGHT,\n          action: action(moveH$2, editor, true)\n        },\n        {\n          keyCode: VK.LEFT,\n          action: action(moveH$2, editor, false)\n        },\n        {\n          keyCode: VK.UP,\n          action: action(moveV$4, editor, false)\n        },\n        {\n          keyCode: VK.DOWN,\n          action: action(moveV$4, editor, true)\n        },\n        ...isMac ? [\n          {\n            keyCode: VK.UP,\n            action: action(selectToEndPoint, editor, false),\n            metaKey: true,\n            shiftKey: true\n          },\n          {\n            keyCode: VK.DOWN,\n            action: action(selectToEndPoint, editor, true),\n            metaKey: true,\n            shiftKey: true\n          }\n        ] : [],\n        {\n          keyCode: VK.RIGHT,\n          action: action(moveH, editor, true)\n        },\n        {\n          keyCode: VK.LEFT,\n          action: action(moveH, editor, false)\n        },\n        {\n          keyCode: VK.UP,\n          action: action(moveV, editor, false)\n        },\n        {\n          keyCode: VK.DOWN,\n          action: action(moveV, editor, true)\n        },\n        {\n          keyCode: VK.UP,\n          action: action(moveV, editor, false)\n        },\n        {\n          keyCode: VK.UP,\n          action: action(moveV$2, editor, false)\n        },\n        {\n          keyCode: VK.DOWN,\n          action: action(moveV$2, editor, true)\n        },\n        {\n          keyCode: VK.RIGHT,\n          action: action(moveH$1, editor, true)\n        },\n        {\n          keyCode: VK.LEFT,\n          action: action(moveH$1, editor, false)\n        },\n        {\n          keyCode: VK.UP,\n          action: action(moveV$1, editor, false)\n        },\n        {\n          keyCode: VK.DOWN,\n          action: action(moveV$1, editor, true)\n        },\n        {\n          keyCode: VK.RIGHT,\n          action: action(move$3, editor, caret, true)\n        },\n        {\n          keyCode: VK.LEFT,\n          action: action(move$3, editor, caret, false)\n        },\n        {\n          keyCode: VK.RIGHT,\n          ctrlKey: !isMac,\n          altKey: isMac,\n          action: action(moveNextWord, editor, caret)\n        },\n        {\n          keyCode: VK.LEFT,\n          ctrlKey: !isMac,\n          altKey: isMac,\n          action: action(movePrevWord, editor, caret)\n        },\n        {\n          keyCode: VK.UP,\n          action: action(moveV$3, editor, false)\n        },\n        {\n          keyCode: VK.DOWN,\n          action: action(moveV$3, editor, true)\n        }\n      ], evt).each(_ => {\n        evt.preventDefault();\n      });\n    };\n    const setup$l = (editor, caret) => {\n      editor.on('keydown', evt => {\n        if (!evt.isDefaultPrevented()) {\n          executeKeydownOverride$4(editor, caret, evt);\n        }\n      });\n    };\n\n    const point = (container, offset) => ({\n      container,\n      offset\n    });\n\n    const DOM$7 = DOMUtils.DOM;\n    const alwaysNext = startNode => node => startNode === node ? -1 : 0;\n    const isBoundary = dom => node => dom.isBlock(node) || contains$2([\n      'BR',\n      'IMG',\n      'HR',\n      'INPUT'\n    ], node.nodeName) || dom.getContentEditable(node) === 'false';\n    const textBefore = (node, offset, rootNode) => {\n      if (isText$b(node) && offset >= 0) {\n        return Optional.some(point(node, offset));\n      } else {\n        const textSeeker = TextSeeker(DOM$7);\n        return Optional.from(textSeeker.backwards(node, offset, alwaysNext(node), rootNode)).map(prev => point(prev.container, prev.container.data.length));\n      }\n    };\n    const textAfter = (node, offset, rootNode) => {\n      if (isText$b(node) && offset >= node.length) {\n        return Optional.some(point(node, offset));\n      } else {\n        const textSeeker = TextSeeker(DOM$7);\n        return Optional.from(textSeeker.forwards(node, offset, alwaysNext(node), rootNode)).map(prev => point(prev.container, 0));\n      }\n    };\n    const scanLeft = (node, offset, rootNode) => {\n      if (!isText$b(node)) {\n        return Optional.none();\n      }\n      const text = node.data;\n      if (offset >= 0 && offset <= text.length) {\n        return Optional.some(point(node, offset));\n      } else {\n        const textSeeker = TextSeeker(DOM$7);\n        return Optional.from(textSeeker.backwards(node, offset, alwaysNext(node), rootNode)).bind(prev => {\n          const prevText = prev.container.data;\n          return scanLeft(prev.container, offset + prevText.length, rootNode);\n        });\n      }\n    };\n    const scanRight = (node, offset, rootNode) => {\n      if (!isText$b(node)) {\n        return Optional.none();\n      }\n      const text = node.data;\n      if (offset <= text.length) {\n        return Optional.some(point(node, offset));\n      } else {\n        const textSeeker = TextSeeker(DOM$7);\n        return Optional.from(textSeeker.forwards(node, offset, alwaysNext(node), rootNode)).bind(next => scanRight(next.container, offset - text.length, rootNode));\n      }\n    };\n    const repeatLeft = (dom, node, offset, process, rootNode) => {\n      const search = TextSeeker(dom, isBoundary(dom));\n      return Optional.from(search.backwards(node, offset, process, rootNode));\n    };\n\n    const isValidTextRange = rng => rng.collapsed && isText$b(rng.startContainer);\n    const getText = rng => trim$2(rng.toString().replace(/\\u00A0/g, ' '));\n    const isWhitespace = chr => chr !== '' && ' \\xA0\\uFEFF\\f\\n\\r\\t\\x0B'.indexOf(chr) !== -1;\n\n    const stripTrigger = (text, trigger) => text.substring(trigger.length);\n    const findTrigger = (text, index, trigger, includeWhitespace = false) => {\n      let i;\n      const firstChar = trigger.charAt(0);\n      for (i = index - 1; i >= 0; i--) {\n        const char = text.charAt(i);\n        if (!includeWhitespace && isWhitespace(char)) {\n          return Optional.none();\n        }\n        if (firstChar === char && contains$1(text, trigger, i, index)) {\n          break;\n        }\n      }\n      return Optional.some(i);\n    };\n    const getContext = (dom, initRange, trigger, includeWhitespace = false) => {\n      if (!isValidTextRange(initRange)) {\n        return Optional.none();\n      }\n      const buffer = {\n        text: '',\n        offset: 0\n      };\n      const findTriggerIndex = (element, offset, text) => {\n        buffer.text = text + buffer.text;\n        buffer.offset += offset;\n        return findTrigger(buffer.text, buffer.offset, trigger, includeWhitespace).getOr(offset);\n      };\n      const root = dom.getParent(initRange.startContainer, dom.isBlock) || dom.getRoot();\n      return repeatLeft(dom, initRange.startContainer, initRange.startOffset, findTriggerIndex, root).bind(spot => {\n        const range = initRange.cloneRange();\n        range.setStart(spot.container, spot.offset);\n        range.setEnd(initRange.endContainer, initRange.endOffset);\n        if (range.collapsed) {\n          return Optional.none();\n        }\n        const text = getText(range);\n        const triggerIndex = text.lastIndexOf(trigger);\n        if (triggerIndex !== 0) {\n          return Optional.none();\n        } else {\n          return Optional.some({\n            text: stripTrigger(text, trigger),\n            range,\n            trigger\n          });\n        }\n      });\n    };\n\n    const isText$1 = node => node.nodeType === TEXT;\n    const isElement = node => node.nodeType === ELEMENT;\n    const toLast = node => {\n      if (isText$1(node)) {\n        return point(node, node.data.length);\n      } else {\n        const children = node.childNodes;\n        return children.length > 0 ? toLast(children[children.length - 1]) : point(node, children.length);\n      }\n    };\n    const toLeaf = (node, offset) => {\n      const children = node.childNodes;\n      if (children.length > 0 && offset < children.length) {\n        return toLeaf(children[offset], 0);\n      } else if (children.length > 0 && isElement(node) && children.length === offset) {\n        return toLast(children[children.length - 1]);\n      } else {\n        return point(node, offset);\n      }\n    };\n\n    const isPreviousCharContent = (dom, leaf) => {\n      var _a;\n      const root = (_a = dom.getParent(leaf.container, dom.isBlock)) !== null && _a !== void 0 ? _a : dom.getRoot();\n      return repeatLeft(dom, leaf.container, leaf.offset, (_element, offset) => offset === 0 ? -1 : offset, root).filter(spot => {\n        const char = spot.container.data.charAt(spot.offset - 1);\n        return !isWhitespace(char);\n      }).isSome();\n    };\n    const isStartOfWord = dom => rng => {\n      const leaf = toLeaf(rng.startContainer, rng.startOffset);\n      return !isPreviousCharContent(dom, leaf);\n    };\n    const getTriggerContext = (dom, initRange, database) => findMap(database.triggers, trigger => getContext(dom, initRange, trigger));\n    const lookup = (editor, getDatabase) => {\n      const database = getDatabase();\n      const rng = editor.selection.getRng();\n      return getTriggerContext(editor.dom, rng, database).bind(context => lookupWithContext(editor, getDatabase, context));\n    };\n    const lookupWithContext = (editor, getDatabase, context, fetchOptions = {}) => {\n      var _a;\n      const database = getDatabase();\n      const rng = editor.selection.getRng();\n      const startText = (_a = rng.startContainer.nodeValue) !== null && _a !== void 0 ? _a : '';\n      const autocompleters = filter$5(database.lookupByTrigger(context.trigger), autocompleter => context.text.length >= autocompleter.minChars && autocompleter.matches.getOrThunk(() => isStartOfWord(editor.dom))(context.range, startText, context.text));\n      if (autocompleters.length === 0) {\n        return Optional.none();\n      }\n      const lookupData = Promise.all(map$3(autocompleters, ac => {\n        const fetchResult = ac.fetch(context.text, ac.maxResults, fetchOptions);\n        return fetchResult.then(results => ({\n          matchText: context.text,\n          items: results,\n          columns: ac.columns,\n          onAction: ac.onAction,\n          highlightOn: ac.highlightOn\n        }));\n      }));\n      return Optional.some({\n        lookupData,\n        context\n      });\n    };\n\n    var SimpleResultType;\n    (function (SimpleResultType) {\n      SimpleResultType[SimpleResultType['Error'] = 0] = 'Error';\n      SimpleResultType[SimpleResultType['Value'] = 1] = 'Value';\n    }(SimpleResultType || (SimpleResultType = {})));\n    const fold$1 = (res, onError, onValue) => res.stype === SimpleResultType.Error ? onError(res.serror) : onValue(res.svalue);\n    const partition = results => {\n      const values = [];\n      const errors = [];\n      each$e(results, obj => {\n        fold$1(obj, err => errors.push(err), val => values.push(val));\n      });\n      return {\n        values,\n        errors\n      };\n    };\n    const mapError = (res, f) => {\n      if (res.stype === SimpleResultType.Error) {\n        return {\n          stype: SimpleResultType.Error,\n          serror: f(res.serror)\n        };\n      } else {\n        return res;\n      }\n    };\n    const map = (res, f) => {\n      if (res.stype === SimpleResultType.Value) {\n        return {\n          stype: SimpleResultType.Value,\n          svalue: f(res.svalue)\n        };\n      } else {\n        return res;\n      }\n    };\n    const bind$1 = (res, f) => {\n      if (res.stype === SimpleResultType.Value) {\n        return f(res.svalue);\n      } else {\n        return res;\n      }\n    };\n    const bindError = (res, f) => {\n      if (res.stype === SimpleResultType.Error) {\n        return f(res.serror);\n      } else {\n        return res;\n      }\n    };\n    const svalue = v => ({\n      stype: SimpleResultType.Value,\n      svalue: v\n    });\n    const serror = e => ({\n      stype: SimpleResultType.Error,\n      serror: e\n    });\n    const toResult = res => fold$1(res, Result.error, Result.value);\n    const fromResult = res => res.fold(serror, svalue);\n    const SimpleResult = {\n      fromResult,\n      toResult,\n      svalue,\n      partition,\n      serror,\n      bind: bind$1,\n      bindError,\n      map,\n      mapError,\n      fold: fold$1\n    };\n\n    const formatObj = input => {\n      return isObject(input) && keys(input).length > 100 ? ' removed due to size' : JSON.stringify(input, null, 2);\n    };\n    const formatErrors = errors => {\n      const es = errors.length > 10 ? errors.slice(0, 10).concat([{\n          path: [],\n          getErrorInfo: constant('... (only showing first ten failures)')\n        }]) : errors;\n      return map$3(es, e => {\n        return 'Failed path: (' + e.path.join(' > ') + ')\\n' + e.getErrorInfo();\n      });\n    };\n\n    const nu = (path, getErrorInfo) => {\n      return SimpleResult.serror([{\n          path,\n          getErrorInfo\n        }]);\n    };\n    const missingRequired = (path, key, obj) => nu(path, () => 'Could not find valid *required* value for \"' + key + '\" in ' + formatObj(obj));\n    const missingKey = (path, key) => nu(path, () => 'Choice schema did not contain choice key: \"' + key + '\"');\n    const missingBranch = (path, branches, branch) => nu(path, () => 'The chosen schema: \"' + branch + '\" did not exist in branches: ' + formatObj(branches));\n    const custom = (path, err) => nu(path, constant(err));\n\n    const chooseFrom = (path, input, branches, ch) => {\n      const fields = get$a(branches, ch);\n      return fields.fold(() => missingBranch(path, branches, ch), vp => vp.extract(path.concat(['branch: ' + ch]), input));\n    };\n    const choose$1 = (key, branches) => {\n      const extract = (path, input) => {\n        const choice = get$a(input, key);\n        return choice.fold(() => missingKey(path, key), chosen => chooseFrom(path, input, branches, chosen));\n      };\n      const toString = () => 'chooseOn(' + key + '). Possible values: ' + keys(branches);\n      return {\n        extract,\n        toString\n      };\n    };\n\n    const shallow = (old, nu) => {\n      return nu;\n    };\n    const deep = (old, nu) => {\n      const bothObjects = isPlainObject(old) && isPlainObject(nu);\n      return bothObjects ? deepMerge(old, nu) : nu;\n    };\n    const baseMerge = merger => {\n      return (...objects) => {\n        if (objects.length === 0) {\n          throw new Error(`Can't merge zero objects`);\n        }\n        const ret = {};\n        for (let j = 0; j < objects.length; j++) {\n          const curObject = objects[j];\n          for (const key in curObject) {\n            if (has$2(curObject, key)) {\n              ret[key] = merger(ret[key], curObject[key]);\n            }\n          }\n        }\n        return ret;\n      };\n    };\n    const deepMerge = baseMerge(deep);\n    const merge = baseMerge(shallow);\n\n    const required = () => ({\n      tag: 'required',\n      process: {}\n    });\n    const defaultedThunk = fallbackThunk => ({\n      tag: 'defaultedThunk',\n      process: fallbackThunk\n    });\n    const defaulted$1 = fallback => defaultedThunk(constant(fallback));\n    const asOption = () => ({\n      tag: 'option',\n      process: {}\n    });\n\n    const mergeValues = (values, base) => values.length > 0 ? SimpleResult.svalue(deepMerge(base, merge.apply(undefined, values))) : SimpleResult.svalue(base);\n    const mergeErrors = errors => compose(SimpleResult.serror, flatten)(errors);\n    const consolidateObj = (objects, base) => {\n      const partition = SimpleResult.partition(objects);\n      return partition.errors.length > 0 ? mergeErrors(partition.errors) : mergeValues(partition.values, base);\n    };\n    const consolidateArr = objects => {\n      const partitions = SimpleResult.partition(objects);\n      return partitions.errors.length > 0 ? mergeErrors(partitions.errors) : SimpleResult.svalue(partitions.values);\n    };\n    const ResultCombine = {\n      consolidateObj,\n      consolidateArr\n    };\n\n    const field$1 = (key, newKey, presence, prop) => ({\n      tag: 'field',\n      key,\n      newKey,\n      presence,\n      prop\n    });\n    const customField$1 = (newKey, instantiator) => ({\n      tag: 'custom',\n      newKey,\n      instantiator\n    });\n    const fold = (value, ifField, ifCustom) => {\n      switch (value.tag) {\n      case 'field':\n        return ifField(value.key, value.newKey, value.presence, value.prop);\n      case 'custom':\n        return ifCustom(value.newKey, value.instantiator);\n      }\n    };\n\n    const value = validator => {\n      const extract = (path, val) => {\n        return SimpleResult.bindError(validator(val), err => custom(path, err));\n      };\n      const toString = constant('val');\n      return {\n        extract,\n        toString\n      };\n    };\n    const anyValue$1 = value(SimpleResult.svalue);\n\n    const requiredAccess = (path, obj, key, bundle) => get$a(obj, key).fold(() => missingRequired(path, key, obj), bundle);\n    const fallbackAccess = (obj, key, fallback, bundle) => {\n      const v = get$a(obj, key).getOrThunk(() => fallback(obj));\n      return bundle(v);\n    };\n    const optionAccess = (obj, key, bundle) => bundle(get$a(obj, key));\n    const optionDefaultedAccess = (obj, key, fallback, bundle) => {\n      const opt = get$a(obj, key).map(val => val === true ? fallback(obj) : val);\n      return bundle(opt);\n    };\n    const extractField = (field, path, obj, key, prop) => {\n      const bundle = av => prop.extract(path.concat([key]), av);\n      const bundleAsOption = optValue => optValue.fold(() => SimpleResult.svalue(Optional.none()), ov => {\n        const result = prop.extract(path.concat([key]), ov);\n        return SimpleResult.map(result, Optional.some);\n      });\n      switch (field.tag) {\n      case 'required':\n        return requiredAccess(path, obj, key, bundle);\n      case 'defaultedThunk':\n        return fallbackAccess(obj, key, field.process, bundle);\n      case 'option':\n        return optionAccess(obj, key, bundleAsOption);\n      case 'defaultedOptionThunk':\n        return optionDefaultedAccess(obj, key, field.process, bundleAsOption);\n      case 'mergeWithThunk': {\n          return fallbackAccess(obj, key, constant({}), v => {\n            const result = deepMerge(field.process(obj), v);\n            return bundle(result);\n          });\n        }\n      }\n    };\n    const extractFields = (path, obj, fields) => {\n      const success = {};\n      const errors = [];\n      for (const field of fields) {\n        fold(field, (key, newKey, presence, prop) => {\n          const result = extractField(presence, path, obj, key, prop);\n          SimpleResult.fold(result, err => {\n            errors.push(...err);\n          }, res => {\n            success[newKey] = res;\n          });\n        }, (newKey, instantiator) => {\n          success[newKey] = instantiator(obj);\n        });\n      }\n      return errors.length > 0 ? SimpleResult.serror(errors) : SimpleResult.svalue(success);\n    };\n    const objOf = values => {\n      const extract = (path, o) => extractFields(path, o, values);\n      const toString = () => {\n        const fieldStrings = map$3(values, value => fold(value, (key, _okey, _presence, prop) => key + ' -> ' + prop.toString(), (newKey, _instantiator) => 'state(' + newKey + ')'));\n        return 'obj{\\n' + fieldStrings.join('\\n') + '}';\n      };\n      return {\n        extract,\n        toString\n      };\n    };\n    const arrOf = prop => {\n      const extract = (path, array) => {\n        const results = map$3(array, (a, i) => prop.extract(path.concat(['[' + i + ']']), a));\n        return ResultCombine.consolidateArr(results);\n      };\n      const toString = () => 'array(' + prop.toString() + ')';\n      return {\n        extract,\n        toString\n      };\n    };\n\n    const valueOf = validator => value(v => validator(v).fold(SimpleResult.serror, SimpleResult.svalue));\n    const extractValue = (label, prop, obj) => {\n      const res = prop.extract([label], obj);\n      return SimpleResult.mapError(res, errs => ({\n        input: obj,\n        errors: errs\n      }));\n    };\n    const asRaw = (label, prop, obj) => SimpleResult.toResult(extractValue(label, prop, obj));\n    const formatError = errInfo => {\n      return 'Errors: \\n' + formatErrors(errInfo.errors).join('\\n') + '\\n\\nInput object: ' + formatObj(errInfo.input);\n    };\n    const choose = (key, branches) => choose$1(key, map$2(branches, objOf));\n\n    const anyValue = constant(anyValue$1);\n    const typedValue = (validator, expectedType) => value(a => {\n      const actualType = typeof a;\n      return validator(a) ? SimpleResult.svalue(a) : SimpleResult.serror(`Expected type: ${ expectedType } but got: ${ actualType }`);\n    });\n    const number = typedValue(isNumber, 'number');\n    const string = typedValue(isString, 'string');\n    const boolean = typedValue(isBoolean, 'boolean');\n    const functionProcessor = typedValue(isFunction, 'function');\n\n    const field = field$1;\n    const customField = customField$1;\n    const validateEnum = values => valueOf(value => contains$2(values, value) ? Result.value(value) : Result.error(`Unsupported value: \"${ value }\", choose one of \"${ values.join(', ') }\".`));\n    const requiredOf = (key, schema) => field(key, key, required(), schema);\n    const requiredString = key => requiredOf(key, string);\n    const requiredFunction = key => requiredOf(key, functionProcessor);\n    const requiredArrayOf = (key, schema) => field(key, key, required(), arrOf(schema));\n    const optionOf = (key, schema) => field(key, key, asOption(), schema);\n    const optionString = key => optionOf(key, string);\n    const optionFunction = key => optionOf(key, functionProcessor);\n    const defaulted = (key, fallback) => field(key, key, defaulted$1(fallback), anyValue());\n    const defaultedOf = (key, fallback, schema) => field(key, key, defaulted$1(fallback), schema);\n    const defaultedNumber = (key, fallback) => defaultedOf(key, fallback, number);\n    const defaultedString = (key, fallback) => defaultedOf(key, fallback, string);\n    const defaultedStringEnum = (key, fallback, values) => defaultedOf(key, fallback, validateEnum(values));\n    const defaultedBoolean = (key, fallback) => defaultedOf(key, fallback, boolean);\n    const defaultedFunction = (key, fallback) => defaultedOf(key, fallback, functionProcessor);\n    const defaultedArrayOf = (key, fallback, schema) => defaultedOf(key, fallback, arrOf(schema));\n\n    const type = requiredString('type');\n    const fetch$1 = requiredFunction('fetch');\n    const onAction = requiredFunction('onAction');\n    const onSetup = defaultedFunction('onSetup', () => noop);\n    const optionalText = optionString('text');\n    const optionalIcon = optionString('icon');\n    const optionalTooltip = optionString('tooltip');\n    const optionalLabel = optionString('label');\n    const active = defaultedBoolean('active', false);\n    const enabled = defaultedBoolean('enabled', true);\n    const primary = defaultedBoolean('primary', false);\n    const defaultedColumns = num => defaulted('columns', num);\n    const defaultedType = type => defaultedString('type', type);\n\n    const autocompleterSchema = objOf([\n      type,\n      requiredString('trigger'),\n      defaultedNumber('minChars', 1),\n      defaultedColumns(1),\n      defaultedNumber('maxResults', 10),\n      optionFunction('matches'),\n      fetch$1,\n      onAction,\n      defaultedArrayOf('highlightOn', [], string)\n    ]);\n    const createAutocompleter = spec => asRaw('Autocompleter', autocompleterSchema, spec);\n\n    const baseToolbarButtonFields = [\n      enabled,\n      optionalTooltip,\n      optionalIcon,\n      optionalText,\n      onSetup,\n      defaultedString('context', 'mode:design')\n    ];\n\n    const baseToolbarToggleButtonFields = [active].concat(baseToolbarButtonFields);\n\n    const contextBarFields = [\n      defaultedFunction('predicate', never),\n      defaultedStringEnum('scope', 'node', [\n        'node',\n        'editor'\n      ]),\n      defaultedStringEnum('position', 'selection', [\n        'node',\n        'selection',\n        'line'\n      ])\n    ];\n\n    const contextButtonFields = baseToolbarButtonFields.concat([\n      defaultedType('contextformbutton'),\n      primary,\n      onAction,\n      customField('original', identity)\n    ]);\n    const contextToggleButtonFields = baseToolbarToggleButtonFields.concat([\n      defaultedType('contextformbutton'),\n      primary,\n      onAction,\n      customField('original', identity)\n    ]);\n    const launchButtonFields = baseToolbarButtonFields.concat([defaultedType('contextformbutton')]);\n    const launchToggleButtonFields = baseToolbarToggleButtonFields.concat([defaultedType('contextformtogglebutton')]);\n    const toggleOrNormal = choose('type', {\n      contextformbutton: contextButtonFields,\n      contextformtogglebutton: contextToggleButtonFields\n    });\n    objOf([\n      defaultedType('contextform'),\n      defaultedFunction('initValue', constant('')),\n      optionalLabel,\n      requiredArrayOf('commands', toggleOrNormal),\n      optionOf('launch', choose('type', {\n        contextformbutton: launchButtonFields,\n        contextformtogglebutton: launchToggleButtonFields\n      }))\n    ].concat(contextBarFields));\n\n    const register$2 = editor => {\n      const popups = editor.ui.registry.getAll().popups;\n      const dataset = map$2(popups, popup => createAutocompleter(popup).fold(err => {\n        throw new Error(formatError(err));\n      }, identity));\n      const triggers = stringArray(mapToArray(dataset, v => v.trigger));\n      const datasetValues = values(dataset);\n      const lookupByTrigger = trigger => filter$5(datasetValues, dv => dv.trigger === trigger);\n      return {\n        dataset,\n        triggers,\n        lookupByTrigger\n      };\n    };\n\n    const setupEditorInput = (editor, api) => {\n      const update = last(api.load, 50);\n      editor.on('input', e => {\n        if (e.inputType === 'insertCompositionText' && !editor.composing) {\n          return;\n        }\n        update.throttle();\n      });\n      editor.on('keydown', e => {\n        const keyCode = e.which;\n        if (keyCode === 8) {\n          update.throttle();\n        } else if (keyCode === 27) {\n          update.cancel();\n          api.cancelIfNecessary();\n        } else if (keyCode === 38 || keyCode === 40) {\n          update.cancel();\n        }\n      }, true);\n      editor.on('remove', update.cancel);\n    };\n    const setup$k = editor => {\n      const activeAutocompleter = value$2();\n      const uiActive = Cell(false);\n      const isActive = activeAutocompleter.isSet;\n      const cancelIfNecessary = () => {\n        if (isActive()) {\n          fireAutocompleterEnd(editor);\n          uiActive.set(false);\n          activeAutocompleter.clear();\n        }\n      };\n      const commenceIfNecessary = context => {\n        if (!isActive()) {\n          activeAutocompleter.set({\n            trigger: context.trigger,\n            matchLength: context.text.length\n          });\n        }\n      };\n      const getAutocompleters = cached(() => register$2(editor));\n      const doLookup = fetchOptions => activeAutocompleter.get().map(ac => getContext(editor.dom, editor.selection.getRng(), ac.trigger, true).bind(newContext => lookupWithContext(editor, getAutocompleters, newContext, fetchOptions))).getOrThunk(() => lookup(editor, getAutocompleters));\n      const load = fetchOptions => {\n        doLookup(fetchOptions).fold(cancelIfNecessary, lookupInfo => {\n          commenceIfNecessary(lookupInfo.context);\n          lookupInfo.lookupData.then(lookupData => {\n            activeAutocompleter.get().map(ac => {\n              const context = lookupInfo.context;\n              if (ac.trigger !== context.trigger) {\n                return;\n              }\n              activeAutocompleter.set({\n                ...ac,\n                matchLength: context.text.length\n              });\n              if (uiActive.get()) {\n                fireAutocompleterUpdateActiveRange(editor, { range: context.range });\n                fireAutocompleterUpdate(editor, { lookupData });\n              } else {\n                uiActive.set(true);\n                fireAutocompleterUpdateActiveRange(editor, { range: context.range });\n                fireAutocompleterStart(editor, { lookupData });\n              }\n            });\n          });\n        });\n      };\n      const isRangeInsideOrEqual = (innerRange, outerRange) => {\n        const startComparison = innerRange.compareBoundaryPoints(window.Range.START_TO_START, outerRange);\n        const endComparison = innerRange.compareBoundaryPoints(window.Range.END_TO_END, outerRange);\n        return startComparison >= 0 && endComparison <= 0;\n      };\n      const readActiveRange = () => {\n        return activeAutocompleter.get().bind(({trigger}) => {\n          const selRange = editor.selection.getRng();\n          return getContext(editor.dom, selRange, trigger, uiActive.get()).filter(({range}) => isRangeInsideOrEqual(selRange, range)).map(({range}) => range);\n        });\n      };\n      editor.addCommand('mceAutocompleterReload', (_ui, value) => {\n        const fetchOptions = isObject(value) ? value.fetchOptions : {};\n        load(fetchOptions);\n      });\n      editor.addCommand('mceAutocompleterClose', cancelIfNecessary);\n      editor.addCommand('mceAutocompleterRefreshActiveRange', () => {\n        readActiveRange().each(range => {\n          fireAutocompleterUpdateActiveRange(editor, { range });\n        });\n      });\n      editor.editorCommands.addQueryStateHandler('mceAutoCompleterInRange', () => readActiveRange().isSome());\n      setupEditorInput(editor, {\n        cancelIfNecessary,\n        load\n      });\n    };\n\n    const browser$1 = detect$1().browser;\n    const isSafari = browser$1.isSafari();\n    const emptyNodeContents = node => fillWithPaddingBr(SugarElement.fromDom(node));\n    const isEntireNodeSelected = (rng, node) => {\n      var _a;\n      return rng.startOffset === 0 && rng.endOffset === ((_a = node.textContent) === null || _a === void 0 ? void 0 : _a.length);\n    };\n    const getParentDetailsElementAtPos = (dom, pos) => Optional.from(dom.getParent(pos.container(), 'details'));\n    const isInDetailsElement = (dom, pos) => getParentDetailsElementAtPos(dom, pos).isSome();\n    const getDetailsElements = (dom, rng) => {\n      const startDetails = Optional.from(dom.getParent(rng.startContainer, 'details'));\n      const endDetails = Optional.from(dom.getParent(rng.endContainer, 'details'));\n      if (startDetails.isSome() || endDetails.isSome()) {\n        const startSummary = startDetails.bind(details => Optional.from(dom.select('summary', details)[0]));\n        return Optional.some({\n          startSummary,\n          startDetails,\n          endDetails\n        });\n      } else {\n        return Optional.none();\n      }\n    };\n    const isCaretInTheBeginningOf = (caretPos, element) => firstPositionIn(element).exists(pos => pos.isEqual(caretPos));\n    const isCaretInTheEndOf = (caretPos, element) => {\n      return lastPositionIn(element).exists(pos => {\n        if (isBr$6(pos.getNode())) {\n          return prevPosition(element, pos).exists(pos2 => pos2.isEqual(caretPos)) || pos.isEqual(caretPos);\n        } else {\n          return pos.isEqual(caretPos);\n        }\n      });\n    };\n    const isCaretAtStartOfSummary = (caretPos, detailsElements) => detailsElements.startSummary.exists(summary => isCaretInTheBeginningOf(caretPos, summary));\n    const isCaretAtEndOfSummary = (caretPos, detailsElements) => detailsElements.startSummary.exists(summary => isCaretInTheEndOf(caretPos, summary));\n    const isCaretInFirstPositionInBody = (caretPos, detailsElements) => detailsElements.startDetails.exists(details => prevPosition(details, caretPos).forall(pos => detailsElements.startSummary.exists(summary => !summary.contains(caretPos.container()) && summary.contains(pos.container()))));\n    const isCaretInLastPositionInBody = (root, caretPos, detailsElements) => detailsElements.startDetails.exists(details => nextPosition(root, caretPos).forall(pos => !details.contains(pos.container())));\n    const setCaretToPosition = (editor, position) => {\n      const node = position.getNode();\n      if (!isUndefined(node)) {\n        editor.selection.setCursorLocation(node, position.offset());\n      }\n    };\n    const moveCaretToDetailsPos = (editor, pos, forward) => {\n      const details = editor.dom.getParent(pos.container(), 'details');\n      if (details && !details.open) {\n        const summary = editor.dom.select('summary', details)[0];\n        if (summary) {\n          const newPos = forward ? firstPositionIn(summary) : lastPositionIn(summary);\n          newPos.each(pos => setCaretToPosition(editor, pos));\n        }\n      } else {\n        setCaretToPosition(editor, pos);\n      }\n    };\n    const isPartialDelete = (rng, detailsElements) => {\n      const containsStart = element => element.contains(rng.startContainer);\n      const containsEnd = element => element.contains(rng.endContainer);\n      const startInSummary = detailsElements.startSummary.exists(containsStart);\n      const endInSummary = detailsElements.startSummary.exists(containsEnd);\n      const isPartiallySelectedDetailsElements = detailsElements.startDetails.forall(startDetails => detailsElements.endDetails.forall(endDetails => startDetails !== endDetails));\n      const isInPartiallySelectedSummary = (startInSummary || endInSummary) && !(startInSummary && endInSummary);\n      return isInPartiallySelectedSummary || isPartiallySelectedDetailsElements;\n    };\n    const shouldPreventDeleteIntoDetails = (editor, forward, granularity) => {\n      const {dom, selection} = editor;\n      const root = editor.getBody();\n      if (granularity === 'character') {\n        const caretPos = CaretPosition.fromRangeStart(selection.getRng());\n        const parentBlock = dom.getParent(caretPos.container(), dom.isBlock);\n        const parentDetailsAtCaret = getParentDetailsElementAtPos(dom, caretPos);\n        const inEmptyParentBlock = parentBlock && dom.isEmpty(parentBlock);\n        const isFirstBlock = isNull(parentBlock === null || parentBlock === void 0 ? void 0 : parentBlock.previousSibling);\n        const isLastBlock = isNull(parentBlock === null || parentBlock === void 0 ? void 0 : parentBlock.nextSibling);\n        if (inEmptyParentBlock) {\n          const firstOrLast = forward ? isLastBlock : isFirstBlock;\n          if (firstOrLast) {\n            const isBeforeAfterDetails = navigate(!forward, root, caretPos).exists(pos => {\n              return isInDetailsElement(dom, pos) && !equals(parentDetailsAtCaret, getParentDetailsElementAtPos(dom, pos));\n            });\n            if (isBeforeAfterDetails) {\n              return true;\n            }\n          }\n        }\n        return navigate(forward, root, caretPos).fold(never, pos => {\n          const parentDetailsAtNewPos = getParentDetailsElementAtPos(dom, pos);\n          if (isInDetailsElement(dom, pos) && !equals(parentDetailsAtCaret, parentDetailsAtNewPos)) {\n            if (!forward) {\n              moveCaretToDetailsPos(editor, pos, false);\n            }\n            if (parentBlock && inEmptyParentBlock) {\n              if (forward && isFirstBlock) {\n                return true;\n              } else if (!forward && isLastBlock) {\n                return true;\n              }\n              moveCaretToDetailsPos(editor, pos, forward);\n              editor.dom.remove(parentBlock);\n            }\n            return true;\n          } else {\n            return false;\n          }\n        });\n      } else {\n        return false;\n      }\n    };\n    const shouldPreventDeleteSummaryAction = (editor, detailElements, forward, granularity) => {\n      const selection = editor.selection;\n      const rng = selection.getRng();\n      const caretPos = CaretPosition.fromRangeStart(rng);\n      const root = editor.getBody();\n      if (granularity === 'selection') {\n        return isPartialDelete(rng, detailElements);\n      } else if (forward) {\n        return isCaretAtEndOfSummary(caretPos, detailElements) || isCaretInLastPositionInBody(root, caretPos, detailElements);\n      } else {\n        return isCaretAtStartOfSummary(caretPos, detailElements) || isCaretInFirstPositionInBody(caretPos, detailElements);\n      }\n    };\n    const shouldPreventDeleteAction = (editor, forward, granularity) => getDetailsElements(editor.dom, editor.selection.getRng()).fold(() => shouldPreventDeleteIntoDetails(editor, forward, granularity), detailsElements => shouldPreventDeleteSummaryAction(editor, detailsElements, forward, granularity) || shouldPreventDeleteIntoDetails(editor, forward, granularity));\n    const handleDeleteActionSafari = (editor, forward, granularity) => {\n      const selection = editor.selection;\n      const node = selection.getNode();\n      const rng = selection.getRng();\n      const caretPos = CaretPosition.fromRangeStart(rng);\n      if (isSummary$1(node)) {\n        if (granularity === 'selection' && isEntireNodeSelected(rng, node) || willDeleteLastPositionInElement(forward, caretPos, node)) {\n          emptyNodeContents(node);\n        } else {\n          editor.undoManager.transact(() => {\n            const sel = selection.getSel();\n            let {anchorNode, anchorOffset, focusNode, focusOffset} = sel !== null && sel !== void 0 ? sel : {};\n            const applySelection = () => {\n              if (isNonNullable(anchorNode) && isNonNullable(anchorOffset) && isNonNullable(focusNode) && isNonNullable(focusOffset)) {\n                sel === null || sel === void 0 ? void 0 : sel.setBaseAndExtent(anchorNode, anchorOffset, focusNode, focusOffset);\n              }\n            };\n            const updateSelection = () => {\n              anchorNode = sel === null || sel === void 0 ? void 0 : sel.anchorNode;\n              anchorOffset = sel === null || sel === void 0 ? void 0 : sel.anchorOffset;\n              focusNode = sel === null || sel === void 0 ? void 0 : sel.focusNode;\n              focusOffset = sel === null || sel === void 0 ? void 0 : sel.focusOffset;\n            };\n            const appendAllChildNodes = (from, to) => {\n              each$e(from.childNodes, child => {\n                if (isNode(child)) {\n                  to.appendChild(child);\n                }\n              });\n            };\n            const container = editor.dom.create('span', { 'data-mce-bogus': '1' });\n            appendAllChildNodes(node, container);\n            node.appendChild(container);\n            applySelection();\n            if (granularity === 'word' || granularity === 'line') {\n              sel === null || sel === void 0 ? void 0 : sel.modify('extend', forward ? 'right' : 'left', granularity);\n            }\n            if (!selection.isCollapsed() && isEntireNodeSelected(selection.getRng(), container)) {\n              emptyNodeContents(node);\n            } else {\n              editor.execCommand(forward ? 'ForwardDelete' : 'Delete');\n              updateSelection();\n              appendAllChildNodes(container, node);\n              applySelection();\n            }\n            editor.dom.remove(container);\n          });\n        }\n        return true;\n      } else {\n        return false;\n      }\n    };\n    const backspaceDelete = (editor, forward, granularity) => shouldPreventDeleteAction(editor, forward, granularity) || isSafari && handleDeleteActionSafari(editor, forward, granularity) ? Optional.some(noop) : Optional.none();\n\n    const createAndFireInputEvent = eventType => (editor, inputType, specifics = {}) => {\n      const target = editor.getBody();\n      const overrides = {\n        bubbles: true,\n        composed: true,\n        data: null,\n        isComposing: false,\n        detail: 0,\n        view: null,\n        target,\n        currentTarget: target,\n        eventPhase: Event.AT_TARGET,\n        originalTarget: target,\n        explicitOriginalTarget: target,\n        isTrusted: false,\n        srcElement: target,\n        cancelable: false,\n        preventDefault: noop,\n        inputType\n      };\n      const input = clone$3(new InputEvent(eventType));\n      return editor.dispatch(eventType, {\n        ...input,\n        ...overrides,\n        ...specifics\n      });\n    };\n    const fireInputEvent = createAndFireInputEvent('input');\n    const fireBeforeInputEvent = createAndFireInputEvent('beforeinput');\n\n    const platform$2 = detect$1();\n    const os = platform$2.os;\n    const isMacOSOriOS = os.isMacOS() || os.isiOS();\n    const browser = platform$2.browser;\n    const isFirefox = browser.isFirefox();\n    const executeKeydownOverride$3 = (editor, caret, evt) => {\n      const inputType = evt.keyCode === VK.BACKSPACE ? 'deleteContentBackward' : 'deleteContentForward';\n      const isCollapsed = editor.selection.isCollapsed();\n      const unmodifiedGranularity = isCollapsed ? 'character' : 'selection';\n      const getModifiedGranularity = isWord => {\n        if (isCollapsed) {\n          return isWord ? 'word' : 'line';\n        } else {\n          return 'selection';\n        }\n      };\n      executeWithDelayedAction([\n        {\n          keyCode: VK.BACKSPACE,\n          action: action(backspaceDelete$1, editor)\n        },\n        {\n          keyCode: VK.BACKSPACE,\n          action: action(backspaceDelete$7, editor, false)\n        },\n        {\n          keyCode: VK.DELETE,\n          action: action(backspaceDelete$7, editor, true)\n        },\n        {\n          keyCode: VK.BACKSPACE,\n          action: action(backspaceDelete$8, editor, false)\n        },\n        {\n          keyCode: VK.DELETE,\n          action: action(backspaceDelete$8, editor, true)\n        },\n        {\n          keyCode: VK.BACKSPACE,\n          action: action(backspaceDelete$4, editor, caret, false)\n        },\n        {\n          keyCode: VK.DELETE,\n          action: action(backspaceDelete$4, editor, caret, true)\n        },\n        {\n          keyCode: VK.BACKSPACE,\n          action: action(backspaceDelete$b, editor, false)\n        },\n        {\n          keyCode: VK.DELETE,\n          action: action(backspaceDelete$b, editor, true)\n        },\n        {\n          keyCode: VK.BACKSPACE,\n          action: action(backspaceDelete, editor, false, unmodifiedGranularity)\n        },\n        {\n          keyCode: VK.DELETE,\n          action: action(backspaceDelete, editor, true, unmodifiedGranularity)\n        },\n        ...isMacOSOriOS ? [\n          {\n            keyCode: VK.BACKSPACE,\n            altKey: true,\n            action: action(backspaceDelete, editor, false, getModifiedGranularity(true))\n          },\n          {\n            keyCode: VK.DELETE,\n            altKey: true,\n            action: action(backspaceDelete, editor, true, getModifiedGranularity(true))\n          },\n          {\n            keyCode: VK.BACKSPACE,\n            metaKey: true,\n            action: action(backspaceDelete, editor, false, getModifiedGranularity(false))\n          }\n        ] : [\n          {\n            keyCode: VK.BACKSPACE,\n            ctrlKey: true,\n            action: action(backspaceDelete, editor, false, getModifiedGranularity(true))\n          },\n          {\n            keyCode: VK.DELETE,\n            ctrlKey: true,\n            action: action(backspaceDelete, editor, true, getModifiedGranularity(true))\n          }\n        ],\n        {\n          keyCode: VK.BACKSPACE,\n          action: action(backspaceDelete$5, editor, false)\n        },\n        {\n          keyCode: VK.DELETE,\n          action: action(backspaceDelete$5, editor, true)\n        },\n        {\n          keyCode: VK.BACKSPACE,\n          action: action(backspaceDelete$2, editor, false)\n        },\n        {\n          keyCode: VK.DELETE,\n          action: action(backspaceDelete$2, editor, true)\n        },\n        {\n          keyCode: VK.BACKSPACE,\n          action: action(backspaceDelete$9, editor, false)\n        },\n        {\n          keyCode: VK.DELETE,\n          action: action(backspaceDelete$9, editor, true)\n        },\n        {\n          keyCode: VK.BACKSPACE,\n          action: action(backspaceDelete$a, editor, false)\n        },\n        {\n          keyCode: VK.DELETE,\n          action: action(backspaceDelete$a, editor, true)\n        },\n        {\n          keyCode: VK.BACKSPACE,\n          action: action(backspaceDelete$3, editor, false)\n        },\n        {\n          keyCode: VK.DELETE,\n          action: action(backspaceDelete$3, editor, true)\n        },\n        {\n          keyCode: VK.BACKSPACE,\n          action: action(backspaceDelete$6, editor, false)\n        },\n        {\n          keyCode: VK.DELETE,\n          action: action(backspaceDelete$6, editor, true)\n        }\n      ], evt).filter(_ => editor.selection.isEditable()).each(applyAction => {\n        evt.preventDefault();\n        const beforeInput = fireBeforeInputEvent(editor, inputType);\n        if (!beforeInput.isDefaultPrevented()) {\n          applyAction();\n          fireInputEvent(editor, inputType);\n        }\n      });\n    };\n    const executeKeyupOverride = (editor, evt, isBackspaceKeydown) => execute([\n      {\n        keyCode: VK.BACKSPACE,\n        action: action(paddEmptyElement, editor)\n      },\n      {\n        keyCode: VK.DELETE,\n        action: action(paddEmptyElement, editor)\n      },\n      ...isMacOSOriOS ? [\n        {\n          keyCode: VK.BACKSPACE,\n          altKey: true,\n          action: action(refreshCaret, editor)\n        },\n        {\n          keyCode: VK.DELETE,\n          altKey: true,\n          action: action(refreshCaret, editor)\n        },\n        ...isBackspaceKeydown ? [{\n            keyCode: isFirefox ? 224 : 91,\n            action: action(refreshCaret, editor)\n          }] : []\n      ] : [\n        {\n          keyCode: VK.BACKSPACE,\n          ctrlKey: true,\n          action: action(refreshCaret, editor)\n        },\n        {\n          keyCode: VK.DELETE,\n          ctrlKey: true,\n          action: action(refreshCaret, editor)\n        }\n      ]\n    ], evt);\n    const setup$j = (editor, caret) => {\n      let isBackspaceKeydown = false;\n      editor.on('keydown', evt => {\n        isBackspaceKeydown = evt.keyCode === VK.BACKSPACE;\n        if (!evt.isDefaultPrevented()) {\n          executeKeydownOverride$3(editor, caret, evt);\n        }\n      });\n      editor.on('keyup', evt => {\n        if (!evt.isDefaultPrevented()) {\n          executeKeyupOverride(editor, evt, isBackspaceKeydown);\n        }\n        isBackspaceKeydown = false;\n      });\n    };\n\n    const firstNonWhiteSpaceNodeSibling = node => {\n      while (node) {\n        if (isElement$6(node) || isText$b(node) && node.data && /[\\r\\n\\s]/.test(node.data)) {\n          return node;\n        }\n        node = node.nextSibling;\n      }\n      return null;\n    };\n    const moveToCaretPosition = (editor, root) => {\n      const dom = editor.dom;\n      const moveCaretBeforeOnEnterElementsMap = editor.schema.getMoveCaretBeforeOnEnterElements();\n      if (!root) {\n        return;\n      }\n      if (/^(LI|DT|DD)$/.test(root.nodeName)) {\n        const firstChild = firstNonWhiteSpaceNodeSibling(root.firstChild);\n        if (firstChild && /^(UL|OL|DL)$/.test(firstChild.nodeName)) {\n          root.insertBefore(dom.doc.createTextNode(nbsp), root.firstChild);\n        }\n      }\n      const rng = dom.createRng();\n      root.normalize();\n      if (root.hasChildNodes()) {\n        const walker = new DomTreeWalker(root, root);\n        let lastNode = root;\n        let node;\n        while (node = walker.current()) {\n          if (isText$b(node)) {\n            rng.setStart(node, 0);\n            rng.setEnd(node, 0);\n            break;\n          }\n          if (moveCaretBeforeOnEnterElementsMap[node.nodeName.toLowerCase()]) {\n            rng.setStartBefore(node);\n            rng.setEndBefore(node);\n            break;\n          }\n          lastNode = node;\n          node = walker.next();\n        }\n        if (!node) {\n          rng.setStart(lastNode, 0);\n          rng.setEnd(lastNode, 0);\n        }\n      } else {\n        if (isBr$6(root)) {\n          if (root.nextSibling && dom.isBlock(root.nextSibling)) {\n            rng.setStartBefore(root);\n            rng.setEndBefore(root);\n          } else {\n            rng.setStartAfter(root);\n            rng.setEndAfter(root);\n          }\n        } else {\n          rng.setStart(root, 0);\n          rng.setEnd(root, 0);\n        }\n      }\n      editor.selection.setRng(rng);\n      scrollRangeIntoView(editor, rng);\n    };\n    const getEditableRoot = (dom, node) => {\n      const root = dom.getRoot();\n      let editableRoot;\n      let parent = node;\n      while (parent !== root && parent && dom.getContentEditable(parent) !== 'false') {\n        if (dom.getContentEditable(parent) === 'true') {\n          editableRoot = parent;\n          break;\n        }\n        parent = parent.parentNode;\n      }\n      return parent !== root ? editableRoot : root;\n    };\n    const getParentBlock$1 = editor => {\n      return Optional.from(editor.dom.getParent(editor.selection.getStart(true), editor.dom.isBlock));\n    };\n    const getParentBlockName = editor => {\n      return getParentBlock$1(editor).fold(constant(''), parentBlock => {\n        return parentBlock.nodeName.toUpperCase();\n      });\n    };\n    const isListItemParentBlock = editor => {\n      return getParentBlock$1(editor).filter(elm => {\n        return isListItem$1(SugarElement.fromDom(elm));\n      }).isSome();\n    };\n    const emptyBlock = elm => {\n      elm.innerHTML = '<br data-mce-bogus=\"1\">';\n    };\n    const applyAttributes = (editor, node, forcedRootBlockAttrs) => {\n      const dom = editor.dom;\n      Optional.from(forcedRootBlockAttrs.style).map(dom.parseStyle).each(attrStyles => {\n        const currentStyles = getAllRaw(SugarElement.fromDom(node));\n        const newStyles = {\n          ...currentStyles,\n          ...attrStyles\n        };\n        dom.setStyles(node, newStyles);\n      });\n      const attrClassesOpt = Optional.from(forcedRootBlockAttrs.class).map(attrClasses => attrClasses.split(/\\s+/));\n      const currentClassesOpt = Optional.from(node.className).map(currentClasses => filter$5(currentClasses.split(/\\s+/), clazz => clazz !== ''));\n      lift2(attrClassesOpt, currentClassesOpt, (attrClasses, currentClasses) => {\n        const filteredClasses = filter$5(currentClasses, clazz => !contains$2(attrClasses, clazz));\n        const newClasses = [\n          ...attrClasses,\n          ...filteredClasses\n        ];\n        dom.setAttrib(node, 'class', newClasses.join(' '));\n      });\n      const appliedAttrs = [\n        'style',\n        'class'\n      ];\n      const remainingAttrs = filter$4(forcedRootBlockAttrs, (_, attrs) => !contains$2(appliedAttrs, attrs));\n      dom.setAttribs(node, remainingAttrs);\n    };\n    const setForcedBlockAttrs = (editor, node) => {\n      const forcedRootBlockName = getForcedRootBlock(editor);\n      if (forcedRootBlockName.toLowerCase() === node.tagName.toLowerCase()) {\n        const forcedRootBlockAttrs = getForcedRootBlockAttrs(editor);\n        applyAttributes(editor, node, forcedRootBlockAttrs);\n      }\n    };\n    const createNewBlock = (editor, container, parentBlock, editableRoot, keepStyles = true, name, styles) => {\n      const dom = editor.dom;\n      const schema = editor.schema;\n      const newBlockName = getForcedRootBlock(editor);\n      const parentBlockName = parentBlock ? parentBlock.nodeName.toUpperCase() : '';\n      let node = container;\n      const textInlineElements = schema.getTextInlineElements();\n      let block;\n      if (name || parentBlockName === 'TABLE' || parentBlockName === 'HR') {\n        block = dom.create(name || newBlockName, styles || {});\n      } else {\n        block = parentBlock.cloneNode(false);\n      }\n      let caretNode = block;\n      if (!keepStyles) {\n        dom.setAttrib(block, 'style', null);\n        dom.setAttrib(block, 'class', null);\n      } else {\n        do {\n          if (textInlineElements[node.nodeName]) {\n            if (isCaretNode(node) || isBookmarkNode$1(node)) {\n              continue;\n            }\n            const clonedNode = node.cloneNode(false);\n            dom.setAttrib(clonedNode, 'id', '');\n            if (block.hasChildNodes()) {\n              clonedNode.appendChild(block.firstChild);\n              block.appendChild(clonedNode);\n            } else {\n              caretNode = clonedNode;\n              block.appendChild(clonedNode);\n            }\n          }\n        } while ((node = node.parentNode) && node !== editableRoot);\n      }\n      setForcedBlockAttrs(editor, block);\n      emptyBlock(caretNode);\n      return block;\n    };\n\n    const getDetailsRoot = (editor, element) => editor.dom.getParent(element, isDetails);\n    const isAtDetailsEdge = (root, element, isTextBlock) => {\n      let node = element;\n      while (node && node !== root && isNull(node.nextSibling)) {\n        const parent = node.parentElement;\n        if (!parent || !isTextBlock(parent)) {\n          return isDetails(parent);\n        }\n        node = parent;\n      }\n      return false;\n    };\n    const isLastEmptyBlockInDetails = (editor, shiftKey, element) => !shiftKey && element.nodeName.toLowerCase() === getForcedRootBlock(editor) && editor.dom.isEmpty(element) && isAtDetailsEdge(editor.getBody(), element, el => has$2(editor.schema.getTextBlockElements(), el.nodeName.toLowerCase()));\n    const insertNewLine = (editor, createNewBlock, parentBlock) => {\n      var _a, _b, _c;\n      const newBlock = createNewBlock(getForcedRootBlock(editor));\n      const root = getDetailsRoot(editor, parentBlock);\n      if (!root) {\n        return;\n      }\n      editor.dom.insertAfter(newBlock, root);\n      moveToCaretPosition(editor, newBlock);\n      if (((_c = (_b = (_a = parentBlock.parentElement) === null || _a === void 0 ? void 0 : _a.childNodes) === null || _b === void 0 ? void 0 : _b.length) !== null && _c !== void 0 ? _c : 0) > 1) {\n        editor.dom.remove(parentBlock);\n      }\n    };\n\n    const hasFirstChild = (elm, name) => {\n      return elm.firstChild && elm.firstChild.nodeName === name;\n    };\n    const isFirstChild = elm => {\n      var _a;\n      return ((_a = elm.parentNode) === null || _a === void 0 ? void 0 : _a.firstChild) === elm;\n    };\n    const hasParent = (elm, parentName) => {\n      const parentNode = elm === null || elm === void 0 ? void 0 : elm.parentNode;\n      return isNonNullable(parentNode) && parentNode.nodeName === parentName;\n    };\n    const isListBlock = elm => {\n      return isNonNullable(elm) && /^(OL|UL|LI)$/.test(elm.nodeName);\n    };\n    const isListItem = elm => {\n      return isNonNullable(elm) && /^(LI|DT|DD)$/.test(elm.nodeName);\n    };\n    const isNestedList = elm => {\n      return isListBlock(elm) && isListBlock(elm.parentNode);\n    };\n    const getContainerBlock = containerBlock => {\n      const containerBlockParent = containerBlock.parentNode;\n      return isListItem(containerBlockParent) ? containerBlockParent : containerBlock;\n    };\n    const isFirstOrLastLi = (containerBlock, parentBlock, first) => {\n      let node = containerBlock[first ? 'firstChild' : 'lastChild'];\n      while (node) {\n        if (isElement$6(node)) {\n          break;\n        }\n        node = node[first ? 'nextSibling' : 'previousSibling'];\n      }\n      return node === parentBlock;\n    };\n    const getStyles = elm => foldl(mapToArray(getAllRaw(SugarElement.fromDom(elm)), (style, styleName) => `${ styleName }: ${ style };`), (acc, s) => acc + s, '');\n    const insert$4 = (editor, createNewBlock, containerBlock, parentBlock, newBlockName) => {\n      const dom = editor.dom;\n      const rng = editor.selection.getRng();\n      const containerParent = containerBlock.parentNode;\n      if (containerBlock === editor.getBody() || !containerParent) {\n        return;\n      }\n      if (isNestedList(containerBlock)) {\n        newBlockName = 'LI';\n      }\n      const parentBlockStyles = isListItem(parentBlock) ? getStyles(parentBlock) : undefined;\n      let newBlock = isListItem(parentBlock) && parentBlockStyles ? createNewBlock(newBlockName, { style: getStyles(parentBlock) }) : createNewBlock(newBlockName);\n      if (isFirstOrLastLi(containerBlock, parentBlock, true) && isFirstOrLastLi(containerBlock, parentBlock, false)) {\n        if (hasParent(containerBlock, 'LI')) {\n          const containerBlockParent = getContainerBlock(containerBlock);\n          dom.insertAfter(newBlock, containerBlockParent);\n          if (isFirstChild(containerBlock)) {\n            dom.remove(containerBlockParent);\n          } else {\n            dom.remove(containerBlock);\n          }\n        } else {\n          dom.replace(newBlock, containerBlock);\n        }\n      } else if (isFirstOrLastLi(containerBlock, parentBlock, true)) {\n        if (hasParent(containerBlock, 'LI')) {\n          dom.insertAfter(newBlock, getContainerBlock(containerBlock));\n          newBlock.appendChild(dom.doc.createTextNode(' '));\n          newBlock.appendChild(containerBlock);\n        } else {\n          containerParent.insertBefore(newBlock, containerBlock);\n        }\n        dom.remove(parentBlock);\n      } else if (isFirstOrLastLi(containerBlock, parentBlock, false)) {\n        dom.insertAfter(newBlock, getContainerBlock(containerBlock));\n        dom.remove(parentBlock);\n      } else {\n        containerBlock = getContainerBlock(containerBlock);\n        const tmpRng = rng.cloneRange();\n        tmpRng.setStartAfter(parentBlock);\n        tmpRng.setEndAfter(containerBlock);\n        const fragment = tmpRng.extractContents();\n        if (newBlockName === 'LI' && hasFirstChild(fragment, 'LI')) {\n          const previousChildren = filter$5(map$3(newBlock.children, SugarElement.fromDom), not(isTag('br')));\n          newBlock = fragment.firstChild;\n          dom.insertAfter(fragment, containerBlock);\n          each$e(previousChildren, child => prepend(SugarElement.fromDom(newBlock), child));\n          if (parentBlockStyles) {\n            newBlock.setAttribute('style', parentBlockStyles);\n          }\n        } else {\n          dom.insertAfter(fragment, containerBlock);\n          dom.insertAfter(newBlock, containerBlock);\n        }\n        dom.remove(parentBlock);\n      }\n      moveToCaretPosition(editor, newBlock);\n    };\n\n    const trimZwsp = fragment => {\n      each$e(descendants$1(SugarElement.fromDom(fragment), isText$c), text => {\n        const rawNode = text.dom;\n        rawNode.nodeValue = trim$2(rawNode.data);\n      });\n    };\n    const isWithinNonEditableList = (editor, node) => {\n      const parentList = editor.dom.getParent(node, 'ol,ul,dl');\n      return parentList !== null && editor.dom.getContentEditableParent(parentList) === 'false';\n    };\n    const isEmptyAnchor = (dom, elm) => {\n      return elm && elm.nodeName === 'A' && dom.isEmpty(elm);\n    };\n    const containerAndPreviousSiblingName = (container, nodeName) => {\n      return container.nodeName === nodeName || container.previousSibling && container.previousSibling.nodeName === nodeName;\n    };\n    const containerAndNextSiblingName = (container, nodeName) => {\n      return container.nodeName === nodeName || container.nextSibling && container.nextSibling.nodeName === nodeName;\n    };\n    const canSplitBlock = (dom, node) => {\n      return isNonNullable(node) && dom.isBlock(node) && !/^(TD|TH|CAPTION|FORM)$/.test(node.nodeName) && !/^(fixed|absolute)/i.test(node.style.position) && dom.isEditable(node.parentNode) && dom.getContentEditable(node) !== 'false';\n    };\n    const trimInlineElementsOnLeftSideOfBlock = (dom, nonEmptyElementsMap, block) => {\n      var _a;\n      const firstChilds = [];\n      if (!block) {\n        return;\n      }\n      let currentNode = block;\n      while (currentNode = currentNode.firstChild) {\n        if (dom.isBlock(currentNode)) {\n          return;\n        }\n        if (isElement$6(currentNode) && !nonEmptyElementsMap[currentNode.nodeName.toLowerCase()]) {\n          firstChilds.push(currentNode);\n        }\n      }\n      let i = firstChilds.length;\n      while (i--) {\n        currentNode = firstChilds[i];\n        if (!currentNode.hasChildNodes() || currentNode.firstChild === currentNode.lastChild && ((_a = currentNode.firstChild) === null || _a === void 0 ? void 0 : _a.nodeValue) === '') {\n          dom.remove(currentNode);\n        } else {\n          if (isEmptyAnchor(dom, currentNode)) {\n            dom.remove(currentNode);\n          }\n        }\n      }\n    };\n    const normalizeZwspOffset = (start, container, offset) => {\n      if (!isText$b(container)) {\n        return offset;\n      } else if (start) {\n        return offset === 1 && container.data.charAt(offset - 1) === ZWSP$1 ? 0 : offset;\n      } else {\n        return offset === container.data.length - 1 && container.data.charAt(offset) === ZWSP$1 ? container.data.length : offset;\n      }\n    };\n    const includeZwspInRange = rng => {\n      const newRng = rng.cloneRange();\n      newRng.setStart(rng.startContainer, normalizeZwspOffset(true, rng.startContainer, rng.startOffset));\n      newRng.setEnd(rng.endContainer, normalizeZwspOffset(false, rng.endContainer, rng.endOffset));\n      return newRng;\n    };\n    const trimLeadingLineBreaks = node => {\n      let currentNode = node;\n      do {\n        if (isText$b(currentNode)) {\n          currentNode.data = currentNode.data.replace(/^[\\r\\n]+/, '');\n        }\n        currentNode = currentNode.firstChild;\n      } while (currentNode);\n    };\n    const wrapSelfAndSiblingsInDefaultBlock = (editor, newBlockName, rng, container, offset) => {\n      var _a, _b;\n      const dom = editor.dom;\n      const editableRoot = (_a = getEditableRoot(dom, container)) !== null && _a !== void 0 ? _a : dom.getRoot();\n      let parentBlock = dom.getParent(container, dom.isBlock);\n      if (!parentBlock || !canSplitBlock(dom, parentBlock)) {\n        parentBlock = parentBlock || editableRoot;\n        if (!parentBlock.hasChildNodes()) {\n          const newBlock = dom.create(newBlockName);\n          setForcedBlockAttrs(editor, newBlock);\n          parentBlock.appendChild(newBlock);\n          rng.setStart(newBlock, 0);\n          rng.setEnd(newBlock, 0);\n          return newBlock;\n        }\n        let node = container;\n        while (node && node.parentNode !== parentBlock) {\n          node = node.parentNode;\n        }\n        let startNode;\n        while (node && !dom.isBlock(node)) {\n          startNode = node;\n          node = node.previousSibling;\n        }\n        const startNodeName = (_b = startNode === null || startNode === void 0 ? void 0 : startNode.parentElement) === null || _b === void 0 ? void 0 : _b.nodeName;\n        if (startNode && startNodeName && editor.schema.isValidChild(startNodeName, newBlockName.toLowerCase())) {\n          const startNodeParent = startNode.parentNode;\n          const newBlock = dom.create(newBlockName);\n          setForcedBlockAttrs(editor, newBlock);\n          startNodeParent.insertBefore(newBlock, startNode);\n          node = startNode;\n          while (node && !dom.isBlock(node)) {\n            const next = node.nextSibling;\n            newBlock.appendChild(node);\n            node = next;\n          }\n          rng.setStart(container, offset);\n          rng.setEnd(container, offset);\n        }\n      }\n      return container;\n    };\n    const addBrToBlockIfNeeded = (dom, block) => {\n      block.normalize();\n      const lastChild = block.lastChild;\n      if (!lastChild || isElement$6(lastChild) && /^(left|right)$/gi.test(dom.getStyle(lastChild, 'float', true))) {\n        dom.add(block, 'br');\n      }\n    };\n    const shouldEndContainer = (editor, container) => {\n      const optionValue = shouldEndContainerOnEmptyBlock(editor);\n      if (isNullable(container)) {\n        return false;\n      } else if (isString(optionValue)) {\n        return contains$2(Tools.explode(optionValue), container.nodeName.toLowerCase());\n      } else {\n        return optionValue;\n      }\n    };\n    const insert$3 = (editor, evt) => {\n      let container;\n      let offset;\n      let parentBlockName;\n      let containerBlock;\n      let isAfterLastNodeInContainer = false;\n      const dom = editor.dom;\n      const schema = editor.schema, nonEmptyElementsMap = schema.getNonEmptyElements();\n      const rng = editor.selection.getRng();\n      const newBlockName = getForcedRootBlock(editor);\n      const start = SugarElement.fromDom(rng.startContainer);\n      const child = child$1(start, rng.startOffset);\n      const isCef = child.exists(element => isHTMLElement$1(element) && !isEditable$2(element));\n      const collapsedAndCef = rng.collapsed && isCef;\n      const createNewBlock$1 = (name, styles) => {\n        return createNewBlock(editor, container, parentBlock, editableRoot, shouldKeepStyles(editor), name, styles);\n      };\n      const isCaretAtStartOrEndOfBlock = start => {\n        const normalizedOffset = normalizeZwspOffset(start, container, offset);\n        if (isText$b(container) && (start ? normalizedOffset > 0 : normalizedOffset < container.data.length)) {\n          return false;\n        }\n        if ((container.parentNode === parentBlock || container === parentBlock) && isAfterLastNodeInContainer && !start) {\n          return true;\n        }\n        if (start && isElement$6(container) && container === parentBlock.firstChild) {\n          return true;\n        }\n        if (containerAndPreviousSiblingName(container, 'TABLE') || containerAndPreviousSiblingName(container, 'HR')) {\n          if (containerAndNextSiblingName(container, 'BR')) {\n            return !start;\n          }\n          return isAfterLastNodeInContainer && !start || !isAfterLastNodeInContainer && start;\n        }\n        const walker = new DomTreeWalker(container, parentBlock);\n        if (isText$b(container)) {\n          if (start && normalizedOffset === 0) {\n            walker.prev();\n          } else if (!start && normalizedOffset === container.data.length) {\n            walker.next();\n          }\n        }\n        let node;\n        while (node = walker.current()) {\n          if (isElement$6(node)) {\n            if (!node.getAttribute('data-mce-bogus')) {\n              const name = node.nodeName.toLowerCase();\n              if (nonEmptyElementsMap[name] && name !== 'br') {\n                return false;\n              }\n            }\n          } else if (isText$b(node) && !isWhitespaceText(node.data)) {\n            return false;\n          }\n          if (start) {\n            walker.prev();\n          } else {\n            walker.next();\n          }\n        }\n        return true;\n      };\n      const insertNewBlockAfter = () => {\n        let block;\n        if (/^(H[1-6]|PRE|FIGURE)$/.test(parentBlockName) && containerBlockName !== 'HGROUP') {\n          block = createNewBlock$1(newBlockName);\n        } else {\n          block = createNewBlock$1();\n        }\n        if (shouldEndContainer(editor, containerBlock) && canSplitBlock(dom, containerBlock) && dom.isEmpty(parentBlock, undefined, { includeZwsp: true })) {\n          block = dom.split(containerBlock, parentBlock);\n        } else {\n          dom.insertAfter(block, parentBlock);\n        }\n        moveToCaretPosition(editor, block);\n        return block;\n      };\n      normalize$2(dom, rng).each(normRng => {\n        rng.setStart(normRng.startContainer, normRng.startOffset);\n        rng.setEnd(normRng.endContainer, normRng.endOffset);\n      });\n      container = rng.startContainer;\n      offset = rng.startOffset;\n      const shiftKey = !!(evt && evt.shiftKey);\n      const ctrlKey = !!(evt && evt.ctrlKey);\n      if (isElement$6(container) && container.hasChildNodes() && !collapsedAndCef) {\n        isAfterLastNodeInContainer = offset > container.childNodes.length - 1;\n        container = container.childNodes[Math.min(offset, container.childNodes.length - 1)] || container;\n        if (isAfterLastNodeInContainer && isText$b(container)) {\n          offset = container.data.length;\n        } else {\n          offset = 0;\n        }\n      }\n      const editableRoot = getEditableRoot(dom, container);\n      if (!editableRoot || isWithinNonEditableList(editor, container)) {\n        return;\n      }\n      if (!shiftKey) {\n        container = wrapSelfAndSiblingsInDefaultBlock(editor, newBlockName, rng, container, offset);\n      }\n      let parentBlock = dom.getParent(container, dom.isBlock) || dom.getRoot();\n      containerBlock = isNonNullable(parentBlock === null || parentBlock === void 0 ? void 0 : parentBlock.parentNode) ? dom.getParent(parentBlock.parentNode, dom.isBlock) : null;\n      parentBlockName = parentBlock ? parentBlock.nodeName.toUpperCase() : '';\n      const containerBlockName = containerBlock ? containerBlock.nodeName.toUpperCase() : '';\n      if (containerBlockName === 'LI' && !ctrlKey) {\n        const liBlock = containerBlock;\n        parentBlock = liBlock;\n        containerBlock = liBlock.parentNode;\n        parentBlockName = containerBlockName;\n      }\n      if (isElement$6(containerBlock) && isLastEmptyBlockInDetails(editor, shiftKey, parentBlock)) {\n        return insertNewLine(editor, createNewBlock$1, parentBlock);\n      }\n      if (/^(LI|DT|DD)$/.test(parentBlockName) && isElement$6(containerBlock)) {\n        if (dom.isEmpty(parentBlock)) {\n          insert$4(editor, createNewBlock$1, containerBlock, parentBlock, newBlockName);\n          return;\n        }\n      }\n      if (!collapsedAndCef && (parentBlock === editor.getBody() || !canSplitBlock(dom, parentBlock))) {\n        return;\n      }\n      const parentBlockParent = parentBlock.parentNode;\n      let newBlock;\n      if (collapsedAndCef) {\n        newBlock = createNewBlock$1(newBlockName);\n        child.fold(() => {\n          append$1(start, SugarElement.fromDom(newBlock));\n        }, child => {\n          before$3(child, SugarElement.fromDom(newBlock));\n        });\n        editor.selection.setCursorLocation(newBlock, 0);\n      } else if (isCaretContainerBlock$1(parentBlock)) {\n        newBlock = showCaretContainerBlock(parentBlock);\n        if (dom.isEmpty(parentBlock)) {\n          emptyBlock(parentBlock);\n        }\n        setForcedBlockAttrs(editor, newBlock);\n        moveToCaretPosition(editor, newBlock);\n      } else if (isCaretAtStartOrEndOfBlock(false)) {\n        newBlock = insertNewBlockAfter();\n      } else if (isCaretAtStartOrEndOfBlock(true) && parentBlockParent) {\n        const caretPos = CaretPosition.fromRangeStart(rng);\n        const afterTable = isAfterTable(caretPos);\n        const parentBlockSugar = SugarElement.fromDom(parentBlock);\n        const afterBr = isAfterBr(parentBlockSugar, caretPos, editor.schema);\n        const prevBrOpt = afterBr ? findPreviousBr(parentBlockSugar, caretPos, editor.schema).bind(pos => Optional.from(pos.getNode())) : Optional.none();\n        newBlock = parentBlockParent.insertBefore(createNewBlock$1(), parentBlock);\n        const root = containerAndPreviousSiblingName(parentBlock, 'HR') || afterTable ? newBlock : prevBrOpt.getOr(parentBlock);\n        moveToCaretPosition(editor, root);\n      } else {\n        const tmpRng = includeZwspInRange(rng).cloneRange();\n        tmpRng.setEndAfter(parentBlock);\n        const fragment = tmpRng.extractContents();\n        trimZwsp(fragment);\n        trimLeadingLineBreaks(fragment);\n        newBlock = fragment.firstChild;\n        dom.insertAfter(fragment, parentBlock);\n        trimInlineElementsOnLeftSideOfBlock(dom, nonEmptyElementsMap, newBlock);\n        addBrToBlockIfNeeded(dom, parentBlock);\n        if (dom.isEmpty(parentBlock)) {\n          emptyBlock(parentBlock);\n        }\n        newBlock.normalize();\n        if (dom.isEmpty(newBlock)) {\n          dom.remove(newBlock);\n          insertNewBlockAfter();\n        } else {\n          setForcedBlockAttrs(editor, newBlock);\n          moveToCaretPosition(editor, newBlock);\n        }\n      }\n      dom.setAttrib(newBlock, 'id', '');\n      editor.dispatch('NewBlock', { newBlock });\n    };\n    const fakeEventName$1 = 'insertParagraph';\n    const blockbreak = {\n      insert: insert$3,\n      fakeEventName: fakeEventName$1\n    };\n\n    const hasRightSideContent = (schema, container, parentBlock) => {\n      const walker = new DomTreeWalker(container, parentBlock);\n      let node;\n      const nonEmptyElementsMap = schema.getNonEmptyElements();\n      while (node = walker.next()) {\n        if (nonEmptyElementsMap[node.nodeName.toLowerCase()] || isText$b(node) && node.length > 0) {\n          return true;\n        }\n      }\n      return false;\n    };\n    const moveSelectionToBr = (editor, brElm, extraBr) => {\n      const rng = editor.dom.createRng();\n      if (!extraBr) {\n        rng.setStartAfter(brElm);\n        rng.setEndAfter(brElm);\n      } else {\n        rng.setStartBefore(brElm);\n        rng.setEndBefore(brElm);\n      }\n      editor.selection.setRng(rng);\n      scrollRangeIntoView(editor, rng);\n    };\n    const insertBrAtCaret = (editor, evt) => {\n      const selection = editor.selection;\n      const dom = editor.dom;\n      const rng = selection.getRng();\n      let brElm;\n      let extraBr = false;\n      normalize$2(dom, rng).each(normRng => {\n        rng.setStart(normRng.startContainer, normRng.startOffset);\n        rng.setEnd(normRng.endContainer, normRng.endOffset);\n      });\n      let offset = rng.startOffset;\n      let container = rng.startContainer;\n      if (isElement$6(container) && container.hasChildNodes()) {\n        const isAfterLastNodeInContainer = offset > container.childNodes.length - 1;\n        container = container.childNodes[Math.min(offset, container.childNodes.length - 1)] || container;\n        if (isAfterLastNodeInContainer && isText$b(container)) {\n          offset = container.data.length;\n        } else {\n          offset = 0;\n        }\n      }\n      let parentBlock = dom.getParent(container, dom.isBlock);\n      const containerBlock = parentBlock && parentBlock.parentNode ? dom.getParent(parentBlock.parentNode, dom.isBlock) : null;\n      const containerBlockName = containerBlock ? containerBlock.nodeName.toUpperCase() : '';\n      const isControlKey = !!(evt && evt.ctrlKey);\n      if (containerBlockName === 'LI' && !isControlKey) {\n        parentBlock = containerBlock;\n      }\n      if (isText$b(container) && offset >= container.data.length) {\n        if (!hasRightSideContent(editor.schema, container, parentBlock || dom.getRoot())) {\n          brElm = dom.create('br');\n          rng.insertNode(brElm);\n          rng.setStartAfter(brElm);\n          rng.setEndAfter(brElm);\n          extraBr = true;\n        }\n      }\n      brElm = dom.create('br');\n      rangeInsertNode(dom, rng, brElm);\n      moveSelectionToBr(editor, brElm, extraBr);\n      editor.undoManager.add();\n    };\n    const insertBrBefore = (editor, inline) => {\n      const br = SugarElement.fromTag('br');\n      before$3(SugarElement.fromDom(inline), br);\n      editor.undoManager.add();\n    };\n    const insertBrAfter = (editor, inline) => {\n      if (!hasBrAfter(editor.getBody(), inline)) {\n        after$4(SugarElement.fromDom(inline), SugarElement.fromTag('br'));\n      }\n      const br = SugarElement.fromTag('br');\n      after$4(SugarElement.fromDom(inline), br);\n      moveSelectionToBr(editor, br.dom, false);\n      editor.undoManager.add();\n    };\n    const isBeforeBr = pos => {\n      return isBr$6(pos.getNode());\n    };\n    const hasBrAfter = (rootNode, startNode) => {\n      if (isBeforeBr(CaretPosition.after(startNode))) {\n        return true;\n      } else {\n        return nextPosition(rootNode, CaretPosition.after(startNode)).map(pos => {\n          return isBr$6(pos.getNode());\n        }).getOr(false);\n      }\n    };\n    const isAnchorLink = elm => {\n      return elm && elm.nodeName === 'A' && 'href' in elm;\n    };\n    const isInsideAnchor = location => {\n      return location.fold(never, isAnchorLink, isAnchorLink, never);\n    };\n    const readInlineAnchorLocation = editor => {\n      const isInlineTarget$1 = curry(isInlineTarget, editor);\n      const position = CaretPosition.fromRangeStart(editor.selection.getRng());\n      return readLocation(isInlineTarget$1, editor.getBody(), position).filter(isInsideAnchor);\n    };\n    const insertBrOutsideAnchor = (editor, location) => {\n      location.fold(noop, curry(insertBrBefore, editor), curry(insertBrAfter, editor), noop);\n    };\n    const insert$2 = (editor, evt) => {\n      const anchorLocation = readInlineAnchorLocation(editor);\n      if (anchorLocation.isSome()) {\n        anchorLocation.each(curry(insertBrOutsideAnchor, editor));\n      } else {\n        insertBrAtCaret(editor, evt);\n      }\n    };\n    const fakeEventName = 'insertLineBreak';\n    const linebreak = {\n      insert: insert$2,\n      fakeEventName\n    };\n\n    const matchesSelector = (editor, selector) => {\n      return getParentBlock$1(editor).filter(parentBlock => {\n        return selector.length > 0 && is$1(SugarElement.fromDom(parentBlock), selector);\n      }).isSome();\n    };\n    const shouldInsertBr = editor => {\n      return matchesSelector(editor, getBrNewLineSelector(editor));\n    };\n    const shouldBlockNewLine$1 = editor => {\n      return matchesSelector(editor, getNoNewLineSelector(editor));\n    };\n\n    const newLineAction = Adt.generate([\n      { br: [] },\n      { block: [] },\n      { none: [] }\n    ]);\n    const shouldBlockNewLine = (editor, _shiftKey) => {\n      return shouldBlockNewLine$1(editor);\n    };\n    const inListBlock = requiredState => {\n      return (editor, _shiftKey) => {\n        return isListItemParentBlock(editor) === requiredState;\n      };\n    };\n    const inBlock = (blockName, requiredState) => (editor, _shiftKey) => {\n      const state = getParentBlockName(editor) === blockName.toUpperCase();\n      return state === requiredState;\n    };\n    const inCefBlock = editor => {\n      const editableRoot = getEditableRoot(editor.dom, editor.selection.getStart());\n      return isNullable(editableRoot);\n    };\n    const inPreBlock = requiredState => inBlock('pre', requiredState);\n    const inSummaryBlock = () => inBlock('summary', true);\n    const shouldPutBrInPre = requiredState => {\n      return (editor, _shiftKey) => {\n        return shouldPutBrInPre$1(editor) === requiredState;\n      };\n    };\n    const inBrContext = (editor, _shiftKey) => {\n      return shouldInsertBr(editor);\n    };\n    const hasShiftKey = (_editor, shiftKey) => {\n      return shiftKey;\n    };\n    const canInsertIntoEditableRoot = editor => {\n      const forcedRootBlock = getForcedRootBlock(editor);\n      const rootEditable = getEditableRoot(editor.dom, editor.selection.getStart());\n      return isNonNullable(rootEditable) && editor.schema.isValidChild(rootEditable.nodeName, forcedRootBlock);\n    };\n    const isInRootWithEmptyOrCEF = editor => {\n      const rng = editor.selection.getRng();\n      const start = SugarElement.fromDom(rng.startContainer);\n      const child = child$1(start, rng.startOffset);\n      const isCefOpt = child.map(element => isHTMLElement$1(element) && !isEditable$2(element));\n      return rng.collapsed && isCefOpt.getOr(true);\n    };\n    const match = (predicates, action) => {\n      return (editor, shiftKey) => {\n        const isMatch = foldl(predicates, (res, p) => {\n          return res && p(editor, shiftKey);\n        }, true);\n        return isMatch ? Optional.some(action) : Optional.none();\n      };\n    };\n    const getAction = (editor, evt) => {\n      return evaluateUntil([\n        match([shouldBlockNewLine], newLineAction.none()),\n        match([\n          inPreBlock(true),\n          inCefBlock\n        ], newLineAction.none()),\n        match([inSummaryBlock()], newLineAction.br()),\n        match([\n          inPreBlock(true),\n          shouldPutBrInPre(false),\n          hasShiftKey\n        ], newLineAction.br()),\n        match([\n          inPreBlock(true),\n          shouldPutBrInPre(false)\n        ], newLineAction.block()),\n        match([\n          inPreBlock(true),\n          shouldPutBrInPre(true),\n          hasShiftKey\n        ], newLineAction.block()),\n        match([\n          inPreBlock(true),\n          shouldPutBrInPre(true)\n        ], newLineAction.br()),\n        match([\n          inListBlock(true),\n          hasShiftKey\n        ], newLineAction.br()),\n        match([inListBlock(true)], newLineAction.block()),\n        match([inBrContext], newLineAction.br()),\n        match([hasShiftKey], newLineAction.br()),\n        match([canInsertIntoEditableRoot], newLineAction.block()),\n        match([isInRootWithEmptyOrCEF], newLineAction.block())\n      ], [\n        editor,\n        !!(evt && evt.shiftKey)\n      ]).getOr(newLineAction.none());\n    };\n\n    const insertBreak = (breakType, editor, evt) => {\n      if (editor.mode.isReadOnly()) {\n        return;\n      }\n      if (!editor.selection.isCollapsed()) {\n        execEditorDeleteCommand(editor);\n      }\n      if (isNonNullable(evt)) {\n        const event = fireBeforeInputEvent(editor, breakType.fakeEventName);\n        if (event.isDefaultPrevented()) {\n          return;\n        }\n      }\n      breakType.insert(editor, evt);\n      if (isNonNullable(evt)) {\n        fireInputEvent(editor, breakType.fakeEventName);\n      }\n    };\n    const insert$1 = (editor, evt) => {\n      if (editor.mode.isReadOnly()) {\n        return;\n      }\n      const br = () => insertBreak(linebreak, editor, evt);\n      const block = () => insertBreak(blockbreak, editor, evt);\n      const logicalAction = getAction(editor, evt);\n      switch (getNewlineBehavior(editor)) {\n      case 'linebreak':\n        logicalAction.fold(br, br, noop);\n        break;\n      case 'block':\n        logicalAction.fold(block, block, noop);\n        break;\n      case 'invert':\n        logicalAction.fold(block, br, noop);\n        break;\n      default:\n        logicalAction.fold(br, block, noop);\n        break;\n      }\n    };\n\n    const platform$1 = detect$1();\n    const isIOSSafari = platform$1.os.isiOS() && platform$1.browser.isSafari();\n    const handleEnterKeyEvent = (editor, event) => {\n      if (event.isDefaultPrevented()) {\n        return;\n      }\n      event.preventDefault();\n      endTypingLevelIgnoreLocks(editor.undoManager);\n      editor.undoManager.transact(() => {\n        insert$1(editor, event);\n      });\n    };\n    const isCaretAfterKoreanCharacter = rng => {\n      if (!rng.collapsed) {\n        return false;\n      }\n      const startContainer = rng.startContainer;\n      if (isText$b(startContainer)) {\n        const koreanCharRegex = /^[\\uAC00-\\uD7AF\\u1100-\\u11FF\\u3130-\\u318F\\uA960-\\uA97F\\uD7B0-\\uD7FF]$/;\n        const char = startContainer.data.charAt(rng.startOffset - 1);\n        return koreanCharRegex.test(char);\n      } else {\n        return false;\n      }\n    };\n    const setup$i = editor => {\n      let iOSSafariKeydownBookmark = Optional.none();\n      const iOSSafariKeydownOverride = editor => {\n        iOSSafariKeydownBookmark = Optional.some(editor.selection.getBookmark());\n        editor.undoManager.add();\n      };\n      const iOSSafariKeyupOverride = (editor, event) => {\n        editor.undoManager.undo();\n        iOSSafariKeydownBookmark.fold(noop, b => editor.selection.moveToBookmark(b));\n        handleEnterKeyEvent(editor, event);\n        iOSSafariKeydownBookmark = Optional.none();\n      };\n      editor.on('keydown', event => {\n        if (event.keyCode === VK.ENTER) {\n          if (isIOSSafari && isCaretAfterKoreanCharacter(editor.selection.getRng())) {\n            iOSSafariKeydownOverride(editor);\n          } else {\n            handleEnterKeyEvent(editor, event);\n          }\n        }\n      });\n      editor.on('keyup', event => {\n        if (event.keyCode === VK.ENTER) {\n          iOSSafariKeydownBookmark.each(() => iOSSafariKeyupOverride(editor, event));\n        }\n      });\n    };\n\n    const executeKeydownOverride$2 = (editor, caret, evt) => {\n      const isMac = Env.os.isMacOS() || Env.os.isiOS();\n      execute([\n        {\n          keyCode: VK.END,\n          action: action(moveToLineEndPoint$1, editor, true)\n        },\n        {\n          keyCode: VK.HOME,\n          action: action(moveToLineEndPoint$1, editor, false)\n        },\n        ...!isMac ? [\n          {\n            keyCode: VK.HOME,\n            action: action(selectToEndPoint, editor, false),\n            ctrlKey: true,\n            shiftKey: true\n          },\n          {\n            keyCode: VK.END,\n            action: action(selectToEndPoint, editor, true),\n            ctrlKey: true,\n            shiftKey: true\n          }\n        ] : [],\n        {\n          keyCode: VK.END,\n          action: action(moveToLineEndPoint, editor, true)\n        },\n        {\n          keyCode: VK.HOME,\n          action: action(moveToLineEndPoint, editor, false)\n        },\n        {\n          keyCode: VK.END,\n          action: action(moveToLineEndPoint$2, editor, true, caret)\n        },\n        {\n          keyCode: VK.HOME,\n          action: action(moveToLineEndPoint$2, editor, false, caret)\n        }\n      ], evt).each(_ => {\n        evt.preventDefault();\n      });\n    };\n    const setup$h = (editor, caret) => {\n      editor.on('keydown', evt => {\n        if (!evt.isDefaultPrevented()) {\n          executeKeydownOverride$2(editor, caret, evt);\n        }\n      });\n    };\n\n    const setup$g = editor => {\n      editor.on('input', e => {\n        if (!e.isComposing) {\n          normalizeNbspsInEditor(editor);\n        }\n      });\n    };\n\n    const platform = detect$1();\n    const executeKeyupAction = (editor, caret, evt) => {\n      execute([\n        {\n          keyCode: VK.PAGE_UP,\n          action: action(moveToLineEndPoint$2, editor, false, caret)\n        },\n        {\n          keyCode: VK.PAGE_DOWN,\n          action: action(moveToLineEndPoint$2, editor, true, caret)\n        }\n      ], evt);\n    };\n    const stopImmediatePropagation = e => e.stopImmediatePropagation();\n    const isPageUpDown = evt => evt.keyCode === VK.PAGE_UP || evt.keyCode === VK.PAGE_DOWN;\n    const setNodeChangeBlocker = (blocked, editor, block) => {\n      if (block && !blocked.get()) {\n        editor.on('NodeChange', stopImmediatePropagation, true);\n      } else if (!block && blocked.get()) {\n        editor.off('NodeChange', stopImmediatePropagation);\n      }\n      blocked.set(block);\n    };\n    const setup$f = (editor, caret) => {\n      if (platform.os.isMacOS()) {\n        return;\n      }\n      const blocked = Cell(false);\n      editor.on('keydown', evt => {\n        if (isPageUpDown(evt)) {\n          setNodeChangeBlocker(blocked, editor, true);\n        }\n      });\n      editor.on('keyup', evt => {\n        if (!evt.isDefaultPrevented()) {\n          executeKeyupAction(editor, caret, evt);\n        }\n        if (isPageUpDown(evt) && blocked.get()) {\n          setNodeChangeBlocker(blocked, editor, false);\n          editor.nodeChanged();\n        }\n      });\n    };\n\n    const setup$e = editor => {\n      editor.on('beforeinput', e => {\n        if (!editor.selection.isEditable() || exists(e.getTargetRanges(), rng => !isEditableRange(editor.dom, rng))) {\n          e.preventDefault();\n        }\n      });\n    };\n\n    const insertTextAtPosition = (text, pos) => {\n      const container = pos.container();\n      const offset = pos.offset();\n      if (isText$b(container)) {\n        container.insertData(offset, text);\n        return Optional.some(CaretPosition(container, offset + text.length));\n      } else {\n        return getElementFromPosition(pos).map(elm => {\n          const textNode = SugarElement.fromText(text);\n          if (pos.isAtEnd()) {\n            after$4(elm, textNode);\n          } else {\n            before$3(elm, textNode);\n          }\n          return CaretPosition(textNode.dom, text.length);\n        });\n      }\n    };\n    const insertNbspAtPosition = curry(insertTextAtPosition, nbsp);\n    const insertSpaceAtPosition = curry(insertTextAtPosition, ' ');\n\n    const insertSpaceOrNbspAtPosition = (root, pos, schema) => needsToHaveNbsp(root, pos, schema) ? insertNbspAtPosition(pos) : insertSpaceAtPosition(pos);\n    const locationToCaretPosition = root => location => location.fold(element => prevPosition(root.dom, CaretPosition.before(element)), element => firstPositionIn(element), element => lastPositionIn(element), element => nextPosition(root.dom, CaretPosition.after(element)));\n    const insertInlineBoundarySpaceOrNbsp = (root, pos, schema) => checkPos => needsToHaveNbsp(root, checkPos, schema) ? insertNbspAtPosition(pos) : insertSpaceAtPosition(pos);\n    const setSelection = editor => pos => {\n      editor.selection.setRng(pos.toRange());\n      editor.nodeChanged();\n    };\n    const isInsideSummary = (domUtils, node) => domUtils.isEditable(domUtils.getParent(node, 'summary'));\n    const insertSpaceOrNbspAtSelection = editor => {\n      const pos = CaretPosition.fromRangeStart(editor.selection.getRng());\n      const root = SugarElement.fromDom(editor.getBody());\n      if (editor.selection.isCollapsed()) {\n        const isInlineTarget$1 = curry(isInlineTarget, editor);\n        const caretPosition = CaretPosition.fromRangeStart(editor.selection.getRng());\n        return readLocation(isInlineTarget$1, editor.getBody(), caretPosition).bind(locationToCaretPosition(root)).map(checkPos => () => insertInlineBoundarySpaceOrNbsp(root, pos, editor.schema)(checkPos).each(setSelection(editor)));\n      } else {\n        return Optional.none();\n      }\n    };\n    const insertSpaceInSummaryAtSelectionOnFirefox = editor => {\n      const insertSpaceThunk = () => {\n        const root = SugarElement.fromDom(editor.getBody());\n        if (!editor.selection.isCollapsed()) {\n          editor.getDoc().execCommand('Delete');\n        }\n        const pos = CaretPosition.fromRangeStart(editor.selection.getRng());\n        insertSpaceOrNbspAtPosition(root, pos, editor.schema).each(setSelection(editor));\n      };\n      return someIf(Env.browser.isFirefox() && editor.selection.isEditable() && isInsideSummary(editor.dom, editor.selection.getRng().startContainer), insertSpaceThunk);\n    };\n\n    const executeKeydownOverride$1 = (editor, evt) => {\n      executeWithDelayedAction([\n        {\n          keyCode: VK.SPACEBAR,\n          action: action(insertSpaceOrNbspAtSelection, editor)\n        },\n        {\n          keyCode: VK.SPACEBAR,\n          action: action(insertSpaceInSummaryAtSelectionOnFirefox, editor)\n        }\n      ], evt).each(applyAction => {\n        evt.preventDefault();\n        const event = fireBeforeInputEvent(editor, 'insertText', { data: ' ' });\n        if (!event.isDefaultPrevented()) {\n          applyAction();\n          fireInputEvent(editor, 'insertText', { data: ' ' });\n        }\n      });\n    };\n    const setup$d = editor => {\n      editor.on('keydown', evt => {\n        if (!evt.isDefaultPrevented()) {\n          executeKeydownOverride$1(editor, evt);\n        }\n      });\n    };\n\n    const tableTabNavigation = editor => {\n      if (hasTableTabNavigation(editor)) {\n        return [\n          {\n            keyCode: VK.TAB,\n            action: action(handleTab, editor, true)\n          },\n          {\n            keyCode: VK.TAB,\n            shiftKey: true,\n            action: action(handleTab, editor, false)\n          }\n        ];\n      } else {\n        return [];\n      }\n    };\n    const executeKeydownOverride = (editor, evt) => {\n      execute([...tableTabNavigation(editor)], evt).each(_ => {\n        evt.preventDefault();\n      });\n    };\n    const setup$c = editor => {\n      editor.on('keydown', evt => {\n        if (!evt.isDefaultPrevented()) {\n          executeKeydownOverride(editor, evt);\n        }\n      });\n    };\n\n    const setup$b = editor => {\n      editor.addShortcut('Meta+P', '', 'mcePrint');\n      setup$k(editor);\n      if (isRtc(editor)) {\n        return Cell(null);\n      } else {\n        const caret = setupSelectedState(editor);\n        setup$e(editor);\n        setup$m(editor);\n        setup$l(editor, caret);\n        setup$j(editor, caret);\n        setup$i(editor);\n        setup$d(editor);\n        setup$g(editor);\n        setup$c(editor);\n        setup$h(editor, caret);\n        setup$f(editor, caret);\n        return caret;\n      }\n    };\n\n    class NodeChange {\n      constructor(editor) {\n        this.lastPath = [];\n        this.editor = editor;\n        let lastRng;\n        const self = this;\n        if (!('onselectionchange' in editor.getDoc())) {\n          editor.on('NodeChange click mouseup keyup focus', e => {\n            const nativeRng = editor.selection.getRng();\n            const fakeRng = {\n              startContainer: nativeRng.startContainer,\n              startOffset: nativeRng.startOffset,\n              endContainer: nativeRng.endContainer,\n              endOffset: nativeRng.endOffset\n            };\n            if (e.type === 'nodechange' || !isEq$4(fakeRng, lastRng)) {\n              editor.dispatch('SelectionChange');\n            }\n            lastRng = fakeRng;\n          });\n        }\n        editor.on('contextmenu', () => {\n          store(editor);\n          editor.dispatch('SelectionChange');\n        });\n        editor.on('SelectionChange', () => {\n          const startElm = editor.selection.getStart(true);\n          if (!startElm) {\n            return;\n          }\n          if (hasAnyRanges(editor) && !self.isSameElementPath(startElm) && editor.dom.isChildOf(startElm, editor.getBody())) {\n            editor.nodeChanged({ selectionChange: true });\n          }\n        });\n        editor.on('mouseup', e => {\n          if (!e.isDefaultPrevented() && hasAnyRanges(editor)) {\n            if (editor.selection.getNode().nodeName === 'IMG') {\n              Delay.setEditorTimeout(editor, () => {\n                editor.nodeChanged();\n              });\n            } else {\n              editor.nodeChanged();\n            }\n          }\n        });\n      }\n      nodeChanged(args = {}) {\n        const editor = this.editor;\n        const selection = editor.selection;\n        let node;\n        if (editor.initialized && selection && !shouldDisableNodeChange(editor)) {\n          const root = editor.getBody();\n          node = selection.getStart(true) || root;\n          if (node.ownerDocument !== editor.getDoc() || !editor.dom.isChildOf(node, root)) {\n            node = root;\n          }\n          const parents = [];\n          editor.dom.getParent(node, node => {\n            if (node === root) {\n              return true;\n            } else {\n              parents.push(node);\n              return false;\n            }\n          });\n          editor.dispatch('NodeChange', {\n            ...args,\n            element: node,\n            parents\n          });\n        }\n      }\n      isSameElementPath(startElm) {\n        let i;\n        const editor = this.editor;\n        const currentPath = reverse(editor.dom.getParents(startElm, always, editor.getBody()));\n        if (currentPath.length === this.lastPath.length) {\n          for (i = currentPath.length; i >= 0; i--) {\n            if (currentPath[i] !== this.lastPath[i]) {\n              break;\n            }\n          }\n          if (i === -1) {\n            this.lastPath = currentPath;\n            return true;\n          }\n        }\n        this.lastPath = currentPath;\n        return false;\n      }\n    }\n\n    const imageId = generate$1('image');\n    const getDragImage = transfer => {\n      const dt = transfer;\n      return Optional.from(dt[imageId]);\n    };\n    const setDragImage = (transfer, imageData) => {\n      const dt = transfer;\n      dt[imageId] = imageData;\n    };\n\n    const eventId = generate$1('event');\n    const getEvent = transfer => {\n      const dt = transfer;\n      return Optional.from(dt[eventId]);\n    };\n    const mkSetEventFn = type => transfer => {\n      const dt = transfer;\n      dt[eventId] = type;\n    };\n    const setEvent = (transfer, type) => mkSetEventFn(type)(transfer);\n    const setDragstartEvent = mkSetEventFn(0);\n    const setDropEvent = mkSetEventFn(2);\n    const setDragendEvent = mkSetEventFn(1);\n    const checkEvent = expectedType => transfer => {\n      const dt = transfer;\n      return Optional.from(dt[eventId]).exists(type => type === expectedType);\n    };\n    const isInDragStartEvent = checkEvent(0);\n\n    const createEmptyFileList = () => Object.freeze({\n      length: 0,\n      item: _ => null\n    });\n\n    const modeId = generate$1('mode');\n    const getMode = transfer => {\n      const dt = transfer;\n      return Optional.from(dt[modeId]);\n    };\n    const mkSetModeFn = mode => transfer => {\n      const dt = transfer;\n      dt[modeId] = mode;\n    };\n    const setMode$1 = (transfer, mode) => mkSetModeFn(mode)(transfer);\n    const setReadWriteMode = mkSetModeFn(0);\n    const setReadOnlyMode = mkSetModeFn(2);\n    const setProtectedMode = mkSetModeFn(1);\n    const checkMode = expectedMode => transfer => {\n      const dt = transfer;\n      return Optional.from(dt[modeId]).exists(mode => mode === expectedMode);\n    };\n    const isInReadWriteMode = checkMode(0);\n    const isInProtectedMode = checkMode(1);\n\n    const normalizeItems = (dataTransfer, itemsImpl) => ({\n      ...itemsImpl,\n      get length() {\n        return itemsImpl.length;\n      },\n      add: (data, type) => {\n        if (isInReadWriteMode(dataTransfer)) {\n          if (isString(data)) {\n            if (!isUndefined(type)) {\n              return itemsImpl.add(data, type);\n            }\n          } else {\n            return itemsImpl.add(data);\n          }\n        }\n        return null;\n      },\n      remove: idx => {\n        if (isInReadWriteMode(dataTransfer)) {\n          itemsImpl.remove(idx);\n        }\n      },\n      clear: () => {\n        if (isInReadWriteMode(dataTransfer)) {\n          itemsImpl.clear();\n        }\n      }\n    });\n\n    const validDropEffects = [\n      'none',\n      'copy',\n      'link',\n      'move'\n    ];\n    const validEffectAlloweds = [\n      'none',\n      'copy',\n      'copyLink',\n      'copyMove',\n      'link',\n      'linkMove',\n      'move',\n      'all',\n      'uninitialized'\n    ];\n    const createDataTransfer = () => {\n      const dataTransferImpl = new window.DataTransfer();\n      let dropEffect = 'move';\n      let effectAllowed = 'all';\n      const dataTransfer = {\n        get dropEffect() {\n          return dropEffect;\n        },\n        set dropEffect(effect) {\n          if (contains$2(validDropEffects, effect)) {\n            dropEffect = effect;\n          }\n        },\n        get effectAllowed() {\n          return effectAllowed;\n        },\n        set effectAllowed(allowed) {\n          if (isInDragStartEvent(dataTransfer) && contains$2(validEffectAlloweds, allowed)) {\n            effectAllowed = allowed;\n          }\n        },\n        get items() {\n          return normalizeItems(dataTransfer, dataTransferImpl.items);\n        },\n        get files() {\n          if (isInProtectedMode(dataTransfer)) {\n            return createEmptyFileList();\n          } else {\n            return dataTransferImpl.files;\n          }\n        },\n        get types() {\n          return dataTransferImpl.types;\n        },\n        setDragImage: (image, x, y) => {\n          if (isInReadWriteMode(dataTransfer)) {\n            setDragImage(dataTransfer, {\n              image,\n              x,\n              y\n            });\n            dataTransferImpl.setDragImage(image, x, y);\n          }\n        },\n        getData: format => {\n          if (isInProtectedMode(dataTransfer)) {\n            return '';\n          } else {\n            return dataTransferImpl.getData(format);\n          }\n        },\n        setData: (format, data) => {\n          if (isInReadWriteMode(dataTransfer)) {\n            dataTransferImpl.setData(format, data);\n          }\n        },\n        clearData: format => {\n          if (isInReadWriteMode(dataTransfer)) {\n            dataTransferImpl.clearData(format);\n          }\n        }\n      };\n      setReadWriteMode(dataTransfer);\n      return dataTransfer;\n    };\n    const cloneDataTransfer = original => {\n      const clone = createDataTransfer();\n      const originalMode = getMode(original);\n      setReadOnlyMode(original);\n      setDragstartEvent(clone);\n      clone.dropEffect = original.dropEffect;\n      clone.effectAllowed = original.effectAllowed;\n      getDragImage(original).each(imageData => clone.setDragImage(imageData.image, imageData.x, imageData.y));\n      each$e(original.types, type => {\n        if (type !== 'Files') {\n          clone.setData(type, original.getData(type));\n        }\n      });\n      each$e(original.files, file => clone.items.add(file));\n      getEvent(original).each(type => {\n        setEvent(clone, type);\n      });\n      originalMode.each(mode => {\n        setMode$1(original, mode);\n        setMode$1(clone, mode);\n      });\n      return clone;\n    };\n\n    const getHtmlData = dataTransfer => {\n      const html = dataTransfer.getData('text/html');\n      return html === '' ? Optional.none() : Optional.some(html);\n    };\n    const setHtmlData = (dataTransfer, html) => dataTransfer.setData('text/html', html);\n\n    const internalMimeType = 'x-tinymce/html';\n    const internalHtmlMime = constant(internalMimeType);\n    const internalMark = '<!-- ' + internalMimeType + ' -->';\n    const mark = html => internalMark + html;\n    const unmark = html => html.replace(internalMark, '');\n    const isMarked = html => html.indexOf(internalMark) !== -1;\n\n    const isPlainText = text => {\n      return !/<(?:\\/?(?!(?:div|p|br|span)>)\\w+|(?:(?!(?:span style=\"white-space:\\s?pre;?\">)|br\\s?\\/>))\\w+\\s[^>]+)>/i.test(text);\n    };\n    const openContainer = (rootTag, rootAttrs) => {\n      let tag = '<' + rootTag;\n      const attrs = mapToArray(rootAttrs, (value, key) => key + '=\"' + Entities.encodeAllRaw(value) + '\"');\n      if (attrs.length) {\n        tag += ' ' + attrs.join(' ');\n      }\n      return tag + '>';\n    };\n    const toBlockElements = (text, rootTag, rootAttrs) => {\n      const blocks = text.split(/\\n\\n/);\n      const tagOpen = openContainer(rootTag, rootAttrs);\n      const tagClose = '</' + rootTag + '>';\n      const paragraphs = map$3(blocks, p => {\n        return p.split(/\\n/).join('<br />');\n      });\n      const stitch = p => {\n        return tagOpen + p + tagClose;\n      };\n      return paragraphs.length === 1 ? paragraphs[0] : map$3(paragraphs, stitch).join('');\n    };\n\n    const pasteBinDefaultContent = '%MCEPASTEBIN%';\n    const create$6 = (editor, lastRngCell) => {\n      const {dom, selection} = editor;\n      const body = editor.getBody();\n      lastRngCell.set(selection.getRng());\n      const pasteBinElm = dom.add(editor.getBody(), 'div', {\n        'id': 'mcepastebin',\n        'class': 'mce-pastebin',\n        'contentEditable': true,\n        'data-mce-bogus': 'all',\n        'style': 'position: fixed; top: 50%; width: 10px; height: 10px; overflow: hidden; opacity: 0'\n      }, pasteBinDefaultContent);\n      if (Env.browser.isFirefox()) {\n        dom.setStyle(pasteBinElm, 'left', dom.getStyle(body, 'direction', true) === 'rtl' ? 65535 : -65535);\n      }\n      dom.bind(pasteBinElm, 'beforedeactivate focusin focusout', e => {\n        e.stopPropagation();\n      });\n      pasteBinElm.focus();\n      selection.select(pasteBinElm, true);\n    };\n    const remove = (editor, lastRngCell) => {\n      const dom = editor.dom;\n      if (getEl(editor)) {\n        let pasteBinClone;\n        const lastRng = lastRngCell.get();\n        while (pasteBinClone = getEl(editor)) {\n          dom.remove(pasteBinClone);\n          dom.unbind(pasteBinClone);\n        }\n        if (lastRng) {\n          editor.selection.setRng(lastRng);\n        }\n      }\n      lastRngCell.set(null);\n    };\n    const getEl = editor => editor.dom.get('mcepastebin');\n    const isPasteBin = elm => isNonNullable(elm) && elm.id === 'mcepastebin';\n    const getHtml = editor => {\n      const dom = editor.dom;\n      const copyAndRemove = (toElm, fromElm) => {\n        toElm.appendChild(fromElm);\n        dom.remove(fromElm, true);\n      };\n      const [pasteBinElm, ...pasteBinClones] = filter$5(editor.getBody().childNodes, isPasteBin);\n      each$e(pasteBinClones, pasteBinClone => {\n        copyAndRemove(pasteBinElm, pasteBinClone);\n      });\n      const dirtyWrappers = dom.select('div[id=mcepastebin]', pasteBinElm);\n      for (let i = dirtyWrappers.length - 1; i >= 0; i--) {\n        const cleanWrapper = dom.create('div');\n        pasteBinElm.insertBefore(cleanWrapper, dirtyWrappers[i]);\n        copyAndRemove(cleanWrapper, dirtyWrappers[i]);\n      }\n      return pasteBinElm ? pasteBinElm.innerHTML : '';\n    };\n    const isDefaultPasteBinContent = content => content === pasteBinDefaultContent;\n    const PasteBin = editor => {\n      const lastRng = Cell(null);\n      return {\n        create: () => create$6(editor, lastRng),\n        remove: () => remove(editor, lastRng),\n        getEl: () => getEl(editor),\n        getHtml: () => getHtml(editor),\n        getLastRng: lastRng.get\n      };\n    };\n\n    const filter$1 = (content, items) => {\n      Tools.each(items, v => {\n        if (is$4(v, RegExp)) {\n          content = content.replace(v, '');\n        } else {\n          content = content.replace(v[0], v[1]);\n        }\n      });\n      return content;\n    };\n    const innerText = html => {\n      const schema = Schema();\n      const domParser = DomParser({}, schema);\n      let text = '';\n      const voidElements = schema.getVoidElements();\n      const ignoreElements = Tools.makeMap('script noscript style textarea video audio iframe object', ' ');\n      const blockElements = schema.getBlockElements();\n      const walk = node => {\n        const name = node.name, currentNode = node;\n        if (name === 'br') {\n          text += '\\n';\n          return;\n        }\n        if (name === 'wbr') {\n          return;\n        }\n        if (voidElements[name]) {\n          text += ' ';\n        }\n        if (ignoreElements[name]) {\n          text += ' ';\n          return;\n        }\n        if (node.type === 3) {\n          text += node.value;\n        }\n        if (!(node.name in schema.getVoidElements())) {\n          let currentNode = node.firstChild;\n          if (currentNode) {\n            do {\n              walk(currentNode);\n            } while (currentNode = currentNode.next);\n          }\n        }\n        if (blockElements[name] && currentNode.next) {\n          text += '\\n';\n          if (name === 'p') {\n            text += '\\n';\n          }\n        }\n      };\n      html = filter$1(html, [/<!\\[[^\\]]+\\]>/g]);\n      walk(domParser.parse(html));\n      return text;\n    };\n    const trimHtml = html => {\n      const trimSpaces = (all, s1, s2) => {\n        if (!s1 && !s2) {\n          return ' ';\n        }\n        return nbsp;\n      };\n      html = filter$1(html, [\n        /^[\\s\\S]*<body[^>]*>\\s*|\\s*<\\/body[^>]*>[\\s\\S]*$/ig,\n        /<!--StartFragment-->|<!--EndFragment-->/g,\n        [\n          /( ?)<span class=\"Apple-converted-space\">\\u00a0<\\/span>( ?)/g,\n          trimSpaces\n        ],\n        /<br class=\"Apple-interchange-newline\">/g,\n        /<br>$/i\n      ]);\n      return html;\n    };\n    const createIdGenerator = prefix => {\n      let count = 0;\n      return () => {\n        return prefix + count++;\n      };\n    };\n    const getImageMimeType = ext => {\n      const lowerExt = ext.toLowerCase();\n      const mimeOverrides = {\n        jpg: 'jpeg',\n        jpe: 'jpeg',\n        jfi: 'jpeg',\n        jif: 'jpeg',\n        jfif: 'jpeg',\n        pjpeg: 'jpeg',\n        pjp: 'jpeg',\n        svg: 'svg+xml'\n      };\n      return Tools.hasOwn(mimeOverrides, lowerExt) ? 'image/' + mimeOverrides[lowerExt] : 'image/' + lowerExt;\n    };\n\n    const preProcess = (editor, html) => {\n      const parser = DomParser({\n        sanitize: shouldSanitizeXss(editor),\n        sandbox_iframes: shouldSandboxIframes(editor),\n        sandbox_iframes_exclusions: getSandboxIframesExclusions(editor),\n        convert_unsafe_embeds: shouldConvertUnsafeEmbeds(editor)\n      }, editor.schema);\n      parser.addNodeFilter('meta', nodes => {\n        Tools.each(nodes, node => {\n          node.remove();\n        });\n      });\n      const fragment = parser.parse(html, {\n        forced_root_block: false,\n        isRootContent: true\n      });\n      return HtmlSerializer({ validate: true }, editor.schema).serialize(fragment);\n    };\n    const processResult = (content, cancelled) => ({\n      content,\n      cancelled\n    });\n    const postProcessFilter = (editor, html, internal) => {\n      const tempBody = editor.dom.create('div', { style: 'display:none' }, html);\n      const postProcessArgs = firePastePostProcess(editor, tempBody, internal);\n      return processResult(postProcessArgs.node.innerHTML, postProcessArgs.isDefaultPrevented());\n    };\n    const filterContent = (editor, content, internal) => {\n      const preProcessArgs = firePastePreProcess(editor, content, internal);\n      const filteredContent = preProcess(editor, preProcessArgs.content);\n      if (editor.hasEventListeners('PastePostProcess') && !preProcessArgs.isDefaultPrevented()) {\n        return postProcessFilter(editor, filteredContent, internal);\n      } else {\n        return processResult(filteredContent, preProcessArgs.isDefaultPrevented());\n      }\n    };\n    const process = (editor, html, internal) => {\n      return filterContent(editor, html, internal);\n    };\n\n    const pasteHtml$1 = (editor, html) => {\n      editor.insertContent(html, {\n        merge: shouldPasteMergeFormats(editor),\n        paste: true\n      });\n      return true;\n    };\n    const isAbsoluteUrl = url => /^https?:\\/\\/[\\w\\-\\/+=.,!;:&%@^~(){}?#]+$/i.test(url);\n    const isImageUrl = (editor, url) => {\n      return isAbsoluteUrl(url) && exists(getAllowedImageFileTypes(editor), type => endsWith(url.toLowerCase(), `.${ type.toLowerCase() }`));\n    };\n    const createImage = (editor, url, pasteHtmlFn) => {\n      editor.undoManager.extra(() => {\n        pasteHtmlFn(editor, url);\n      }, () => {\n        editor.insertContent('<img src=\"' + url + '\">');\n      });\n      return true;\n    };\n    const createLink = (editor, url, pasteHtmlFn) => {\n      editor.undoManager.extra(() => {\n        pasteHtmlFn(editor, url);\n      }, () => {\n        editor.execCommand('mceInsertLink', false, url);\n      });\n      return true;\n    };\n    const linkSelection = (editor, html, pasteHtmlFn) => !editor.selection.isCollapsed() && isAbsoluteUrl(html) ? createLink(editor, html, pasteHtmlFn) : false;\n    const insertImage = (editor, html, pasteHtmlFn) => isImageUrl(editor, html) ? createImage(editor, html, pasteHtmlFn) : false;\n    const smartInsertContent = (editor, html) => {\n      Tools.each([\n        linkSelection,\n        insertImage,\n        pasteHtml$1\n      ], action => {\n        return !action(editor, html, pasteHtml$1);\n      });\n    };\n    const insertContent = (editor, html, pasteAsText) => {\n      if (pasteAsText || !isSmartPasteEnabled(editor)) {\n        pasteHtml$1(editor, html);\n      } else {\n        smartInsertContent(editor, html);\n      }\n    };\n\n    const uniqueId = createIdGenerator('mceclip');\n    const createPasteDataTransfer = html => {\n      const dataTransfer = createDataTransfer();\n      setHtmlData(dataTransfer, html);\n      setReadOnlyMode(dataTransfer);\n      return dataTransfer;\n    };\n    const doPaste = (editor, content, internal, pasteAsText, shouldSimulateInputEvent) => {\n      const res = process(editor, content, internal);\n      if (!res.cancelled) {\n        const content = res.content;\n        const doPasteAction = () => insertContent(editor, content, pasteAsText);\n        if (shouldSimulateInputEvent) {\n          const args = fireBeforeInputEvent(editor, 'insertFromPaste', { dataTransfer: createPasteDataTransfer(content) });\n          if (!args.isDefaultPrevented()) {\n            doPasteAction();\n            fireInputEvent(editor, 'insertFromPaste');\n          }\n        } else {\n          doPasteAction();\n        }\n      }\n    };\n    const pasteHtml = (editor, html, internalFlag, shouldSimulateInputEvent) => {\n      const internal = internalFlag ? internalFlag : isMarked(html);\n      doPaste(editor, unmark(html), internal, false, shouldSimulateInputEvent);\n    };\n    const pasteText = (editor, text, shouldSimulateInputEvent) => {\n      const encodedText = editor.dom.encode(text).replace(/\\r\\n/g, '\\n');\n      const normalizedText = normalize$4(encodedText, getPasteTabSpaces(editor));\n      const html = toBlockElements(normalizedText, getForcedRootBlock(editor), getForcedRootBlockAttrs(editor));\n      doPaste(editor, html, false, true, shouldSimulateInputEvent);\n    };\n    const getDataTransferItems = dataTransfer => {\n      const items = {};\n      if (dataTransfer && dataTransfer.types) {\n        for (let i = 0; i < dataTransfer.types.length; i++) {\n          const contentType = dataTransfer.types[i];\n          try {\n            items[contentType] = dataTransfer.getData(contentType);\n          } catch (ex) {\n            items[contentType] = '';\n          }\n        }\n      }\n      return items;\n    };\n    const hasContentType = (clipboardContent, mimeType) => mimeType in clipboardContent && clipboardContent[mimeType].length > 0;\n    const hasHtmlOrText = content => hasContentType(content, 'text/html') || hasContentType(content, 'text/plain');\n    const extractFilename = (editor, str) => {\n      const m = str.match(/([\\s\\S]+?)(?:\\.[a-z0-9.]+)$/i);\n      return isNonNullable(m) ? editor.dom.encode(m[1]) : undefined;\n    };\n    const createBlobInfo = (editor, blobCache, file, base64) => {\n      const id = uniqueId();\n      const useFileName = shouldReuseFileName(editor) && isNonNullable(file.name);\n      const name = useFileName ? extractFilename(editor, file.name) : id;\n      const filename = useFileName ? file.name : undefined;\n      const blobInfo = blobCache.create(id, file, base64, name, filename);\n      blobCache.add(blobInfo);\n      return blobInfo;\n    };\n    const pasteImage = (editor, imageItem) => {\n      parseDataUri(imageItem.uri).each(({data, type, base64Encoded}) => {\n        const base64 = base64Encoded ? data : btoa(data);\n        const file = imageItem.file;\n        const blobCache = editor.editorUpload.blobCache;\n        const existingBlobInfo = blobCache.getByData(base64, type);\n        const blobInfo = existingBlobInfo !== null && existingBlobInfo !== void 0 ? existingBlobInfo : createBlobInfo(editor, blobCache, file, base64);\n        pasteHtml(editor, `<img src=\"${ blobInfo.blobUri() }\">`, false, true);\n      });\n    };\n    const isClipboardEvent = event => event.type === 'paste';\n    const readFilesAsDataUris = items => Promise.all(map$3(items, file => {\n      return blobToDataUri(file).then(uri => ({\n        file,\n        uri\n      }));\n    }));\n    const isImage = editor => {\n      const allowedExtensions = getAllowedImageFileTypes(editor);\n      return file => startsWith(file.type, 'image/') && exists(allowedExtensions, extension => {\n        return getImageMimeType(extension) === file.type;\n      });\n    };\n    const getImagesFromDataTransfer = (editor, dataTransfer) => {\n      const items = dataTransfer.items ? bind$3(from(dataTransfer.items), item => {\n        return item.kind === 'file' ? [item.getAsFile()] : [];\n      }) : [];\n      const files = dataTransfer.files ? from(dataTransfer.files) : [];\n      return filter$5(items.length > 0 ? items : files, isImage(editor));\n    };\n    const pasteImageData = (editor, e, rng) => {\n      const dataTransfer = isClipboardEvent(e) ? e.clipboardData : e.dataTransfer;\n      if (shouldPasteDataImages(editor) && dataTransfer) {\n        const images = getImagesFromDataTransfer(editor, dataTransfer);\n        if (images.length > 0) {\n          e.preventDefault();\n          readFilesAsDataUris(images).then(fileResults => {\n            if (rng) {\n              editor.selection.setRng(rng);\n            }\n            each$e(fileResults, result => {\n              pasteImage(editor, result);\n            });\n          });\n          return true;\n        }\n      }\n      return false;\n    };\n    const isBrokenAndroidClipboardEvent = e => {\n      var _a, _b;\n      return Env.os.isAndroid() && ((_b = (_a = e.clipboardData) === null || _a === void 0 ? void 0 : _a.items) === null || _b === void 0 ? void 0 : _b.length) === 0;\n    };\n    const isKeyboardPasteEvent = e => VK.metaKeyPressed(e) && e.keyCode === 86 || e.shiftKey && e.keyCode === 45;\n    const insertClipboardContent = (editor, clipboardContent, html, plainTextMode, shouldSimulateInputEvent) => {\n      let content = trimHtml(html);\n      const isInternal = hasContentType(clipboardContent, internalHtmlMime()) || isMarked(html);\n      const isPlainTextHtml = !isInternal && isPlainText(content);\n      const isAbsoluteUrl$1 = isAbsoluteUrl(content);\n      if (isDefaultPasteBinContent(content) || !content.length || isPlainTextHtml && !isAbsoluteUrl$1) {\n        plainTextMode = true;\n      }\n      if (plainTextMode || isAbsoluteUrl$1) {\n        if (hasContentType(clipboardContent, 'text/plain') && isPlainTextHtml) {\n          content = clipboardContent['text/plain'];\n        } else {\n          content = innerText(content);\n        }\n      }\n      if (isDefaultPasteBinContent(content)) {\n        return;\n      }\n      if (plainTextMode) {\n        pasteText(editor, content, shouldSimulateInputEvent);\n      } else {\n        pasteHtml(editor, content, isInternal, shouldSimulateInputEvent);\n      }\n    };\n    const registerEventHandlers = (editor, pasteBin, pasteFormat) => {\n      let keyboardPastePlainTextState;\n      const getLastRng = () => pasteBin.getLastRng() || editor.selection.getRng();\n      editor.on('keydown', e => {\n        if (isKeyboardPasteEvent(e) && !e.isDefaultPrevented()) {\n          keyboardPastePlainTextState = e.shiftKey && e.keyCode === 86;\n        }\n      });\n      editor.on('paste', e => {\n        if (e.isDefaultPrevented() || isBrokenAndroidClipboardEvent(e)) {\n          return;\n        }\n        const plainTextMode = pasteFormat.get() === 'text' || keyboardPastePlainTextState;\n        keyboardPastePlainTextState = false;\n        const clipboardContent = getDataTransferItems(e.clipboardData);\n        if (!hasHtmlOrText(clipboardContent) && pasteImageData(editor, e, getLastRng())) {\n          return;\n        }\n        if (hasContentType(clipboardContent, 'text/html')) {\n          e.preventDefault();\n          insertClipboardContent(editor, clipboardContent, clipboardContent['text/html'], plainTextMode, true);\n        } else if (hasContentType(clipboardContent, 'text/plain') && hasContentType(clipboardContent, 'text/uri-list')) {\n          e.preventDefault();\n          insertClipboardContent(editor, clipboardContent, clipboardContent['text/plain'], plainTextMode, true);\n        } else {\n          pasteBin.create();\n          Delay.setEditorTimeout(editor, () => {\n            const html = pasteBin.getHtml();\n            pasteBin.remove();\n            insertClipboardContent(editor, clipboardContent, html, plainTextMode, false);\n          }, 0);\n        }\n      });\n    };\n    const registerDataImageFilter = editor => {\n      const isWebKitFakeUrl = src => startsWith(src, 'webkit-fake-url');\n      const isDataUri = src => startsWith(src, 'data:');\n      const isPasteInsert = args => {\n        var _a;\n        return ((_a = args.data) === null || _a === void 0 ? void 0 : _a.paste) === true;\n      };\n      editor.parser.addNodeFilter('img', (nodes, name, args) => {\n        if (!shouldPasteDataImages(editor) && isPasteInsert(args)) {\n          for (const node of nodes) {\n            const src = node.attr('src');\n            if (isString(src) && !node.attr('data-mce-object') && src !== Env.transparentSrc) {\n              if (isWebKitFakeUrl(src)) {\n                node.remove();\n              } else if (!shouldAllowHtmlDataUrls(editor) && isDataUri(src)) {\n                node.remove();\n              }\n            }\n          }\n        }\n      });\n    };\n    const registerEventsAndFilters = (editor, pasteBin, pasteFormat) => {\n      registerEventHandlers(editor, pasteBin, pasteFormat);\n      registerDataImageFilter(editor);\n    };\n\n    const togglePlainTextPaste = (editor, pasteFormat) => {\n      if (pasteFormat.get() === 'text') {\n        pasteFormat.set('html');\n        firePastePlainTextToggle(editor, false);\n      } else {\n        pasteFormat.set('text');\n        firePastePlainTextToggle(editor, true);\n      }\n      editor.focus();\n    };\n    const register$1 = (editor, pasteFormat) => {\n      editor.addCommand('mceTogglePlainTextPaste', () => {\n        togglePlainTextPaste(editor, pasteFormat);\n      });\n      editor.addCommand('mceInsertClipboardContent', (ui, value) => {\n        if (value.html) {\n          pasteHtml(editor, value.html, value.internal, false);\n        }\n        if (value.text) {\n          pasteText(editor, value.text, false);\n        }\n      });\n    };\n\n    const setHtml5Clipboard = (clipboardData, html, text) => {\n      if (clipboardData) {\n        try {\n          clipboardData.clearData();\n          clipboardData.setData('text/html', html);\n          clipboardData.setData('text/plain', text);\n          clipboardData.setData(internalHtmlMime(), html);\n          return true;\n        } catch (e) {\n          return false;\n        }\n      } else {\n        return false;\n      }\n    };\n    const setClipboardData = (evt, data, fallback, done) => {\n      if (setHtml5Clipboard(evt.clipboardData, data.html, data.text)) {\n        evt.preventDefault();\n        done();\n      } else {\n        fallback(data.html, done);\n      }\n    };\n    const fallback = editor => (html, done) => {\n      const {dom, selection} = editor;\n      const outer = dom.create('div', {\n        'contenteditable': 'false',\n        'data-mce-bogus': 'all'\n      });\n      const inner = dom.create('div', { contenteditable: 'true' }, html);\n      dom.setStyles(outer, {\n        position: 'fixed',\n        top: '0',\n        left: '-3000px',\n        width: '1000px',\n        overflow: 'hidden'\n      });\n      outer.appendChild(inner);\n      dom.add(editor.getBody(), outer);\n      const range = selection.getRng();\n      inner.focus();\n      const offscreenRange = dom.createRng();\n      offscreenRange.selectNodeContents(inner);\n      selection.setRng(offscreenRange);\n      Delay.setEditorTimeout(editor, () => {\n        selection.setRng(range);\n        dom.remove(outer);\n        done();\n      }, 0);\n    };\n    const getData = editor => ({\n      html: mark(editor.selection.getContent({ contextual: true })),\n      text: editor.selection.getContent({ format: 'text' })\n    });\n    const isTableSelection = editor => !!editor.dom.getParent(editor.selection.getStart(), 'td[data-mce-selected],th[data-mce-selected]', editor.getBody());\n    const hasSelectedContent = editor => !editor.selection.isCollapsed() || isTableSelection(editor);\n    const cut = editor => evt => {\n      if (!evt.isDefaultPrevented() && hasSelectedContent(editor) && editor.selection.isEditable()) {\n        setClipboardData(evt, getData(editor), fallback(editor), () => {\n          if (Env.browser.isChromium() || Env.browser.isFirefox()) {\n            const rng = editor.selection.getRng();\n            Delay.setEditorTimeout(editor, () => {\n              editor.selection.setRng(rng);\n              editor.execCommand('Delete');\n            }, 0);\n          } else {\n            editor.execCommand('Delete');\n          }\n        });\n      }\n    };\n    const copy = editor => evt => {\n      if (!evt.isDefaultPrevented() && hasSelectedContent(editor)) {\n        setClipboardData(evt, getData(editor), fallback(editor), noop);\n      }\n    };\n    const register = editor => {\n      editor.on('cut', cut(editor));\n      editor.on('copy', copy(editor));\n    };\n\n    const getCaretRangeFromEvent = (editor, e) => {\n      var _a, _b;\n      return RangeUtils.getCaretRangeFromPoint((_a = e.clientX) !== null && _a !== void 0 ? _a : 0, (_b = e.clientY) !== null && _b !== void 0 ? _b : 0, editor.getDoc());\n    };\n    const isPlainTextFileUrl = content => {\n      const plainTextContent = content['text/plain'];\n      return plainTextContent ? plainTextContent.indexOf('file://') === 0 : false;\n    };\n    const setFocusedRange = (editor, rng) => {\n      editor.focus();\n      if (rng) {\n        editor.selection.setRng(rng);\n      }\n    };\n    const hasImage = dataTransfer => exists(dataTransfer.files, file => /^image\\//.test(file.type));\n    const needsCustomInternalDrop = (dom, schema, target, dropContent) => {\n      const parentTransparent = dom.getParent(target, node => isTransparentBlock(schema, node));\n      const inSummary = !isNull(dom.getParent(target, 'summary'));\n      if (inSummary) {\n        return true;\n      } else if (parentTransparent && has$2(dropContent, 'text/html')) {\n        const fragment = new DOMParser().parseFromString(dropContent['text/html'], 'text/html').body;\n        return !isNull(fragment.querySelector(parentTransparent.nodeName.toLowerCase()));\n      } else {\n        return false;\n      }\n    };\n    const setupSummaryDeleteByDragFix = editor => {\n      editor.on('input', e => {\n        const hasNoSummary = el => isNull(el.querySelector('summary'));\n        if (e.inputType === 'deleteByDrag') {\n          const brokenDetailElements = filter$5(editor.dom.select('details'), hasNoSummary);\n          each$e(brokenDetailElements, details => {\n            if (isBr$6(details.firstChild)) {\n              details.firstChild.remove();\n            }\n            const summary = editor.dom.create('summary');\n            summary.appendChild(createPaddingBr().dom);\n            details.prepend(summary);\n          });\n        }\n      });\n    };\n    const setup$a = (editor, draggingInternallyState) => {\n      if (shouldPasteBlockDrop(editor)) {\n        editor.on('dragend dragover draggesture dragdrop drop drag', e => {\n          e.preventDefault();\n          e.stopPropagation();\n        });\n      }\n      if (!shouldPasteDataImages(editor)) {\n        editor.on('drop', e => {\n          const dataTransfer = e.dataTransfer;\n          if (dataTransfer && hasImage(dataTransfer)) {\n            e.preventDefault();\n          }\n        });\n      }\n      editor.on('drop', e => {\n        if (e.isDefaultPrevented()) {\n          return;\n        }\n        const rng = getCaretRangeFromEvent(editor, e);\n        if (isNullable(rng)) {\n          return;\n        }\n        const dropContent = getDataTransferItems(e.dataTransfer);\n        const internal = hasContentType(dropContent, internalHtmlMime());\n        if ((!hasHtmlOrText(dropContent) || isPlainTextFileUrl(dropContent)) && pasteImageData(editor, e, rng)) {\n          return;\n        }\n        const internalContent = dropContent[internalHtmlMime()];\n        const content = internalContent || dropContent['text/html'] || dropContent['text/plain'];\n        const needsInternalDrop = needsCustomInternalDrop(editor.dom, editor.schema, rng.startContainer, dropContent);\n        const isInternalDrop = draggingInternallyState.get();\n        if (isInternalDrop && !needsInternalDrop) {\n          return;\n        }\n        if (content) {\n          e.preventDefault();\n          Delay.setEditorTimeout(editor, () => {\n            editor.undoManager.transact(() => {\n              if (internalContent || isInternalDrop && needsInternalDrop) {\n                editor.execCommand('Delete');\n              }\n              setFocusedRange(editor, rng);\n              const trimmedContent = trimHtml(content);\n              if (dropContent['text/html']) {\n                pasteHtml(editor, trimmedContent, internal, true);\n              } else {\n                pasteText(editor, trimmedContent, true);\n              }\n            });\n          });\n        }\n      });\n      editor.on('dragstart', _e => {\n        draggingInternallyState.set(true);\n      });\n      editor.on('dragover dragend', e => {\n        if (shouldPasteDataImages(editor) && !draggingInternallyState.get()) {\n          e.preventDefault();\n          setFocusedRange(editor, getCaretRangeFromEvent(editor, e));\n        }\n        if (e.type === 'dragend') {\n          draggingInternallyState.set(false);\n        }\n      });\n      setupSummaryDeleteByDragFix(editor);\n    };\n\n    const setup$9 = editor => {\n      const processEvent = f => e => {\n        f(editor, e);\n      };\n      const preProcess = getPastePreProcess(editor);\n      if (isFunction(preProcess)) {\n        editor.on('PastePreProcess', processEvent(preProcess));\n      }\n      const postProcess = getPastePostProcess(editor);\n      if (isFunction(postProcess)) {\n        editor.on('PastePostProcess', processEvent(postProcess));\n      }\n    };\n\n    const addPreProcessFilter = (editor, filterFunc) => {\n      editor.on('PastePreProcess', e => {\n        e.content = filterFunc(editor, e.content, e.internal);\n      });\n    };\n    const rgbRegExp = /rgb\\s*\\(\\s*([0-9]+)\\s*,\\s*([0-9]+)\\s*,\\s*([0-9]+)\\s*\\)/gi;\n    const rgbToHex = value => Tools.trim(value).replace(rgbRegExp, rgbaToHexString).toLowerCase();\n    const removeWebKitStyles = (editor, content, internal) => {\n      const webKitStylesOption = getPasteWebkitStyles(editor);\n      if (internal || webKitStylesOption === 'all' || !shouldPasteRemoveWebKitStyles(editor)) {\n        return content;\n      }\n      const webKitStyles = webKitStylesOption ? webKitStylesOption.split(/[, ]/) : [];\n      if (webKitStyles && webKitStylesOption !== 'none') {\n        const dom = editor.dom, node = editor.selection.getNode();\n        content = content.replace(/(<[^>]+) style=\"([^\"]*)\"([^>]*>)/gi, (all, before, value, after) => {\n          const inputStyles = dom.parseStyle(dom.decode(value));\n          const outputStyles = {};\n          for (let i = 0; i < webKitStyles.length; i++) {\n            const inputValue = inputStyles[webKitStyles[i]];\n            let compareInput = inputValue;\n            let currentValue = dom.getStyle(node, webKitStyles[i], true);\n            if (/color/.test(webKitStyles[i])) {\n              compareInput = rgbToHex(compareInput);\n              currentValue = rgbToHex(currentValue);\n            }\n            if (currentValue !== compareInput) {\n              outputStyles[webKitStyles[i]] = inputValue;\n            }\n          }\n          const outputStyle = dom.serializeStyle(outputStyles, 'span');\n          if (outputStyle) {\n            return before + ' style=\"' + outputStyle + '\"' + after;\n          }\n          return before + after;\n        });\n      } else {\n        content = content.replace(/(<[^>]+) style=\"([^\"]*)\"([^>]*>)/gi, '$1$3');\n      }\n      content = content.replace(/(<[^>]+) data-mce-style=\"([^\"]+)\"([^>]*>)/gi, (all, before, value, after) => {\n        return before + ' style=\"' + value + '\"' + after;\n      });\n      return content;\n    };\n    const setup$8 = editor => {\n      if (Env.browser.isChromium() || Env.browser.isSafari()) {\n        addPreProcessFilter(editor, removeWebKitStyles);\n      }\n    };\n\n    const setup$7 = editor => {\n      const draggingInternallyState = Cell(false);\n      const pasteFormat = Cell(isPasteAsTextEnabled(editor) ? 'text' : 'html');\n      const pasteBin = PasteBin(editor);\n      setup$8(editor);\n      register$1(editor, pasteFormat);\n      setup$9(editor);\n      editor.addQueryStateHandler('mceTogglePlainTextPaste', () => pasteFormat.get() === 'text');\n      editor.on('PreInit', () => {\n        register(editor);\n        setup$a(editor, draggingInternallyState);\n        registerEventsAndFilters(editor, pasteBin, pasteFormat);\n      });\n    };\n\n    const preventSummaryToggle = editor => {\n      editor.on('click', e => {\n        if (editor.dom.getParent(e.target, 'details')) {\n          e.preventDefault();\n        }\n      });\n    };\n    const filterDetails = editor => {\n      editor.parser.addNodeFilter('details', elms => {\n        const initialStateOption = getDetailsInitialState(editor);\n        each$e(elms, details => {\n          if (initialStateOption === 'expanded') {\n            details.attr('open', 'open');\n          } else if (initialStateOption === 'collapsed') {\n            details.attr('open', null);\n          }\n        });\n      });\n      editor.serializer.addNodeFilter('details', elms => {\n        const serializedStateOption = getDetailsSerializedState(editor);\n        each$e(elms, details => {\n          if (serializedStateOption === 'expanded') {\n            details.attr('open', 'open');\n          } else if (serializedStateOption === 'collapsed') {\n            details.attr('open', null);\n          }\n        });\n      });\n    };\n    const setup$6 = editor => {\n      preventSummaryToggle(editor);\n      filterDetails(editor);\n    };\n\n    const isBr = isBr$6;\n    const isText = isText$b;\n    const isContentEditableFalse$2 = elm => isContentEditableFalse$b(elm.dom);\n    const isContentEditableTrue = elm => isContentEditableTrue$3(elm.dom);\n    const isRoot = rootNode => elm => eq(SugarElement.fromDom(rootNode), elm);\n    const getClosestScope = (node, rootNode, schema) => closest$4(SugarElement.fromDom(node), elm => isContentEditableTrue(elm) || schema.isBlock(name(elm)), isRoot(rootNode)).getOr(SugarElement.fromDom(rootNode)).dom;\n    const getClosestCef = (node, rootNode) => closest$4(SugarElement.fromDom(node), isContentEditableFalse$2, isRoot(rootNode));\n    const findEdgeCaretCandidate = (startNode, scope, forward) => {\n      const walker = new DomTreeWalker(startNode, scope);\n      const next = forward ? walker.next.bind(walker) : walker.prev.bind(walker);\n      let result = startNode;\n      for (let current = forward ? startNode : next(); current && !isBr(current); current = next()) {\n        if (isCaretCandidate$3(current)) {\n          result = current;\n        }\n      }\n      return result;\n    };\n    const findClosestBlockRange = (startRng, rootNode, schema) => {\n      const startPos = CaretPosition.fromRangeStart(startRng);\n      const clickNode = startPos.getNode();\n      const scope = getClosestScope(clickNode, rootNode, schema);\n      const startNode = findEdgeCaretCandidate(clickNode, scope, false);\n      const endNode = findEdgeCaretCandidate(clickNode, scope, true);\n      const rng = document.createRange();\n      getClosestCef(startNode, scope).fold(() => {\n        if (isText(startNode)) {\n          rng.setStart(startNode, 0);\n        } else {\n          rng.setStartBefore(startNode);\n        }\n      }, cef => rng.setStartBefore(cef.dom));\n      getClosestCef(endNode, scope).fold(() => {\n        if (isText(endNode)) {\n          rng.setEnd(endNode, endNode.data.length);\n        } else {\n          rng.setEndAfter(endNode);\n        }\n      }, cef => rng.setEndAfter(cef.dom));\n      return rng;\n    };\n    const onTripleClickSelect = editor => {\n      const rng = findClosestBlockRange(editor.selection.getRng(), editor.getBody(), editor.schema);\n      editor.selection.setRng(normalize(rng));\n    };\n    const setup$5 = editor => {\n      editor.on('mousedown', e => {\n        if (e.detail >= 3) {\n          e.preventDefault();\n          onTripleClickSelect(editor);\n        }\n      });\n    };\n\n    var FakeCaretPosition;\n    (function (FakeCaretPosition) {\n      FakeCaretPosition['Before'] = 'before';\n      FakeCaretPosition['After'] = 'after';\n    }(FakeCaretPosition || (FakeCaretPosition = {})));\n    const distanceToRectLeft = (clientRect, clientX) => Math.abs(clientRect.left - clientX);\n    const distanceToRectRight = (clientRect, clientX) => Math.abs(clientRect.right - clientX);\n    const isInsideY = (clientY, clientRect) => clientY >= clientRect.top && clientY <= clientRect.bottom;\n    const collidesY = (r1, r2) => r1.top < r2.bottom && r1.bottom > r2.top;\n    const isOverlapping = (r1, r2) => {\n      const overlap = overlapY(r1, r2) / Math.min(r1.height, r2.height);\n      return collidesY(r1, r2) && overlap > 0.5;\n    };\n    const splitRectsPerAxis = (rects, y) => {\n      const intersectingRects = filter$5(rects, rect => isInsideY(y, rect));\n      return boundingClientRectFromRects(intersectingRects).fold(() => [\n        [],\n        rects\n      ], boundingRect => {\n        const {\n          pass: horizontal,\n          fail: vertical\n        } = partition$2(rects, rect => isOverlapping(rect, boundingRect));\n        return [\n          horizontal,\n          vertical\n        ];\n      });\n    };\n    const clientInfo = (rect, clientX) => {\n      return {\n        node: rect.node,\n        position: distanceToRectLeft(rect, clientX) < distanceToRectRight(rect, clientX) ? FakeCaretPosition.Before : FakeCaretPosition.After\n      };\n    };\n    const horizontalDistance = (rect, x, _y) => x > rect.left && x < rect.right ? 0 : Math.min(Math.abs(rect.left - x), Math.abs(rect.right - x));\n    const closestChildCaretCandidateNodeRect = (children, clientX, clientY, findCloserTextNode) => {\n      const caretCandidateRect = rect => {\n        if (isCaretCandidate$3(rect.node)) {\n          return Optional.some(rect);\n        } else if (isElement$6(rect.node)) {\n          return closestChildCaretCandidateNodeRect(from(rect.node.childNodes), clientX, clientY, false);\n        } else {\n          return Optional.none();\n        }\n      };\n      const tryFindSecondBestTextNode = (closest, sndClosest, distance) => {\n        return caretCandidateRect(sndClosest).filter(rect => {\n          const deltaDistance = Math.abs(distance(closest, clientX, clientY) - distance(rect, clientX, clientY));\n          return deltaDistance < 2 && isText$b(rect.node);\n        });\n      };\n      const findClosestCaretCandidateNodeRect = (rects, distance) => {\n        const sortedRects = sort(rects, (r1, r2) => distance(r1, clientX, clientY) - distance(r2, clientX, clientY));\n        return findMap(sortedRects, caretCandidateRect).map(closest => {\n          if (findCloserTextNode && !isText$b(closest.node) && sortedRects.length > 1) {\n            return tryFindSecondBestTextNode(closest, sortedRects[1], distance).getOr(closest);\n          } else {\n            return closest;\n          }\n        });\n      };\n      const [horizontalRects, verticalRects] = splitRectsPerAxis(getClientRects(children), clientY);\n      const {\n        pass: above,\n        fail: below\n      } = partition$2(verticalRects, rect => rect.top < clientY);\n      return findClosestCaretCandidateNodeRect(horizontalRects, horizontalDistance).orThunk(() => findClosestCaretCandidateNodeRect(below, distanceToRectEdgeFromXY)).orThunk(() => findClosestCaretCandidateNodeRect(above, distanceToRectEdgeFromXY));\n    };\n    const traverseUp = (rootElm, scope, clientX, clientY) => {\n      const helper = (scope, prevScope) => {\n        const isDragGhostContainer = node => isElement$6(node) && node.classList.contains('mce-drag-container');\n        const childNodesWithoutGhost = filter$5(scope.dom.childNodes, not(isDragGhostContainer));\n        return prevScope.fold(() => closestChildCaretCandidateNodeRect(childNodesWithoutGhost, clientX, clientY, true), prevScope => {\n          const uncheckedChildren = filter$5(childNodesWithoutGhost, node => node !== prevScope.dom);\n          return closestChildCaretCandidateNodeRect(uncheckedChildren, clientX, clientY, true);\n        }).orThunk(() => {\n          const parent = eq(scope, rootElm) ? Optional.none() : parentElement(scope);\n          return parent.bind(newScope => helper(newScope, Optional.some(scope)));\n        });\n      };\n      return helper(scope, Optional.none());\n    };\n    const closestCaretCandidateNodeRect = (root, clientX, clientY) => {\n      const rootElm = SugarElement.fromDom(root);\n      const ownerDoc = documentOrOwner(rootElm);\n      const elementAtPoint = SugarElement.fromPoint(ownerDoc, clientX, clientY).filter(elm => contains(rootElm, elm));\n      const element = elementAtPoint.getOr(rootElm);\n      return traverseUp(rootElm, element, clientX, clientY);\n    };\n    const closestFakeCaretCandidate = (root, clientX, clientY) => closestCaretCandidateNodeRect(root, clientX, clientY).filter(rect => isFakeCaretTarget(rect.node)).map(rect => clientInfo(rect, clientX));\n\n    const getAbsolutePosition = elm => {\n      var _a, _b;\n      const clientRect = elm.getBoundingClientRect();\n      const doc = elm.ownerDocument;\n      const docElem = doc.documentElement;\n      const win = doc.defaultView;\n      return {\n        top: clientRect.top + ((_a = win === null || win === void 0 ? void 0 : win.scrollY) !== null && _a !== void 0 ? _a : 0) - docElem.clientTop,\n        left: clientRect.left + ((_b = win === null || win === void 0 ? void 0 : win.scrollX) !== null && _b !== void 0 ? _b : 0) - docElem.clientLeft\n      };\n    };\n    const getBodyPosition = editor => editor.inline ? getAbsolutePosition(editor.getBody()) : {\n      left: 0,\n      top: 0\n    };\n    const getScrollPosition = editor => {\n      const body = editor.getBody();\n      return editor.inline ? {\n        left: body.scrollLeft,\n        top: body.scrollTop\n      } : {\n        left: 0,\n        top: 0\n      };\n    };\n    const getBodyScroll = editor => {\n      const body = editor.getBody(), docElm = editor.getDoc().documentElement;\n      const inlineScroll = {\n        left: body.scrollLeft,\n        top: body.scrollTop\n      };\n      const iframeScroll = {\n        left: body.scrollLeft || docElm.scrollLeft,\n        top: body.scrollTop || docElm.scrollTop\n      };\n      return editor.inline ? inlineScroll : iframeScroll;\n    };\n    const getMousePosition = (editor, event) => {\n      if (event.target.ownerDocument !== editor.getDoc()) {\n        const iframePosition = getAbsolutePosition(editor.getContentAreaContainer());\n        const scrollPosition = getBodyScroll(editor);\n        return {\n          left: event.pageX - iframePosition.left + scrollPosition.left,\n          top: event.pageY - iframePosition.top + scrollPosition.top\n        };\n      }\n      return {\n        left: event.pageX,\n        top: event.pageY\n      };\n    };\n    const calculatePosition = (bodyPosition, scrollPosition, mousePosition) => ({\n      pageX: mousePosition.left - bodyPosition.left + scrollPosition.left,\n      pageY: mousePosition.top - bodyPosition.top + scrollPosition.top\n    });\n    const calc = (editor, event) => calculatePosition(getBodyPosition(editor), getScrollPosition(editor), getMousePosition(editor, event));\n\n    const getTargetProps = target => ({\n      target,\n      srcElement: target\n    });\n    const makeDndEventFromMouseEvent = (type, mouseEvent, target, dataTransfer) => ({\n      ...mouseEvent,\n      dataTransfer,\n      type,\n      ...getTargetProps(target)\n    });\n    const makeDndEvent = (type, target, dataTransfer) => {\n      const fail = die('Function not supported on simulated event.');\n      const event = {\n        bubbles: true,\n        cancelBubble: false,\n        cancelable: true,\n        composed: false,\n        currentTarget: null,\n        defaultPrevented: false,\n        eventPhase: 0,\n        isTrusted: true,\n        returnValue: false,\n        timeStamp: 0,\n        type,\n        composedPath: fail,\n        initEvent: fail,\n        preventDefault: noop,\n        stopImmediatePropagation: noop,\n        stopPropagation: noop,\n        AT_TARGET: window.Event.AT_TARGET,\n        BUBBLING_PHASE: window.Event.BUBBLING_PHASE,\n        CAPTURING_PHASE: window.Event.CAPTURING_PHASE,\n        NONE: window.Event.NONE,\n        altKey: false,\n        button: 0,\n        buttons: 0,\n        clientX: 0,\n        clientY: 0,\n        ctrlKey: false,\n        metaKey: false,\n        movementX: 0,\n        movementY: 0,\n        offsetX: 0,\n        offsetY: 0,\n        pageX: 0,\n        pageY: 0,\n        relatedTarget: null,\n        screenX: 0,\n        screenY: 0,\n        shiftKey: false,\n        x: 0,\n        y: 0,\n        detail: 0,\n        view: null,\n        which: 0,\n        initUIEvent: fail,\n        initMouseEvent: fail,\n        getModifierState: fail,\n        dataTransfer,\n        ...getTargetProps(target)\n      };\n      return event;\n    };\n    const makeDataTransferCopyForDragEvent = (dataTransfer, eventType) => {\n      const copy = cloneDataTransfer(dataTransfer);\n      if (eventType === 'dragstart') {\n        setDragstartEvent(copy);\n        setReadWriteMode(copy);\n      } else if (eventType === 'drop') {\n        setDropEvent(copy);\n        setReadOnlyMode(copy);\n      } else {\n        setDragendEvent(copy);\n        setProtectedMode(copy);\n      }\n      return copy;\n    };\n    const makeDragEvent = (type, target, dataTransfer, mouseEvent) => {\n      const dataTransferForDispatch = makeDataTransferCopyForDragEvent(dataTransfer, type);\n      return isUndefined(mouseEvent) ? makeDndEvent(type, target, dataTransferForDispatch) : makeDndEventFromMouseEvent(type, mouseEvent, target, dataTransferForDispatch);\n    };\n\n    const scrollPixelsPerInterval = 32;\n    const scrollIntervalValue = 100;\n    const mouseRangeToTriggerScrollInsideEditor = 8;\n    const mouseRangeToTriggerScrollOutsideEditor = 16;\n    const isContentEditableFalse$1 = isContentEditableFalse$b;\n    const isContentEditable = or(isContentEditableFalse$1, isContentEditableTrue$3);\n    const isDraggable = (dom, rootElm, elm) => isContentEditableFalse$1(elm) && elm !== rootElm && dom.isEditable(elm.parentElement);\n    const isValidDropTarget = (editor, targetElement, dragElement) => {\n      if (isNullable(targetElement)) {\n        return false;\n      } else if (targetElement === dragElement || editor.dom.isChildOf(targetElement, dragElement)) {\n        return false;\n      } else {\n        return editor.dom.isEditable(targetElement);\n      }\n    };\n    const createGhost = (editor, elm, width, height) => {\n      const dom = editor.dom;\n      const clonedElm = elm.cloneNode(true);\n      dom.setStyles(clonedElm, {\n        width,\n        height\n      });\n      dom.setAttrib(clonedElm, 'data-mce-selected', null);\n      const ghostElm = dom.create('div', {\n        'class': 'mce-drag-container',\n        'data-mce-bogus': 'all',\n        'unselectable': 'on',\n        'contenteditable': 'false'\n      });\n      dom.setStyles(ghostElm, {\n        position: 'absolute',\n        opacity: 0.5,\n        overflow: 'hidden',\n        border: 0,\n        padding: 0,\n        margin: 0,\n        width,\n        height\n      });\n      dom.setStyles(clonedElm, {\n        margin: 0,\n        boxSizing: 'border-box'\n      });\n      ghostElm.appendChild(clonedElm);\n      return ghostElm;\n    };\n    const appendGhostToBody = (ghostElm, bodyElm) => {\n      if (ghostElm.parentNode !== bodyElm) {\n        bodyElm.appendChild(ghostElm);\n      }\n    };\n    const scrollEditor = (direction, amount) => win => () => {\n      const current = direction === 'left' ? win.scrollX : win.scrollY;\n      win.scroll({\n        [direction]: current + amount,\n        behavior: 'smooth'\n      });\n    };\n    const scrollLeft = scrollEditor('left', -scrollPixelsPerInterval);\n    const scrollRight = scrollEditor('left', scrollPixelsPerInterval);\n    const scrollUp = scrollEditor('top', -scrollPixelsPerInterval);\n    const scrollDown = scrollEditor('top', scrollPixelsPerInterval);\n    const moveGhost = (ghostElm, position, width, height, maxX, maxY, mouseY, mouseX, contentAreaContainer, win, state, mouseEventOriginatedFromWithinTheEditor) => {\n      let overflowX = 0, overflowY = 0;\n      ghostElm.style.left = position.pageX + 'px';\n      ghostElm.style.top = position.pageY + 'px';\n      if (position.pageX + width > maxX) {\n        overflowX = position.pageX + width - maxX;\n      }\n      if (position.pageY + height > maxY) {\n        overflowY = position.pageY + height - maxY;\n      }\n      ghostElm.style.width = width - overflowX + 'px';\n      ghostElm.style.height = height - overflowY + 'px';\n      const clientHeight = contentAreaContainer.clientHeight;\n      const clientWidth = contentAreaContainer.clientWidth;\n      const outerMouseY = mouseY + contentAreaContainer.getBoundingClientRect().top;\n      const outerMouseX = mouseX + contentAreaContainer.getBoundingClientRect().left;\n      state.on(state => {\n        state.intervalId.clear();\n        if (state.dragging && mouseEventOriginatedFromWithinTheEditor) {\n          if (mouseY + mouseRangeToTriggerScrollInsideEditor >= clientHeight) {\n            state.intervalId.set(scrollDown(win));\n          } else if (mouseY - mouseRangeToTriggerScrollInsideEditor <= 0) {\n            state.intervalId.set(scrollUp(win));\n          } else if (mouseX + mouseRangeToTriggerScrollInsideEditor >= clientWidth) {\n            state.intervalId.set(scrollRight(win));\n          } else if (mouseX - mouseRangeToTriggerScrollInsideEditor <= 0) {\n            state.intervalId.set(scrollLeft(win));\n          } else if (outerMouseY + mouseRangeToTriggerScrollOutsideEditor >= window.innerHeight) {\n            state.intervalId.set(scrollDown(window));\n          } else if (outerMouseY - mouseRangeToTriggerScrollOutsideEditor <= 0) {\n            state.intervalId.set(scrollUp(window));\n          } else if (outerMouseX + mouseRangeToTriggerScrollOutsideEditor >= window.innerWidth) {\n            state.intervalId.set(scrollRight(window));\n          } else if (outerMouseX - mouseRangeToTriggerScrollOutsideEditor <= 0) {\n            state.intervalId.set(scrollLeft(window));\n          }\n        }\n      });\n    };\n    const removeElement = elm => {\n      if (elm && elm.parentNode) {\n        elm.parentNode.removeChild(elm);\n      }\n    };\n    const removeElementWithPadding = (dom, elm) => {\n      const parentBlock = dom.getParent(elm.parentNode, dom.isBlock);\n      removeElement(elm);\n      if (parentBlock && parentBlock !== dom.getRoot() && dom.isEmpty(parentBlock)) {\n        fillWithPaddingBr(SugarElement.fromDom(parentBlock));\n      }\n    };\n    const isLeftMouseButtonPressed = e => e.button === 0;\n    const applyRelPos = (state, position) => ({\n      pageX: position.pageX - state.relX,\n      pageY: position.pageY + 5\n    });\n    const start = (state, editor) => e => {\n      if (isLeftMouseButtonPressed(e)) {\n        const ceElm = find$2(editor.dom.getParents(e.target), isContentEditable).getOr(null);\n        if (isNonNullable(ceElm) && isDraggable(editor.dom, editor.getBody(), ceElm)) {\n          const elmPos = editor.dom.getPos(ceElm);\n          const bodyElm = editor.getBody();\n          const docElm = editor.getDoc().documentElement;\n          state.set({\n            element: ceElm,\n            dataTransfer: createDataTransfer(),\n            dragging: false,\n            screenX: e.screenX,\n            screenY: e.screenY,\n            maxX: (editor.inline ? bodyElm.scrollWidth : docElm.offsetWidth) - 2,\n            maxY: (editor.inline ? bodyElm.scrollHeight : docElm.offsetHeight) - 2,\n            relX: e.pageX - elmPos.x,\n            relY: e.pageY - elmPos.y,\n            width: ceElm.offsetWidth,\n            height: ceElm.offsetHeight,\n            ghost: createGhost(editor, ceElm, ceElm.offsetWidth, ceElm.offsetHeight),\n            intervalId: repeatable(scrollIntervalValue)\n          });\n        }\n      }\n    };\n    const placeCaretAt = (editor, clientX, clientY) => {\n      editor._selectionOverrides.hideFakeCaret();\n      closestFakeCaretCandidate(editor.getBody(), clientX, clientY).fold(() => editor.selection.placeCaretAt(clientX, clientY), caretInfo => {\n        const range = editor._selectionOverrides.showCaret(1, caretInfo.node, caretInfo.position === FakeCaretPosition.Before, false);\n        if (range) {\n          editor.selection.setRng(range);\n        } else {\n          editor.selection.placeCaretAt(clientX, clientY);\n        }\n      });\n    };\n    const dispatchDragEvent = (editor, type, target, dataTransfer, mouseEvent) => {\n      if (type === 'dragstart') {\n        setHtmlData(dataTransfer, editor.dom.getOuterHTML(target));\n      }\n      const event = makeDragEvent(type, target, dataTransfer, mouseEvent);\n      const args = editor.dispatch(type, event);\n      return args;\n    };\n    const move = (state, editor) => {\n      const throttledPlaceCaretAt = first$1((clientX, clientY) => placeCaretAt(editor, clientX, clientY), 0);\n      editor.on('remove', throttledPlaceCaretAt.cancel);\n      const state_ = state;\n      return e => state.on(state => {\n        const movement = Math.max(Math.abs(e.screenX - state.screenX), Math.abs(e.screenY - state.screenY));\n        if (!state.dragging && movement > 10) {\n          const args = dispatchDragEvent(editor, 'dragstart', state.element, state.dataTransfer, e);\n          if (isNonNullable(args.dataTransfer)) {\n            state.dataTransfer = args.dataTransfer;\n          }\n          if (args.isDefaultPrevented()) {\n            return;\n          }\n          state.dragging = true;\n          editor.focus();\n        }\n        if (state.dragging) {\n          const mouseEventOriginatedFromWithinTheEditor = e.currentTarget === editor.getDoc().documentElement;\n          const targetPos = applyRelPos(state, calc(editor, e));\n          appendGhostToBody(state.ghost, editor.getBody());\n          moveGhost(state.ghost, targetPos, state.width, state.height, state.maxX, state.maxY, e.clientY, e.clientX, editor.getContentAreaContainer(), editor.getWin(), state_, mouseEventOriginatedFromWithinTheEditor);\n          throttledPlaceCaretAt.throttle(e.clientX, e.clientY);\n        }\n      });\n    };\n    const getRawTarget = selection => {\n      const sel = selection.getSel();\n      if (isNonNullable(sel)) {\n        const rng = sel.getRangeAt(0);\n        const startContainer = rng.startContainer;\n        return isText$b(startContainer) ? startContainer.parentNode : startContainer;\n      } else {\n        return null;\n      }\n    };\n    const drop = (state, editor) => e => {\n      state.on(state => {\n        var _a;\n        state.intervalId.clear();\n        if (state.dragging) {\n          if (isValidDropTarget(editor, getRawTarget(editor.selection), state.element)) {\n            const dropTarget = (_a = editor.getDoc().elementFromPoint(e.clientX, e.clientY)) !== null && _a !== void 0 ? _a : editor.getBody();\n            const args = dispatchDragEvent(editor, 'drop', dropTarget, state.dataTransfer, e);\n            if (!args.isDefaultPrevented()) {\n              editor.undoManager.transact(() => {\n                removeElementWithPadding(editor.dom, state.element);\n                getHtmlData(state.dataTransfer).each(content => editor.insertContent(content));\n                editor._selectionOverrides.hideFakeCaret();\n              });\n            }\n          }\n          dispatchDragEvent(editor, 'dragend', editor.getBody(), state.dataTransfer, e);\n        }\n      });\n      removeDragState(state);\n    };\n    const stopDragging = (state, editor, e) => {\n      state.on(state => {\n        state.intervalId.clear();\n        if (state.dragging) {\n          e.fold(() => dispatchDragEvent(editor, 'dragend', state.element, state.dataTransfer), mouseEvent => dispatchDragEvent(editor, 'dragend', state.element, state.dataTransfer, mouseEvent));\n        }\n      });\n      removeDragState(state);\n    };\n    const stop = (state, editor) => e => stopDragging(state, editor, Optional.some(e));\n    const removeDragState = state => {\n      state.on(state => {\n        state.intervalId.clear();\n        removeElement(state.ghost);\n      });\n      state.clear();\n    };\n    const bindFakeDragEvents = editor => {\n      const state = value$2();\n      const pageDom = DOMUtils.DOM;\n      const rootDocument = document;\n      const dragStartHandler = start(state, editor);\n      const dragHandler = move(state, editor);\n      const dropHandler = drop(state, editor);\n      const dragEndHandler = stop(state, editor);\n      editor.on('mousedown', dragStartHandler);\n      editor.on('mousemove', dragHandler);\n      editor.on('mouseup', dropHandler);\n      pageDom.bind(rootDocument, 'mousemove', dragHandler);\n      pageDom.bind(rootDocument, 'mouseup', dragEndHandler);\n      editor.on('remove', () => {\n        pageDom.unbind(rootDocument, 'mousemove', dragHandler);\n        pageDom.unbind(rootDocument, 'mouseup', dragEndHandler);\n      });\n      editor.on('keydown', e => {\n        if (e.keyCode === VK.ESC) {\n          stopDragging(state, editor, Optional.none());\n        }\n      });\n    };\n    const blockUnsupportedFileDrop = editor => {\n      const preventFileDrop = e => {\n        if (!e.isDefaultPrevented()) {\n          const dataTransfer = e.dataTransfer;\n          if (dataTransfer && (contains$2(dataTransfer.types, 'Files') || dataTransfer.files.length > 0)) {\n            e.preventDefault();\n            if (e.type === 'drop') {\n              displayError(editor, 'Dropped file type is not supported');\n            }\n          }\n        }\n      };\n      const preventFileDropIfUIElement = e => {\n        if (isUIElement(editor, e.target)) {\n          preventFileDrop(e);\n        }\n      };\n      const setup = () => {\n        const pageDom = DOMUtils.DOM;\n        const dom = editor.dom;\n        const doc = document;\n        const editorRoot = editor.inline ? editor.getBody() : editor.getDoc();\n        const eventNames = [\n          'drop',\n          'dragover'\n        ];\n        each$e(eventNames, name => {\n          pageDom.bind(doc, name, preventFileDropIfUIElement);\n          dom.bind(editorRoot, name, preventFileDrop);\n        });\n        editor.on('remove', () => {\n          each$e(eventNames, name => {\n            pageDom.unbind(doc, name, preventFileDropIfUIElement);\n            dom.unbind(editorRoot, name, preventFileDrop);\n          });\n        });\n      };\n      editor.on('init', () => {\n        Delay.setEditorTimeout(editor, setup, 0);\n      });\n    };\n    const init$2 = editor => {\n      bindFakeDragEvents(editor);\n      if (shouldBlockUnsupportedDrop(editor)) {\n        blockUnsupportedFileDrop(editor);\n      }\n    };\n\n    const setup$4 = editor => {\n      const renderFocusCaret = first$1(() => {\n        if (!editor.removed && editor.getBody().contains(document.activeElement)) {\n          const rng = editor.selection.getRng();\n          if (rng.collapsed) {\n            const caretRange = renderRangeCaret(editor, rng, false);\n            editor.selection.setRng(caretRange);\n          }\n        }\n      }, 0);\n      editor.on('focus', () => {\n        renderFocusCaret.throttle();\n      });\n      editor.on('blur', () => {\n        renderFocusCaret.cancel();\n      });\n    };\n\n    const setup$3 = editor => {\n      editor.on('init', () => {\n        editor.on('focusin', e => {\n          const target = e.target;\n          if (isMedia$2(target)) {\n            const ceRoot = getContentEditableRoot$1(editor.getBody(), target);\n            const node = isContentEditableFalse$b(ceRoot) ? ceRoot : target;\n            if (editor.selection.getNode() !== node) {\n              selectNode(editor, node).each(rng => editor.selection.setRng(rng));\n            }\n          }\n        });\n      });\n    };\n\n    const isContentEditableFalse = isContentEditableFalse$b;\n    const getContentEditableRoot = (editor, node) => getContentEditableRoot$1(editor.getBody(), node);\n    const SelectionOverrides = editor => {\n      const selection = editor.selection, dom = editor.dom;\n      const rootNode = editor.getBody();\n      const fakeCaret = FakeCaret(editor, rootNode, dom.isBlock, () => hasFocus(editor));\n      const realSelectionId = 'sel-' + dom.uniqueId();\n      const elementSelectionAttr = 'data-mce-selected';\n      let selectedElement;\n      const isFakeSelectionElement = node => isNonNullable(node) && dom.hasClass(node, 'mce-offscreen-selection');\n      const isFakeSelectionTargetElement = node => node !== rootNode && (isContentEditableFalse(node) || isMedia$2(node)) && dom.isChildOf(node, rootNode) && dom.isEditable(node.parentNode);\n      const setRange = range => {\n        if (range) {\n          selection.setRng(range);\n        }\n      };\n      const showCaret = (direction, node, before, scrollIntoView = true) => {\n        const e = editor.dispatch('ShowCaret', {\n          target: node,\n          direction,\n          before\n        });\n        if (e.isDefaultPrevented()) {\n          return null;\n        }\n        if (scrollIntoView) {\n          selection.scrollIntoView(node, direction === -1);\n        }\n        return fakeCaret.show(before, node);\n      };\n      const showBlockCaretContainer = blockCaretContainer => {\n        if (blockCaretContainer.hasAttribute('data-mce-caret')) {\n          showCaretContainerBlock(blockCaretContainer);\n          selection.scrollIntoView(blockCaretContainer);\n        }\n      };\n      const registerEvents = () => {\n        editor.on('click', e => {\n          if (!dom.isEditable(e.target)) {\n            e.preventDefault();\n            editor.focus();\n          }\n        });\n        editor.on('blur NewBlock', removeElementSelection);\n        editor.on('ResizeWindow FullscreenStateChanged', fakeCaret.reposition);\n        editor.on('tap', e => {\n          const targetElm = e.target;\n          const contentEditableRoot = getContentEditableRoot(editor, targetElm);\n          if (isContentEditableFalse(contentEditableRoot)) {\n            e.preventDefault();\n            selectNode(editor, contentEditableRoot).each(setElementSelection);\n          } else if (isFakeSelectionTargetElement(targetElm)) {\n            selectNode(editor, targetElm).each(setElementSelection);\n          }\n        }, true);\n        editor.on('mousedown', e => {\n          const targetElm = e.target;\n          if (targetElm !== rootNode && targetElm.nodeName !== 'HTML' && !dom.isChildOf(targetElm, rootNode)) {\n            return;\n          }\n          if (!isXYInContentArea(editor, e.clientX, e.clientY)) {\n            return;\n          }\n          removeElementSelection();\n          hideFakeCaret();\n          const closestContentEditable = getContentEditableRoot(editor, targetElm);\n          if (isContentEditableFalse(closestContentEditable)) {\n            e.preventDefault();\n            selectNode(editor, closestContentEditable).each(setElementSelection);\n          } else {\n            closestFakeCaretCandidate(rootNode, e.clientX, e.clientY).each(caretInfo => {\n              e.preventDefault();\n              const range = showCaret(1, caretInfo.node, caretInfo.position === FakeCaretPosition.Before, false);\n              setRange(range);\n              if (isHTMLElement(closestContentEditable)) {\n                closestContentEditable.focus();\n              } else {\n                editor.getBody().focus();\n              }\n            });\n          }\n        });\n        editor.on('keypress', e => {\n          if (VK.modifierPressed(e)) {\n            return;\n          }\n          if (isContentEditableFalse(selection.getNode())) {\n            e.preventDefault();\n          }\n        });\n        editor.on('GetSelectionRange', e => {\n          let rng = e.range;\n          if (selectedElement) {\n            if (!selectedElement.parentNode) {\n              selectedElement = null;\n              return;\n            }\n            rng = rng.cloneRange();\n            rng.selectNode(selectedElement);\n            e.range = rng;\n          }\n        });\n        editor.on('SetSelectionRange', e => {\n          e.range = normalizeVoidElementSelection(e.range);\n          const rng = setElementSelection(e.range, e.forward);\n          if (rng) {\n            e.range = rng;\n          }\n        });\n        const isPasteBin = node => isElement$6(node) && node.id === 'mcepastebin';\n        editor.on('AfterSetSelectionRange', e => {\n          const rng = e.range;\n          const parent = rng.startContainer.parentElement;\n          if (!isRangeInCaretContainer(rng) && !isPasteBin(parent)) {\n            hideFakeCaret();\n          }\n          if (!isFakeSelectionElement(parent)) {\n            removeElementSelection();\n          }\n        });\n        init$2(editor);\n        setup$4(editor);\n        setup$3(editor);\n      };\n      const isWithinCaretContainer = node => isCaretContainer$2(node) || startsWithCaretContainer$1(node) || endsWithCaretContainer$1(node);\n      const isRangeInCaretContainer = rng => isWithinCaretContainer(rng.startContainer) || isWithinCaretContainer(rng.endContainer);\n      const normalizeVoidElementSelection = rng => {\n        const voidElements = editor.schema.getVoidElements();\n        const newRng = dom.createRng();\n        const startContainer = rng.startContainer;\n        const startOffset = rng.startOffset;\n        const endContainer = rng.endContainer;\n        const endOffset = rng.endOffset;\n        if (has$2(voidElements, startContainer.nodeName.toLowerCase())) {\n          if (startOffset === 0) {\n            newRng.setStartBefore(startContainer);\n          } else {\n            newRng.setStartAfter(startContainer);\n          }\n        } else {\n          newRng.setStart(startContainer, startOffset);\n        }\n        if (has$2(voidElements, endContainer.nodeName.toLowerCase())) {\n          if (endOffset === 0) {\n            newRng.setEndBefore(endContainer);\n          } else {\n            newRng.setEndAfter(endContainer);\n          }\n        } else {\n          newRng.setEnd(endContainer, endOffset);\n        }\n        return newRng;\n      };\n      const setupOffscreenSelection = (node, targetClone) => {\n        const body = SugarElement.fromDom(editor.getBody());\n        const doc = editor.getDoc();\n        const realSelectionContainer = descendant$1(body, '#' + realSelectionId).getOrThunk(() => {\n          const newContainer = SugarElement.fromHtml('<div data-mce-bogus=\"all\" class=\"mce-offscreen-selection\"></div>', doc);\n          set$3(newContainer, 'id', realSelectionId);\n          append$1(body, newContainer);\n          return newContainer;\n        });\n        const newRange = dom.createRng();\n        empty(realSelectionContainer);\n        append(realSelectionContainer, [\n          SugarElement.fromText(nbsp, doc),\n          SugarElement.fromDom(targetClone),\n          SugarElement.fromText(nbsp, doc)\n        ]);\n        newRange.setStart(realSelectionContainer.dom.firstChild, 1);\n        newRange.setEnd(realSelectionContainer.dom.lastChild, 0);\n        setAll(realSelectionContainer, { top: dom.getPos(node, editor.getBody()).y + 'px' });\n        focus$1(realSelectionContainer);\n        const sel = selection.getSel();\n        if (sel) {\n          sel.removeAllRanges();\n          sel.addRange(newRange);\n        }\n        return newRange;\n      };\n      const selectElement = elm => {\n        const targetClone = elm.cloneNode(true);\n        const e = editor.dispatch('ObjectSelected', {\n          target: elm,\n          targetClone\n        });\n        if (e.isDefaultPrevented()) {\n          return null;\n        }\n        const range = setupOffscreenSelection(elm, e.targetClone);\n        const nodeElm = SugarElement.fromDom(elm);\n        each$e(descendants(SugarElement.fromDom(editor.getBody()), `*[${ elementSelectionAttr }]`), elm => {\n          if (!eq(nodeElm, elm)) {\n            remove$9(elm, elementSelectionAttr);\n          }\n        });\n        if (!dom.getAttrib(elm, elementSelectionAttr)) {\n          elm.setAttribute(elementSelectionAttr, '1');\n        }\n        selectedElement = elm;\n        hideFakeCaret();\n        return range;\n      };\n      const setElementSelection = (range, forward) => {\n        if (!range) {\n          return null;\n        }\n        if (range.collapsed) {\n          if (!isRangeInCaretContainer(range)) {\n            const dir = forward ? 1 : -1;\n            const caretPosition = getNormalizedRangeEndPoint(dir, rootNode, range);\n            const beforeNode = caretPosition.getNode(!forward);\n            if (isNonNullable(beforeNode)) {\n              if (isFakeCaretTarget(beforeNode)) {\n                return showCaret(dir, beforeNode, forward ? !caretPosition.isAtEnd() : false, false);\n              }\n              if (isCaretContainerInline(beforeNode) && isContentEditableFalse$b(beforeNode.nextSibling)) {\n                const rng = dom.createRng();\n                rng.setStart(beforeNode, 0);\n                rng.setEnd(beforeNode, 0);\n                return rng;\n              }\n            }\n            const afterNode = caretPosition.getNode(forward);\n            if (isNonNullable(afterNode)) {\n              if (isFakeCaretTarget(afterNode)) {\n                return showCaret(dir, afterNode, forward ? false : !caretPosition.isAtEnd(), false);\n              }\n              if (isCaretContainerInline(afterNode) && isContentEditableFalse$b(afterNode.previousSibling)) {\n                const rng = dom.createRng();\n                rng.setStart(afterNode, 1);\n                rng.setEnd(afterNode, 1);\n                return rng;\n              }\n            }\n          }\n          return null;\n        }\n        let startContainer = range.startContainer;\n        let startOffset = range.startOffset;\n        const endOffset = range.endOffset;\n        if (isText$b(startContainer) && startOffset === 0 && isContentEditableFalse(startContainer.parentNode)) {\n          startContainer = startContainer.parentNode;\n          startOffset = dom.nodeIndex(startContainer);\n          startContainer = startContainer.parentNode;\n        }\n        if (!isElement$6(startContainer)) {\n          return null;\n        }\n        if (endOffset === startOffset + 1 && startContainer === range.endContainer) {\n          const node = startContainer.childNodes[startOffset];\n          if (isFakeSelectionTargetElement(node)) {\n            return selectElement(node);\n          }\n        }\n        return null;\n      };\n      const removeElementSelection = () => {\n        if (selectedElement) {\n          selectedElement.removeAttribute(elementSelectionAttr);\n        }\n        descendant$1(SugarElement.fromDom(editor.getBody()), '#' + realSelectionId).each(remove$4);\n        selectedElement = null;\n      };\n      const destroy = () => {\n        fakeCaret.destroy();\n        selectedElement = null;\n      };\n      const hideFakeCaret = () => {\n        fakeCaret.hide();\n      };\n      if (!isRtc(editor)) {\n        registerEvents();\n      }\n      return {\n        showCaret,\n        showBlockCaretContainer,\n        hideFakeCaret,\n        destroy\n      };\n    };\n\n    const getNormalizedTextOffset = (container, offset) => {\n      let normalizedOffset = offset;\n      for (let node = container.previousSibling; isText$b(node); node = node.previousSibling) {\n        normalizedOffset += node.data.length;\n      }\n      return normalizedOffset;\n    };\n    const generatePath = (dom, root, node, offset, normalized) => {\n      if (isText$b(node) && (offset < 0 || offset > node.data.length)) {\n        return [];\n      }\n      const p = normalized && isText$b(node) ? [getNormalizedTextOffset(node, offset)] : [offset];\n      let current = node;\n      while (current !== root && current.parentNode) {\n        p.push(dom.nodeIndex(current, normalized));\n        current = current.parentNode;\n      }\n      return current === root ? p.reverse() : [];\n    };\n    const generatePathRange = (dom, root, startNode, startOffset, endNode, endOffset, normalized = false) => {\n      const start = generatePath(dom, root, startNode, startOffset, normalized);\n      const end = generatePath(dom, root, endNode, endOffset, normalized);\n      return {\n        start,\n        end\n      };\n    };\n    const resolvePath = (root, path) => {\n      const nodePath = path.slice();\n      const offset = nodePath.pop();\n      if (!isNumber(offset)) {\n        return Optional.none();\n      } else {\n        const resolvedNode = foldl(nodePath, (optNode, index) => optNode.bind(node => Optional.from(node.childNodes[index])), Optional.some(root));\n        return resolvedNode.bind(node => {\n          if (isText$b(node) && (offset < 0 || offset > node.data.length)) {\n            return Optional.none();\n          } else {\n            return Optional.some({\n              node,\n              offset\n            });\n          }\n        });\n      }\n    };\n    const resolvePathRange = (root, range) => resolvePath(root, range.start).bind(({\n      node: startNode,\n      offset: startOffset\n    }) => resolvePath(root, range.end).map(({\n      node: endNode,\n      offset: endOffset\n    }) => {\n      const rng = document.createRange();\n      rng.setStart(startNode, startOffset);\n      rng.setEnd(endNode, endOffset);\n      return rng;\n    }));\n    const generatePathRangeFromRange = (dom, root, range, normalized = false) => generatePathRange(dom, root, range.startContainer, range.startOffset, range.endContainer, range.endOffset, normalized);\n\n    const cleanEmptyNodes = (dom, node, isRoot) => {\n      if (node && dom.isEmpty(node) && !isRoot(node)) {\n        const parent = node.parentNode;\n        dom.remove(node, isText$b(node.firstChild) && isWhitespaceText(node.firstChild.data));\n        cleanEmptyNodes(dom, parent, isRoot);\n      }\n    };\n    const deleteRng = (dom, rng, isRoot, clean = true) => {\n      const startParent = rng.startContainer.parentNode;\n      const endParent = rng.endContainer.parentNode;\n      rng.deleteContents();\n      if (clean && !isRoot(rng.startContainer)) {\n        if (isText$b(rng.startContainer) && rng.startContainer.data.length === 0) {\n          dom.remove(rng.startContainer);\n        }\n        if (isText$b(rng.endContainer) && rng.endContainer.data.length === 0) {\n          dom.remove(rng.endContainer);\n        }\n        cleanEmptyNodes(dom, startParent, isRoot);\n        if (startParent !== endParent) {\n          cleanEmptyNodes(dom, endParent, isRoot);\n        }\n      }\n    };\n    const getParentBlock = (editor, rng) => Optional.from(editor.dom.getParent(rng.startContainer, editor.dom.isBlock));\n    const resolveFromDynamicPatterns = (patternSet, block, beforeText) => {\n      const dynamicPatterns = patternSet.dynamicPatternsLookup({\n        text: beforeText,\n        block\n      });\n      return {\n        ...patternSet,\n        blockPatterns: getBlockPatterns(dynamicPatterns).concat(patternSet.blockPatterns),\n        inlinePatterns: getInlinePatterns(dynamicPatterns).concat(patternSet.inlinePatterns)\n      };\n    };\n    const getBeforeText = (dom, block, node, offset) => {\n      const rng = dom.createRng();\n      rng.setStart(block, 0);\n      rng.setEnd(node, offset);\n      return rng.toString();\n    };\n\n    const newMarker = (dom, id) => dom.create('span', {\n      'data-mce-type': 'bookmark',\n      id\n    });\n    const rangeFromMarker = (dom, marker) => {\n      const rng = dom.createRng();\n      rng.setStartAfter(marker.start);\n      rng.setEndBefore(marker.end);\n      return rng;\n    };\n    const createMarker = (dom, markerPrefix, pathRange) => {\n      const rng = resolvePathRange(dom.getRoot(), pathRange).getOrDie('Unable to resolve path range');\n      const startNode = rng.startContainer;\n      const endNode = rng.endContainer;\n      const textEnd = rng.endOffset === 0 ? endNode : endNode.splitText(rng.endOffset);\n      const textStart = rng.startOffset === 0 ? startNode : startNode.splitText(rng.startOffset);\n      const startParentNode = textStart.parentNode;\n      const endParentNode = textEnd.parentNode;\n      return {\n        prefix: markerPrefix,\n        end: endParentNode.insertBefore(newMarker(dom, markerPrefix + '-end'), textEnd),\n        start: startParentNode.insertBefore(newMarker(dom, markerPrefix + '-start'), textStart)\n      };\n    };\n    const removeMarker = (dom, marker, isRoot) => {\n      cleanEmptyNodes(dom, dom.get(marker.prefix + '-end'), isRoot);\n      cleanEmptyNodes(dom, dom.get(marker.prefix + '-start'), isRoot);\n    };\n\n    const isReplacementPattern = pattern => pattern.start.length === 0;\n    const matchesPattern = patternContent => (element, offset) => {\n      const text = element.data;\n      const searchText = text.substring(0, offset);\n      const startEndIndex = searchText.lastIndexOf(patternContent.charAt(patternContent.length - 1));\n      const startIndex = searchText.lastIndexOf(patternContent);\n      if (startIndex !== -1) {\n        return startIndex + patternContent.length;\n      } else if (startEndIndex !== -1) {\n        return startEndIndex + 1;\n      } else {\n        return -1;\n      }\n    };\n    const findPatternStartFromSpot = (dom, pattern, block, spot) => {\n      const startPattern = pattern.start;\n      const startSpot = repeatLeft(dom, spot.container, spot.offset, matchesPattern(startPattern), block);\n      return startSpot.bind(spot => {\n        var _a, _b;\n        const startPatternIndex = (_b = (_a = block.textContent) === null || _a === void 0 ? void 0 : _a.indexOf(startPattern)) !== null && _b !== void 0 ? _b : -1;\n        const isCompleteMatch = startPatternIndex !== -1 && spot.offset >= startPatternIndex + startPattern.length;\n        if (isCompleteMatch) {\n          const rng = dom.createRng();\n          rng.setStart(spot.container, spot.offset - startPattern.length);\n          rng.setEnd(spot.container, spot.offset);\n          return Optional.some(rng);\n        } else {\n          const offset = spot.offset - startPattern.length;\n          return scanLeft(spot.container, offset, block).map(nextSpot => {\n            const rng = dom.createRng();\n            rng.setStart(nextSpot.container, nextSpot.offset);\n            rng.setEnd(spot.container, spot.offset);\n            return rng;\n          }).filter(rng => rng.toString() === startPattern).orThunk(() => findPatternStartFromSpot(dom, pattern, block, point(spot.container, 0)));\n        }\n      });\n    };\n    const findPatternStart = (dom, pattern, node, offset, block, requireGap = false) => {\n      if (pattern.start.length === 0 && !requireGap) {\n        const rng = dom.createRng();\n        rng.setStart(node, offset);\n        rng.setEnd(node, offset);\n        return Optional.some(rng);\n      }\n      return textBefore(node, offset, block).bind(spot => {\n        const start = findPatternStartFromSpot(dom, pattern, block, spot);\n        return start.bind(startRange => {\n          var _a;\n          if (requireGap) {\n            if (startRange.endContainer === spot.container && startRange.endOffset === spot.offset) {\n              return Optional.none();\n            } else if (spot.offset === 0 && ((_a = startRange.endContainer.textContent) === null || _a === void 0 ? void 0 : _a.length) === startRange.endOffset) {\n              return Optional.none();\n            }\n          }\n          return Optional.some(startRange);\n        });\n      });\n    };\n    const findPattern$3 = (editor, block, details, normalizedMatches) => {\n      const dom = editor.dom;\n      const root = dom.getRoot();\n      const pattern = details.pattern;\n      const endNode = details.position.container;\n      const endOffset = details.position.offset;\n      return scanLeft(endNode, endOffset - details.pattern.end.length, block).bind(spot => {\n        const endPathRng = generatePathRange(dom, root, spot.container, spot.offset, endNode, endOffset, normalizedMatches);\n        if (isReplacementPattern(pattern)) {\n          return Optional.some({\n            matches: [{\n                pattern,\n                startRng: endPathRng,\n                endRng: endPathRng\n              }],\n            position: spot\n          });\n        } else {\n          const resultsOpt = findPatternsRec(editor, details.remainingPatterns, spot.container, spot.offset, block, normalizedMatches);\n          const results = resultsOpt.getOr({\n            matches: [],\n            position: spot\n          });\n          const pos = results.position;\n          const start = findPatternStart(dom, pattern, pos.container, pos.offset, block, resultsOpt.isNone());\n          return start.map(startRng => {\n            const startPathRng = generatePathRangeFromRange(dom, root, startRng, normalizedMatches);\n            return {\n              matches: results.matches.concat([{\n                  pattern,\n                  startRng: startPathRng,\n                  endRng: endPathRng\n                }]),\n              position: point(startRng.startContainer, startRng.startOffset)\n            };\n          });\n        }\n      });\n    };\n    const findPatternsRec = (editor, patterns, node, offset, block, normalizedMatches) => {\n      const dom = editor.dom;\n      return textBefore(node, offset, dom.getRoot()).bind(endSpot => {\n        const text = getBeforeText(dom, block, node, offset);\n        for (let i = 0; i < patterns.length; i++) {\n          const pattern = patterns[i];\n          if (!endsWith(text, pattern.end)) {\n            continue;\n          }\n          const patternsWithoutCurrent = patterns.slice();\n          patternsWithoutCurrent.splice(i, 1);\n          const result = findPattern$3(editor, block, {\n            pattern,\n            remainingPatterns: patternsWithoutCurrent,\n            position: endSpot\n          }, normalizedMatches);\n          if (result.isNone() && offset > 0) {\n            return findPatternsRec(editor, patterns, node, offset - 1, block, normalizedMatches);\n          }\n          if (result.isSome()) {\n            return result;\n          }\n        }\n        return Optional.none();\n      });\n    };\n    const applyPattern$2 = (editor, pattern, patternRange) => {\n      editor.selection.setRng(patternRange);\n      if (pattern.type === 'inline-format') {\n        each$e(pattern.format, format => {\n          editor.formatter.apply(format);\n        });\n      } else {\n        editor.execCommand(pattern.cmd, false, pattern.value);\n      }\n    };\n    const applyReplacementPattern = (editor, pattern, marker, isRoot) => {\n      const markerRange = rangeFromMarker(editor.dom, marker);\n      deleteRng(editor.dom, markerRange, isRoot);\n      applyPattern$2(editor, pattern, markerRange);\n    };\n    const applyPatternWithContent = (editor, pattern, startMarker, endMarker, isRoot) => {\n      const dom = editor.dom;\n      const markerEndRange = rangeFromMarker(dom, endMarker);\n      const markerStartRange = rangeFromMarker(dom, startMarker);\n      deleteRng(dom, markerStartRange, isRoot);\n      deleteRng(dom, markerEndRange, isRoot);\n      const patternMarker = {\n        prefix: startMarker.prefix,\n        start: startMarker.end,\n        end: endMarker.start\n      };\n      const patternRange = rangeFromMarker(dom, patternMarker);\n      applyPattern$2(editor, pattern, patternRange);\n    };\n    const addMarkers = (dom, matches) => {\n      const markerPrefix = generate$1('mce_textpattern');\n      const matchesWithEnds = foldr(matches, (acc, match) => {\n        const endMarker = createMarker(dom, markerPrefix + `_end${ acc.length }`, match.endRng);\n        return acc.concat([{\n            ...match,\n            endMarker\n          }]);\n      }, []);\n      return foldr(matchesWithEnds, (acc, match) => {\n        const idx = matchesWithEnds.length - acc.length - 1;\n        const startMarker = isReplacementPattern(match.pattern) ? match.endMarker : createMarker(dom, markerPrefix + `_start${ idx }`, match.startRng);\n        return acc.concat([{\n            ...match,\n            startMarker\n          }]);\n      }, []);\n    };\n    const sortPatterns$1 = patterns => sort(patterns, (a, b) => b.end.length - a.end.length);\n    const getBestMatches = (matches, matchesWithSortedPatterns) => {\n      const hasSameMatches = forall(matches, match => exists(matchesWithSortedPatterns, sortedMatch => match.pattern.start === sortedMatch.pattern.start && match.pattern.end === sortedMatch.pattern.end));\n      if (matches.length === matchesWithSortedPatterns.length) {\n        if (hasSameMatches) {\n          return matches;\n        } else {\n          return matchesWithSortedPatterns;\n        }\n      }\n      return matches.length > matchesWithSortedPatterns.length ? matches : matchesWithSortedPatterns;\n    };\n    const findPatterns$2 = (editor, block, node, offset, patternSet, normalizedMatches) => {\n      const matches = findPatternsRec(editor, patternSet.inlinePatterns, node, offset, block, normalizedMatches).fold(() => [], result => result.matches);\n      const matchesWithSortedPatterns = findPatternsRec(editor, sortPatterns$1(patternSet.inlinePatterns), node, offset, block, normalizedMatches).fold(() => [], result => result.matches);\n      return getBestMatches(matches, matchesWithSortedPatterns);\n    };\n    const applyMatches$2 = (editor, matches) => {\n      if (matches.length === 0) {\n        return;\n      }\n      const dom = editor.dom;\n      const bookmark = editor.selection.getBookmark();\n      const matchesWithMarkers = addMarkers(dom, matches);\n      each$e(matchesWithMarkers, match => {\n        const block = dom.getParent(match.startMarker.start, dom.isBlock);\n        const isRoot = node => node === block;\n        if (isReplacementPattern(match.pattern)) {\n          applyReplacementPattern(editor, match.pattern, match.endMarker, isRoot);\n        } else {\n          applyPatternWithContent(editor, match.pattern, match.startMarker, match.endMarker, isRoot);\n        }\n        removeMarker(dom, match.endMarker, isRoot);\n        removeMarker(dom, match.startMarker, isRoot);\n      });\n      editor.selection.moveToBookmark(bookmark);\n    };\n\n    const stripPattern$1 = (dom, block, pattern) => {\n      return textAfter(block, 0, block).map(spot => {\n        const node = spot.container;\n        scanRight(node, pattern.start.length, block).each(end => {\n          const rng = dom.createRng();\n          rng.setStart(node, 0);\n          rng.setEnd(end.container, end.offset);\n          deleteRng(dom, rng, e => e === block);\n        });\n        return node;\n      });\n    };\n    const createApplyPattern = stripPattern => (editor, match) => {\n      const dom = editor.dom;\n      const pattern = match.pattern;\n      const rng = resolvePathRange(dom.getRoot(), match.range).getOrDie('Unable to resolve path range');\n      const isBlockFormatName = (name, formatter) => {\n        const formatSet = formatter.get(name);\n        return isArray$1(formatSet) && head(formatSet).exists(format => has$2(format, 'block'));\n      };\n      getParentBlock(editor, rng).each(block => {\n        if (pattern.type === 'block-format') {\n          if (isBlockFormatName(pattern.format, editor.formatter)) {\n            editor.undoManager.transact(() => {\n              stripPattern(editor.dom, block, pattern);\n              editor.formatter.apply(pattern.format);\n            });\n          }\n        } else if (pattern.type === 'block-command') {\n          editor.undoManager.transact(() => {\n            stripPattern(editor.dom, block, pattern);\n            editor.execCommand(pattern.cmd, false, pattern.value);\n          });\n        }\n      });\n      return true;\n    };\n    const sortPatterns = patterns => sort(patterns, (a, b) => b.start.length - a.start.length);\n    const findPattern$2 = predicate => (patterns, text) => {\n      const sortedPatterns = sortPatterns(patterns);\n      const nuText = text.replace(nbsp, ' ');\n      return find$2(sortedPatterns, pattern => predicate(pattern, text, nuText));\n    };\n    const createFindPatterns = (findPattern, skipFullMatch) => (editor, block, patternSet, normalizedMatches, text) => {\n      var _a;\n      if (text === void 0) {\n        text = (_a = block.textContent) !== null && _a !== void 0 ? _a : '';\n      }\n      const dom = editor.dom;\n      const forcedRootBlock = getForcedRootBlock(editor);\n      if (!dom.is(block, forcedRootBlock)) {\n        return [];\n      }\n      return findPattern(patternSet.blockPatterns, text).map(pattern => {\n        if (skipFullMatch && Tools.trim(text).length === pattern.start.length) {\n          return [];\n        }\n        return [{\n            pattern,\n            range: generatePathRange(dom, dom.getRoot(), block, 0, block, 0, normalizedMatches)\n          }];\n      }).getOr([]);\n    };\n\n    const startsWithSingleSpace = s => /^\\s[^\\s]/.test(s);\n    const stripPattern = (dom, block, pattern) => {\n      stripPattern$1(dom, block, pattern).each(node => {\n        const text = SugarElement.fromDom(node);\n        const textContent = get$3(text);\n        if (startsWithSingleSpace(textContent)) {\n          set(text, textContent.slice(1));\n        }\n      });\n    };\n    const applyPattern$1 = createApplyPattern(stripPattern);\n    const findPattern$1 = findPattern$2((pattern, text, nuText) => text.indexOf(pattern.start) === 0 || nuText.indexOf(pattern.start) === 0);\n    const findPatterns$1 = createFindPatterns(findPattern$1, true);\n    const getMatches$1 = (editor, patternSet) => {\n      const rng = editor.selection.getRng();\n      return getParentBlock(editor, rng).map(block => {\n        var _a;\n        const offset = Math.max(0, rng.startOffset);\n        const dynamicPatternSet = resolveFromDynamicPatterns(patternSet, block, (_a = block.textContent) !== null && _a !== void 0 ? _a : '');\n        const inlineMatches = findPatterns$2(editor, block, rng.startContainer, offset, dynamicPatternSet, true);\n        const blockMatches = findPatterns$1(editor, block, dynamicPatternSet, true);\n        return {\n          inlineMatches,\n          blockMatches\n        };\n      }).filter(({inlineMatches, blockMatches}) => blockMatches.length > 0 || inlineMatches.length > 0);\n    };\n    const applyMatches$1 = (editor, matches) => {\n      if (matches.length === 0) {\n        return;\n      }\n      const bookmark = editor.selection.getBookmark();\n      each$e(matches, match => applyPattern$1(editor, match));\n      editor.selection.moveToBookmark(bookmark);\n    };\n\n    const applyPattern = createApplyPattern(stripPattern$1);\n    const findPattern = findPattern$2((pattern, text, nuText) => text === pattern.start || nuText === pattern.start);\n    const findPatterns = createFindPatterns(findPattern, false);\n    const getMatches = (editor, patternSet) => {\n      const rng = editor.selection.getRng();\n      return getParentBlock(editor, rng).map(block => {\n        const offset = Math.max(0, rng.startOffset);\n        const beforeText = getBeforeText(editor.dom, block, rng.startContainer, offset);\n        const dynamicPatternSet = resolveFromDynamicPatterns(patternSet, block, beforeText);\n        return findPatterns(editor, block, dynamicPatternSet, false, beforeText);\n      }).filter(matches => matches.length > 0);\n    };\n    const applyMatches = (editor, matches) => {\n      each$e(matches, match => applyPattern(editor, match));\n    };\n\n    const handleEnter = (editor, patternSet) => getMatches$1(editor, patternSet).fold(never, ({inlineMatches, blockMatches}) => {\n      editor.undoManager.add();\n      editor.undoManager.extra(() => {\n        editor.execCommand('mceInsertNewLine');\n      }, () => {\n        insert$5(editor);\n        applyMatches$2(editor, inlineMatches);\n        applyMatches$1(editor, blockMatches);\n        const range = editor.selection.getRng();\n        const spot = textBefore(range.startContainer, range.startOffset, editor.dom.getRoot());\n        editor.execCommand('mceInsertNewLine');\n        spot.each(s => {\n          const node = s.container;\n          if (node.data.charAt(s.offset - 1) === zeroWidth) {\n            node.deleteData(s.offset - 1, 1);\n            cleanEmptyNodes(editor.dom, node.parentNode, e => e === editor.dom.getRoot());\n          }\n        });\n      });\n      return true;\n    });\n    const handleInlineKey = (editor, patternSet) => {\n      const rng = editor.selection.getRng();\n      getParentBlock(editor, rng).map(block => {\n        const offset = Math.max(0, rng.startOffset - 1);\n        const beforeText = getBeforeText(editor.dom, block, rng.startContainer, offset);\n        const dynamicPatternSet = resolveFromDynamicPatterns(patternSet, block, beforeText);\n        const inlineMatches = findPatterns$2(editor, block, rng.startContainer, offset, dynamicPatternSet, false);\n        if (inlineMatches.length > 0) {\n          editor.undoManager.transact(() => {\n            applyMatches$2(editor, inlineMatches);\n          });\n        }\n      });\n    };\n    const handleBlockPatternOnSpace = (editor, patternSet) => getMatches(editor, patternSet).fold(never, matches => {\n      editor.undoManager.transact(() => {\n        applyMatches(editor, matches);\n      });\n      return true;\n    });\n    const checkKeyEvent = (codes, event, predicate) => {\n      for (let i = 0; i < codes.length; i++) {\n        if (predicate(codes[i], event)) {\n          return true;\n        }\n      }\n      return false;\n    };\n    const checkKeyCode = (codes, event) => checkKeyEvent(codes, event, (code, event) => {\n      return code === event.keyCode && !VK.modifierPressed(event);\n    });\n    const checkCharCode = (chars, event) => checkKeyEvent(chars, event, (chr, event) => {\n      return chr.charCodeAt(0) === event.charCode;\n    });\n\n    const setup$2 = editor => {\n      const charCodes = [\n        ',',\n        '.',\n        ';',\n        ':',\n        '!',\n        '?'\n      ];\n      const keyCodes = [32];\n      const getPatternSet = () => createPatternSet(getTextPatterns(editor).filter(pattern => {\n        if (pattern.type === 'inline-command' || pattern.type === 'block-command') {\n          return editor.queryCommandSupported(pattern.cmd);\n        }\n        return true;\n      }), getTextPatternsLookup(editor));\n      const hasDynamicPatterns = () => hasTextPatternsLookup(editor);\n      editor.on('keydown', e => {\n        if (e.keyCode === 13 && !VK.modifierPressed(e) && editor.selection.isCollapsed() && editor.selection.isEditable()) {\n          const patternSet = filterByTrigger(getPatternSet(), 'enter');\n          const hasPatterns = patternSet.inlinePatterns.length > 0 || patternSet.blockPatterns.length > 0 || hasDynamicPatterns();\n          if (hasPatterns && handleEnter(editor, patternSet)) {\n            e.preventDefault();\n          }\n        }\n      }, true);\n      editor.on('keydown', e => {\n        if (e.keyCode === 32 && editor.selection.isCollapsed() && editor.selection.isEditable()) {\n          const patternSet = filterByTrigger(getPatternSet(), 'space');\n          const hasPatterns = patternSet.blockPatterns.length > 0 || hasDynamicPatterns();\n          if (hasPatterns && handleBlockPatternOnSpace(editor, patternSet)) {\n            e.preventDefault();\n          }\n        }\n      }, true);\n      const handleInlineTrigger = () => {\n        if (editor.selection.isCollapsed() && editor.selection.isEditable()) {\n          const patternSet = filterByTrigger(getPatternSet(), 'space');\n          const hasPatterns = patternSet.inlinePatterns.length > 0 || hasDynamicPatterns();\n          if (hasPatterns) {\n            handleInlineKey(editor, patternSet);\n          }\n        }\n      };\n      editor.on('keyup', e => {\n        if (checkKeyCode(keyCodes, e)) {\n          handleInlineTrigger();\n        }\n      });\n      editor.on('keypress', e => {\n        if (checkCharCode(charCodes, e)) {\n          Delay.setEditorTimeout(editor, handleInlineTrigger);\n        }\n      });\n    };\n\n    const setup$1 = editor => {\n      setup$2(editor);\n    };\n\n    const Quirks = editor => {\n      const each = Tools.each;\n      const BACKSPACE = VK.BACKSPACE, DELETE = VK.DELETE, dom = editor.dom, selection = editor.selection, parser = editor.parser;\n      const browser = Env.browser;\n      const isGecko = browser.isFirefox();\n      const isWebKit = browser.isChromium() || browser.isSafari();\n      const isiOS = Env.deviceType.isiPhone() || Env.deviceType.isiPad();\n      const isMac = Env.os.isMacOS() || Env.os.isiOS();\n      const setEditorCommandState = (cmd, state) => {\n        try {\n          editor.getDoc().execCommand(cmd, false, String(state));\n        } catch (ex) {\n        }\n      };\n      const isDefaultPrevented = e => {\n        return e.isDefaultPrevented();\n      };\n      const emptyEditorWhenDeleting = () => {\n        const serializeRng = rng => {\n          const body = dom.create('body');\n          const contents = rng.cloneContents();\n          body.appendChild(contents);\n          return selection.serializer.serialize(body, { format: 'html' });\n        };\n        const allContentsSelected = rng => {\n          const selection = serializeRng(rng);\n          const allRng = dom.createRng();\n          allRng.selectNode(editor.getBody());\n          const allSelection = serializeRng(allRng);\n          return selection === allSelection;\n        };\n        editor.on('keydown', e => {\n          const keyCode = e.keyCode;\n          if (!isDefaultPrevented(e) && (keyCode === DELETE || keyCode === BACKSPACE) && editor.selection.isEditable()) {\n            const isCollapsed = editor.selection.isCollapsed();\n            const body = editor.getBody();\n            if (isCollapsed && !isEmptyNode(editor.schema, body)) {\n              return;\n            }\n            if (!isCollapsed && !allContentsSelected(editor.selection.getRng())) {\n              return;\n            }\n            e.preventDefault();\n            editor.setContent('');\n            if (body.firstChild && dom.isBlock(body.firstChild)) {\n              editor.selection.setCursorLocation(body.firstChild, 0);\n            } else {\n              editor.selection.setCursorLocation(body, 0);\n            }\n            editor.nodeChanged();\n          }\n        });\n      };\n      const selectAll = () => {\n        editor.shortcuts.add('meta+a', null, 'SelectAll');\n      };\n      const documentElementEditingFocus = () => {\n        if (!editor.inline) {\n          dom.bind(editor.getDoc(), 'mousedown mouseup', e => {\n            let rng;\n            if (e.target === editor.getDoc().documentElement) {\n              rng = selection.getRng();\n              editor.getBody().focus();\n              if (e.type === 'mousedown') {\n                if (isCaretContainer$2(rng.startContainer)) {\n                  return;\n                }\n                selection.placeCaretAt(e.clientX, e.clientY);\n              } else {\n                selection.setRng(rng);\n              }\n            }\n          });\n        }\n      };\n      const removeHrOnBackspace = () => {\n        editor.on('keydown', e => {\n          if (!isDefaultPrevented(e) && e.keyCode === BACKSPACE) {\n            if (!editor.getBody().getElementsByTagName('hr').length) {\n              return;\n            }\n            if (selection.isCollapsed() && selection.getRng().startOffset === 0) {\n              const node = selection.getNode();\n              const previousSibling = node.previousSibling;\n              if (node.nodeName === 'HR') {\n                dom.remove(node);\n                e.preventDefault();\n                return;\n              }\n              if (previousSibling && previousSibling.nodeName && previousSibling.nodeName.toLowerCase() === 'hr') {\n                dom.remove(previousSibling);\n                e.preventDefault();\n              }\n            }\n          }\n        });\n      };\n      const focusBody = () => {\n        if (!Range.prototype.getClientRects) {\n          editor.on('mousedown', e => {\n            if (!isDefaultPrevented(e) && e.target.nodeName === 'HTML') {\n              const body = editor.getBody();\n              body.blur();\n              Delay.setEditorTimeout(editor, () => {\n                body.focus();\n              });\n            }\n          });\n        }\n      };\n      const selectControlElements = () => {\n        const visualAidsAnchorClass = getVisualAidsAnchorClass(editor);\n        editor.on('click', e => {\n          const target = e.target;\n          if (/^(IMG|HR)$/.test(target.nodeName) && dom.isEditable(target)) {\n            e.preventDefault();\n            editor.selection.select(target);\n            editor.nodeChanged();\n          }\n          if (target.nodeName === 'A' && dom.hasClass(target, visualAidsAnchorClass) && target.childNodes.length === 0 && dom.isEditable(target.parentNode)) {\n            e.preventDefault();\n            selection.select(target);\n          }\n        });\n      };\n      const removeStylesWhenDeletingAcrossBlockElements = () => {\n        const getAttributeApplyFunction = () => {\n          const template = dom.getAttribs(selection.getStart().cloneNode(false));\n          return () => {\n            const target = selection.getStart();\n            if (target !== editor.getBody()) {\n              dom.setAttrib(target, 'style', null);\n              each(template, attr => {\n                target.setAttributeNode(attr.cloneNode(true));\n              });\n            }\n          };\n        };\n        const isSelectionAcrossElements = () => {\n          return !selection.isCollapsed() && dom.getParent(selection.getStart(), dom.isBlock) !== dom.getParent(selection.getEnd(), dom.isBlock);\n        };\n        editor.on('keypress', e => {\n          let applyAttributes;\n          if (!isDefaultPrevented(e) && (e.keyCode === 8 || e.keyCode === 46) && isSelectionAcrossElements()) {\n            applyAttributes = getAttributeApplyFunction();\n            editor.getDoc().execCommand('delete', false);\n            applyAttributes();\n            e.preventDefault();\n            return false;\n          } else {\n            return true;\n          }\n        });\n        dom.bind(editor.getDoc(), 'cut', e => {\n          if (!isDefaultPrevented(e) && isSelectionAcrossElements()) {\n            const applyAttributes = getAttributeApplyFunction();\n            Delay.setEditorTimeout(editor, () => {\n              applyAttributes();\n            });\n          }\n        });\n      };\n      const disableBackspaceIntoATable = () => {\n        editor.on('keydown', e => {\n          if (!isDefaultPrevented(e) && e.keyCode === BACKSPACE) {\n            if (selection.isCollapsed() && selection.getRng().startOffset === 0) {\n              const previousSibling = selection.getNode().previousSibling;\n              if (previousSibling && previousSibling.nodeName && previousSibling.nodeName.toLowerCase() === 'table') {\n                e.preventDefault();\n                return false;\n              }\n            }\n          }\n          return true;\n        });\n      };\n      const removeBlockQuoteOnBackSpace = () => {\n        editor.on('keydown', e => {\n          if (isDefaultPrevented(e) || e.keyCode !== VK.BACKSPACE) {\n            return;\n          }\n          let rng = selection.getRng();\n          const container = rng.startContainer;\n          const offset = rng.startOffset;\n          const root = dom.getRoot();\n          let parent = container;\n          if (!rng.collapsed || offset !== 0) {\n            return;\n          }\n          while (parent.parentNode && parent.parentNode.firstChild === parent && parent.parentNode !== root) {\n            parent = parent.parentNode;\n          }\n          if (parent.nodeName === 'BLOCKQUOTE') {\n            editor.formatter.toggle('blockquote', undefined, parent);\n            rng = dom.createRng();\n            rng.setStart(container, 0);\n            rng.setEnd(container, 0);\n            selection.setRng(rng);\n          }\n        });\n      };\n      const setGeckoEditingOptions = () => {\n        const setOpts = () => {\n          setEditorCommandState('StyleWithCSS', false);\n          setEditorCommandState('enableInlineTableEditing', false);\n          if (!getObjectResizing(editor)) {\n            setEditorCommandState('enableObjectResizing', false);\n          }\n        };\n        if (!isReadOnly$1(editor)) {\n          editor.on('BeforeExecCommand mousedown', setOpts);\n        }\n      };\n      const addBrAfterLastLinks = () => {\n        const fixLinks = () => {\n          each(dom.select('a:not([data-mce-block])'), node => {\n            var _a;\n            let parentNode = node.parentNode;\n            const root = dom.getRoot();\n            if ((parentNode === null || parentNode === void 0 ? void 0 : parentNode.lastChild) === node) {\n              while (parentNode && !dom.isBlock(parentNode)) {\n                if (((_a = parentNode.parentNode) === null || _a === void 0 ? void 0 : _a.lastChild) !== parentNode || parentNode === root) {\n                  return;\n                }\n                parentNode = parentNode.parentNode;\n              }\n              dom.add(parentNode, 'br', { 'data-mce-bogus': 1 });\n            }\n          });\n        };\n        editor.on('SetContent ExecCommand', e => {\n          if (e.type === 'setcontent' || e.command === 'mceInsertLink') {\n            fixLinks();\n          }\n        });\n      };\n      const setDefaultBlockType = () => {\n        editor.on('init', () => {\n          setEditorCommandState('DefaultParagraphSeparator', getForcedRootBlock(editor));\n        });\n      };\n      const isAllContentSelected = editor => {\n        const body = editor.getBody();\n        const rng = editor.selection.getRng();\n        return rng.startContainer === rng.endContainer && rng.startContainer === body && rng.startOffset === 0 && rng.endOffset === body.childNodes.length;\n      };\n      const normalizeSelection = () => {\n        editor.on('keyup focusin mouseup', e => {\n          if (!VK.modifierPressed(e) && !isAllContentSelected(editor)) {\n            selection.normalize();\n          }\n        }, true);\n      };\n      const showBrokenImageIcon = () => {\n        editor.contentStyles.push('img:-moz-broken {' + '-moz-force-broken-image-icon:1;' + 'min-width:24px;' + 'min-height:24px' + '}');\n      };\n      const restoreFocusOnKeyDown = () => {\n        if (!editor.inline) {\n          editor.on('keydown', () => {\n            if (document.activeElement === document.body) {\n              editor.getWin().focus();\n            }\n          });\n        }\n      };\n      const bodyHeight = () => {\n        if (!editor.inline) {\n          editor.contentStyles.push('body {min-height: 150px}');\n          editor.on('click', e => {\n            let rng;\n            if (e.target.nodeName === 'HTML') {\n              rng = editor.selection.getRng();\n              editor.getBody().focus();\n              editor.selection.setRng(rng);\n              editor.selection.normalize();\n              editor.nodeChanged();\n            }\n          });\n        }\n      };\n      const blockCmdArrowNavigation = () => {\n        if (isMac) {\n          editor.on('keydown', e => {\n            if (VK.metaKeyPressed(e) && !e.shiftKey && (e.keyCode === 37 || e.keyCode === 39)) {\n              e.preventDefault();\n              const selection = editor.selection.getSel();\n              selection.modify('move', e.keyCode === 37 ? 'backward' : 'forward', 'lineboundary');\n            }\n          });\n        }\n      };\n      const tapLinksAndImages = () => {\n        editor.on('click', e => {\n          let elm = e.target;\n          do {\n            if (elm.tagName === 'A') {\n              e.preventDefault();\n              return;\n            }\n          } while (elm = elm.parentNode);\n        });\n        editor.contentStyles.push('.mce-content-body {-webkit-touch-callout: none}');\n      };\n      const blockFormSubmitInsideEditor = () => {\n        editor.on('init', () => {\n          editor.dom.bind(editor.getBody(), 'submit', e => {\n            e.preventDefault();\n          });\n        });\n      };\n      const removeAppleInterchangeBrs = () => {\n        parser.addNodeFilter('br', nodes => {\n          let i = nodes.length;\n          while (i--) {\n            if (nodes[i].attr('class') === 'Apple-interchange-newline') {\n              nodes[i].remove();\n            }\n          }\n        });\n      };\n      const refreshContentEditable = noop;\n      const isHidden = () => {\n        if (!isGecko || editor.removed) {\n          return false;\n        }\n        const sel = editor.selection.getSel();\n        return !sel || !sel.rangeCount || sel.rangeCount === 0;\n      };\n      const setupRtc = () => {\n        if (isWebKit) {\n          documentElementEditingFocus();\n          selectControlElements();\n          blockFormSubmitInsideEditor();\n          selectAll();\n          if (isiOS) {\n            restoreFocusOnKeyDown();\n            bodyHeight();\n            tapLinksAndImages();\n          }\n        }\n        if (isGecko) {\n          focusBody();\n          setGeckoEditingOptions();\n          showBrokenImageIcon();\n          blockCmdArrowNavigation();\n        }\n      };\n      const setup = () => {\n        removeBlockQuoteOnBackSpace();\n        emptyEditorWhenDeleting();\n        if (!Env.windowsPhone) {\n          normalizeSelection();\n        }\n        if (isWebKit) {\n          documentElementEditingFocus();\n          selectControlElements();\n          setDefaultBlockType();\n          blockFormSubmitInsideEditor();\n          disableBackspaceIntoATable();\n          removeAppleInterchangeBrs();\n          if (isiOS) {\n            restoreFocusOnKeyDown();\n            bodyHeight();\n            tapLinksAndImages();\n          } else {\n            selectAll();\n          }\n        }\n        if (isGecko) {\n          removeHrOnBackspace();\n          focusBody();\n          removeStylesWhenDeletingAcrossBlockElements();\n          setGeckoEditingOptions();\n          addBrAfterLastLinks();\n          showBrokenImageIcon();\n          blockCmdArrowNavigation();\n          disableBackspaceIntoATable();\n        }\n      };\n      if (isRtc(editor)) {\n        setupRtc();\n      } else {\n        setup();\n      }\n      return {\n        refreshContentEditable,\n        isHidden\n      };\n    };\n\n    const isGplKey = key => key.toLowerCase() === 'gpl';\n    const isValidGeneratedKey = key => key.length >= 64 && key.length <= 255;\n    const validateLicenseKey = key => isGplKey(key) || isValidGeneratedKey(key) ? 'VALID' : 'INVALID';\n    const validateEditorLicenseKey = editor => {\n      const licenseKey = getLicenseKey(editor);\n      const hasApiKey = isString(getApiKey(editor));\n      if (!hasApiKey && (isUndefined(licenseKey) || validateLicenseKey(licenseKey) === 'INVALID')) {\n        console.warn(`TinyMCE is running in evaluation mode. Provide a valid license key or add license_key: 'gpl' to the init config to agree to the open source license terms. Read more at https://www.tiny.cloud/license-key/`);\n      }\n    };\n\n    const DOM$6 = DOMUtils.DOM;\n    const appendStyle = (editor, text) => {\n      const body = SugarElement.fromDom(editor.getBody());\n      const container = getStyleContainer(getRootNode(body));\n      const style = SugarElement.fromTag('style');\n      set$3(style, 'type', 'text/css');\n      append$1(style, SugarElement.fromText(text));\n      append$1(container, style);\n      editor.on('remove', () => {\n        remove$4(style);\n      });\n    };\n    const getRootName = editor => editor.inline ? editor.getElement().nodeName.toLowerCase() : undefined;\n    const removeUndefined = obj => filter$4(obj, v => isUndefined(v) === false);\n    const mkParserSettings = editor => {\n      const getOption = editor.options.get;\n      const blobCache = editor.editorUpload.blobCache;\n      return removeUndefined({\n        allow_conditional_comments: getOption('allow_conditional_comments'),\n        allow_html_data_urls: getOption('allow_html_data_urls'),\n        allow_svg_data_urls: getOption('allow_svg_data_urls'),\n        allow_html_in_named_anchor: getOption('allow_html_in_named_anchor'),\n        allow_script_urls: getOption('allow_script_urls'),\n        allow_mathml_annotation_encodings: getOption('allow_mathml_annotation_encodings'),\n        allow_unsafe_link_target: getOption('allow_unsafe_link_target'),\n        convert_unsafe_embeds: getOption('convert_unsafe_embeds'),\n        convert_fonts_to_spans: getOption('convert_fonts_to_spans'),\n        fix_list_elements: getOption('fix_list_elements'),\n        font_size_legacy_values: getOption('font_size_legacy_values'),\n        forced_root_block: getOption('forced_root_block'),\n        forced_root_block_attrs: getOption('forced_root_block_attrs'),\n        preserve_cdata: getOption('preserve_cdata'),\n        inline_styles: getOption('inline_styles'),\n        root_name: getRootName(editor),\n        sandbox_iframes: getOption('sandbox_iframes'),\n        sandbox_iframes_exclusions: getSandboxIframesExclusions(editor),\n        sanitize: getOption('xss_sanitization'),\n        validate: true,\n        blob_cache: blobCache,\n        document: editor.getDoc()\n      });\n    };\n    const mkSchemaSettings = editor => {\n      const getOption = editor.options.get;\n      return removeUndefined({\n        custom_elements: getOption('custom_elements'),\n        extended_valid_elements: getOption('extended_valid_elements'),\n        invalid_elements: getOption('invalid_elements'),\n        invalid_styles: getOption('invalid_styles'),\n        schema: getOption('schema'),\n        valid_children: getOption('valid_children'),\n        valid_classes: getOption('valid_classes'),\n        valid_elements: getOption('valid_elements'),\n        valid_styles: getOption('valid_styles'),\n        verify_html: getOption('verify_html'),\n        padd_empty_block_inline_children: getOption('format_empty_lines')\n      });\n    };\n    const mkSerializerSettings = editor => {\n      const getOption = editor.options.get;\n      return {\n        ...mkParserSettings(editor),\n        ...mkSchemaSettings(editor),\n        ...removeUndefined({\n          remove_trailing_brs: getOption('remove_trailing_brs'),\n          pad_empty_with_br: getOption('pad_empty_with_br'),\n          url_converter: getOption('url_converter'),\n          url_converter_scope: getOption('url_converter_scope'),\n          element_format: getOption('element_format'),\n          entities: getOption('entities'),\n          entity_encoding: getOption('entity_encoding'),\n          indent: getOption('indent'),\n          indent_after: getOption('indent_after'),\n          indent_before: getOption('indent_before')\n        })\n      };\n    };\n    const createParser = editor => {\n      const parser = DomParser(mkParserSettings(editor), editor.schema);\n      parser.addAttributeFilter('src,href,style,tabindex', (nodes, name) => {\n        const dom = editor.dom;\n        const internalName = 'data-mce-' + name;\n        let i = nodes.length;\n        while (i--) {\n          const node = nodes[i];\n          let value = node.attr(name);\n          if (value && !node.attr(internalName)) {\n            if (value.indexOf('data:') === 0 || value.indexOf('blob:') === 0) {\n              continue;\n            }\n            if (name === 'style') {\n              value = dom.serializeStyle(dom.parseStyle(value), node.name);\n              if (!value.length) {\n                value = null;\n              }\n              node.attr(internalName, value);\n              node.attr(name, value);\n            } else if (name === 'tabindex') {\n              node.attr(internalName, value);\n              node.attr(name, null);\n            } else {\n              node.attr(internalName, editor.convertURL(value, name, node.name));\n            }\n          }\n        }\n      });\n      parser.addNodeFilter('script', nodes => {\n        let i = nodes.length;\n        while (i--) {\n          const node = nodes[i];\n          const type = node.attr('type') || 'no/type';\n          if (type.indexOf('mce-') !== 0) {\n            node.attr('type', 'mce-' + type);\n          }\n        }\n      });\n      if (shouldPreserveCData(editor)) {\n        parser.addNodeFilter('#cdata', nodes => {\n          var _a;\n          let i = nodes.length;\n          while (i--) {\n            const node = nodes[i];\n            node.type = 8;\n            node.name = '#comment';\n            node.value = '[CDATA[' + editor.dom.encode((_a = node.value) !== null && _a !== void 0 ? _a : '') + ']]';\n          }\n        });\n      }\n      parser.addNodeFilter('p,h1,h2,h3,h4,h5,h6,div', nodes => {\n        let i = nodes.length;\n        const nonEmptyElements = editor.schema.getNonEmptyElements();\n        while (i--) {\n          const node = nodes[i];\n          if (node.isEmpty(nonEmptyElements) && node.getAll('br').length === 0) {\n            node.append(new AstNode('br', 1));\n          }\n        }\n      });\n      return parser;\n    };\n    const autoFocus = editor => {\n      const autoFocus = getAutoFocus(editor);\n      if (autoFocus) {\n        Delay.setEditorTimeout(editor, () => {\n          let focusEditor;\n          if (autoFocus === true) {\n            focusEditor = editor;\n          } else {\n            focusEditor = editor.editorManager.get(autoFocus);\n          }\n          if (focusEditor && !focusEditor.destroyed) {\n            focusEditor.focus();\n            focusEditor.selection.scrollIntoView();\n          }\n        }, 100);\n      }\n    };\n    const moveSelectionToFirstCaretPosition = editor => {\n      const root = editor.dom.getRoot();\n      if (!editor.inline && (!hasAnyRanges(editor) || editor.selection.getStart(true) === root)) {\n        firstPositionIn(root).each(pos => {\n          const node = pos.getNode();\n          const caretPos = isTable$2(node) ? firstPositionIn(node).getOr(pos) : pos;\n          editor.selection.setRng(caretPos.toRange());\n        });\n      }\n    };\n    const initEditor = editor => {\n      editor.bindPendingEventDelegates();\n      editor.initialized = true;\n      fireInit(editor);\n      editor.focus(true);\n      moveSelectionToFirstCaretPosition(editor);\n      editor.nodeChanged({ initial: true });\n      const initInstanceCallback = getInitInstanceCallback(editor);\n      if (isFunction(initInstanceCallback)) {\n        initInstanceCallback.call(editor, editor);\n      }\n      autoFocus(editor);\n    };\n    const getStyleSheetLoader$1 = editor => editor.inline ? editor.ui.styleSheetLoader : editor.dom.styleSheetLoader;\n    const makeStylesheetLoadingPromises = (editor, css, framedFonts) => {\n      const {\n        pass: bundledCss,\n        fail: normalCss\n      } = partition$2(css, name => tinymce.Resource.has(toContentSkinResourceName(name)));\n      const bundledPromises = bundledCss.map(url => {\n        const css = tinymce.Resource.get(toContentSkinResourceName(url));\n        if (isString(css)) {\n          return Promise.resolve(getStyleSheetLoader$1(editor).loadRawCss(url, css));\n        }\n        return Promise.resolve();\n      });\n      const promises = [\n        ...bundledPromises,\n        getStyleSheetLoader$1(editor).loadAll(normalCss)\n      ];\n      if (editor.inline) {\n        return promises;\n      } else {\n        return promises.concat([editor.ui.styleSheetLoader.loadAll(framedFonts)]);\n      }\n    };\n    const loadContentCss = editor => {\n      const styleSheetLoader = getStyleSheetLoader$1(editor);\n      const fontCss = getFontCss(editor);\n      const css = editor.contentCSS;\n      const removeCss = () => {\n        styleSheetLoader.unloadAll(css);\n        if (!editor.inline) {\n          editor.ui.styleSheetLoader.unloadAll(fontCss);\n        }\n      };\n      const loaded = () => {\n        if (editor.removed) {\n          removeCss();\n        } else {\n          editor.on('remove', removeCss);\n        }\n      };\n      if (editor.contentStyles.length > 0) {\n        let contentCssText = '';\n        Tools.each(editor.contentStyles, style => {\n          contentCssText += style + '\\r\\n';\n        });\n        editor.dom.addStyle(contentCssText);\n      }\n      const allStylesheets = Promise.all(makeStylesheetLoadingPromises(editor, css, fontCss)).then(loaded).catch(loaded);\n      const contentStyle = getContentStyle(editor);\n      if (contentStyle) {\n        appendStyle(editor, contentStyle);\n      }\n      return allStylesheets;\n    };\n    const preInit = editor => {\n      const doc = editor.getDoc(), body = editor.getBody();\n      firePreInit(editor);\n      if (!shouldBrowserSpellcheck(editor)) {\n        doc.body.spellcheck = false;\n        DOM$6.setAttrib(body, 'spellcheck', 'false');\n      }\n      editor.quirks = Quirks(editor);\n      firePostRender(editor);\n      const directionality = getDirectionality(editor);\n      if (directionality !== undefined) {\n        body.dir = directionality;\n      }\n      const protect = getProtect(editor);\n      if (protect) {\n        editor.on('BeforeSetContent', e => {\n          Tools.each(protect, pattern => {\n            e.content = e.content.replace(pattern, str => {\n              return '<!--mce:protected ' + escape(str) + '-->';\n            });\n          });\n        });\n      }\n      editor.on('SetContent', () => {\n        editor.addVisual(editor.getBody());\n      });\n      editor.on('compositionstart compositionend', e => {\n        editor.composing = e.type === 'compositionstart';\n      });\n    };\n    const loadInitialContent = editor => {\n      if (!isRtc(editor)) {\n        editor.load({\n          initial: true,\n          format: 'html'\n        });\n      }\n      editor.startContent = editor.getContent({ format: 'raw' });\n    };\n    const initEditorWithInitialContent = editor => {\n      if (editor.removed !== true) {\n        loadInitialContent(editor);\n        initEditor(editor);\n      }\n    };\n    const startProgress = editor => {\n      let canceled = false;\n      const progressTimeout = setTimeout(() => {\n        if (!canceled) {\n          editor.setProgressState(true);\n        }\n      }, 500);\n      return () => {\n        clearTimeout(progressTimeout);\n        canceled = true;\n        editor.setProgressState(false);\n      };\n    };\n    const contentBodyLoaded = editor => {\n      const targetElm = editor.getElement();\n      let doc = editor.getDoc();\n      if (editor.inline) {\n        DOM$6.addClass(targetElm, 'mce-content-body');\n        editor.contentDocument = doc = document;\n        editor.contentWindow = window;\n        editor.bodyElement = targetElm;\n        editor.contentAreaContainer = targetElm;\n      }\n      const body = editor.getBody();\n      body.disabled = true;\n      editor.readonly = isReadOnly$1(editor);\n      editor._editableRoot = hasEditableRoot$1(editor);\n      if (editor.hasEditableRoot()) {\n        if (editor.inline && DOM$6.getStyle(body, 'position', true) === 'static') {\n          body.style.position = 'relative';\n        }\n        body.contentEditable = 'true';\n      }\n      body.disabled = false;\n      editor.editorUpload = EditorUpload(editor);\n      editor.schema = Schema(mkSchemaSettings(editor));\n      editor.dom = DOMUtils(doc, {\n        keep_values: true,\n        url_converter: editor.convertURL,\n        url_converter_scope: editor,\n        update_styles: true,\n        root_element: editor.inline ? editor.getBody() : null,\n        collect: editor.inline,\n        schema: editor.schema,\n        contentCssCors: shouldUseContentCssCors(editor),\n        referrerPolicy: getReferrerPolicy(editor),\n        onSetAttrib: e => {\n          editor.dispatch('SetAttrib', e);\n        }\n      });\n      editor.parser = createParser(editor);\n      editor.serializer = DomSerializer(mkSerializerSettings(editor), editor);\n      editor.selection = EditorSelection(editor.dom, editor.getWin(), editor.serializer, editor);\n      editor.annotator = Annotator(editor);\n      editor.formatter = Formatter(editor);\n      editor.undoManager = UndoManager(editor);\n      editor._nodeChangeDispatcher = new NodeChange(editor);\n      editor._selectionOverrides = SelectionOverrides(editor);\n      setup$p(editor);\n      setup$6(editor);\n      setup$n(editor);\n      if (!isRtc(editor)) {\n        setup$5(editor);\n        setup$1(editor);\n      }\n      const caret = setup$b(editor);\n      setup$q(editor, caret);\n      setup$o(editor);\n      setup$r(editor);\n      setup$7(editor);\n      const setupRtcThunk = setup$t(editor);\n      preInit(editor);\n      validateEditorLicenseKey(editor);\n      setupRtcThunk.fold(() => {\n        const cancelProgress = startProgress(editor);\n        loadContentCss(editor).then(() => {\n          initEditorWithInitialContent(editor);\n          cancelProgress();\n        });\n      }, setupRtc => {\n        editor.setProgressState(true);\n        loadContentCss(editor).then(() => {\n          setupRtc().then(_rtcMode => {\n            editor.setProgressState(false);\n            initEditorWithInitialContent(editor);\n            bindEvents(editor);\n          }, err => {\n            editor.notificationManager.open({\n              type: 'error',\n              text: String(err)\n            });\n            initEditorWithInitialContent(editor);\n            bindEvents(editor);\n          });\n        });\n      });\n    };\n\n    const filter = always;\n    const bind = (element, event, handler) => bind$2(element, event, filter, handler);\n\n    const DOM$5 = DOMUtils.DOM;\n    const createIframeElement = (id, title, customAttrs, tabindex) => {\n      const iframe = SugarElement.fromTag('iframe');\n      tabindex.each(t => set$3(iframe, 'tabindex', t));\n      setAll$1(iframe, customAttrs);\n      setAll$1(iframe, {\n        id: id + '_ifr',\n        frameBorder: '0',\n        allowTransparency: 'true',\n        title\n      });\n      add$2(iframe, 'tox-edit-area__iframe');\n      return iframe;\n    };\n    const getIframeHtml = editor => {\n      let iframeHTML = getDocType(editor) + '<html><head>';\n      if (getDocumentBaseUrl(editor) !== editor.documentBaseUrl) {\n        iframeHTML += '<base href=\"' + editor.documentBaseURI.getURI() + '\" />';\n      }\n      iframeHTML += '<meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\" />';\n      const bodyId = getBodyId(editor);\n      const bodyClass = getBodyClass(editor);\n      const translatedAriaText = editor.translate(getIframeAriaText(editor));\n      if (getContentSecurityPolicy(editor)) {\n        iframeHTML += '<meta http-equiv=\"Content-Security-Policy\" content=\"' + getContentSecurityPolicy(editor) + '\" />';\n      }\n      iframeHTML += '</head>' + `<body id=\"${ bodyId }\" class=\"mce-content-body ${ bodyClass }\" data-id=\"${ editor.id }\" aria-label=\"${ translatedAriaText }\">` + '<br>' + '</body></html>';\n      return iframeHTML;\n    };\n    const createIframe = (editor, boxInfo) => {\n      const iframeTitle = Env.browser.isFirefox() ? getIframeAriaText(editor) : 'Rich Text Area';\n      const translatedTitle = editor.translate(iframeTitle);\n      const tabindex = getOpt(SugarElement.fromDom(editor.getElement()), 'tabindex').bind(toInt);\n      const ifr = createIframeElement(editor.id, translatedTitle, getIframeAttrs(editor), tabindex).dom;\n      ifr.onload = () => {\n        ifr.onload = null;\n        editor.dispatch('load');\n      };\n      editor.contentAreaContainer = boxInfo.iframeContainer;\n      editor.iframeElement = ifr;\n      editor.iframeHTML = getIframeHtml(editor);\n      DOM$5.add(boxInfo.iframeContainer, ifr);\n    };\n    const setupIframeBody = editor => {\n      const iframe = editor.iframeElement;\n      const ready = () => {\n        editor.contentDocument = iframe.contentDocument;\n        contentBodyLoaded(editor);\n      };\n      if (shouldUseDocumentWrite(editor) || Env.browser.isFirefox()) {\n        const doc = editor.getDoc();\n        doc.open();\n        doc.write(editor.iframeHTML);\n        doc.close();\n        ready();\n      } else {\n        const binder = bind(SugarElement.fromDom(iframe), 'load', () => {\n          binder.unbind();\n          ready();\n        });\n        iframe.srcdoc = editor.iframeHTML;\n      }\n    };\n    const init$1 = (editor, boxInfo) => {\n      createIframe(editor, boxInfo);\n      if (boxInfo.editorContainer) {\n        boxInfo.editorContainer.style.display = editor.orgDisplay;\n        editor.hidden = DOM$5.isHidden(boxInfo.editorContainer);\n      }\n      editor.getElement().style.display = 'none';\n      DOM$5.setAttrib(editor.id, 'aria-hidden', 'true');\n      editor.getElement().style.visibility = editor.orgVisibility;\n      setupIframeBody(editor);\n    };\n\n    const DOM$4 = DOMUtils.DOM;\n    const initPlugin = (editor, initializedPlugins, plugin) => {\n      const Plugin = PluginManager.get(plugin);\n      const pluginUrl = PluginManager.urls[plugin] || editor.documentBaseUrl.replace(/\\/$/, '');\n      plugin = Tools.trim(plugin);\n      if (Plugin && Tools.inArray(initializedPlugins, plugin) === -1) {\n        if (editor.plugins[plugin]) {\n          return;\n        }\n        try {\n          const pluginInstance = Plugin(editor, pluginUrl) || {};\n          editor.plugins[plugin] = pluginInstance;\n          if (isFunction(pluginInstance.init)) {\n            pluginInstance.init(editor, pluginUrl);\n            initializedPlugins.push(plugin);\n          }\n        } catch (e) {\n          pluginInitError(editor, plugin, e);\n        }\n      }\n    };\n    const trimLegacyPrefix = name => {\n      return name.replace(/^\\-/, '');\n    };\n    const initPlugins = editor => {\n      const initializedPlugins = [];\n      each$e(getPlugins(editor), name => {\n        initPlugin(editor, initializedPlugins, trimLegacyPrefix(name));\n      });\n    };\n    const initIcons = editor => {\n      const iconPackName = Tools.trim(getIconPackName(editor));\n      const currentIcons = editor.ui.registry.getAll().icons;\n      const loadIcons = {\n        ...IconManager.get('default').icons,\n        ...IconManager.get(iconPackName).icons\n      };\n      each$d(loadIcons, (svgData, icon) => {\n        if (!has$2(currentIcons, icon)) {\n          editor.ui.registry.addIcon(icon, svgData);\n        }\n      });\n    };\n    const initTheme = editor => {\n      const theme = getTheme(editor);\n      if (isString(theme)) {\n        const Theme = ThemeManager.get(theme);\n        editor.theme = Theme(editor, ThemeManager.urls[theme]) || {};\n        if (isFunction(editor.theme.init)) {\n          editor.theme.init(editor, ThemeManager.urls[theme] || editor.documentBaseUrl.replace(/\\/$/, ''));\n        }\n      } else {\n        editor.theme = {};\n      }\n    };\n    const initModel = editor => {\n      const model = getModel(editor);\n      const Model = ModelManager.get(model);\n      editor.model = Model(editor, ModelManager.urls[model]);\n    };\n    const renderFromLoadedTheme = editor => {\n      const render = editor.theme.renderUI;\n      return render ? render() : renderThemeFalse(editor);\n    };\n    const renderFromThemeFunc = editor => {\n      const elm = editor.getElement();\n      const theme = getTheme(editor);\n      const info = theme(editor, elm);\n      if (info.editorContainer.nodeType) {\n        info.editorContainer.id = info.editorContainer.id || editor.id + '_parent';\n      }\n      if (info.iframeContainer && info.iframeContainer.nodeType) {\n        info.iframeContainer.id = info.iframeContainer.id || editor.id + '_iframecontainer';\n      }\n      info.height = info.iframeHeight ? info.iframeHeight : elm.offsetHeight;\n      return info;\n    };\n    const createThemeFalseResult = (element, iframe) => {\n      return {\n        editorContainer: element,\n        iframeContainer: iframe,\n        api: {}\n      };\n    };\n    const renderThemeFalseIframe = targetElement => {\n      const iframeContainer = DOM$4.create('div');\n      DOM$4.insertAfter(iframeContainer, targetElement);\n      return createThemeFalseResult(iframeContainer, iframeContainer);\n    };\n    const renderThemeFalse = editor => {\n      const targetElement = editor.getElement();\n      return editor.inline ? createThemeFalseResult(null) : renderThemeFalseIframe(targetElement);\n    };\n    const renderThemeUi = editor => {\n      const elm = editor.getElement();\n      editor.orgDisplay = elm.style.display;\n      if (isString(getTheme(editor))) {\n        return renderFromLoadedTheme(editor);\n      } else if (isFunction(getTheme(editor))) {\n        return renderFromThemeFunc(editor);\n      } else {\n        return renderThemeFalse(editor);\n      }\n    };\n    const augmentEditorUiApi = (editor, api) => {\n      const uiApiFacade = {\n        show: Optional.from(api.show).getOr(noop),\n        hide: Optional.from(api.hide).getOr(noop),\n        isEnabled: Optional.from(api.isEnabled).getOr(always),\n        setEnabled: state => {\n          const shouldSkip = state && editor.mode.get() === 'readonly';\n          if (!shouldSkip) {\n            Optional.from(api.setEnabled).each(f => f(state));\n          }\n        }\n      };\n      editor.ui = {\n        ...editor.ui,\n        ...uiApiFacade\n      };\n    };\n    const init = async editor => {\n      editor.dispatch('ScriptsLoaded');\n      initIcons(editor);\n      initTheme(editor);\n      initModel(editor);\n      initPlugins(editor);\n      const renderInfo = await renderThemeUi(editor);\n      augmentEditorUiApi(editor, Optional.from(renderInfo.api).getOr({}));\n      editor.editorContainer = renderInfo.editorContainer;\n      appendContentCssFromSettings(editor);\n      if (editor.inline) {\n        contentBodyLoaded(editor);\n      } else {\n        init$1(editor, {\n          editorContainer: renderInfo.editorContainer,\n          iframeContainer: renderInfo.iframeContainer\n        });\n      }\n    };\n\n    const DOM$3 = DOMUtils.DOM;\n    const hasSkipLoadPrefix = name => name.charAt(0) === '-';\n    const loadLanguage = (scriptLoader, editor) => {\n      const languageCode = getLanguageCode(editor);\n      const languageUrl = getLanguageUrl(editor);\n      if (!I18n.hasCode(languageCode) && languageCode !== 'en') {\n        const url = isNotEmpty(languageUrl) ? languageUrl : `${ editor.editorManager.baseURL }/langs/${ languageCode }.js`;\n        scriptLoader.add(url).catch(() => {\n          languageLoadError(editor, url, languageCode);\n        });\n      }\n    };\n    const loadTheme = (editor, suffix) => {\n      const theme = getTheme(editor);\n      if (isString(theme) && !hasSkipLoadPrefix(theme) && !has$2(ThemeManager.urls, theme)) {\n        const themeUrl = getThemeUrl(editor);\n        const url = themeUrl ? editor.documentBaseURI.toAbsolute(themeUrl) : `themes/${ theme }/theme${ suffix }.js`;\n        ThemeManager.load(theme, url).catch(() => {\n          themeLoadError(editor, url, theme);\n        });\n      }\n    };\n    const loadModel = (editor, suffix) => {\n      const model = getModel(editor);\n      if (model !== 'plugin' && !has$2(ModelManager.urls, model)) {\n        const modelUrl = getModelUrl(editor);\n        const url = isString(modelUrl) ? editor.documentBaseURI.toAbsolute(modelUrl) : `models/${ model }/model${ suffix }.js`;\n        ModelManager.load(model, url).catch(() => {\n          modelLoadError(editor, url, model);\n        });\n      }\n    };\n    const getIconsUrlMetaFromUrl = editor => Optional.from(getIconsUrl(editor)).filter(isNotEmpty).map(url => ({\n      url,\n      name: Optional.none()\n    }));\n    const getIconsUrlMetaFromName = (editor, name, suffix) => Optional.from(name).filter(name => isNotEmpty(name) && !IconManager.has(name)).map(name => ({\n      url: `${ editor.editorManager.baseURL }/icons/${ name }/icons${ suffix }.js`,\n      name: Optional.some(name)\n    }));\n    const loadIcons = (scriptLoader, editor, suffix) => {\n      const defaultIconsUrl = getIconsUrlMetaFromName(editor, 'default', suffix);\n      const customIconsUrl = getIconsUrlMetaFromUrl(editor).orThunk(() => getIconsUrlMetaFromName(editor, getIconPackName(editor), ''));\n      each$e(cat([\n        defaultIconsUrl,\n        customIconsUrl\n      ]), urlMeta => {\n        scriptLoader.add(urlMeta.url).catch(() => {\n          iconsLoadError(editor, urlMeta.url, urlMeta.name.getOrUndefined());\n        });\n      });\n    };\n    const loadPlugins = (editor, suffix) => {\n      const loadPlugin = (name, url) => {\n        PluginManager.load(name, url).catch(() => {\n          pluginLoadError(editor, url, name);\n        });\n      };\n      each$d(getExternalPlugins$1(editor), (url, name) => {\n        loadPlugin(name, url);\n        editor.options.set('plugins', getPlugins(editor).concat(name));\n      });\n      each$e(getPlugins(editor), plugin => {\n        plugin = Tools.trim(plugin);\n        if (plugin && !PluginManager.urls[plugin] && !hasSkipLoadPrefix(plugin)) {\n          loadPlugin(plugin, `plugins/${ plugin }/plugin${ suffix }.js`);\n        }\n      });\n    };\n    const isThemeLoaded = editor => {\n      const theme = getTheme(editor);\n      return !isString(theme) || isNonNullable(ThemeManager.get(theme));\n    };\n    const isModelLoaded = editor => {\n      const model = getModel(editor);\n      return isNonNullable(ModelManager.get(model));\n    };\n    const loadScripts = (editor, suffix) => {\n      const scriptLoader = ScriptLoader.ScriptLoader;\n      const initEditor = () => {\n        if (!editor.removed && isThemeLoaded(editor) && isModelLoaded(editor)) {\n          init(editor);\n        }\n      };\n      loadTheme(editor, suffix);\n      loadModel(editor, suffix);\n      loadLanguage(scriptLoader, editor);\n      loadIcons(scriptLoader, editor, suffix);\n      loadPlugins(editor, suffix);\n      scriptLoader.loadQueue().then(initEditor, initEditor);\n    };\n    const getStyleSheetLoader = (element, editor) => instance.forElement(element, {\n      contentCssCors: hasContentCssCors(editor),\n      referrerPolicy: getReferrerPolicy(editor)\n    });\n    const render = editor => {\n      const id = editor.id;\n      I18n.setCode(getLanguageCode(editor));\n      const readyHandler = () => {\n        DOM$3.unbind(window, 'ready', readyHandler);\n        editor.render();\n      };\n      if (!EventUtils.Event.domLoaded) {\n        DOM$3.bind(window, 'ready', readyHandler);\n        return;\n      }\n      if (!editor.getElement()) {\n        return;\n      }\n      const element = SugarElement.fromDom(editor.getElement());\n      const snapshot = clone$4(element);\n      editor.on('remove', () => {\n        eachr(element.dom.attributes, attr => remove$9(element, attr.name));\n        setAll$1(element, snapshot);\n      });\n      editor.ui.styleSheetLoader = getStyleSheetLoader(element, editor);\n      if (!isInline$1(editor)) {\n        editor.orgVisibility = editor.getElement().style.visibility;\n        editor.getElement().style.visibility = 'hidden';\n      } else {\n        editor.inline = true;\n      }\n      const form = editor.getElement().form || DOM$3.getParent(id, 'form');\n      if (form) {\n        editor.formElement = form;\n        if (hasHiddenInput(editor) && !isTextareaOrInput(editor.getElement())) {\n          DOM$3.insertAfter(DOM$3.create('input', {\n            type: 'hidden',\n            name: id\n          }), id);\n          editor.hasHiddenInput = true;\n        }\n        editor.formEventDelegate = e => {\n          editor.dispatch(e.type, e);\n        };\n        DOM$3.bind(form, 'submit reset', editor.formEventDelegate);\n        editor.on('reset', () => {\n          editor.resetContent();\n        });\n        if (shouldPatchSubmit(editor) && !form.submit.nodeType && !form.submit.length && !form._mceOldSubmit) {\n          form._mceOldSubmit = form.submit;\n          form.submit = () => {\n            editor.editorManager.triggerSave();\n            editor.setDirty(false);\n            return form._mceOldSubmit(form);\n          };\n        }\n      }\n      editor.windowManager = WindowManager(editor);\n      editor.notificationManager = NotificationManager(editor);\n      if (isEncodingXml(editor)) {\n        editor.on('GetContent', e => {\n          if (e.save) {\n            e.content = DOM$3.encode(e.content);\n          }\n        });\n      }\n      if (shouldAddFormSubmitTrigger(editor)) {\n        editor.on('submit', () => {\n          if (editor.initialized) {\n            editor.save();\n          }\n        });\n      }\n      if (shouldAddUnloadTrigger(editor)) {\n        editor._beforeUnload = () => {\n          if (editor.initialized && !editor.destroyed && !editor.isHidden()) {\n            editor.save({\n              format: 'raw',\n              no_events: true,\n              set_dirty: false\n            });\n          }\n        };\n        editor.editorManager.on('BeforeUnload', editor._beforeUnload);\n      }\n      editor.editorManager.add(editor);\n      loadScripts(editor, editor.suffix);\n    };\n\n    const setEditableRoot = (editor, state) => {\n      if (editor._editableRoot !== state) {\n        editor._editableRoot = state;\n        editor.getBody().contentEditable = String(editor.hasEditableRoot());\n        editor.nodeChanged();\n        fireEditableRootStateChange(editor, state);\n      }\n    };\n    const hasEditableRoot = editor => editor._editableRoot;\n\n    const sectionResult = (sections, settings) => ({\n      sections: constant(sections),\n      options: constant(settings)\n    });\n    const deviceDetection = detect$1().deviceType;\n    const isPhone = deviceDetection.isPhone();\n    const isTablet = deviceDetection.isTablet();\n    const normalizePlugins = plugins => {\n      if (isNullable(plugins)) {\n        return [];\n      } else {\n        const pluginNames = isArray$1(plugins) ? plugins : plugins.split(/[ ,]/);\n        const trimmedPlugins = map$3(pluginNames, trim$4);\n        return filter$5(trimmedPlugins, isNotEmpty);\n      }\n    };\n    const extractSections = (keys, options) => {\n      const result = bifilter(options, (value, key) => {\n        return contains$2(keys, key);\n      });\n      return sectionResult(result.t, result.f);\n    };\n    const getSection = (sectionResult, name, defaults = {}) => {\n      const sections = sectionResult.sections();\n      const sectionOptions = get$a(sections, name).getOr({});\n      return Tools.extend({}, defaults, sectionOptions);\n    };\n    const hasSection = (sectionResult, name) => {\n      return has$2(sectionResult.sections(), name);\n    };\n    const getSectionConfig = (sectionResult, name) => {\n      return hasSection(sectionResult, name) ? sectionResult.sections()[name] : {};\n    };\n    const getMobileOverrideOptions = (mobileOptions, isPhone) => {\n      const defaultMobileOptions = {\n        table_grid: false,\n        object_resizing: false,\n        resize: false,\n        toolbar_mode: get$a(mobileOptions, 'toolbar_mode').getOr('scrolling'),\n        toolbar_sticky: false\n      };\n      const defaultPhoneOptions = { menubar: false };\n      return {\n        ...defaultMobileOptions,\n        ...isPhone ? defaultPhoneOptions : {}\n      };\n    };\n    const getExternalPlugins = (overrideOptions, options) => {\n      var _a;\n      const userDefinedExternalPlugins = (_a = options.external_plugins) !== null && _a !== void 0 ? _a : {};\n      if (overrideOptions && overrideOptions.external_plugins) {\n        return Tools.extend({}, overrideOptions.external_plugins, userDefinedExternalPlugins);\n      } else {\n        return userDefinedExternalPlugins;\n      }\n    };\n    const combinePlugins = (forcedPlugins, plugins) => [\n      ...normalizePlugins(forcedPlugins),\n      ...normalizePlugins(plugins)\n    ];\n    const getPlatformPlugins = (isMobileDevice, sectionResult, desktopPlugins, mobilePlugins) => {\n      if (isMobileDevice && hasSection(sectionResult, 'mobile')) {\n        return mobilePlugins;\n      } else {\n        return desktopPlugins;\n      }\n    };\n    const processPlugins = (isMobileDevice, sectionResult, defaultOverrideOptions, options) => {\n      const forcedPlugins = normalizePlugins(defaultOverrideOptions.forced_plugins);\n      const desktopPlugins = normalizePlugins(options.plugins);\n      const mobileConfig = getSectionConfig(sectionResult, 'mobile');\n      const mobilePlugins = mobileConfig.plugins ? normalizePlugins(mobileConfig.plugins) : desktopPlugins;\n      const platformPlugins = getPlatformPlugins(isMobileDevice, sectionResult, desktopPlugins, mobilePlugins);\n      const combinedPlugins = combinePlugins(forcedPlugins, platformPlugins);\n      return Tools.extend(options, {\n        forced_plugins: forcedPlugins,\n        plugins: combinedPlugins\n      });\n    };\n    const isOnMobile = (isMobileDevice, sectionResult) => {\n      return isMobileDevice && hasSection(sectionResult, 'mobile');\n    };\n    const combineOptions = (isMobileDevice, isPhone, defaultOptions, defaultOverrideOptions, options) => {\n      var _a;\n      const deviceOverrideOptions = isMobileDevice ? { mobile: getMobileOverrideOptions((_a = options.mobile) !== null && _a !== void 0 ? _a : {}, isPhone) } : {};\n      const sectionResult = extractSections(['mobile'], deepMerge(deviceOverrideOptions, options));\n      const extendedOptions = Tools.extend(defaultOptions, defaultOverrideOptions, sectionResult.options(), isOnMobile(isMobileDevice, sectionResult) ? getSection(sectionResult, 'mobile') : {}, { external_plugins: getExternalPlugins(defaultOverrideOptions, sectionResult.options()) });\n      return processPlugins(isMobileDevice, sectionResult, defaultOverrideOptions, extendedOptions);\n    };\n    const normalizeOptions = (defaultOverrideOptions, options) => {\n      const copiedOptions = merge(options);\n      return combineOptions(isPhone || isTablet, isPhone, copiedOptions, defaultOverrideOptions, copiedOptions);\n    };\n\n    const addVisual = (editor, elm) => addVisual$1(editor, elm);\n\n    const registerExecCommands$2 = editor => {\n      const toggleFormat = (name, value) => {\n        editor.formatter.toggle(name, value);\n        editor.nodeChanged();\n      };\n      const toggleAlign = align => () => {\n        each$e('left,center,right,justify'.split(','), name => {\n          if (align !== name) {\n            editor.formatter.remove('align' + name);\n          }\n        });\n        if (align !== 'none') {\n          toggleFormat('align' + align);\n        }\n      };\n      editor.editorCommands.addCommands({\n        JustifyLeft: toggleAlign('left'),\n        JustifyCenter: toggleAlign('center'),\n        JustifyRight: toggleAlign('right'),\n        JustifyFull: toggleAlign('justify'),\n        JustifyNone: toggleAlign('none')\n      });\n    };\n    const registerQueryStateCommands = editor => {\n      const alignStates = name => () => {\n        const selection = editor.selection;\n        const nodes = selection.isCollapsed() ? [editor.dom.getParent(selection.getNode(), editor.dom.isBlock)] : selection.getSelectedBlocks();\n        return exists(nodes, node => isNonNullable(editor.formatter.matchNode(node, name)));\n      };\n      editor.editorCommands.addCommands({\n        JustifyLeft: alignStates('alignleft'),\n        JustifyCenter: alignStates('aligncenter'),\n        JustifyRight: alignStates('alignright'),\n        JustifyFull: alignStates('alignjustify')\n      }, 'state');\n    };\n    const registerCommands$a = editor => {\n      registerExecCommands$2(editor);\n      registerQueryStateCommands(editor);\n    };\n\n    const registerCommands$9 = editor => {\n      editor.editorCommands.addCommands({\n        'Cut,Copy,Paste': command => {\n          const doc = editor.getDoc();\n          let failed;\n          try {\n            doc.execCommand(command);\n          } catch (ex) {\n            failed = true;\n          }\n          if (command === 'paste' && !doc.queryCommandEnabled(command)) {\n            failed = true;\n          }\n          if (failed || !doc.queryCommandSupported(command)) {\n            let msg = editor.translate(`Your browser doesn't support direct access to the clipboard. ` + 'Please use the Ctrl+X/C/V keyboard shortcuts instead.');\n            if (Env.os.isMacOS() || Env.os.isiOS()) {\n              msg = msg.replace(/Ctrl\\+/g, '\\u2318+');\n            }\n            editor.notificationManager.open({\n              text: msg,\n              type: 'error'\n            });\n          }\n        }\n      });\n    };\n\n    const trimOrPadLeftRight = (dom, rng, html, schema) => {\n      const root = SugarElement.fromDom(dom.getRoot());\n      if (needsToBeNbspLeft(root, CaretPosition.fromRangeStart(rng), schema)) {\n        html = html.replace(/^ /, '&nbsp;');\n      } else {\n        html = html.replace(/^&nbsp;/, ' ');\n      }\n      if (needsToBeNbspRight(root, CaretPosition.fromRangeEnd(rng), schema)) {\n        html = html.replace(/(&nbsp;| )(<br( \\/)>)?$/, '&nbsp;');\n      } else {\n        html = html.replace(/&nbsp;(<br( \\/)?>)?$/, ' ');\n      }\n      return html;\n    };\n\n    const processValue$1 = value => {\n      if (typeof value !== 'string') {\n        const details = Tools.extend({\n          paste: value.paste,\n          data: { paste: value.paste }\n        }, value);\n        return {\n          content: value.content,\n          details\n        };\n      }\n      return {\n        content: value,\n        details: {}\n      };\n    };\n    const trimOrPad = (editor, value) => {\n      const selection = editor.selection;\n      const dom = editor.dom;\n      if (/^ | $/.test(value)) {\n        return trimOrPadLeftRight(dom, selection.getRng(), value, editor.schema);\n      } else {\n        return value;\n      }\n    };\n    const insertAtCaret = (editor, value) => {\n      if (editor.selection.isEditable()) {\n        const {content, details} = processValue$1(value);\n        preProcessSetContent(editor, {\n          ...details,\n          content: trimOrPad(editor, content),\n          format: 'html',\n          set: false,\n          selection: true\n        }).each(args => {\n          const insertedContent = insertContent$1(editor, args.content, details);\n          postProcessSetContent(editor, insertedContent, args);\n          editor.addVisual();\n        });\n      }\n    };\n\n    const registerCommands$8 = editor => {\n      editor.editorCommands.addCommands({\n        mceCleanup: () => {\n          const bm = editor.selection.getBookmark();\n          editor.setContent(editor.getContent());\n          editor.selection.moveToBookmark(bm);\n        },\n        insertImage: (_command, _ui, value) => {\n          insertAtCaret(editor, editor.dom.createHTML('img', { src: value }));\n        },\n        insertHorizontalRule: () => {\n          editor.execCommand('mceInsertContent', false, '<hr>');\n        },\n        insertText: (_command, _ui, value) => {\n          insertAtCaret(editor, editor.dom.encode(value));\n        },\n        insertHTML: (_command, _ui, value) => {\n          insertAtCaret(editor, value);\n        },\n        mceInsertContent: (_command, _ui, value) => {\n          insertAtCaret(editor, value);\n        },\n        mceSetContent: (_command, _ui, value) => {\n          editor.setContent(value);\n        },\n        mceReplaceContent: (_command, _ui, value) => {\n          editor.execCommand('mceInsertContent', false, value.replace(/\\{\\$selection\\}/g, editor.selection.getContent({ format: 'text' })));\n        },\n        mceNewDocument: () => {\n          editor.setContent(getNewDocumentContent(editor));\n        }\n      });\n    };\n\n    const legacyPropNames = {\n      'font-size': 'size',\n      'font-family': 'face'\n    };\n    const isFont = isTag('font');\n    const getSpecifiedFontProp = (propName, rootElm, elm) => {\n      const getProperty = elm => getRaw(elm, propName).orThunk(() => {\n        if (isFont(elm)) {\n          return get$a(legacyPropNames, propName).bind(legacyPropName => getOpt(elm, legacyPropName));\n        } else {\n          return Optional.none();\n        }\n      });\n      const isRoot = elm => eq(SugarElement.fromDom(rootElm), elm);\n      return closest$1(SugarElement.fromDom(elm), elm => getProperty(elm), isRoot);\n    };\n    const normalizeFontFamily = fontFamily => fontFamily.replace(/[\\'\\\"\\\\]/g, '').replace(/,\\s+/g, ',');\n    const getComputedFontProp = (propName, elm) => Optional.from(DOMUtils.DOM.getStyle(elm, propName, true));\n    const getFontProp = propName => (rootElm, elm) => Optional.from(elm).map(SugarElement.fromDom).filter(isElement$7).bind(element => getSpecifiedFontProp(propName, rootElm, element.dom).or(getComputedFontProp(propName, element.dom))).getOr('');\n    const getFontSize = getFontProp('font-size');\n    const getFontFamily = compose(normalizeFontFamily, getFontProp('font-family'));\n\n    const findFirstCaretElement = editor => firstPositionIn(editor.getBody()).bind(caret => {\n      const container = caret.container();\n      return Optional.from(isText$b(container) ? container.parentNode : container);\n    });\n    const getCaretElement = editor => Optional.from(editor.selection.getRng()).bind(rng => {\n      const root = editor.getBody();\n      const atStartOfNode = rng.startContainer === root && rng.startOffset === 0;\n      return atStartOfNode ? Optional.none() : Optional.from(editor.selection.getStart(true));\n    });\n    const bindRange = (editor, binder) => getCaretElement(editor).orThunk(curry(findFirstCaretElement, editor)).map(SugarElement.fromDom).filter(isElement$7).bind(binder);\n    const mapRange = (editor, mapper) => bindRange(editor, compose1(Optional.some, mapper));\n\n    const fromFontSizeNumber = (editor, value) => {\n      if (/^[0-9.]+$/.test(value)) {\n        const fontSizeNumber = parseInt(value, 10);\n        if (fontSizeNumber >= 1 && fontSizeNumber <= 7) {\n          const fontSizes = getFontStyleValues(editor);\n          const fontClasses = getFontSizeClasses(editor);\n          if (fontClasses.length > 0) {\n            return fontClasses[fontSizeNumber - 1] || value;\n          } else {\n            return fontSizes[fontSizeNumber - 1] || value;\n          }\n        } else {\n          return value;\n        }\n      } else {\n        return value;\n      }\n    };\n    const normalizeFontNames = font => {\n      const fonts = font.split(/\\s*,\\s*/);\n      return map$3(fonts, font => {\n        if (font.indexOf(' ') !== -1 && !(startsWith(font, '\"') || startsWith(font, `'`))) {\n          return `'${ font }'`;\n        } else {\n          return font;\n        }\n      }).join(',');\n    };\n    const fontNameAction = (editor, value) => {\n      const font = fromFontSizeNumber(editor, value);\n      editor.formatter.toggle('fontname', { value: normalizeFontNames(font) });\n      editor.nodeChanged();\n    };\n    const fontNameQuery = editor => mapRange(editor, elm => getFontFamily(editor.getBody(), elm.dom)).getOr('');\n    const fontSizeAction = (editor, value) => {\n      editor.formatter.toggle('fontsize', { value: fromFontSizeNumber(editor, value) });\n      editor.nodeChanged();\n    };\n    const fontSizeQuery = editor => mapRange(editor, elm => getFontSize(editor.getBody(), elm.dom)).getOr('');\n\n    const lineHeightQuery = editor => mapRange(editor, elm => {\n      const root = SugarElement.fromDom(editor.getBody());\n      const specifiedStyle = closest$1(elm, elm => getRaw(elm, 'line-height'), curry(eq, root));\n      const computedStyle = () => {\n        const lineHeight = parseFloat(get$7(elm, 'line-height'));\n        const fontSize = parseFloat(get$7(elm, 'font-size'));\n        return String(lineHeight / fontSize);\n      };\n      return specifiedStyle.getOrThunk(computedStyle);\n    }).getOr('');\n    const lineHeightAction = (editor, lineHeight) => {\n      editor.formatter.toggle('lineheight', { value: String(lineHeight) });\n      editor.nodeChanged();\n    };\n\n    const registerExecCommands$1 = editor => {\n      const toggleFormat = (name, value) => {\n        editor.formatter.toggle(name, value);\n        editor.nodeChanged();\n      };\n      editor.editorCommands.addCommands({\n        'Bold,Italic,Underline,Strikethrough,Superscript,Subscript': command => {\n          toggleFormat(command);\n        },\n        'ForeColor,HiliteColor': (command, _ui, value) => {\n          toggleFormat(command, { value });\n        },\n        'BackColor': (_command, _ui, value) => {\n          toggleFormat('hilitecolor', { value });\n        },\n        'FontName': (_command, _ui, value) => {\n          fontNameAction(editor, value);\n        },\n        'FontSize': (_command, _ui, value) => {\n          fontSizeAction(editor, value);\n        },\n        'LineHeight': (_command, _ui, value) => {\n          lineHeightAction(editor, value);\n        },\n        'Lang': (command, _ui, lang) => {\n          var _a;\n          toggleFormat(command, {\n            value: lang.code,\n            customValue: (_a = lang.customCode) !== null && _a !== void 0 ? _a : null\n          });\n        },\n        'RemoveFormat': command => {\n          editor.formatter.remove(command);\n        },\n        'mceBlockQuote': () => {\n          toggleFormat('blockquote');\n        },\n        'FormatBlock': (_command, _ui, value) => {\n          toggleFormat(isString(value) ? value : 'p');\n        },\n        'mceToggleFormat': (_command, _ui, value) => {\n          toggleFormat(value);\n        }\n      });\n    };\n    const registerQueryValueCommands = editor => {\n      const isFormatMatch = name => editor.formatter.match(name);\n      editor.editorCommands.addCommands({\n        'Bold,Italic,Underline,Strikethrough,Superscript,Subscript': command => isFormatMatch(command),\n        'mceBlockQuote': () => isFormatMatch('blockquote')\n      }, 'state');\n      editor.editorCommands.addQueryValueHandler('FontName', () => fontNameQuery(editor));\n      editor.editorCommands.addQueryValueHandler('FontSize', () => fontSizeQuery(editor));\n      editor.editorCommands.addQueryValueHandler('LineHeight', () => lineHeightQuery(editor));\n    };\n    const registerCommands$7 = editor => {\n      registerExecCommands$1(editor);\n      registerQueryValueCommands(editor);\n    };\n\n    const registerCommands$6 = editor => {\n      editor.editorCommands.addCommands({\n        mceAddUndoLevel: () => {\n          editor.undoManager.add();\n        },\n        mceEndUndoLevel: () => {\n          editor.undoManager.add();\n        },\n        Undo: () => {\n          editor.undoManager.undo();\n        },\n        Redo: () => {\n          editor.undoManager.redo();\n        }\n      });\n    };\n\n    const registerCommands$5 = editor => {\n      editor.editorCommands.addCommands({\n        Indent: () => {\n          indent(editor);\n        },\n        Outdent: () => {\n          outdent(editor);\n        }\n      });\n      editor.editorCommands.addCommands({ Outdent: () => canOutdent(editor) }, 'state');\n    };\n\n    const registerCommands$4 = editor => {\n      const applyLinkToSelection = (_command, _ui, value) => {\n        if (editor.mode.isReadOnly()) {\n          return;\n        }\n        const linkDetails = isString(value) ? { href: value } : value;\n        const anchor = editor.dom.getParent(editor.selection.getNode(), 'a');\n        if (isObject(linkDetails) && isString(linkDetails.href)) {\n          linkDetails.href = linkDetails.href.replace(/ /g, '%20');\n          if (!anchor || !linkDetails.href) {\n            editor.formatter.remove('link');\n          }\n          if (linkDetails.href) {\n            editor.formatter.apply('link', linkDetails, anchor);\n          }\n        }\n      };\n      editor.editorCommands.addCommands({\n        unlink: () => {\n          if (editor.selection.isEditable()) {\n            if (editor.selection.isCollapsed()) {\n              const elm = editor.dom.getParent(editor.selection.getStart(), 'a');\n              if (elm) {\n                editor.dom.remove(elm, true);\n              }\n              return;\n            }\n            editor.formatter.remove('link');\n          }\n        },\n        mceInsertLink: applyLinkToSelection,\n        createLink: applyLinkToSelection\n      });\n    };\n\n    const getTopParentBlock = (editor, node, root, container) => {\n      const dom = editor.dom;\n      const selector = node => dom.isBlock(node) && node.parentElement === root;\n      const topParentBlock = selector(node) ? node : dom.getParent(container, selector, root);\n      return Optional.from(topParentBlock).map(SugarElement.fromDom);\n    };\n    const insert = (editor, before) => {\n      if (editor.mode.isReadOnly()) {\n        return;\n      }\n      const dom = editor.dom;\n      const rng = editor.selection.getRng();\n      const node = before ? editor.selection.getStart() : editor.selection.getEnd();\n      const container = before ? rng.startContainer : rng.endContainer;\n      const root = getEditableRoot(dom, container);\n      if (!root || !root.isContentEditable) {\n        return;\n      }\n      const insertFn = before ? before$3 : after$4;\n      const newBlockName = getForcedRootBlock(editor);\n      getTopParentBlock(editor, node, root, container).each(parentBlock => {\n        const newBlock = createNewBlock(editor, container, parentBlock.dom, root, false, newBlockName);\n        insertFn(parentBlock, SugarElement.fromDom(newBlock));\n        editor.selection.setCursorLocation(newBlock, 0);\n        editor.dispatch('NewBlock', { newBlock });\n        fireInputEvent(editor, 'insertParagraph');\n      });\n    };\n    const insertBefore = editor => insert(editor, true);\n    const insertAfter = editor => insert(editor, false);\n\n    const registerCommands$3 = editor => {\n      editor.editorCommands.addCommands({\n        InsertNewBlockBefore: () => {\n          insertBefore(editor);\n        },\n        InsertNewBlockAfter: () => {\n          insertAfter(editor);\n        }\n      });\n    };\n\n    const registerCommands$2 = editor => {\n      editor.editorCommands.addCommands({\n        insertParagraph: () => {\n          insertBreak(blockbreak, editor);\n        },\n        mceInsertNewLine: (_command, _ui, value) => {\n          insert$1(editor, value);\n        },\n        InsertLineBreak: (_command, _ui, _value) => {\n          insertBreak(linebreak, editor);\n        }\n      });\n    };\n\n    const registerCommands$1 = editor => {\n      editor.editorCommands.addCommands({\n        mceSelectNodeDepth: (_command, _ui, value) => {\n          let counter = 0;\n          editor.dom.getParent(editor.selection.getNode(), node => {\n            if (isElement$6(node) && counter++ === value) {\n              editor.selection.select(node);\n              return false;\n            } else {\n              return true;\n            }\n          }, editor.getBody());\n        },\n        mceSelectNode: (_command, _ui, value) => {\n          editor.selection.select(value);\n        },\n        selectAll: () => {\n          const editingHost = editor.dom.getParent(editor.selection.getStart(), isContentEditableTrue$3);\n          if (editingHost) {\n            const rng = editor.dom.createRng();\n            rng.selectNodeContents(editingHost);\n            editor.selection.setRng(rng);\n          }\n        }\n      });\n    };\n\n    const registerExecCommands = editor => {\n      editor.editorCommands.addCommands({\n        mceRemoveNode: (_command, _ui, value) => {\n          const node = value !== null && value !== void 0 ? value : editor.selection.getNode();\n          if (node !== editor.getBody()) {\n            const bm = editor.selection.getBookmark();\n            editor.dom.remove(node, true);\n            editor.selection.moveToBookmark(bm);\n          }\n        },\n        mcePrint: () => {\n          editor.getWin().print();\n        },\n        mceFocus: (_command, _ui, value) => {\n          focus(editor, value === true);\n        },\n        mceToggleVisualAid: () => {\n          editor.hasVisual = !editor.hasVisual;\n          editor.addVisual();\n        }\n      });\n    };\n    const registerCommands = editor => {\n      registerCommands$a(editor);\n      registerCommands$9(editor);\n      registerCommands$6(editor);\n      registerCommands$1(editor);\n      registerCommands$8(editor);\n      registerCommands$4(editor);\n      registerCommands$5(editor);\n      registerCommands$3(editor);\n      registerCommands$2(editor);\n      registerCommands$7(editor);\n      registerExecCommands(editor);\n    };\n\n    const selectionSafeCommands = ['toggleview'];\n    const isSelectionSafeCommand = command => contains$2(selectionSafeCommands, command.toLowerCase());\n    class EditorCommands {\n      constructor(editor) {\n        this.commands = {\n          state: {},\n          exec: {},\n          value: {}\n        };\n        this.editor = editor;\n      }\n      execCommand(command, ui = false, value, args) {\n        const editor = this.editor;\n        const lowerCaseCommand = command.toLowerCase();\n        const skipFocus = args === null || args === void 0 ? void 0 : args.skip_focus;\n        if (editor.removed) {\n          return false;\n        }\n        if (lowerCaseCommand !== 'mcefocus') {\n          if (!/^(mceAddUndoLevel|mceEndUndoLevel)$/i.test(lowerCaseCommand) && !skipFocus) {\n            editor.focus();\n          } else {\n            restore(editor);\n          }\n        }\n        const eventArgs = editor.dispatch('BeforeExecCommand', {\n          command,\n          ui,\n          value\n        });\n        if (eventArgs.isDefaultPrevented()) {\n          return false;\n        }\n        const func = this.commands.exec[lowerCaseCommand];\n        if (isFunction(func)) {\n          func(lowerCaseCommand, ui, value);\n          editor.dispatch('ExecCommand', {\n            command,\n            ui,\n            value\n          });\n          return true;\n        }\n        return false;\n      }\n      queryCommandState(command) {\n        if (!isSelectionSafeCommand(command) && this.editor.quirks.isHidden() || this.editor.removed) {\n          return false;\n        }\n        const lowerCaseCommand = command.toLowerCase();\n        const func = this.commands.state[lowerCaseCommand];\n        if (isFunction(func)) {\n          return func(lowerCaseCommand);\n        }\n        return false;\n      }\n      queryCommandValue(command) {\n        if (!isSelectionSafeCommand(command) && this.editor.quirks.isHidden() || this.editor.removed) {\n          return '';\n        }\n        const lowerCaseCommand = command.toLowerCase();\n        const func = this.commands.value[lowerCaseCommand];\n        if (isFunction(func)) {\n          return func(lowerCaseCommand);\n        }\n        return '';\n      }\n      addCommands(commandList, type = 'exec') {\n        const commands = this.commands;\n        each$d(commandList, (callback, command) => {\n          each$e(command.toLowerCase().split(','), command => {\n            commands[type][command] = callback;\n          });\n        });\n      }\n      addCommand(command, callback, scope) {\n        const lowerCaseCommand = command.toLowerCase();\n        this.commands.exec[lowerCaseCommand] = (_command, ui, value) => callback.call(scope !== null && scope !== void 0 ? scope : this.editor, ui, value);\n      }\n      queryCommandSupported(command) {\n        const lowerCaseCommand = command.toLowerCase();\n        if (this.commands.exec[lowerCaseCommand]) {\n          return true;\n        } else {\n          return false;\n        }\n      }\n      addQueryStateHandler(command, callback, scope) {\n        this.commands.state[command.toLowerCase()] = () => callback.call(scope !== null && scope !== void 0 ? scope : this.editor);\n      }\n      addQueryValueHandler(command, callback, scope) {\n        this.commands.value[command.toLowerCase()] = () => callback.call(scope !== null && scope !== void 0 ? scope : this.editor);\n      }\n    }\n\n    const toggleClass = (elm, cls, state) => {\n      if (has(elm, cls) && !state) {\n        remove$6(elm, cls);\n      } else if (state) {\n        add$2(elm, cls);\n      }\n    };\n    const setEditorCommandState = (editor, cmd, state) => {\n      try {\n        editor.getDoc().execCommand(cmd, false, String(state));\n      } catch (ex) {\n      }\n    };\n    const setContentEditable = (elm, state) => {\n      elm.dom.contentEditable = state ? 'true' : 'false';\n    };\n    const removeFakeSelection = editor => {\n      Optional.from(editor.selection.getNode()).each(elm => {\n        elm.removeAttribute('data-mce-selected');\n      });\n    };\n    const restoreFakeSelection = editor => {\n      editor.selection.setRng(editor.selection.getRng());\n    };\n    const setCommonEditorCommands = (editor, state) => {\n      setEditorCommandState(editor, 'StyleWithCSS', state);\n      setEditorCommandState(editor, 'enableInlineTableEditing', state);\n      setEditorCommandState(editor, 'enableObjectResizing', state);\n    };\n    const setEditorReadonly = editor => {\n      editor.readonly = true;\n      editor.selection.controlSelection.hideResizeRect();\n      editor._selectionOverrides.hideFakeCaret();\n      removeFakeSelection(editor);\n    };\n    const unsetEditorReadonly = (editor, body) => {\n      editor.readonly = false;\n      if (editor.hasEditableRoot()) {\n        setContentEditable(body, true);\n      }\n      setCommonEditorCommands(editor, false);\n      if (hasEditorOrUiFocus(editor)) {\n        editor.focus();\n      }\n      restoreFakeSelection(editor);\n      editor.nodeChanged();\n    };\n    const toggleReadOnly = (editor, state) => {\n      const body = SugarElement.fromDom(editor.getBody());\n      toggleClass(body, 'mce-content-readonly', state);\n      if (state) {\n        setEditorReadonly(editor);\n        if (editor.hasEditableRoot()) {\n          setContentEditable(body, true);\n        }\n      } else {\n        unsetEditorReadonly(editor, body);\n      }\n    };\n    const isReadOnly = editor => editor.readonly;\n    const isClickEvent = e => e.type === 'click';\n    const allowedEvents = ['copy'];\n    const isReadOnlyAllowedEvent = e => contains$2(allowedEvents, e.type);\n    const getAnchorHrefOpt = (editor, elm) => {\n      const isRoot = elm => eq(elm, SugarElement.fromDom(editor.getBody()));\n      return closest$3(elm, 'a', isRoot).bind(a => getOpt(a, 'href'));\n    };\n    const processReadonlyEvents = (editor, e) => {\n      if (isClickEvent(e) && !VK.metaKeyPressed(e)) {\n        const elm = SugarElement.fromDom(e.target);\n        getAnchorHrefOpt(editor, elm).each(href => {\n          e.preventDefault();\n          if (/^#/.test(href)) {\n            const targetEl = editor.dom.select(`${ href },[name=\"${ removeLeading(href, '#') }\"]`);\n            if (targetEl.length) {\n              editor.selection.scrollIntoView(targetEl[0], true);\n            }\n          } else {\n            window.open(href, '_blank', 'rel=noopener noreferrer,menubar=yes,toolbar=yes,location=yes,status=yes,resizable=yes,scrollbars=yes');\n          }\n        });\n      } else if (isReadOnlyAllowedEvent(e)) {\n        editor.dispatch(e.type, e);\n      }\n    };\n    const registerReadOnlySelectionBlockers = editor => {\n      editor.on('beforeinput paste cut dragend dragover draggesture dragdrop drop drag', e => {\n        if (isReadOnly(editor)) {\n          e.preventDefault();\n        }\n      });\n      editor.on('BeforeExecCommand', e => {\n        if ((e.command === 'Undo' || e.command === 'Redo') && isReadOnly(editor)) {\n          e.preventDefault();\n        }\n      });\n      editor.on('input', e => {\n        if (!e.isComposing && isReadOnly(editor)) {\n          const undoLevel = editor.undoManager.add();\n          if (isNonNullable(undoLevel)) {\n            editor.undoManager.undo();\n          }\n        }\n      });\n      editor.on('compositionend', () => {\n        if (isReadOnly(editor)) {\n          const undoLevel = editor.undoManager.add();\n          if (isNonNullable(undoLevel)) {\n            editor.undoManager.undo();\n          }\n        }\n      });\n    };\n\n    const nativeEvents = Tools.makeMap('focus blur focusin focusout click dblclick mousedown mouseup mousemove mouseover beforepaste paste cut copy selectionchange ' + 'mouseout mouseenter mouseleave wheel keydown keypress keyup input beforeinput contextmenu dragstart dragend dragover ' + 'draggesture dragdrop drop drag submit ' + 'compositionstart compositionend compositionupdate touchstart touchmove touchend touchcancel', ' ');\n    class EventDispatcher {\n      static isNative(name) {\n        return !!nativeEvents[name.toLowerCase()];\n      }\n      constructor(settings) {\n        this.bindings = {};\n        this.settings = settings || {};\n        this.scope = this.settings.scope || this;\n        this.toggleEvent = this.settings.toggleEvent || never;\n      }\n      fire(name, args) {\n        return this.dispatch(name, args);\n      }\n      dispatch(name, args) {\n        const lcName = name.toLowerCase();\n        const event = normalize$3(lcName, args !== null && args !== void 0 ? args : {}, this.scope);\n        if (this.settings.beforeFire) {\n          this.settings.beforeFire(event);\n        }\n        const handlers = this.bindings[lcName];\n        if (handlers) {\n          for (let i = 0, l = handlers.length; i < l; i++) {\n            const callback = handlers[i];\n            if (callback.removed) {\n              continue;\n            }\n            if (callback.once) {\n              this.off(lcName, callback.func);\n            }\n            if (event.isImmediatePropagationStopped()) {\n              return event;\n            }\n            if (callback.func.call(this.scope, event) === false) {\n              event.preventDefault();\n              return event;\n            }\n          }\n        }\n        return event;\n      }\n      on(name, callback, prepend, extra) {\n        if (callback === false) {\n          callback = never;\n        }\n        if (callback) {\n          const wrappedCallback = {\n            func: callback,\n            removed: false\n          };\n          if (extra) {\n            Tools.extend(wrappedCallback, extra);\n          }\n          const names = name.toLowerCase().split(' ');\n          let i = names.length;\n          while (i--) {\n            const currentName = names[i];\n            let handlers = this.bindings[currentName];\n            if (!handlers) {\n              handlers = [];\n              this.toggleEvent(currentName, true);\n            }\n            if (prepend) {\n              handlers = [\n                wrappedCallback,\n                ...handlers\n              ];\n            } else {\n              handlers = [\n                ...handlers,\n                wrappedCallback\n              ];\n            }\n            this.bindings[currentName] = handlers;\n          }\n        }\n        return this;\n      }\n      off(name, callback) {\n        if (name) {\n          const names = name.toLowerCase().split(' ');\n          let i = names.length;\n          while (i--) {\n            const currentName = names[i];\n            let handlers = this.bindings[currentName];\n            if (!currentName) {\n              each$d(this.bindings, (_value, bindingName) => {\n                this.toggleEvent(bindingName, false);\n                delete this.bindings[bindingName];\n              });\n              return this;\n            }\n            if (handlers) {\n              if (!callback) {\n                handlers.length = 0;\n              } else {\n                const filteredHandlers = partition$2(handlers, handler => handler.func === callback);\n                handlers = filteredHandlers.fail;\n                this.bindings[currentName] = handlers;\n                each$e(filteredHandlers.pass, handler => {\n                  handler.removed = true;\n                });\n              }\n              if (!handlers.length) {\n                this.toggleEvent(name, false);\n                delete this.bindings[currentName];\n              }\n            }\n          }\n        } else {\n          each$d(this.bindings, (_value, name) => {\n            this.toggleEvent(name, false);\n          });\n          this.bindings = {};\n        }\n        return this;\n      }\n      once(name, callback, prepend) {\n        return this.on(name, callback, prepend, { once: true });\n      }\n      has(name) {\n        name = name.toLowerCase();\n        const binding = this.bindings[name];\n        return !(!binding || binding.length === 0);\n      }\n    }\n\n    const getEventDispatcher = obj => {\n      if (!obj._eventDispatcher) {\n        obj._eventDispatcher = new EventDispatcher({\n          scope: obj,\n          toggleEvent: (name, state) => {\n            if (EventDispatcher.isNative(name) && obj.toggleNativeEvent) {\n              obj.toggleNativeEvent(name, state);\n            }\n          }\n        });\n      }\n      return obj._eventDispatcher;\n    };\n    const Observable = {\n      fire(name, args, bubble) {\n        return this.dispatch(name, args, bubble);\n      },\n      dispatch(name, args, bubble) {\n        const self = this;\n        if (self.removed && name !== 'remove' && name !== 'detach') {\n          return normalize$3(name.toLowerCase(), args !== null && args !== void 0 ? args : {}, self);\n        }\n        const dispatcherArgs = getEventDispatcher(self).dispatch(name, args);\n        if (bubble !== false && self.parent) {\n          let parent = self.parent();\n          while (parent && !dispatcherArgs.isPropagationStopped()) {\n            parent.dispatch(name, dispatcherArgs, false);\n            parent = parent.parent ? parent.parent() : undefined;\n          }\n        }\n        return dispatcherArgs;\n      },\n      on(name, callback, prepend) {\n        return getEventDispatcher(this).on(name, callback, prepend);\n      },\n      off(name, callback) {\n        return getEventDispatcher(this).off(name, callback);\n      },\n      once(name, callback) {\n        return getEventDispatcher(this).once(name, callback);\n      },\n      hasEventListeners(name) {\n        return getEventDispatcher(this).has(name);\n      }\n    };\n\n    const DOM$2 = DOMUtils.DOM;\n    let customEventRootDelegates;\n    const getEventTarget = (editor, eventName) => {\n      if (eventName === 'selectionchange') {\n        return editor.getDoc();\n      }\n      if (!editor.inline && /^(?:mouse|touch|click|contextmenu|drop|dragover|dragend)/.test(eventName)) {\n        return editor.getDoc().documentElement;\n      }\n      const eventRoot = getEventRoot(editor);\n      if (eventRoot) {\n        if (!editor.eventRoot) {\n          editor.eventRoot = DOM$2.select(eventRoot)[0];\n        }\n        return editor.eventRoot;\n      }\n      return editor.getBody();\n    };\n    const isListening = editor => !editor.hidden;\n    const fireEvent = (editor, eventName, e) => {\n      if (isListening(editor)) {\n        editor.dispatch(eventName, e);\n      } else if (isReadOnly(editor)) {\n        processReadonlyEvents(editor, e);\n      }\n    };\n    const bindEventDelegate = (editor, eventName) => {\n      if (!editor.delegates) {\n        editor.delegates = {};\n      }\n      if (editor.delegates[eventName] || editor.removed) {\n        return;\n      }\n      const eventRootElm = getEventTarget(editor, eventName);\n      if (getEventRoot(editor)) {\n        if (!customEventRootDelegates) {\n          customEventRootDelegates = {};\n          editor.editorManager.on('removeEditor', () => {\n            if (!editor.editorManager.activeEditor) {\n              if (customEventRootDelegates) {\n                each$d(customEventRootDelegates, (_value, name) => {\n                  editor.dom.unbind(getEventTarget(editor, name));\n                });\n                customEventRootDelegates = null;\n              }\n            }\n          });\n        }\n        if (customEventRootDelegates[eventName]) {\n          return;\n        }\n        const delegate = e => {\n          const target = e.target;\n          const editors = editor.editorManager.get();\n          let i = editors.length;\n          while (i--) {\n            const body = editors[i].getBody();\n            if (body === target || DOM$2.isChildOf(target, body)) {\n              fireEvent(editors[i], eventName, e);\n            }\n          }\n        };\n        customEventRootDelegates[eventName] = delegate;\n        DOM$2.bind(eventRootElm, eventName, delegate);\n      } else {\n        const delegate = e => {\n          fireEvent(editor, eventName, e);\n        };\n        DOM$2.bind(eventRootElm, eventName, delegate);\n        editor.delegates[eventName] = delegate;\n      }\n    };\n    const EditorObservable = {\n      ...Observable,\n      bindPendingEventDelegates() {\n        const self = this;\n        Tools.each(self._pendingNativeEvents, name => {\n          bindEventDelegate(self, name);\n        });\n      },\n      toggleNativeEvent(name, state) {\n        const self = this;\n        if (name === 'focus' || name === 'blur') {\n          return;\n        }\n        if (self.removed) {\n          return;\n        }\n        if (state) {\n          if (self.initialized) {\n            bindEventDelegate(self, name);\n          } else {\n            if (!self._pendingNativeEvents) {\n              self._pendingNativeEvents = [name];\n            } else {\n              self._pendingNativeEvents.push(name);\n            }\n          }\n        } else if (self.initialized && self.delegates) {\n          self.dom.unbind(getEventTarget(self, name), name, self.delegates[name]);\n          delete self.delegates[name];\n        }\n      },\n      unbindAllNativeEvents() {\n        const self = this;\n        const body = self.getBody();\n        const dom = self.dom;\n        if (self.delegates) {\n          each$d(self.delegates, (value, name) => {\n            self.dom.unbind(getEventTarget(self, name), name, value);\n          });\n          delete self.delegates;\n        }\n        if (!self.inline && body && dom) {\n          body.onload = null;\n          dom.unbind(self.getWin());\n          dom.unbind(self.getDoc());\n        }\n        if (dom) {\n          dom.unbind(body);\n          dom.unbind(self.getContainer());\n        }\n      }\n    };\n\n    const stringListProcessor = value => {\n      if (isString(value)) {\n        return {\n          value: value.split(/[ ,]/),\n          valid: true\n        };\n      } else if (isArrayOf(value, isString)) {\n        return {\n          value,\n          valid: true\n        };\n      } else {\n        return {\n          valid: false,\n          message: `The value must be a string[] or a comma/space separated string.`\n        };\n      }\n    };\n    const getBuiltInProcessor = type => {\n      const validator = (() => {\n        switch (type) {\n        case 'array':\n          return isArray$1;\n        case 'boolean':\n          return isBoolean;\n        case 'function':\n          return isFunction;\n        case 'number':\n          return isNumber;\n        case 'object':\n          return isObject;\n        case 'string':\n          return isString;\n        case 'string[]':\n          return stringListProcessor;\n        case 'object[]':\n          return val => isArrayOf(val, isObject);\n        case 'regexp':\n          return val => is$4(val, RegExp);\n        default:\n          return always;\n        }\n      })();\n      return value => processValue(value, validator, `The value must be a ${ type }.`);\n    };\n    const isBuiltInSpec = spec => isString(spec.processor);\n    const getErrorMessage = (message, result) => {\n      const additionalText = isEmpty$3(result.message) ? '' : `. ${ result.message }`;\n      return message + additionalText;\n    };\n    const isValidResult = result => result.valid;\n    const processValue = (value, processor, message = '') => {\n      const result = processor(value);\n      if (isBoolean(result)) {\n        return result ? {\n          value: value,\n          valid: true\n        } : {\n          valid: false,\n          message\n        };\n      } else {\n        return result;\n      }\n    };\n    const processDefaultValue = (name, defaultValue, processor) => {\n      if (!isUndefined(defaultValue)) {\n        const result = processValue(defaultValue, processor);\n        if (isValidResult(result)) {\n          return result.value;\n        } else {\n          console.error(getErrorMessage(`Invalid default value passed for the \"${ name }\" option`, result));\n        }\n      }\n      return undefined;\n    };\n    const create$5 = (editor, initialOptions, rawInitialOptions = initialOptions) => {\n      const registry = {};\n      const values = {};\n      const setValue = (name, value, processor) => {\n        const result = processValue(value, processor);\n        if (isValidResult(result)) {\n          values[name] = result.value;\n          return true;\n        } else {\n          console.warn(getErrorMessage(`Invalid value passed for the ${ name } option`, result));\n          return false;\n        }\n      };\n      const register = (name, spec) => {\n        const processor = isBuiltInSpec(spec) ? getBuiltInProcessor(spec.processor) : spec.processor;\n        const defaultValue = processDefaultValue(name, spec.default, processor);\n        registry[name] = {\n          ...spec,\n          default: defaultValue,\n          processor\n        };\n        const initValue = get$a(values, name).orThunk(() => get$a(initialOptions, name));\n        initValue.each(value => setValue(name, value, processor));\n      };\n      const isRegistered = name => has$2(registry, name);\n      const get = name => get$a(values, name).orThunk(() => get$a(registry, name).map(spec => spec.default)).getOrUndefined();\n      const set = (name, value) => {\n        if (!isRegistered(name)) {\n          console.warn(`\"${ name }\" is not a registered option. Ensure the option has been registered before setting a value.`);\n          return false;\n        } else {\n          const spec = registry[name];\n          if (spec.immutable) {\n            console.error(`\"${ name }\" is an immutable option and cannot be updated`);\n            return false;\n          } else {\n            return setValue(name, value, spec.processor);\n          }\n        }\n      };\n      const unset = name => {\n        const registered = isRegistered(name);\n        if (registered) {\n          delete values[name];\n        }\n        return registered;\n      };\n      const isSet = name => has$2(values, name);\n      const debug = () => {\n        try {\n          console.log(JSON.parse(JSON.stringify(rawInitialOptions, (_key, value) => {\n            if (isBoolean(value) || isNumber(value) || isString(value) || isNull(value) || isArray$1(value) || isPlainObject(value)) {\n              return value;\n            }\n            return Object.prototype.toString.call(value);\n          })));\n        } catch (error) {\n          console.error(error);\n        }\n      };\n      return {\n        register,\n        isRegistered,\n        get,\n        set,\n        unset,\n        isSet,\n        debug\n      };\n    };\n\n    const defaultModes = [\n      'design',\n      'readonly'\n    ];\n    const switchToMode = (editor, activeMode, availableModes, mode) => {\n      const oldMode = availableModes[activeMode.get()];\n      const newMode = availableModes[mode];\n      try {\n        newMode.activate();\n      } catch (e) {\n        console.error(`problem while activating editor mode ${ mode }:`, e);\n        return;\n      }\n      oldMode.deactivate();\n      if (oldMode.editorReadOnly !== newMode.editorReadOnly) {\n        toggleReadOnly(editor, newMode.editorReadOnly);\n      }\n      activeMode.set(mode);\n      fireSwitchMode(editor, mode);\n    };\n    const setMode = (editor, availableModes, activeMode, mode) => {\n      if (mode === activeMode.get()) {\n        return;\n      } else if (!has$2(availableModes, mode)) {\n        throw new Error(`Editor mode '${ mode }' is invalid`);\n      }\n      if (editor.initialized) {\n        switchToMode(editor, activeMode, availableModes, mode);\n      } else {\n        editor.on('init', () => switchToMode(editor, activeMode, availableModes, mode));\n      }\n    };\n    const registerMode = (availableModes, mode, api) => {\n      if (contains$2(defaultModes, mode)) {\n        throw new Error(`Cannot override default mode ${ mode }`);\n      }\n      return {\n        ...availableModes,\n        [mode]: {\n          ...api,\n          deactivate: () => {\n            try {\n              api.deactivate();\n            } catch (e) {\n              console.error(`problem while deactivating editor mode ${ mode }:`, e);\n            }\n          }\n        }\n      };\n    };\n\n    const create$4 = editor => {\n      const activeMode = Cell('design');\n      const availableModes = Cell({\n        design: {\n          activate: noop,\n          deactivate: noop,\n          editorReadOnly: false\n        },\n        readonly: {\n          activate: noop,\n          deactivate: noop,\n          editorReadOnly: true\n        }\n      });\n      registerReadOnlySelectionBlockers(editor);\n      return {\n        isReadOnly: () => isReadOnly(editor),\n        set: mode => setMode(editor, availableModes.get(), activeMode, mode),\n        get: () => activeMode.get(),\n        register: (mode, api) => {\n          availableModes.set(registerMode(availableModes.get(), mode, api));\n        }\n      };\n    };\n\n    const each$2 = Tools.each, explode = Tools.explode;\n    const keyCodeLookup = {\n      f1: 112,\n      f2: 113,\n      f3: 114,\n      f4: 115,\n      f5: 116,\n      f6: 117,\n      f7: 118,\n      f8: 119,\n      f9: 120,\n      f10: 121,\n      f11: 122,\n      f12: 123\n    };\n    const modifierNames = Tools.makeMap('alt,ctrl,shift,meta,access');\n    const isModifier = key => key in modifierNames;\n    const parseShortcut = pattern => {\n      const shortcut = {};\n      const isMac = Env.os.isMacOS() || Env.os.isiOS();\n      each$2(explode(pattern.toLowerCase(), '+'), value => {\n        if (isModifier(value)) {\n          shortcut[value] = true;\n        } else {\n          if (/^[0-9]{2,}$/.test(value)) {\n            shortcut.keyCode = parseInt(value, 10);\n          } else {\n            shortcut.charCode = value.charCodeAt(0);\n            shortcut.keyCode = keyCodeLookup[value] || value.toUpperCase().charCodeAt(0);\n          }\n        }\n      });\n      const id = [shortcut.keyCode];\n      let key;\n      for (key in modifierNames) {\n        if (shortcut[key]) {\n          id.push(key);\n        } else {\n          shortcut[key] = false;\n        }\n      }\n      shortcut.id = id.join(',');\n      if (shortcut.access) {\n        shortcut.alt = true;\n        if (isMac) {\n          shortcut.ctrl = true;\n        } else {\n          shortcut.shift = true;\n        }\n      }\n      if (shortcut.meta) {\n        if (isMac) {\n          shortcut.meta = true;\n        } else {\n          shortcut.ctrl = true;\n          shortcut.meta = false;\n        }\n      }\n      return shortcut;\n    };\n    class Shortcuts {\n      constructor(editor) {\n        this.shortcuts = {};\n        this.pendingPatterns = [];\n        this.editor = editor;\n        const self = this;\n        editor.on('keyup keypress keydown', e => {\n          if ((self.hasModifier(e) || self.isFunctionKey(e)) && !e.isDefaultPrevented()) {\n            each$2(self.shortcuts, shortcut => {\n              if (self.matchShortcut(e, shortcut)) {\n                self.pendingPatterns = shortcut.subpatterns.slice(0);\n                if (e.type === 'keydown') {\n                  self.executeShortcutAction(shortcut);\n                }\n              }\n            });\n            if (self.matchShortcut(e, self.pendingPatterns[0])) {\n              if (self.pendingPatterns.length === 1) {\n                if (e.type === 'keydown') {\n                  self.executeShortcutAction(self.pendingPatterns[0]);\n                }\n              }\n              self.pendingPatterns.shift();\n            }\n          }\n        });\n      }\n      add(pattern, desc, cmdFunc, scope) {\n        const self = this;\n        const func = self.normalizeCommandFunc(cmdFunc);\n        each$2(explode(Tools.trim(pattern)), pattern => {\n          const shortcut = self.createShortcut(pattern, desc, func, scope);\n          self.shortcuts[shortcut.id] = shortcut;\n        });\n        return true;\n      }\n      remove(pattern) {\n        const shortcut = this.createShortcut(pattern);\n        if (this.shortcuts[shortcut.id]) {\n          delete this.shortcuts[shortcut.id];\n          return true;\n        }\n        return false;\n      }\n      normalizeCommandFunc(cmdFunc) {\n        const self = this;\n        const cmd = cmdFunc;\n        if (typeof cmd === 'string') {\n          return () => {\n            self.editor.execCommand(cmd, false, null);\n          };\n        } else if (Tools.isArray(cmd)) {\n          return () => {\n            self.editor.execCommand(cmd[0], cmd[1], cmd[2]);\n          };\n        } else {\n          return cmd;\n        }\n      }\n      createShortcut(pattern, desc, cmdFunc, scope) {\n        const shortcuts = Tools.map(explode(pattern, '>'), parseShortcut);\n        shortcuts[shortcuts.length - 1] = Tools.extend(shortcuts[shortcuts.length - 1], {\n          func: cmdFunc,\n          scope: scope || this.editor\n        });\n        return Tools.extend(shortcuts[0], {\n          desc: this.editor.translate(desc),\n          subpatterns: shortcuts.slice(1)\n        });\n      }\n      hasModifier(e) {\n        return e.altKey || e.ctrlKey || e.metaKey;\n      }\n      isFunctionKey(e) {\n        return e.type === 'keydown' && e.keyCode >= 112 && e.keyCode <= 123;\n      }\n      matchShortcut(e, shortcut) {\n        if (!shortcut) {\n          return false;\n        }\n        if (shortcut.ctrl !== e.ctrlKey || shortcut.meta !== e.metaKey) {\n          return false;\n        }\n        if (shortcut.alt !== e.altKey || shortcut.shift !== e.shiftKey) {\n          return false;\n        }\n        if (e.keyCode === shortcut.keyCode || e.charCode && e.charCode === shortcut.charCode) {\n          e.preventDefault();\n          return true;\n        }\n        return false;\n      }\n      executeShortcutAction(shortcut) {\n        return shortcut.func ? shortcut.func.call(shortcut.scope) : null;\n      }\n    }\n\n    const create$3 = () => {\n      const buttons = {};\n      const menuItems = {};\n      const popups = {};\n      const icons = {};\n      const contextMenus = {};\n      const contextToolbars = {};\n      const contexts = {};\n      const sidebars = {};\n      const views = {};\n      const add = (collection, type) => (name, spec) => {\n        collection[name.toLowerCase()] = {\n          ...spec,\n          type\n        };\n      };\n      const addIcon = (name, svgData) => icons[name.toLowerCase()] = svgData;\n      const addContext = (name, pred) => contexts[name.toLowerCase()] = pred;\n      return {\n        addButton: add(buttons, 'button'),\n        addGroupToolbarButton: add(buttons, 'grouptoolbarbutton'),\n        addToggleButton: add(buttons, 'togglebutton'),\n        addMenuButton: add(buttons, 'menubutton'),\n        addSplitButton: add(buttons, 'splitbutton'),\n        addMenuItem: add(menuItems, 'menuitem'),\n        addNestedMenuItem: add(menuItems, 'nestedmenuitem'),\n        addToggleMenuItem: add(menuItems, 'togglemenuitem'),\n        addAutocompleter: add(popups, 'autocompleter'),\n        addContextMenu: add(contextMenus, 'contextmenu'),\n        addContextToolbar: add(contextToolbars, 'contexttoolbar'),\n        addContextForm: add(contextToolbars, 'contextform'),\n        addSidebar: add(sidebars, 'sidebar'),\n        addView: add(views, 'views'),\n        addIcon,\n        addContext,\n        getAll: () => ({\n          buttons,\n          menuItems,\n          icons,\n          popups,\n          contextMenus,\n          contextToolbars,\n          sidebars,\n          views,\n          contexts\n        })\n      };\n    };\n\n    const registry = () => {\n      const bridge = create$3();\n      return {\n        addAutocompleter: bridge.addAutocompleter,\n        addButton: bridge.addButton,\n        addContextForm: bridge.addContextForm,\n        addContextMenu: bridge.addContextMenu,\n        addContextToolbar: bridge.addContextToolbar,\n        addIcon: bridge.addIcon,\n        addMenuButton: bridge.addMenuButton,\n        addMenuItem: bridge.addMenuItem,\n        addNestedMenuItem: bridge.addNestedMenuItem,\n        addSidebar: bridge.addSidebar,\n        addSplitButton: bridge.addSplitButton,\n        addToggleButton: bridge.addToggleButton,\n        addGroupToolbarButton: bridge.addGroupToolbarButton,\n        addToggleMenuItem: bridge.addToggleMenuItem,\n        addView: bridge.addView,\n        addContext: bridge.addContext,\n        getAll: bridge.getAll\n      };\n    };\n\n    const DOM$1 = DOMUtils.DOM;\n    const extend = Tools.extend, each$1 = Tools.each;\n    class Editor {\n      constructor(id, options, editorManager) {\n        this.plugins = {};\n        this.contentCSS = [];\n        this.contentStyles = [];\n        this.loadedCSS = {};\n        this.isNotDirty = false;\n        this.composing = false;\n        this.destroyed = false;\n        this.hasHiddenInput = false;\n        this.iframeElement = null;\n        this.initialized = false;\n        this.readonly = false;\n        this.removed = false;\n        this.startContent = '';\n        this._pendingNativeEvents = [];\n        this._skinLoaded = false;\n        this._editableRoot = true;\n        this.editorManager = editorManager;\n        this.documentBaseUrl = editorManager.documentBaseURL;\n        extend(this, EditorObservable);\n        const self = this;\n        this.id = id;\n        this.hidden = false;\n        const normalizedOptions = normalizeOptions(editorManager.defaultOptions, options);\n        this.options = create$5(self, normalizedOptions, options);\n        register$7(self);\n        const getOption = this.options.get;\n        if (getOption('deprecation_warnings')) {\n          logWarnings(options, normalizedOptions);\n        }\n        const suffix = getOption('suffix');\n        if (suffix) {\n          editorManager.suffix = suffix;\n        }\n        this.suffix = editorManager.suffix;\n        const baseUrl = getOption('base_url');\n        if (baseUrl) {\n          editorManager._setBaseUrl(baseUrl);\n        }\n        this.baseUri = editorManager.baseURI;\n        const referrerPolicy = getReferrerPolicy(self);\n        if (referrerPolicy) {\n          ScriptLoader.ScriptLoader._setReferrerPolicy(referrerPolicy);\n          DOMUtils.DOM.styleSheetLoader._setReferrerPolicy(referrerPolicy);\n        }\n        const contentCssCors = hasContentCssCors(self);\n        if (isNonNullable(contentCssCors)) {\n          DOMUtils.DOM.styleSheetLoader._setContentCssCors(contentCssCors);\n        }\n        AddOnManager.languageLoad = getOption('language_load');\n        AddOnManager.baseURL = editorManager.baseURL;\n        this.setDirty(false);\n        this.documentBaseURI = new URI(getDocumentBaseUrl(self), { base_uri: this.baseUri });\n        this.baseURI = this.baseUri;\n        this.inline = isInline$1(self);\n        this.hasVisual = isVisualAidsEnabled(self);\n        this.shortcuts = new Shortcuts(this);\n        this.editorCommands = new EditorCommands(this);\n        registerCommands(this);\n        const cacheSuffix = getOption('cache_suffix');\n        if (cacheSuffix) {\n          Env.cacheSuffix = cacheSuffix.replace(/^[\\?\\&]+/, '');\n        }\n        this.ui = {\n          registry: registry(),\n          styleSheetLoader: undefined,\n          show: noop,\n          hide: noop,\n          setEnabled: noop,\n          isEnabled: always\n        };\n        this.mode = create$4(self);\n        editorManager.dispatch('SetupEditor', { editor: this });\n        const setupCallback = getSetupCallback(self);\n        if (isFunction(setupCallback)) {\n          setupCallback.call(self, self);\n        }\n      }\n      render() {\n        render(this);\n      }\n      focus(skipFocus) {\n        this.execCommand('mceFocus', false, skipFocus);\n      }\n      hasFocus() {\n        return hasFocus(this);\n      }\n      translate(text) {\n        return I18n.translate(text);\n      }\n      getParam(name, defaultVal, type) {\n        const options = this.options;\n        if (!options.isRegistered(name)) {\n          if (isNonNullable(type)) {\n            options.register(name, {\n              processor: type,\n              default: defaultVal\n            });\n          } else {\n            options.register(name, {\n              processor: always,\n              default: defaultVal\n            });\n          }\n        }\n        return !options.isSet(name) && !isUndefined(defaultVal) ? defaultVal : options.get(name);\n      }\n      hasPlugin(name, loaded) {\n        const hasPlugin = contains$2(getPlugins(this), name);\n        if (hasPlugin) {\n          return loaded ? PluginManager.get(name) !== undefined : true;\n        } else {\n          return false;\n        }\n      }\n      nodeChanged(args) {\n        this._nodeChangeDispatcher.nodeChanged(args);\n      }\n      addCommand(name, callback, scope) {\n        this.editorCommands.addCommand(name, callback, scope);\n      }\n      addQueryStateHandler(name, callback, scope) {\n        this.editorCommands.addQueryStateHandler(name, callback, scope);\n      }\n      addQueryValueHandler(name, callback, scope) {\n        this.editorCommands.addQueryValueHandler(name, callback, scope);\n      }\n      addShortcut(pattern, desc, cmdFunc, scope) {\n        this.shortcuts.add(pattern, desc, cmdFunc, scope);\n      }\n      execCommand(cmd, ui, value, args) {\n        return this.editorCommands.execCommand(cmd, ui, value, args);\n      }\n      queryCommandState(cmd) {\n        return this.editorCommands.queryCommandState(cmd);\n      }\n      queryCommandValue(cmd) {\n        return this.editorCommands.queryCommandValue(cmd);\n      }\n      queryCommandSupported(cmd) {\n        return this.editorCommands.queryCommandSupported(cmd);\n      }\n      show() {\n        const self = this;\n        if (self.hidden) {\n          self.hidden = false;\n          if (self.inline) {\n            self.getBody().contentEditable = 'true';\n          } else {\n            DOM$1.show(self.getContainer());\n            DOM$1.hide(self.id);\n          }\n          self.load();\n          self.dispatch('show');\n        }\n      }\n      hide() {\n        const self = this;\n        if (!self.hidden) {\n          self.save();\n          if (self.inline) {\n            self.getBody().contentEditable = 'false';\n            if (self === self.editorManager.focusedEditor) {\n              self.editorManager.focusedEditor = null;\n            }\n          } else {\n            DOM$1.hide(self.getContainer());\n            DOM$1.setStyle(self.id, 'display', self.orgDisplay);\n          }\n          self.hidden = true;\n          self.dispatch('hide');\n        }\n      }\n      isHidden() {\n        return this.hidden;\n      }\n      setProgressState(state, time) {\n        this.dispatch('ProgressState', {\n          state,\n          time\n        });\n      }\n      load(args = {}) {\n        const self = this;\n        const elm = self.getElement();\n        if (self.removed) {\n          return '';\n        }\n        if (elm) {\n          const loadArgs = {\n            ...args,\n            load: true\n          };\n          const value = isTextareaOrInput(elm) ? elm.value : elm.innerHTML;\n          const html = self.setContent(value, loadArgs);\n          if (!loadArgs.no_events) {\n            self.dispatch('LoadContent', {\n              ...loadArgs,\n              element: elm\n            });\n          }\n          return html;\n        } else {\n          return '';\n        }\n      }\n      save(args = {}) {\n        const self = this;\n        let elm = self.getElement();\n        if (!elm || !self.initialized || self.removed) {\n          return '';\n        }\n        const getArgs = {\n          ...args,\n          save: true,\n          element: elm\n        };\n        let html = self.getContent(getArgs);\n        const saveArgs = {\n          ...getArgs,\n          content: html\n        };\n        if (!saveArgs.no_events) {\n          self.dispatch('SaveContent', saveArgs);\n        }\n        if (saveArgs.format === 'raw') {\n          self.dispatch('RawSaveContent', saveArgs);\n        }\n        html = saveArgs.content;\n        if (!isTextareaOrInput(elm)) {\n          if (args.is_removing || !self.inline) {\n            elm.innerHTML = html;\n          }\n          const form = DOM$1.getParent(self.id, 'form');\n          if (form) {\n            each$1(form.elements, elm => {\n              if (elm.name === self.id) {\n                elm.value = html;\n                return false;\n              } else {\n                return true;\n              }\n            });\n          }\n        } else {\n          elm.value = html;\n        }\n        saveArgs.element = getArgs.element = elm = null;\n        if (saveArgs.set_dirty !== false) {\n          self.setDirty(false);\n        }\n        return html;\n      }\n      setContent(content, args) {\n        return setContent(this, content, args);\n      }\n      getContent(args) {\n        return getContent(this, args);\n      }\n      insertContent(content, args) {\n        if (args) {\n          content = extend({ content }, args);\n        }\n        this.execCommand('mceInsertContent', false, content);\n      }\n      resetContent(initialContent) {\n        if (initialContent === undefined) {\n          setContent(this, this.startContent, { format: 'raw' });\n        } else {\n          setContent(this, initialContent);\n        }\n        this.undoManager.reset();\n        this.setDirty(false);\n        this.nodeChanged();\n      }\n      isDirty() {\n        return !this.isNotDirty;\n      }\n      setDirty(state) {\n        const oldState = !this.isNotDirty;\n        this.isNotDirty = !state;\n        if (state && state !== oldState) {\n          this.dispatch('dirty');\n        }\n      }\n      getContainer() {\n        const self = this;\n        if (!self.container) {\n          self.container = self.editorContainer || DOM$1.get(self.id + '_parent');\n        }\n        return self.container;\n      }\n      getContentAreaContainer() {\n        return this.contentAreaContainer;\n      }\n      getElement() {\n        if (!this.targetElm) {\n          this.targetElm = DOM$1.get(this.id);\n        }\n        return this.targetElm;\n      }\n      getWin() {\n        const self = this;\n        if (!self.contentWindow) {\n          const elm = self.iframeElement;\n          if (elm) {\n            self.contentWindow = elm.contentWindow;\n          }\n        }\n        return self.contentWindow;\n      }\n      getDoc() {\n        const self = this;\n        if (!self.contentDocument) {\n          const win = self.getWin();\n          if (win) {\n            self.contentDocument = win.document;\n          }\n        }\n        return self.contentDocument;\n      }\n      getBody() {\n        var _a, _b;\n        const doc = this.getDoc();\n        return (_b = (_a = this.bodyElement) !== null && _a !== void 0 ? _a : doc === null || doc === void 0 ? void 0 : doc.body) !== null && _b !== void 0 ? _b : null;\n      }\n      convertURL(url, name, elm) {\n        const self = this, getOption = self.options.get;\n        const urlConverterCallback = getUrlConverterCallback(self);\n        if (isFunction(urlConverterCallback)) {\n          return urlConverterCallback.call(self, url, elm, true, name);\n        }\n        if (!getOption('convert_urls') || elm === 'link' || isObject(elm) && elm.nodeName === 'LINK' || url.indexOf('file:') === 0 || url.length === 0) {\n          return url;\n        }\n        const urlObject = new URI(url);\n        if (urlObject.protocol !== 'http' && urlObject.protocol !== 'https' && urlObject.protocol !== '') {\n          return url;\n        }\n        if (getOption('relative_urls')) {\n          return self.documentBaseURI.toRelative(url);\n        }\n        url = self.documentBaseURI.toAbsolute(url, getOption('remove_script_host'));\n        return url;\n      }\n      addVisual(elm) {\n        addVisual(this, elm);\n      }\n      setEditableRoot(state) {\n        setEditableRoot(this, state);\n      }\n      hasEditableRoot() {\n        return hasEditableRoot(this);\n      }\n      remove() {\n        remove$1(this);\n      }\n      destroy(automatic) {\n        destroy(this, automatic);\n      }\n      uploadImages() {\n        return this.editorUpload.uploadImages();\n      }\n      _scanForImages() {\n        return this.editorUpload.scanForImages();\n      }\n    }\n\n    const DOM = DOMUtils.DOM;\n    const each = Tools.each;\n    let boundGlobalEvents = false;\n    let beforeUnloadDelegate;\n    let editors = [];\n    const globalEventDelegate = e => {\n      const type = e.type;\n      each(EditorManager.get(), editor => {\n        switch (type) {\n        case 'scroll':\n          editor.dispatch('ScrollWindow', e);\n          break;\n        case 'resize':\n          editor.dispatch('ResizeWindow', e);\n          break;\n        }\n      });\n    };\n    const toggleGlobalEvents = state => {\n      if (state !== boundGlobalEvents) {\n        const DOM = DOMUtils.DOM;\n        if (state) {\n          DOM.bind(window, 'resize', globalEventDelegate);\n          DOM.bind(window, 'scroll', globalEventDelegate);\n        } else {\n          DOM.unbind(window, 'resize', globalEventDelegate);\n          DOM.unbind(window, 'scroll', globalEventDelegate);\n        }\n        boundGlobalEvents = state;\n      }\n    };\n    const removeEditorFromList = targetEditor => {\n      const oldEditors = editors;\n      editors = filter$5(editors, editor => {\n        return targetEditor !== editor;\n      });\n      if (EditorManager.activeEditor === targetEditor) {\n        EditorManager.activeEditor = editors.length > 0 ? editors[0] : null;\n      }\n      if (EditorManager.focusedEditor === targetEditor) {\n        EditorManager.focusedEditor = null;\n      }\n      return oldEditors.length !== editors.length;\n    };\n    const purgeDestroyedEditor = editor => {\n      if (editor && editor.initialized && !(editor.getContainer() || editor.getBody()).parentNode) {\n        removeEditorFromList(editor);\n        editor.unbindAllNativeEvents();\n        editor.destroy(true);\n        editor.removed = true;\n      }\n    };\n    const isQuirksMode = document.compatMode !== 'CSS1Compat';\n    const EditorManager = {\n      ...Observable,\n      baseURI: null,\n      baseURL: null,\n      defaultOptions: {},\n      documentBaseURL: null,\n      suffix: null,\n      majorVersion: '7',\n      minorVersion: '5.1',\n      releaseDate: 'TBD',\n      i18n: I18n,\n      activeEditor: null,\n      focusedEditor: null,\n      setup() {\n        const self = this;\n        let baseURL = '';\n        let suffix = '';\n        let documentBaseURL = URI.getDocumentBaseUrl(document.location);\n        if (/^[^:]+:\\/\\/\\/?[^\\/]+\\//.test(documentBaseURL)) {\n          documentBaseURL = documentBaseURL.replace(/[\\?#].*$/, '').replace(/[\\/\\\\][^\\/]+$/, '');\n          if (!/[\\/\\\\]$/.test(documentBaseURL)) {\n            documentBaseURL += '/';\n          }\n        }\n        const preInit = window.tinymce || window.tinyMCEPreInit;\n        if (preInit) {\n          baseURL = preInit.base || preInit.baseURL;\n          suffix = preInit.suffix;\n        } else {\n          const scripts = document.getElementsByTagName('script');\n          for (let i = 0; i < scripts.length; i++) {\n            const src = scripts[i].src || '';\n            if (src === '') {\n              continue;\n            }\n            const srcScript = src.substring(src.lastIndexOf('/'));\n            if (/tinymce(\\.full|\\.jquery|)(\\.min|\\.dev|)\\.js/.test(src)) {\n              if (srcScript.indexOf('.min') !== -1) {\n                suffix = '.min';\n              }\n              baseURL = src.substring(0, src.lastIndexOf('/'));\n              break;\n            }\n          }\n          if (!baseURL && document.currentScript) {\n            const src = document.currentScript.src;\n            if (src.indexOf('.min') !== -1) {\n              suffix = '.min';\n            }\n            baseURL = src.substring(0, src.lastIndexOf('/'));\n          }\n        }\n        self.baseURL = new URI(documentBaseURL).toAbsolute(baseURL);\n        self.documentBaseURL = documentBaseURL;\n        self.baseURI = new URI(self.baseURL);\n        self.suffix = suffix;\n        setup$w(self);\n      },\n      overrideDefaults(defaultOptions) {\n        const baseUrl = defaultOptions.base_url;\n        if (baseUrl) {\n          this._setBaseUrl(baseUrl);\n        }\n        const suffix = defaultOptions.suffix;\n        if (suffix) {\n          this.suffix = suffix;\n        }\n        this.defaultOptions = defaultOptions;\n        const pluginBaseUrls = defaultOptions.plugin_base_urls;\n        if (pluginBaseUrls !== undefined) {\n          each$d(pluginBaseUrls, (pluginBaseUrl, pluginName) => {\n            AddOnManager.PluginManager.urls[pluginName] = pluginBaseUrl;\n          });\n        }\n      },\n      init(options) {\n        const self = this;\n        let result;\n        const invalidInlineTargets = Tools.makeMap('area base basefont br col frame hr img input isindex link meta param embed source wbr track ' + 'colgroup option table tbody tfoot thead tr th td script noscript style textarea video audio iframe object menu', ' ');\n        const isInvalidInlineTarget = (options, elm) => options.inline && elm.tagName.toLowerCase() in invalidInlineTargets;\n        const createId = elm => {\n          let id = elm.id;\n          if (!id) {\n            id = get$a(elm, 'name').filter(name => !DOM.get(name)).getOrThunk(DOM.uniqueId);\n            elm.setAttribute('id', id);\n          }\n          return id;\n        };\n        const execCallback = name => {\n          const callback = options[name];\n          if (!callback) {\n            return;\n          }\n          return callback.apply(self, []);\n        };\n        const findTargets = options => {\n          if (Env.browser.isIE() || Env.browser.isEdge()) {\n            initError('TinyMCE does not support the browser you are using. For a list of supported' + ' browsers please see: https://www.tiny.cloud/docs/tinymce/7/support/#supportedwebbrowsers');\n            return [];\n          } else if (isQuirksMode) {\n            initError('Failed to initialize the editor as the document is not in standards mode. ' + 'TinyMCE requires standards mode.');\n            return [];\n          } else if (isString(options.selector)) {\n            return DOM.select(options.selector);\n          } else if (isNonNullable(options.target)) {\n            return [options.target];\n          } else {\n            return [];\n          }\n        };\n        let provideResults = editors => {\n          result = editors;\n        };\n        const initEditors = () => {\n          let initCount = 0;\n          const editors = [];\n          let targets;\n          const createEditor = (id, options, targetElm) => {\n            const editor = new Editor(id, options, self);\n            editors.push(editor);\n            editor.on('init', () => {\n              if (++initCount === targets.length) {\n                provideResults(editors);\n              }\n            });\n            editor.targetElm = editor.targetElm || targetElm;\n            editor.render();\n          };\n          DOM.unbind(window, 'ready', initEditors);\n          execCallback('onpageload');\n          targets = unique$1(findTargets(options));\n          Tools.each(targets, elm => {\n            purgeDestroyedEditor(self.get(elm.id));\n          });\n          targets = Tools.grep(targets, elm => {\n            return !self.get(elm.id);\n          });\n          if (targets.length === 0) {\n            provideResults([]);\n          } else {\n            each(targets, elm => {\n              if (isInvalidInlineTarget(options, elm)) {\n                initError('Could not initialize inline editor on invalid inline target element', elm);\n              } else {\n                createEditor(createId(elm), options, elm);\n              }\n            });\n          }\n        };\n        DOM.bind(window, 'ready', initEditors);\n        return new Promise(resolve => {\n          if (result) {\n            resolve(result);\n          } else {\n            provideResults = editors => {\n              resolve(editors);\n            };\n          }\n        });\n      },\n      get(id) {\n        if (arguments.length === 0) {\n          return editors.slice(0);\n        } else if (isString(id)) {\n          return find$2(editors, editor => {\n            return editor.id === id;\n          }).getOr(null);\n        } else if (isNumber(id)) {\n          return editors[id] ? editors[id] : null;\n        } else {\n          return null;\n        }\n      },\n      add(editor) {\n        const self = this;\n        const existingEditor = self.get(editor.id);\n        if (existingEditor === editor) {\n          return editor;\n        }\n        if (existingEditor === null) {\n          editors.push(editor);\n        }\n        toggleGlobalEvents(true);\n        self.activeEditor = editor;\n        self.dispatch('AddEditor', { editor });\n        if (!beforeUnloadDelegate) {\n          beforeUnloadDelegate = e => {\n            const event = self.dispatch('BeforeUnload');\n            if (event.returnValue) {\n              e.preventDefault();\n              e.returnValue = event.returnValue;\n              return event.returnValue;\n            }\n          };\n          window.addEventListener('beforeunload', beforeUnloadDelegate);\n        }\n        return editor;\n      },\n      createEditor(id, options) {\n        return this.add(new Editor(id, options, this));\n      },\n      remove(selector) {\n        const self = this;\n        let editor;\n        if (!selector) {\n          for (let i = editors.length - 1; i >= 0; i--) {\n            self.remove(editors[i]);\n          }\n          return;\n        }\n        if (isString(selector)) {\n          each(DOM.select(selector), elm => {\n            editor = self.get(elm.id);\n            if (editor) {\n              self.remove(editor);\n            }\n          });\n          return;\n        }\n        editor = selector;\n        if (isNull(self.get(editor.id))) {\n          return null;\n        }\n        if (removeEditorFromList(editor)) {\n          self.dispatch('RemoveEditor', { editor });\n        }\n        if (editors.length === 0) {\n          window.removeEventListener('beforeunload', beforeUnloadDelegate);\n        }\n        editor.remove();\n        toggleGlobalEvents(editors.length > 0);\n        return editor;\n      },\n      execCommand(cmd, ui, value) {\n        var _a;\n        const self = this;\n        const editorId = isObject(value) ? (_a = value.id) !== null && _a !== void 0 ? _a : value.index : value;\n        switch (cmd) {\n        case 'mceAddEditor': {\n            if (!self.get(editorId)) {\n              const editorOptions = value.options;\n              new Editor(editorId, editorOptions, self).render();\n            }\n            return true;\n          }\n        case 'mceRemoveEditor': {\n            const editor = self.get(editorId);\n            if (editor) {\n              editor.remove();\n            }\n            return true;\n          }\n        case 'mceToggleEditor': {\n            const editor = self.get(editorId);\n            if (!editor) {\n              self.execCommand('mceAddEditor', false, value);\n              return true;\n            }\n            if (editor.isHidden()) {\n              editor.show();\n            } else {\n              editor.hide();\n            }\n            return true;\n          }\n        }\n        if (self.activeEditor) {\n          return self.activeEditor.execCommand(cmd, ui, value);\n        }\n        return false;\n      },\n      triggerSave: () => {\n        each(editors, editor => {\n          editor.save();\n        });\n      },\n      addI18n: (code, items) => {\n        I18n.add(code, items);\n      },\n      translate: text => {\n        return I18n.translate(text);\n      },\n      setActive(editor) {\n        const activeEditor = this.activeEditor;\n        if (this.activeEditor !== editor) {\n          if (activeEditor) {\n            activeEditor.dispatch('deactivate', { relatedTarget: editor });\n          }\n          editor.dispatch('activate', { relatedTarget: activeEditor });\n        }\n        this.activeEditor = editor;\n      },\n      _setBaseUrl(baseUrl) {\n        this.baseURL = new URI(this.documentBaseURL).toAbsolute(baseUrl.replace(/\\/+$/, ''));\n        this.baseURI = new URI(this.baseURL);\n      }\n    };\n    EditorManager.setup();\n\n    const setup = () => {\n      const dataValue = value$2();\n      const FakeClipboardItem = items => ({\n        items,\n        types: keys(items),\n        getType: type => get$a(items, type).getOrUndefined()\n      });\n      const write = data => {\n        dataValue.set(data);\n      };\n      const read = () => dataValue.get().getOrUndefined();\n      const clear = dataValue.clear;\n      return {\n        FakeClipboardItem,\n        write,\n        read,\n        clear\n      };\n    };\n    const FakeClipboard = setup();\n\n    const min = Math.min, max = Math.max, round = Math.round;\n    const relativePosition = (rect, targetRect, rel) => {\n      let x = targetRect.x;\n      let y = targetRect.y;\n      const w = rect.w;\n      const h = rect.h;\n      const targetW = targetRect.w;\n      const targetH = targetRect.h;\n      const relChars = (rel || '').split('');\n      if (relChars[0] === 'b') {\n        y += targetH;\n      }\n      if (relChars[1] === 'r') {\n        x += targetW;\n      }\n      if (relChars[0] === 'c') {\n        y += round(targetH / 2);\n      }\n      if (relChars[1] === 'c') {\n        x += round(targetW / 2);\n      }\n      if (relChars[3] === 'b') {\n        y -= h;\n      }\n      if (relChars[4] === 'r') {\n        x -= w;\n      }\n      if (relChars[3] === 'c') {\n        y -= round(h / 2);\n      }\n      if (relChars[4] === 'c') {\n        x -= round(w / 2);\n      }\n      return create$2(x, y, w, h);\n    };\n    const findBestRelativePosition = (rect, targetRect, constrainRect, rels) => {\n      for (let i = 0; i < rels.length; i++) {\n        const pos = relativePosition(rect, targetRect, rels[i]);\n        if (pos.x >= constrainRect.x && pos.x + pos.w <= constrainRect.w + constrainRect.x && pos.y >= constrainRect.y && pos.y + pos.h <= constrainRect.h + constrainRect.y) {\n          return rels[i];\n        }\n      }\n      return null;\n    };\n    const inflate = (rect, w, h) => {\n      return create$2(rect.x - w, rect.y - h, rect.w + w * 2, rect.h + h * 2);\n    };\n    const intersect = (rect, cropRect) => {\n      const x1 = max(rect.x, cropRect.x);\n      const y1 = max(rect.y, cropRect.y);\n      const x2 = min(rect.x + rect.w, cropRect.x + cropRect.w);\n      const y2 = min(rect.y + rect.h, cropRect.y + cropRect.h);\n      if (x2 - x1 < 0 || y2 - y1 < 0) {\n        return null;\n      }\n      return create$2(x1, y1, x2 - x1, y2 - y1);\n    };\n    const clamp = (rect, clampRect, fixedSize) => {\n      let x1 = rect.x;\n      let y1 = rect.y;\n      let x2 = rect.x + rect.w;\n      let y2 = rect.y + rect.h;\n      const cx2 = clampRect.x + clampRect.w;\n      const cy2 = clampRect.y + clampRect.h;\n      const underflowX1 = max(0, clampRect.x - x1);\n      const underflowY1 = max(0, clampRect.y - y1);\n      const overflowX2 = max(0, x2 - cx2);\n      const overflowY2 = max(0, y2 - cy2);\n      x1 += underflowX1;\n      y1 += underflowY1;\n      if (fixedSize) {\n        x2 += underflowX1;\n        y2 += underflowY1;\n        x1 -= overflowX2;\n        y1 -= overflowY2;\n      }\n      x2 -= overflowX2;\n      y2 -= overflowY2;\n      return create$2(x1, y1, x2 - x1, y2 - y1);\n    };\n    const create$2 = (x, y, w, h) => {\n      return {\n        x,\n        y,\n        w,\n        h\n      };\n    };\n    const fromClientRect = clientRect => {\n      return create$2(clientRect.left, clientRect.top, clientRect.width, clientRect.height);\n    };\n    const Rect = {\n      inflate,\n      relativePosition,\n      findBestRelativePosition,\n      intersect,\n      clamp,\n      create: create$2,\n      fromClientRect\n    };\n\n    const awaiter = (resolveCb, rejectCb, timeout = 1000) => {\n      let done = false;\n      let timer = null;\n      const complete = completer => (...args) => {\n        if (!done) {\n          done = true;\n          if (timer !== null) {\n            clearTimeout(timer);\n            timer = null;\n          }\n          completer.apply(null, args);\n        }\n      };\n      const resolve = complete(resolveCb);\n      const reject = complete(rejectCb);\n      const start = (...args) => {\n        if (!done && timer === null) {\n          timer = setTimeout(() => reject.apply(null, args), timeout);\n        }\n      };\n      return {\n        start,\n        resolve,\n        reject\n      };\n    };\n    const create$1 = () => {\n      const tasks = {};\n      const resultFns = {};\n      const resources = {};\n      const load = (id, url) => {\n        const loadErrMsg = `Script at URL \"${ url }\" failed to load`;\n        const runErrMsg = `Script at URL \"${ url }\" did not call \\`tinymce.Resource.add('${ id }', data)\\` within 1 second`;\n        if (tasks[id] !== undefined) {\n          return tasks[id];\n        } else {\n          const task = new Promise((resolve, reject) => {\n            const waiter = awaiter(resolve, reject);\n            resultFns[id] = waiter.resolve;\n            ScriptLoader.ScriptLoader.loadScript(url).then(() => waiter.start(runErrMsg), () => waiter.reject(loadErrMsg));\n          });\n          tasks[id] = task;\n          return task;\n        }\n      };\n      const add = (id, data) => {\n        if (resultFns[id] !== undefined) {\n          resultFns[id](data);\n          delete resultFns[id];\n        }\n        tasks[id] = Promise.resolve(data);\n        resources[id] = data;\n      };\n      const has = id => {\n        return id in resources;\n      };\n      const unload = id => {\n        delete tasks[id];\n        delete resources[id];\n      };\n      const get = id => resources[id];\n      return {\n        load,\n        add,\n        has,\n        get,\n        unload\n      };\n    };\n    const Resource = create$1();\n\n    const create = () => (() => {\n      let data = {};\n      let keys = [];\n      const storage = {\n        getItem: key => {\n          const item = data[key];\n          return item ? item : null;\n        },\n        setItem: (key, value) => {\n          keys.push(key);\n          data[key] = String(value);\n        },\n        key: index => {\n          return keys[index];\n        },\n        removeItem: key => {\n          keys = keys.filter(k => k === key);\n          delete data[key];\n        },\n        clear: () => {\n          keys = [];\n          data = {};\n        },\n        length: 0\n      };\n      Object.defineProperty(storage, 'length', {\n        get: () => keys.length,\n        configurable: false,\n        enumerable: false\n      });\n      return storage;\n    })();\n\n    let localStorage;\n    try {\n      const test = '__storage_test__';\n      localStorage = window.localStorage;\n      localStorage.setItem(test, test);\n      localStorage.removeItem(test);\n    } catch (e) {\n      localStorage = create();\n    }\n    var LocalStorage = localStorage;\n\n    const publicApi = {\n      geom: { Rect },\n      util: {\n        Delay,\n        Tools,\n        VK,\n        URI,\n        EventDispatcher,\n        Observable,\n        I18n,\n        LocalStorage,\n        ImageUploader\n      },\n      dom: {\n        EventUtils,\n        TreeWalker: DomTreeWalker,\n        TextSeeker,\n        DOMUtils,\n        ScriptLoader,\n        RangeUtils,\n        Serializer: DomSerializer,\n        StyleSheetLoader,\n        ControlSelection,\n        BookmarkManager,\n        Selection: EditorSelection,\n        Event: EventUtils.Event\n      },\n      html: {\n        Styles,\n        Entities,\n        Node: AstNode,\n        Schema,\n        DomParser,\n        Writer,\n        Serializer: HtmlSerializer\n      },\n      Env,\n      AddOnManager,\n      Annotator,\n      Formatter,\n      UndoManager,\n      EditorCommands,\n      WindowManager,\n      NotificationManager,\n      EditorObservable,\n      Shortcuts,\n      Editor,\n      FocusManager,\n      EditorManager,\n      DOM: DOMUtils.DOM,\n      ScriptLoader: ScriptLoader.ScriptLoader,\n      PluginManager,\n      ThemeManager,\n      ModelManager,\n      IconManager,\n      Resource,\n      FakeClipboard,\n      trim: Tools.trim,\n      isArray: Tools.isArray,\n      is: Tools.is,\n      toArray: Tools.toArray,\n      makeMap: Tools.makeMap,\n      each: Tools.each,\n      map: Tools.map,\n      grep: Tools.grep,\n      inArray: Tools.inArray,\n      extend: Tools.extend,\n      walk: Tools.walk,\n      resolve: Tools.resolve,\n      explode: Tools.explode,\n      _addCacheSuffix: Tools._addCacheSuffix\n    };\n    const tinymce$1 = Tools.extend(EditorManager, publicApi);\n\n    const exportToModuleLoaders = tinymce => {\n      if (typeof module === 'object') {\n        try {\n          module.exports = tinymce;\n        } catch (_) {\n        }\n      }\n    };\n    const exportToWindowGlobal = tinymce => {\n      window.tinymce = tinymce;\n      window.tinyMCE = tinymce;\n    };\n    exportToWindowGlobal(tinymce$1);\n    exportToModuleLoaders(tinymce$1);\n\n})();\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}